<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_05) on Tue Aug 25 13:47:52 CEST 2015 -->
<title>Query</title>
<meta name="date" content="2015-08-25">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Query";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../org/jpl7/PrologException.html" title="class in org.jpl7"><span class="strong">Prev Class</span></a></li>
<li><a href="../../org/jpl7/Term.html" title="class in org.jpl7"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?org/jpl7/Query.html" target="_top">Frames</a></li>
<li><a href="Query.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.jpl7</div>
<h2 title="Class Query" class="title">Class Query</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.jpl7.Query</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.lang.Iterable&lt;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&gt;, java.util.Iterator&lt;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&gt;</dd>
</dl>
<hr>
<br>
<pre>public class <span class="strong">Query</span>
extends java.lang.Object
implements java.lang.Iterable&lt;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&gt;, java.util.Iterator&lt;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&gt;</pre>
<div class="block">A Query instance is created by an application in order to query the Prolog database (or to invoke a built-in predicate). It is initialised with a Compound (or Atom) denoting the goal which is to be
 called, and also contains assorted private state relating to solutions. In some future version, it may contain details of the module in which the goal is to be called.
 <p>
 A Query is either open or closed: when closed, it has no connection to the Prolog system; when open, it is linked to an active goal within a Prolog engine.
 <p>
 The Query class implements the Enumeration interface, through which one can obtain successive solutions. The Enumeration hasMoreElements() method returns true if the call or redo succeeded
 (otherwise false), and if the call or redo did succeed, the nextElement() method returns a Map representing variable bindings; the elements in the Map are Terms, indexed by the (String) names of
 the Variables with which they are associated. For example, if <i>p(a)</i> and <i>p(b)</i> are facts in the Prolog database, then the following is equivalent to printing all the solutions to the
 Prolog query <i>p(X)</i>:
 
 <pre>
 Variable X = new Variable(&quot;X&quot;);
 Term arg[] = { X };
 Query q = new Query(&quot;p&quot;, arg);
 
 while (q.hasMoreElements()) {
        Term bound_to_x = ((Map) q.nextElement()).get(&quot;X&quot;);
        System.out.println(bound_to_x);
 }
 </pre>
 
 Make sure to close the Query (using the close() method) if you do not need any further solutions which it may have. It is safe (although redundant) to close a Query whose solutions are already
 exhausted, or which is already closed.
 
 To obtain just one solution from a Query, use the oneSolution() method.
 
 To obtain all solutions, use the allSolutions() method.
 
 To obtain at most N solutions, use the nSolutions() method.
 
 To determine merely whether the Query is provable, use the hasSolution() method (i.e. has at least one solution).
 <hr>
 <i> Copyright (C) 2007 Paul Singleton
 <p>
 Copyright (C) 1998 Fred Dushin
 <p>
 This library is free software; you can redistribute it and/or modify it under the terms of the GNU Library Public License as published by the Free Software Foundation; either version 2 of the
 License, or (at your option) any later version.
 <p>
 This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 Library Public License for more details.
 <p>
 </i>
 <hr></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../org/jpl7/Query.html#Query(java.lang.String)">Query</a></strong>(java.lang.String&nbsp;text)</code>
<div class="block">This constructor builds a Query from the given Prolog source text.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../org/jpl7/Query.html#Query(java.lang.String, org.jpl7.Term)">Query</a></strong>(java.lang.String&nbsp;text,
     <a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&nbsp;arg)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../org/jpl7/Query.html#Query(java.lang.String, org.jpl7.Term[])">Query</a></strong>(java.lang.String&nbsp;text,
     <a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>[]&nbsp;args)</code>
<div class="block">If text denotes an atom, this constructor is shorthand for <font face="monospace">new Query(new Compound(name,args))</font>, but if text denotes a term containing N query (?) symbols and there
 are N args, each query is replaced by its corresponding arg to provide the new Query's goal.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../org/jpl7/Query.html#Query(org.jpl7.Term)">Query</a></strong>(<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&nbsp;t)</code>
<div class="block">This constructor creates a Query whose goal is the specified Term.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;[]</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#allSolutions()">allSolutions</a></strong>()</code>
<div class="block">calls the Query's goal to exhaustion and returns an array of zero or more Maps of zero or more variablename-to-term bindings (each Map represents a solution, in the order in which they were
 found).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;[]</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#allSolutions(java.lang.String)">allSolutions</a></strong>(java.lang.String&nbsp;text)</code>
<div class="block">This static method creates a Query from the given Prolog source text fragment, calls it to exhaustion, and returns an array of zero or more Maps of zero or more variablename-to-term bindings
 (each Map represents a solution, in the order in which they were found).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;[]</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#allSolutions(java.lang.String, org.jpl7.Term[])">allSolutions</a></strong>(java.lang.String&nbsp;text,
            <a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>[]&nbsp;params)</code>
<div class="block">If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols and there are N accompanying Term params, this static method replaces each questionmark symbol
 by its respective param, calls the resulting goal to exhaustion, and returns an array of zero or more Maps of zero or more variablename-to-term bindings (each Map represents a solution, in the
 order in which they were found).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;[]</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#allSolutions(org.jpl7.Term)">allSolutions</a></strong>(<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&nbsp;goal)</code>
<div class="block">This static method creates a Query whose goal is the given Term, calls it to exhaustion, and returns an array of zero or more Maps of zero or more variablename-to-term bindings (each Map
 represents a solution, in the order in which they were found).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#close()">close</a></strong>()</code>
<div class="block">This method can be used to close an open query before its solutions are exhausted.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#getSolution()">getSolution</a></strong>()</code>
<div class="block">This method returns a java.util.Map, which represents a set of bindings from the names of query variables to terms within the solution.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#getSubstWithNameVars()">getSubstWithNameVars</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a></code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#goal()">goal</a></strong>()</code>
<div class="block">Returns the Term (Atom or Compound) which is the goal of this Query</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#hasMoreElements()">hasMoreElements</a></strong>()</code>
<div class="block">This method implements part of the java.util.Enumeration interface.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#hasMoreSolutions()">hasMoreSolutions</a></strong>()</code>
<div class="block">This method returns true if JPL was able to initiate a "call" of this Query within a Prolog engine.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#hasNext()">hasNext</a></strong>()</code>
<div class="block">whether this Query has a (further) solution</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#hasSolution()">hasSolution</a></strong>()</code>
<div class="block">This method will attempt to call this Query's goal within an available Prolog engine.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#hasSolution(java.lang.String)">hasSolution</a></strong>(java.lang.String&nbsp;text)</code>
<div class="block">This static method creates a Query from the given Prolog source text and calls it at most once, returning true if a solution was found, else false.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#hasSolution(java.lang.String, org.jpl7.Term[])">hasSolution</a></strong>(java.lang.String&nbsp;text,
           <a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>[]&nbsp;params)</code>
<div class="block">If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols and there are N params, each questionmark symbol is replaced by its corresponding arg to
 provide the new Query's goal: the resulting Query is called as described above.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#hasSolution(org.jpl7.Term)">hasSolution</a></strong>(<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&nbsp;goal)</code>
<div class="block">This static method creates a Query (whose goal is the specified Term) and calls it at most once, returning true if a solution was found, else false.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#isOpen()">isOpen</a></strong>()</code>
<div class="block">isOpen() returns true iff the query is open.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Iterator&lt;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#iterator()">iterator</a></strong>()</code>
<div class="block">a Query is its own Iterator</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#next()">next</a></strong>()</code>
<div class="block">this Query's next solution</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#nextElement()">nextElement</a></strong>()</code>
<div class="block">This method implements part of the java.util.Enumeration interface.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#nextSolution()">nextSolution</a></strong>()</code>
<div class="block">This method returns a java.util.Map, which represents a binding from the names of query variables to terms within the solution.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;[]</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#nSolutions(long)">nSolutions</a></strong>(long&nbsp;n)</code>
<div class="block">calls the Query's goal to exhaustion or until N solutions are found, whichever is sooner, and returns an array containing (as possibly empty Maps of variablename-to-term bindings) every found
 solution (in the order in which they were found).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;[]</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#nSolutions(java.lang.String, long)">nSolutions</a></strong>(java.lang.String&nbsp;text,
          long&nbsp;n)</code>
<div class="block">This static method creates a Query from the given Prolog source text fragment, calls it to exhaustion or until N solutions are found, whichever is sooner, and returns an array containing (as
 possibly empty Maps of variablename-to-term bindings) every found solution (in the order in which they were found).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;[]</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#nSolutions(java.lang.String, org.jpl7.Term[], long)">nSolutions</a></strong>(java.lang.String&nbsp;text,
          <a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>[]&nbsp;params,
          long&nbsp;n)</code>
<div class="block">If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols and there are N accompanying params, this static method replaces each questionmark symbol by
 its respective param, calls the resulting goal to exhaustion or until N solutions are found, whichever is sooner, and returns an array containing (as possibly empty Maps of variablename-to-term
 bindings) every found solution (in the order in which they were found).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;[]</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#nSolutions(org.jpl7.Term, long)">nSolutions</a></strong>(<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&nbsp;goal,
          long&nbsp;n)</code>
<div class="block">This static method creates a Query whose goal is the given Term, calls it to exhaustion or until N solutions are found, whichever is sooner, and returns an array containing (as possibly empty
 Maps of variablename-to-term bindings) every found solution (in the order in which they were found).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#oneSolution()">oneSolution</a></strong>()</code>
<div class="block">Returns the first solution, if any, as a (possibly empty) Map of variablename-to-term bindings, else null.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#oneSolution(java.lang.String)">oneSolution</a></strong>(java.lang.String&nbsp;text)</code>
<div class="block">This static method creates a Query from the given Prolog source text fragment, and calls it at most once, returning the first solution, if there is one, as a (possibly empty) Map, else null.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#oneSolution(java.lang.String, org.jpl7.Term[])">oneSolution</a></strong>(java.lang.String&nbsp;text,
           <a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>[]&nbsp;params)</code>
<div class="block">If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols and there are N params, each questionmark symbol is replaced by its respective param to
 provide the goal of this query: the resulting goal is then called (at most once) and the first solution, if there is one, is returned as a (possibly empty) Map, else null.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#oneSolution(org.jpl7.Term)">oneSolution</a></strong>(<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&nbsp;goal)</code>
<div class="block">This static method creates a Query (whose goal is the specified Term) and calls it at most once, returning the first solution, if there is one, as a (possibly empty) Map, else null.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#open()">open</a></strong>()</code>
<div class="block">This method returns true if JPL was able to initiate a "call" of this Query within the Prolog engine.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#remove()">remove</a></strong>()</code>
<div class="block">this method (required by Iterator interface) is a no-op</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../org/jpl7/Query.html#toString()">toString</a></strong>()</code>
<div class="block">Returns a crude String representation of a Query.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Query(org.jpl7.Term)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Query</h4>
<pre>public&nbsp;Query(<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&nbsp;t)</pre>
<div class="block">This constructor creates a Query whose goal is the specified Term. The Query is initially closed. <b>NB</b> Creating an instance of the Query class does not result in a call to a Prolog engine.
 <b>NB</b> The goal can be a Compound or an Atom (Atom extends Compound), but cannot be an instance of jpl.Float, jpl.Integer or jpl.Variable.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>t</code> - the goal of this Query</dd></dl>
</li>
</ul>
<a name="Query(java.lang.String, org.jpl7.Term[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Query</h4>
<pre>public&nbsp;Query(java.lang.String&nbsp;text,
     <a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>[]&nbsp;args)</pre>
<div class="block">If text denotes an atom, this constructor is shorthand for <font face="monospace">new Query(new Compound(name,args))</font>, but if text denotes a term containing N query (?) symbols and there
 are N args, each query is replaced by its corresponding arg to provide the new Query's goal.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - the name of the principal functor of this Query's goal</dd><dd><code>args</code> - the arguments of this Query's goal</dd></dl>
</li>
</ul>
<a name="Query(java.lang.String, org.jpl7.Term)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Query</h4>
<pre>public&nbsp;Query(java.lang.String&nbsp;text,
     <a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&nbsp;arg)</pre>
</li>
</ul>
<a name="Query(java.lang.String)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Query</h4>
<pre>public&nbsp;Query(java.lang.String&nbsp;text)</pre>
<div class="block">This constructor builds a Query from the given Prolog source text. Throws PrologException containing error(syntax_error(_),_) if text is invalid.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - the Prolog source text of this Query</dd></dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="goal()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goal</h4>
<pre>public final&nbsp;<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&nbsp;goal()</pre>
<div class="block">Returns the Term (Atom or Compound) which is the goal of this Query</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>a Term representing the goal of this Query</dd></dl>
</li>
</ul>
<a name="iterator()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>iterator</h4>
<pre>public&nbsp;java.util.Iterator&lt;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&gt;&nbsp;iterator()</pre>
<div class="block">a Query is its own Iterator</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code>iterator</code>&nbsp;in interface&nbsp;<code>java.lang.Iterable&lt;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&gt;</code></dd>
<dt><span class="strong">See Also:</span></dt><dd><code>Iterable.iterator()</code></dd></dl>
</li>
</ul>
<a name="hasNext()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNext</h4>
<pre>public&nbsp;boolean&nbsp;hasNext()</pre>
<div class="block">whether this Query has a (further) solution</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code>hasNext</code>&nbsp;in interface&nbsp;<code>java.util.Iterator&lt;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&gt;</code></dd>
<dt><span class="strong">See Also:</span></dt><dd><code>Iterator.hasNext()</code></dd></dl>
</li>
</ul>
<a name="next()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>next</h4>
<pre>public&nbsp;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&nbsp;next()</pre>
<div class="block">this Query's next solution</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code>next</code>&nbsp;in interface&nbsp;<code>java.util.Iterator&lt;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&gt;</code></dd>
<dt><span class="strong">See Also:</span></dt><dd><code>Iterator.next()</code></dd></dl>
</li>
</ul>
<a name="remove()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>remove</h4>
<pre>public&nbsp;void&nbsp;remove()</pre>
<div class="block">this method (required by Iterator interface) is a no-op</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code>remove</code>&nbsp;in interface&nbsp;<code>java.util.Iterator&lt;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&gt;</code></dd>
<dt><span class="strong">See Also:</span></dt><dd><code>Iterator.remove()</code></dd></dl>
</li>
</ul>
<a name="isOpen()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isOpen</h4>
<pre>public final&nbsp;boolean&nbsp;isOpen()</pre>
<div class="block">isOpen() returns true iff the query is open.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>true if the query is open, otherwise false.</dd></dl>
</li>
</ul>
<a name="hasMoreSolutions()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMoreSolutions</h4>
<pre>public final&nbsp;boolean&nbsp;hasMoreSolutions()</pre>
<div class="block">This method returns true if JPL was able to initiate a "call" of this Query within a Prolog engine. It is designed to be used with the nextSolution() method to retrieve one or more
 substitutions in the form of Maps. To iterate through all the solutions to a Query, for example, one might write
 
 <pre>
 Query q = // obtain Query reference
 while (q.hasMoreSolutions()) {
     Map solution = q.nextSolution();
     // process solution...
 }
 </pre>
 
 To ensure thread-safety, you should wrap sequential calls to this method in a synchronized block, using the static lock method to obtain the monitor.
 
 <pre>
 Query q = // obtain Query reference
 synchronized ( jpl.Query.lock() ){
     while ( q.hasMoreElements() ){
          Map solution = q.nextSolution();
          // process solution...
     }
 }
 </pre></div>
<dl><dt><span class="strong">Returns:</span></dt><dd>true if the Prolog query succeeds; otherwise false.</dd></dl>
</li>
</ul>
<a name="open()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>open</h4>
<pre>public final&nbsp;void&nbsp;open()</pre>
<div class="block">This method returns true if JPL was able to initiate a "call" of this Query within the Prolog engine. It is designed to be used with the getSolution() and close() methods to retrieve one or
 more substitutions in the form of Maps.
 
 <pre>
 Query q = // obtain Query reference
 Map soln;
 q.open();
 while ((soln = q.getSolution()) != null) {
      // process solution...
 }
 </pre>
 <p>
 If this method is called on an already-open Query, or if the query cannot be set up for whatever reason, then a JPLException will be thrown.</div>
</li>
</ul>
<a name="getSolution()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSolution</h4>
<pre>public final&nbsp;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&nbsp;getSolution()</pre>
<div class="block">This method returns a java.util.Map, which represents a set of bindings from the names of query variables to terms within the solution.
 <p>
 For example, if a Query has an occurrence of a jpl.Variable, say, named "X", one can obtain the Term bound to "X" in the solution by looking up "X" in the Map.
 
 <pre>
 Variable x = new Variable("X");
 Query q = // obtain Query reference (with x in the Term array)
 while (q.hasMoreSolutions()) {
     Map solution = q.nextSolution();
     // make t the Term bound to "X" in the solution
     Term t = (Term) solution.get("X");
     // ...
 }
 </pre>
 
 Programmers should obey the following rules when using this method. <menu>
 <li>The nextSolution() method should only be called after the hasMoreSolutions() method returns true; otherwise a JPLException will be raised, indicating that the Query is no longer open.
 <li>The nextSolution() and hasMoreSolutions() should be called in the same thread of execution, for a given Query instance. </menu>
 
 This method will throw a JPLException if Query is not open.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>A Map representing a substitution, or null</dd></dl>
</li>
</ul>
<a name="getSubstWithNameVars()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSubstWithNameVars</h4>
<pre>public final&nbsp;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&nbsp;getSubstWithNameVars()</pre>
</li>
</ul>
<a name="nextSolution()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nextSolution</h4>
<pre>public final&nbsp;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&nbsp;nextSolution()</pre>
<div class="block">This method returns a java.util.Map, which represents a binding from the names of query variables to terms within the solution.
 <p>
 For example, if a Query has an occurrence of a jpl.Variable, say, named "X", one can obtain the Term bound to "X" in the solution by looking up "X" in the Map.
 
 <pre>
 Variable x = new Variable("X");
 Query q = // obtain Query reference (with x in the Term array)
 while (q.hasMoreSolutions()) {
     Map solution = q.nextSolution();
     // make t the Term bound to "X" in the solution
     Term t = (Term) solution.get("X");
     // ...
 }
 </pre>
 
 Programmers should obey the following rules when using this method. <menu>
 <li>The nextSolution() method should only be called after the hasMoreSolutions() method returns true; otherwise a JPLException will be raised, indicating that the Query is no longer open.
 <li>The nextSolution() and hasMoreSolutions() should be called in the same thread of execution, for a given Query instance. </menu>
 
 This method will throw a JPLException if Query is not open.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>A Map representing a substitution.</dd></dl>
</li>
</ul>
<a name="hasMoreElements()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasMoreElements</h4>
<pre>public final&nbsp;boolean&nbsp;hasMoreElements()</pre>
<div class="block">This method implements part of the java.util.Enumeration interface. It is a wrapper for hasMoreSolutions.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>true if the Prolog query yields a (or another) solution, else false.</dd></dl>
</li>
</ul>
<a name="nextElement()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nextElement</h4>
<pre>public final&nbsp;java.lang.Object&nbsp;nextElement()</pre>
<div class="block">This method implements part of the java.util.Enumeration interface. It is a wrapper for nextSolution.
 <p></div>
<dl><dt><span class="strong">Returns:</span></dt><dd>A Map representing a substitution.</dd></dl>
</li>
</ul>
<a name="close()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>close</h4>
<pre>public final&nbsp;void&nbsp;close()</pre>
<div class="block">This method can be used to close an open query before its solutions are exhausted. It is called automatically when solutions are exhausted. Calling close() on an already closed Query has no
 effect.
 <p>
 
 Here is one way to get the first three solutions to a Query:
 
 <pre>
 Query q = new Query(predicate, args);
 Map&lt;String, Term&gt; sub1 = q.nextSolution();
 Map&lt;String, Term&gt; sub2 = q.nextSolution();
 Map&lt;String, Term&gt; sub3 = q.nextSolution();
 q.close();
 </pre>
 <p></div>
</li>
</ul>
<a name="allSolutions()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allSolutions</h4>
<pre>public final&nbsp;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;[]&nbsp;allSolutions()</pre>
<div class="block">calls the Query's goal to exhaustion and returns an array of zero or more Maps of zero or more variablename-to-term bindings (each Map represents a solution, in the order in which they were
 found).</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>an array of zero or more Maps of zero or more variablename-to-term bindings (each Map represents a solution, in the order in which they were found) <b>NB</b> in JPL 1.0.1, this method
         (inconsistently) returned null when a Query had no solutions; in JPL 2.x onwards it returns an empty array (thus the length of the array is, in every case, the quantity of solutions).
         <p>
         <b>NB</b> in JPL 1.0.1, bindings were keyed (awkwardly) by Variable instances; in JPL 2.x onwards they are keyed by the (String) names of variables, which is consistent with the Term
         type being just a concrete syntax for terms (and hence queries).
         <p></dd></dl>
</li>
</ul>
<a name="allSolutions(org.jpl7.Term)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allSolutions</h4>
<pre>public static final&nbsp;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;[]&nbsp;allSolutions(<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&nbsp;goal)</pre>
<div class="block">This static method creates a Query whose goal is the given Term, calls it to exhaustion, and returns an array of zero or more Maps of zero or more variablename-to-term bindings (each Map
 represents a solution, in the order in which they were found). Throws JPLException if goal is neither a jpl.Atom nor a jpl.Compound.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>goal</code> - the goal of this Query</dd>
<dt><span class="strong">Returns:</span></dt><dd>an array of zero or more Maps of zero or more variablename-to-term bindings (each Map represents a solution, in the order in which they were found)</dd></dl>
</li>
</ul>
<a name="allSolutions(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allSolutions</h4>
<pre>public static final&nbsp;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;[]&nbsp;allSolutions(java.lang.String&nbsp;text)</pre>
<div class="block">This static method creates a Query from the given Prolog source text fragment, calls it to exhaustion, and returns an array of zero or more Maps of zero or more variablename-to-term bindings
 (each Map represents a solution, in the order in which they were found). Throws PrologException containing error(syntax_error(_),_) if text is invalid.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - a Prolog source text fragment denoting a goal</dd>
<dt><span class="strong">Returns:</span></dt><dd>an array of zero or more Maps of zero or more variablename-to-term bindings (each Map represents a solution, in the order in which they were found)</dd></dl>
</li>
</ul>
<a name="allSolutions(java.lang.String, org.jpl7.Term[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allSolutions</h4>
<pre>public static final&nbsp;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;[]&nbsp;allSolutions(java.lang.String&nbsp;text,
                                                  <a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>[]&nbsp;params)</pre>
<div class="block">If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols and there are N accompanying Term params, this static method replaces each questionmark symbol
 by its respective param, calls the resulting goal to exhaustion, and returns an array of zero or more Maps of zero or more variablename-to-term bindings (each Map represents a solution, in the
 order in which they were found).
 
 Otherwise, if text denotes an atom, this static method creates a Query where text is the name of the goal and params are the args; the resulting goal is then called as above. This letter mode
 is redundant, deprecated (informally), and retained only for backward compatibility.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - the Prolog source text of a goal, in which questionmarks are regarded as substitutible parameters</dd><dd><code>params</code> - terms to be substituted for the respective questionmarks in the query text</dd>
<dt><span class="strong">Returns:</span></dt><dd>an array of zero or more Maps of zero or more variablename-to-term bindings (each Map represents a solution, in the order in which they were found)</dd></dl>
</li>
</ul>
<a name="nSolutions(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nSolutions</h4>
<pre>public final&nbsp;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;[]&nbsp;nSolutions(long&nbsp;n)</pre>
<div class="block">calls the Query's goal to exhaustion or until N solutions are found, whichever is sooner, and returns an array containing (as possibly empty Maps of variablename-to-term bindings) every found
 solution (in the order in which they were found).</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>an array of Maps (possibly none), each of which is a solution (in the order in which they were found) of the Query; at most 'n' solutions will be found and returned. <b>NB</b> in JPL
         1.0.1, this method (inconsistently) returned null when a Query had no solutions; in JPL 2.x onwards it returns an empty array (thus the length of the array is, in every case, the
         quantity of solutions).
         <p>
         <b>NB</b> in JPL 1.0.1, bindings were keyed (awkwardly) by Variable instances; in JPL 2.x onwards they are keyed by the (String) names of variables, which is consistent with the Term
         type being just a concrete syntax for terms (and hence queries).
         <p></dd></dl>
</li>
</ul>
<a name="nSolutions(org.jpl7.Term, long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nSolutions</h4>
<pre>public static final&nbsp;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;[]&nbsp;nSolutions(<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&nbsp;goal,
                                                long&nbsp;n)</pre>
<div class="block">This static method creates a Query whose goal is the given Term, calls it to exhaustion or until N solutions are found, whichever is sooner, and returns an array containing (as possibly empty
 Maps of variablename-to-term bindings) every found solution (in the order in which they were found). Throws JPLException if goal is neither a jpl.Atom nor a jpl.Compound.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>goal</code> - the goal of this Query</dd></dl>
</li>
</ul>
<a name="nSolutions(java.lang.String, long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nSolutions</h4>
<pre>public static final&nbsp;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;[]&nbsp;nSolutions(java.lang.String&nbsp;text,
                                                long&nbsp;n)</pre>
<div class="block">This static method creates a Query from the given Prolog source text fragment, calls it to exhaustion or until N solutions are found, whichever is sooner, and returns an array containing (as
 possibly empty Maps of variablename-to-term bindings) every found solution (in the order in which they were found). Throws PrologException containing error(syntax_error(_),_) if text is
 invalid.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - a Prolog source text fragment denoting a goal</dd></dl>
</li>
</ul>
<a name="nSolutions(java.lang.String, org.jpl7.Term[], long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nSolutions</h4>
<pre>public static final&nbsp;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;[]&nbsp;nSolutions(java.lang.String&nbsp;text,
                                                <a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>[]&nbsp;params,
                                                long&nbsp;n)</pre>
<div class="block">If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols and there are N accompanying params, this static method replaces each questionmark symbol by
 its respective param, calls the resulting goal to exhaustion or until N solutions are found, whichever is sooner, and returns an array containing (as possibly empty Maps of variablename-to-term
 bindings) every found solution (in the order in which they were found).
 
 Otherwise, if text denotes an atom, this static method creates a Query where text is the name of the goal and params are the args; the resulting goal is then called as above. This latter mode
 is redundant, deprecated (informally), and retained only for backward compatibility.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - the Prolog source text of a goal, in which questionmarks are regarded as substitutible parameters</dd><dd><code>params</code> - terms to be substituted for the respective questionmarks in the query text</dd></dl>
</li>
</ul>
<a name="oneSolution()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>oneSolution</h4>
<pre>public final&nbsp;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&nbsp;oneSolution()</pre>
<div class="block">Returns the first solution, if any, as a (possibly empty) Map of variablename-to-term bindings, else null.
 
 This method will throw a JPLException if this Query is already open (and the Query will remain open as before). Otherwise, upon return, the Query will be closed.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the first solution, if the query has one, as a (possibly empty) Map. If the return value is null, this means that the Query has no solutions.
         <p></dd></dl>
</li>
</ul>
<a name="oneSolution(org.jpl7.Term)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>oneSolution</h4>
<pre>public static final&nbsp;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&nbsp;oneSolution(<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&nbsp;goal)</pre>
<div class="block">This static method creates a Query (whose goal is the specified Term) and calls it at most once, returning the first solution, if there is one, as a (possibly empty) Map, else null. The goal
 can be a jpl.Atom or a jpl.Compound, but cannot be an instance of jpl.Float, jpl.Integer or jpl.Variable.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>goal</code> - the goal of this Query</dd></dl>
</li>
</ul>
<a name="oneSolution(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>oneSolution</h4>
<pre>public static final&nbsp;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&nbsp;oneSolution(java.lang.String&nbsp;text)</pre>
<div class="block">This static method creates a Query from the given Prolog source text fragment, and calls it at most once, returning the first solution, if there is one, as a (possibly empty) Map, else null.
 Throws PrologException containing error(syntax_error(_),_) if text is invalid.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - a Prolog source text fragment denoting a goal</dd></dl>
</li>
</ul>
<a name="oneSolution(java.lang.String, org.jpl7.Term[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>oneSolution</h4>
<pre>public static final&nbsp;java.util.Map&lt;java.lang.String,<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&gt;&nbsp;oneSolution(java.lang.String&nbsp;text,
                                               <a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>[]&nbsp;params)</pre>
<div class="block">If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols and there are N params, each questionmark symbol is replaced by its respective param to
 provide the goal of this query: the resulting goal is then called (at most once) and the first solution, if there is one, is returned as a (possibly empty) Map, else null.
 
 Otherwise, if text denotes an atom, this static method creates a Query where text is the name of the goal and params are the args; the resulting goal is then called as above. This latter mode
 is redundant, deprecated (informally), and retained only for backward compatibility.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - the Prolog source text of a goal, in which questionmarks are regarded as substitutible parameters</dd><dd><code>params</code> - terms to be substituted for the respective questionmarks in the query text</dd></dl>
</li>
</ul>
<a name="hasSolution()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSolution</h4>
<pre>public final&nbsp;boolean&nbsp;hasSolution()</pre>
<div class="block">This method will attempt to call this Query's goal within an available Prolog engine.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the provability of the Query, i.e. 'true' if it has at least one solution, 'false' if the call fails without finding a solution.
         <p>
 
         Only the first solution (if there is one) will be found; any bindings will be discarded, and the Query will be closed.
         <p>
         This method will throw a JPLException if this Query is already open.</dd></dl>
</li>
</ul>
<a name="hasSolution(org.jpl7.Term)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSolution</h4>
<pre>public static final&nbsp;boolean&nbsp;hasSolution(<a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>&nbsp;goal)</pre>
<div class="block">This static method creates a Query (whose goal is the specified Term) and calls it at most once, returning true if a solution was found, else false. The goal can be a jpl.Atom or a
 jpl.Compound, but cannot be an instance of jpl.Float, jpl.Integer or jpl.Variable.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>goal</code> - the goal of this Query</dd></dl>
</li>
</ul>
<a name="hasSolution(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSolution</h4>
<pre>public static final&nbsp;boolean&nbsp;hasSolution(java.lang.String&nbsp;text)</pre>
<div class="block">This static method creates a Query from the given Prolog source text and calls it at most once, returning true if a solution was found, else false. Throws PrologException containing
 error(syntax_error(_),_) if text is invalid.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - the goal of this Query, as Prolog source text</dd></dl>
</li>
</ul>
<a name="hasSolution(java.lang.String, org.jpl7.Term[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasSolution</h4>
<pre>public static final&nbsp;boolean&nbsp;hasSolution(java.lang.String&nbsp;text,
                  <a href="../../org/jpl7/Term.html" title="class in org.jpl7">Term</a>[]&nbsp;params)</pre>
<div class="block">If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols and there are N params, each questionmark symbol is replaced by its corresponding arg to
 provide the new Query's goal: the resulting Query is called as described above.
 
 Otherwise, if text denotes an atom, this static method creates a Query where text is the name of its goal and args are its args; it then calls this goal (at most once) and returns true if a
 solution was found, else false. This latter mode is redundant, deprecated (informally), and retained only for backward compatibility.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>text</code> - the Prolog source text of a goal, in which questionmarks are regarded as substitutible parameters</dd><dd><code>params</code> - terms to be substituted for the respective questionmarks in the query text</dd></dl>
</li>
</ul>
<a name="toString()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>toString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toString()</pre>
<div class="block">Returns a crude String representation of a Query.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="strong">Returns:</span></dt><dd>a crude String representation of a Query</dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../org/jpl7/PrologException.html" title="class in org.jpl7"><span class="strong">Prev Class</span></a></li>
<li><a href="../../org/jpl7/Term.html" title="class in org.jpl7"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?org/jpl7/Query.html" target="_top">Frames</a></li>
<li><a href="Query.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
