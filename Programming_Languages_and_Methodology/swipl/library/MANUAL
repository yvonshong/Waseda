
 VU University Amsterdam                          University of Amsterdam

~  De1Boelelaan01081a,81 HV  Amsterdam              KruislaanV419,A1098Amsterdam
     The Netherlands                                  The Netherlands

                             SWI-Prolog 7.2
                            Reference Manual
                 _U_p_d_a_t_e_d _f_o_r _v_e_r_s_i_o_n _7_._2_._3_, _A_u_g_u_s_t _2_0_1_5

                             _J_a_n _W_i_e_l_e_m_a_k_e_r
                           J.Wielemaker@vu.nl
                       http://www.swi-prolog.org

    SWI-Prolog  is a  comprehensive and portable  implementation of
    the  Prolog  programming language.    SWI-Prolog  aims to  be a
    robust  and scalable implementation supporting  a wide range of
    applications.   In  particular, it  ships with a  wide range of
    interface  libraries, providing interfaces  to other languages,
    databases,  graphics  and networking.    It  provides extensive
    support  for  managing HTML/SGML/XML  and RDF  documents.   The
    system  is particularly suited  for server  applications due to
    robust support for multithreading and HTTP server libraries.

    SWI-Prolog  is  designed  in the  `Edinburgh  tradition'.    In
    addition  to the ISO  Prolog standard it  is largely compatible
    to  Quintus, SICStus  and YAP  Prolog.   SWI-Prolog  provides a
    compatibility  framework developed in cooperation  with YAP and
    instantiated for YAP, SICStus and IF/Prolog.

    SWI-Prolog  aims at  providing a good  development environment,
    including  extensive  editor  support,  graphical  source-level
    debugger,   autoloading  and `make'  facility  and  much  more.
    SWI-Prolog  editor  and  the  PDT  plugin  for Eclipse  provide
    alternative environments.

    This  document gives an overview of the features, system limits
    and built-in predicates.


~

    This  work is licensed under  the Creative Commons Attribution-
    ShareAlike  3.0  Unported License.    To  view a  copy  of this
    license,  visit  http://creativecommons.org/licenses/by-sa/3.0/
    or  send a letter to Creative Commons, 444 Castro Street, Suite
    900, Mountain View, California, 94041, USA.


CChhaapptteerr 11..  IINNTTRROODDUUCCTTIIOONN

This document  is a  _r_e_f_e_r_e_n_c_e _m_a_n_u_a_l.    That means  that it  documents
the  system,  but  it  does  not  explain   the  basics  of  the  Prolog
language  and it  leaves  many  details of  the  syntax,  semantics  and
built-in primitives  undefined where  SWI-Prolog follows the  standards.
This  manual is  intended  for people  that  are familiar  with  Prolog.
For  those not  familiar  with Prolog,  we  recommend  to start  with  a
Prolog textbook  such as  [Bratko, 1986], [Sterling & Shapiro, 1986]  or
[Clocksin & Melish, 1987].  For more advanced Prolog  usage we recommend
[O'Keefe, 1990].


11..11 PPoossiittiioonniinngg SSWWII--PPrroolloogg

Most implementations  of the  Prolog language  are designed  to serve  a
limited set  of use cases.    SWI-Prolog is no  exception to this  rule.
SWI-Prolog  positions  itself  primarily as  a  Prolog  environment  for
`programming in the large'  and use cases where it plays a  central role
in an  application, i.e.,  where it acts  as `glue' between  components.
At  the same  time,  SWI-Prolog aims  at  providing a  productive  rapid
prototyping environment.    Its orientation towards  programming in  the
large is backed  up by scalability, compiler speed,  program structuring
(modules), support  for multithreading  to accommodate servers,  Unicode
and interfaces  to a  large number  of document  formats, protocols  and
programming languages.   Prototyping is facilitated by good  development
tools,  both  for  command  line  usage  as  for  usage  with  graphical
development tools.   Demand loading of  predicates from the library  and
a  `make' facility  avoids the  _r_e_q_u_i_r_e_m_e_n_t for  using declarations  and
reduces typing.

SWI-Prolog is traditionally  strong in education because it is  free and
portable, but also  because of its compatibility with textbooks  and its
easy-to-use environment.

Note that these  positions do not imply  that the system cannot be  used
with other scenarios.  SWI-Prolog is used as  an embedded language where
it serves as a small rule subsystem in a large application.   It is also
used as a  deductive database.  In  some cases this is the right  choice
because SWI-Prolog  has features that are  required in the  application,
such as threading or  Unicode support.  In general though,  for example,
GNU-Prolog is  more suited  for embedding  because it is  small and  can
compile to  native code, XSB is  better for deductive databases  because
it provides  advanced resolution  techniques (tabling),  and ECLiPSe  is
better at constraint handling.

The  syntax  and  set  of  built-in  predicates  is  based  on  the  ISO
standard  [Hodgson, 1998].     Most  extensions  follow  the  `Edinburgh
tradition' (DEC10 Prolog  and C-Prolog) and Quintus Prolog  [Qui, 1997].
The  infrastructure  for  constraint programming  is  based  on  hProlog
[Demoen, 2002].     Some libraries  are  copied  from  the  YAP  system.
Together   with  YAP   we  developed   a   portability  framework   (see
section 14).   This framework has  been filled for SICStus Prolog,  YAP,
IF/Prolog and Ciao.  SWI-Prolog version 7  introduces various extensions
to the Prolog  language (see section 5).   The _s_t_r_i_n_g data type and  its
supporting set of built-in predicates is compatibility with ECLiPSe.


11..22 SSttaattuuss aanndd rreelleeaasseess

This manual describes version  7.2 of SWI-Prolog.  SWI-Prolog  is widely
considered to  be a  robust and  scalable implementation  of the  Prolog
language.   It is widely used in  education and research.  In  addition,
it  is in  use for  247* mission  critical commercial  server processes.
The site http://www.swi-prolog.org  is hosted using the SWI-Prolog  HTTP
server  infrastructure.    It receives  approximately 2.3  million  hits
and serves  approximately 300 Gbytes on  manual data and downloads  each
month.    SWI-Prolog  applications  range from  student  assignments  to
commercial  applications that  count  more  than one  million  lines  of
Prolog code.

SWI-Prolog has  two development tracks.   _S_t_a_b_l_e  releases have an  even
_m_i_n_o_r version  number (e.g., 6.2.1)  and are released  as a branch  from
the  development version  when  the  development version  is  considered
stable and  there is sufficient  new functionality  to justify a  stable
release.   Stable releases often  get a few  patch updates to deal  with
installation  issues or  major flaws.    A  new _D_e_v_e_l_o_p_m_e_n_t  version  is
typically released  every couple of  weeks as a  snapshot of the  public
git  repository.    `Extra  editions'  of the  development  version  may
be released  after problems  that severely  hindered the  user in  their
progress have been fixed.

Known  bugs that  are  not likely  to be  fixed  soon are  described  as
footnotes in this manual.


11..33 SShhoouulldd II bbee uussiinngg SSWWII--PPrroolloogg??

There  are a  number of  reasons  why it  might be  better  to choose  a
commercial, or another free, Prolog system:

  o _S_W_I_-_P_r_o_l_o_g _c_o_m_e_s _w_i_t_h _n_o _w_a_r_r_a_n_t_i_e_s
    Although   the  developers   or  the  community   often  provide   a
    work-around or a fix for  a bug, there is no place you can go to for
    guaranteed  support.  However, the full source archive  is available
    and can be used  to compile and debug SWI-Prolog using free tools on
    all  major platforms.   Users requiring  more support should  ensure
    access to knowledgeable developers.

  o _P_e_r_f_o_r_m_a_n_c_e _i_s _y_o_u_r _f_i_r_s_t _c_o_n_c_e_r_n
    Various  free and commercial systems have better performance.   But,
    `standard'  Prolog benchmarks disregard many factors that  are often
    critical  to the performance of  large applications.  SWI-Prolog  is
    not  good  at fast  calling of  simple  predicates and  if-then-else
    selection  based  on simple  built-in tests,  but  it is  fast  with
    dynamic  code,   meta-calling  and  predicates  that  contain  large
    numbers  of clauses.   Many of SWI-Prolog's built-in predicates  are
    written in C and have excellent performance.

  o _Y_o_u _n_e_e_d _f_e_a_t_u_r_e_s _n_o_t _o_f_f_e_r_e_d _b_y _S_W_I_-_P_r_o_l_o_g
    Although   SWI-Prolog  has  many  features,   it  also  lacks   some
    important  features.    The  most  well  known is  probably  _t_a_b_l_i_n_g
    [Freire _e_t _a_l_., 1997].   If you require additional features  and you
    have  resources, be  it financial or  expertise, please contact  the
    developers.

On the  other hand,  SWI-Prolog offers some  facilities that are  widely
appreciated by users:

  o _N_i_c_e _e_n_v_i_r_o_n_m_e_n_t
    SWI-Prolog  provides a good command line environment,  including `Do
    What I Mean',  autocompletion, history and a tracer that operates on
    single  key strokes.   The system automatically recompiles  modified
    parts  of the source code using the make/0 command.  The  system can
    be  instructed to  open an arbitrary  editor on  the right file  and
    line based on its  source database.  It ships with various graphical
    tools  and can be combined with the SWI-Prolog editor,  PDT (Eclipse
    plugin for Prolog) or GNU-Emacs.

  o _F_a_s_t _c_o_m_p_i_l_e_r
    Even  very  large applications  can  be loaded  in seconds  on  most
    machines.   If this is not  enough, there is the Quick  Load Format.
    See qcompile/1 and qsave_program/2.

  o _T_r_a_n_s_p_a_r_e_n_t _c_o_m_p_i_l_e_d _c_o_d_e
    SWI-Prolog  compiled code can be  treated just as interpreted  code:
    you  can list it, trace  it, etc.  This  implies you do not have  to
    decide  beforehand whether a module  should be loaded for  debugging
    or  not, and the  performance of debugged code  is close to that  of
    normal operation.

  o _S_o_u_r_c_e _l_e_v_e_l _d_e_b_u_g_g_e_r
    The  source  level   debugger  provides  a  good  overview  of  your
    current  location  in  the  search  tree,  variable  bindings,  your
    source  code  and  open choice  points.    Choice  point  inspection
    provides  meaningful insight to both novices and  experienced users.
    Avoiding unintended choice  points often provides a huge increase in
    performance and a huge saving in memory usage.

  o _P_r_o_f_i_l_i_n_g
    SWI-Prolog  offers an execution profiler with either  textual output
    or  graphical output.   Finding and  improving hotspots in a  Prolog
    program may result in huge speedups.

  o _F_l_e_x_i_b_i_l_i_t_y
    SWI-Prolog  can  easily   be  integrated  with  C,  supporting  non-
    determinism  in Prolog calling  C as well  as C calling Prolog  (see
    section  10).   It can  also be _e_m_b_e_d_d_e_d  in external programs  (see
    section  10.5).    System  predicates can  be redefined  locally  to
    provide compatibility with other Prolog systems.

  o _T_h_r_e_a_d_s
    Robust  support for multiple threads may improve performance  and is
    a key enabling factor for deploying Prolog in server applications.

  o _I_n_t_e_r_f_a_c_e_s
    SWI-Prolog   ships  with  many   extension  packages  that   provide
    robust  interfaces  to processes,  encryption,  TCP/IP, TIPC,  ODBC,
    SGML/XML/HTML, RDF, HTTP, graphics and much more.


11..44 SSuuppppoorrtt tthhee SSWWII--PPrroolloogg pprroojjeecctt

You  can support  the SWI-Prolog  project in  several ways.    Academics
are  invited to  cite one  of the  publications on  SWI-Prolog.    Users
can  help  by  identifying and/or  fixing  problems  with  the  code  or
its  documentation..    Users  can  contribute  new  features  or,  more
lightweight,   contribute  packs.      Commercial  users  may   consider
contacting the  developers to  sponsor the development  of new  features
or seek  for opportunities  to cooperate  with the  developers or  other
commercial users.


11..55 IImmpplleemmeennttaattiioonn hhiissttoorryy

SWI-Prolog started back in  1986 with the requirement for a  Prolog that
could handle recursive interaction with the C-language:   Prolog calling
C and C calling  Prolog recursively.  In those days Prolog  systems were
not very  aware of  their environment  and we  needed such  a system  to
support interactive applications.  Since then,  SWI-Prolog's development
has  been  guided  by  requests  from  the  user  community,  especially
focussing  on (in  arbitrary order)  interaction  with the  environment,
scalability, (I/O)  performance, standard  compliance, teaching and  the
program development environment.

SWI-Prolog  is  based   on  a  simple  Prolog  virtual  machine   called
ZIP   [Bowen _e_t _a_l_., 1983,  Neumerkel, 1993]   which  defines   only   7
instructions.    Prolog  can  easily  be compiled  into  this  language,
and the  abstract machine code  is easily  decompiled back into  Prolog.
As  it is  also  possible to  wire a  standard  4-port debugger  in  the
virtual machine,  there is  no need for  a distinction between  compiled
and interpreted  code.   Besides  simplifying the design  of the  Prolog
system itself,  this approach  has advantages  for program  development:
the  compiler is  simple and  fast, the  user  does not  have to  decide
in  advance whether  debugging is  required, and  the  system only  runs
slightly slower in debug  mode compared to normal execution.   The price
we have to pay is some performance degradation (taking  out the debugger
from the VM interpreter improves performance by about  20%) and somewhat
additional memory usage to help the decompiler and debugger.

SWI-Prolog  extends  the  minimal  set  of   instructions  described  in
[Bowen _e_t _a_l_., 1983]  to improve  performance.    While  extending  this
set, care  has been  taken to maintain  the advantages of  decompilation
and  tracing of  compiled  code.    The extensions  include  specialised
instructions  for unification,  predicate  invocation,  some  frequently
used built-in  predicates, arithmetic, and  control (;/2, |/2),  if-then
(->/2) and negation-by-failure (\+/1).


11..66 AAcckknnoowwlleeddggeemmeennttss

Some small parts of the Prolog code of SWI-Prolog  are modified versions
of the corresponding Edinburgh C-Prolog code:   grammar rule compilation
and  writef/2.    Also some  of  the  C-code originates  from  C-Prolog:
finding the  path of the  currently running executable  and some of  the
code underlying  absolute_file_name/2.   Ideas  on programming style  and
techniques originate from  C-Prolog and Richard O'Keefe's _t_h_i_e_f  editor.
An  important  source  of inspiration  are  the  programming  techniques
introduced by Anjo Anjewierden in PCE version 1 and 2.

Our special  thanks go  to those  who had the  fate of  using the  early
versions of this system,  suggested extensions or reported bugs.   Among
them are Anjo Anjewierden, Huub Knops, Bob  Wielinga, Wouter Jansweijer,
Luc Peerdeman, Eric Nombden, Frank van Harmelen, Bert Rengel.

Martin Jansche  (jansche@novell1.gs.uni-heidelberg.de) has been so  kind
to reorganise the sources  for version 2.1.3 of this manual.   Horst von
Brand has been so kind to fix many typos in the  2.7.14 manual.  Thanks!
Randy Sharp fixed many issues in the 6.0.x version of the manual.

Bart  Demoen and  Tom  Schrijvers  have helped  me  adding  coroutining,
constraints,  global  variables and  support  for  cyclic terms  to  the
kernel.  Tom Schrijvers has provided a first  clp(fd) constraint solver,
the CHR compiler and some of the coroutining predicates.   Markus Triska
contributed the current clp(fd) implementation.

Paul Singleton has integrated Fred Dushin's  Java-calls-Prolog side with
his Prolog-calls-Java side into the current  bidirectional JPL interface
package.

Richard O'Keefe  is gratefully acknowledged for  his efforts to  educate
beginners as well as valuable comments on proposed new developments.

Scientific  Software and  Systems Limited,  www.sss.co.nz has  sponsored
the  development of  the SSL  library,  unbounded integer  and  rational
number arithmetic and many enhancements to the memory  management of the
system.

Leslie de Koninck has made clp(QR) available to SWI-Prolog.

Jeff  Rosenwald contributed  the TIPC  networking  library and  Google's
protocol buffer handling.

Paulo  Moura's  great   experience  in  maintaining  Logtalk  for   many
Prolog systems  including SWI-Prolog  has helped in  many places  fixing
compatibility issues.   He also worked on the MacOS port and  fixed many
typos in the 5.6.9 release of the documentation.


CChhaapptteerr 22..  OOVVEERRVVIIEEWW


22..11 GGeettttiinngg ssttaarrtteedd qquuiicckkllyy


22..11..11 SSttaarrttiinngg SSWWII--PPrroolloogg


22..11..11..11 SSttaarrttiinngg SSWWII--PPrroolloogg oonn UUnniixx

By  default, SWI-Prolog  is  installed as  `swipl'.   The  command  line
arguments of SWI-Prolog  itself and its utility programs are  documented
using standard Unix  man pages.   SWI-Prolog is normally operated as  an
interactive application simply by starting the program:

________________________________________________________________________|                                                                        |
|machine% swipl                                                          |

|Welcome to SWI-Prolog ...                                               |
|...                                                                     |
|                                                                        |
|1|?-___________________________________________________________________ | |

After  starting Prolog,  one  normally loads  a  program into  it  using
consult/1, which may be  abbreviated by putting the name of  the program
file  between square  brackets.    The  following  goal loads  the  file
likes.pl containing clauses for the predicates likes/2:

________________________________________________________________________|                                                                        |
|?- [likes].                                                             |
|% likes compiled, 0.00 sec, 17 clauses                                  |

|true.                                                                   |
|                                                                        |
|?-|____________________________________________________________________ |  |

After this  point, Unix  and Windows users  unite, so  if you are  using
Unix please continue at section 2.1.2.


22..11..11..22 SSttaarrttiinngg SSWWII--PPrroolloogg oonn WWiinnddoowwss

After SWI-Prolog has been  installed on a Windows system,  the following
important new things are available to the user:

  o A  folder  (called  _d_i_r_e_c_t_o_r_y in  the  remainder of  this  document)
    called  swipl containing  the executables, libraries,  etc., of  the
    system.  No files are installed outside this directory.

  o A  program swipl-win.exe,  providing a  window for interaction  with
    Prolog.  The  program swipl.exe is a version of SWI-Prolog that runs
    in a console window.

  o The  file  extension  .pl  is associated  with  the  program  swipl-
    win.exe.    Opening a .pl  file will  cause swipl-win.exe to  start,
    change  directory  to  the  directory  in which  the  file  to  open
    resides, and load this file.

The normal way to  start the likes.pl file mentioned in  section 2.1.1.1
is by simply double-clicking this file in the Windows explorer.


22..11..22 EExxeeccuuttiinngg aa qquueerryy

After loading a program,  one can ask Prolog queries about  the program.
The query below asks Prolog what food `sam' likes.   The system responds
with X = <_v_a_l_u_e> if it can prove the goal for a certain _X. The  user can
type the  semi-colon (;)  or spacebar if  (s)he wants another  solution.
Use the return key if  you do not want to see the more answers.   Prolog
completes the output with a  full stop (.)  if the user uses  the return
key or Prolog  _k_n_o_w_s there are no more  answers.  If Prolog cannot  find
(more) answers,  it  writes ffaallssee..    Finally, Prolog  answers using  an
error message to indicate the query or program contains an error.

________________________________________________________________________|                                                                        |
|?- likes(sam, X).                                                       |

|X = dahl ;                                                              |
|X = tandoori ;                                                          |
|...                                                                     |
|X = chips.                                                              |
|                                                                        |
|?-|____________________________________________________________________ |  |

Note  that the  answer  written by  Prolog  is  a valid  Prolog  program
that, when  executed, produces the same  set of answers as the  original
program.


22..22 TThhee uusseerr''ss iinniittiiaalliissaattiioonn ffiillee

After the  system initialisation,  the system  consults (see  consult/1)
the user's startup file.  The basename of  this file follows conventions
of  the operating  system.   On  MS-Windows,  it is  the file  swipl.ini
and  on  Unix  systems  .swiplrc.    The  file  is  searched  using  the
file_search_path/2 clauses for user_profile.  The table below  shows the
default value for this search  path.  The phrase <_a_p_p_d_a_t_a> refers to the
Windows CSIDL  name for  the folder.   The  actual name  depends on  the
Windows language.  English versions typically use ApplicationData.   See
also win_folder/2

                   __________________________________
                   |____________|UUnniixx__||WWiinnddoowwss__________________________ ||
                   ||_hhoommee_||~____|<_a_p_p_d_a_t_a>/SWI-Prolog_|

After the  first startup  file is found  it is  loaded and Prolog  stops
looking for further startup files.  The name of the  startup file can be
changed with the  `-f file' option.   If _F_i_l_e denotes an absolute  path,
this file is loaded,  otherwise the file is searched for using  the same
conventions as for the default startup file.  Finally,  if _f_i_l_e is none,
no file is loaded.

The installation provides  a file customize/dotswiplrc with  (commented)
commands that are often used to customize the behaviour  of Prolog, such
as interfacing  to the  editor, color selection  or history  parameters.
Many  of the  development tools  provide menu  entries  for editing  the
startup  file  and  starting  a  fresh  startup  file  from  the  system
skeleton.

See  also  the  -s  (script)  and  -F  (system-wide  initialisation)  in
section 2.4 and section 2.3.


22..33 IInniittiiaalliissaattiioonn ffiilleess aanndd ggooaallss

Using  command line  arguments  (see  section 2.4),  SWI-Prolog  can  be
forced to  load files  and execute queries  for initialisation  purposes
or  non-interactive operation.    The  most  commonly used  options  are
-f file or  -s file to  make Prolog load  a file,  -g goal to define  an
initialisation  goal and  -t goal to  define the  _t_o_p_-_l_e_v_e_l _g_o_a_l.    The
following  is a  typical example  for starting  an application  directly
from the command line.

________________________________________________________________________|                                                                        |
|machine%|swipl_-s_load.pl_-g_go_-t_halt________________________________ |        |

It  tells  SWI-Prolog to  load  load.pl,  start  the  application  using
the _e_n_t_r_y  _p_o_i_n_t go/0  and ---instead  of entering  the interactive  top
level--- exit  after completing go/0.   The -q  may be used to  suppress
all informational messages.

In  MS-Windows,  the  same  can  be  achieved  using  a  short-cut  with
appropriately  defined  command  line  arguments.     A  typically  seen
alternative  is to  write  a file  run.pl  with content  as  illustrated
below.  Double-clicking run.pl will start the application.

________________________________________________________________________|                                                                        |

|:- [load].                      % load program                          |
|:- go.                          % run it                                |
|:-|halt.________________________%_and_exit_____________________________ |  |

Section 2.10.2.1  discusses further  scripting options,  and chapter  11
discusses the  generation of runtime executables.   Runtime  executables
are  a means  to deliver  executables  that do  not require  the  Prolog
system.


22..44 CCoommmmaanndd lliinnee ooppttiioonnss

SWI-Prolog can be executed in one of the following modes:

swipl --help
swipl --version
swipl --arch
swipl --dump-runtime-variables
    These  options must appear  as only  option.   They cause Prolog  to
    print an informational message and exit.  See section 2.4.1.

swipl [[_o_p_t_i_o_n ......]]  _s_c_r_i_p_t_-_f_i_l_e [[_a_r_g ......]]
    These arguments are  passed on Unix systems if file that starts with
    #!/path/to/executable [_o_p_t_i_o_n ...]  is  executed.   Arguments  after
    the script file are made available in the Prolog flag argv.

swipl [[_o_p_t_i_o_n ......]]  _p_r_o_l_o_g_-_f_i_l_e ......  [[[[--]] _a_r_g ......]]
    This  is the normal way to start Prolog.  The options  are described
    in section 2.4.2, section  2.4.3 and section 2.4.4.  The Prolog flag
    argc  provides access to  _a_r_g ...   If the  _o_p_t_i_o_n_s are followed  by
    one  or more  Prolog file  names  (i.e., names  with extension  .pl,
    .prolog  or (on  Windows)  the user  preferred extension  registered
    during  installation),  these files  are  loaded.   The  first  file
    is  registered in  the Prolog  flag associated_file.   In  addition,
    pl-win[.exe] switches to  the directory in which this primary source
    file is located using working_directory/2.

swipl --oo _o_u_t_p_u_t --cc _p_r_o_l_o_g_-_f_i_l_e ......
    The  -c option  is used to  compile a  set of Prolog  files into  an
    executable.  See section 2.4.5.

swipl --oo _o_u_t_p_u_t --bb _b_o_o_t_f_i_l_e _p_r_o_l_o_g_-_f_i_l_e ......
    Bootstrap compilation.  See section 2.4.6.


22..44..11 IInnffoorrmmaattiioonnaall ccoommmmaanndd lliinnee ooppttiioonnss

--arch
    When   given  as  the  only  option,  it  prints   the  architecture
    identifier   (see  Prolog  flag   arch)  and  exits.      See   also
    -dump-runtime-variables.  Also available as -arch.

--dump-runtime-variables _[_=_f_o_r_m_a_t_]
    When  given as  the only option,  it prints  a sequence of  variable
    settings   that  can  be  used   in  shell  scripts  to  deal   with
    Prolog  parameters.   This  feature is  also used  by swipl-ld  (see
    section 10.5).  Below is a typical example of using this feature.

    ____________________________________________________________________|                                                                    |
    | eval `swipl --dump-runtime-variables`                              |

    ||cc_-I$PLBASE/include_-L$PLBASE/lib/$PLARCH_...____________________ ||

    The  option can be  followed by  =sh to dump  in POSIX shell  format
    (default) or =cmd to dump in MS-Windows cmd.exe compatible format.

--help
    When  given as  the only  option, it summarises  the most  important
    options.  Also available as -h and -help.

--version
    When  given as the  only option, it  summarises the version and  the
    architecture identifier.  Also available as -v.


22..44..22 CCoommmmaanndd lliinnee ooppttiioonnss ffoorr rruunnnniinngg PPrroolloogg

--home=DIR
    Use DIR as home directory.  See section 10.6 for details.

--quiet
    Set  the Prolog  flag verbose to  silent, suppressing  informational
    and banner messages.  Also available as -q.

--nodebug
    Disable   debugging.        See   the   current_prolog_flag/2   flag
    generate_debug_info for details.

--nosignals
    Inhibit any signal  handling by Prolog, a property that is sometimes
    desirable  for embedded  applications.   This option  sets the  flag
    signals to false.  See section 10.4.21.1 for details.

--pldoc _[_=_p_o_r_t_]
    Start  the PlDoc  documentation system  on a free  network port  and
    launch  the user's browser  on http://localhost:<_p_o_r_t>.   If _p_o_r_t is
    specified,  the server is started at the given port and  the browser
    is _n_o_t launched.

-tty
    Unix  only.      Switches  controlling  the  terminal  for  allowing
    single-character  commands to the tracer and  get_single_char/1.   By
    default,  manipulating  the terminal  is enabled  unless the  system
    detects  it is not  connected to a  terminal or it  is running as  a
    GNU-Emacs inferior process.  See also tty_control.

--win_app
    This  option  is   available  only  in  swipl-win.exe  and  is  used
    for  the  start-menu  item.     If causes  plwin  to  start  in  the
    folder  ...\My Documents\Prolog  or  local equivalent  thereof  (see
    win_folder/2).   The Prolog subdirectory  is created if it does  not
    exist.

-O
    Optimised  compilation.  See current_prolog_flag/2flag  optimise for
    details.

-s _f_i_l_e
    Use  _f_i_l_e as a  script file.   The script file  is loaded after  the
    initialisation  file  specified with  the -f file  option.    Unlike
    -f file,  using -s does  not stop Prolog  from loading the  personal
    initialisation file.

-f _f_i_l_e
    Use  _f_i_l_e as  initialisation file  instead of  the default  .swiplrc
    (Unix)  or swipl.ini  (Windows).   `-f none'  stops SWI-Prolog  from
    searching  for  a startup  file.   This  option can  be  used as  an
    alternative  to -s file that stops Prolog from loading  the personal
    initialisation file.  See also section 2.2.

-F _s_c_r_i_p_t
    Select  a startup script  from the SWI-Prolog  home directory.   The
    script  file  is named  <_s_c_r_i_p_t>.rc.    The  default _s_c_r_i_p_t  name  is
    deduced  from  the  executable,  taking the  leading  alphanumerical
    characters  (letters, digits and underscore) from the  program name.
    -F none stops looking  for a script.  Intended for simple management
    of  slightly different  versions.   One  could,  for example,  write
    a  script  iso.rc  and  then select  ISO  compatibility  mode  using
    pl -F iso or make a link from iso-pl to pl.

-x _b_o_o_t_f_i_l_e
    Boot  from _b_o_o_t_f_i_l_e instead  of the system's default  boot file.   A
    boot  file is a file resulting  from a Prolog compilation using  the
    -b or -c option or a program saved using qsave_program/[1,2].

-p _a_l_i_a_s_=_p_a_t_h_1_[_:_p_a_t_h_2 _._._._]
    Define  a  path  alias  for file_search_path.    _a_l_i_a_s  is  the  name
    of  the  alias, and  argpath1 ...    is  a list  of  values for  the
    alias.    On Windows  the list  separator is ;.    On other  systems
    it  is :.   A  value is either  a term of  the form alias(value)  or
    pathname.    The  computed aliases  are added  to file_search_path/2
    using  asserta/1, so they precede  predefined values for the  alias.
    See  file_search_path/2 for  details  on  using this  file  location
    mechanism.

--traditional
    This  flag  disables the  most  important extensions  of  SWI-Prolog
    version  7 (see  section 5)  that introduce incompatibilities.    In
    particular,  lists  will  be  represented in  the  traditional  way,
    double  quoted text  is  represented by  a list  of character  codes
    and  the functional  notation on  maps is not  supported.   Maps  as
    a  syntactic  entity and  the  predicates that  act on  them  remain
    supported if this flag is present.

--
    Stops  scanning for more  arguments, so you  can pass arguments  for
    your  application after this  one.   See current_prolog_flag/2 using
    the flag argv for obtaining the command line arguments.


22..44..33 CCoonnttrroolllliinngg tthhee ssttaacckk ssiizzeess

The default limit for the  Prolog stacks is 128 MB on 32-bit and  256 MB
on 64-bit hardware.   The 128 MB limit on 32-bit systems is  the highest
possible value  and the command  line options can thus  only be used  to
lower the  limit.   On  64-bit systems,  the limit can  both be  reduced
and enlarged.   See  section 2.19.   Below are  two examples, the  first
reducing the local stack limit to catch unbounded  recursion quickly and
the second using a  big (32 GB) global limit, which is only  possible on
64-bit hardware.   Note  that setting the limit  using the command  line
only sets a _s_o_f_t  limit.  Stack parameters can be changed  (both reduced
and enlarged) at any time using the predicate set_prolog_stack/2.

________________________________________________________________________|                                                                        |
|$ swipl -L8m                                                            |

|$|swipl_-G32g__________________________________________________________ | |

-G_s_i_z_e_[_k_m_g_]
    Limit  for the  global stack  (sometimes also called  _t_e_r_m _s_t_a_c_k  or
    _h_e_a_p).  This is where compound terms and large numbers live.

-L_s_i_z_e_[_k_m_g_]
    Limit  for  the  local  stack  (sometimes  also  called  _e_n_v_i_r_o_n_m_e_n_t
    _s_t_a_c_k).  This is where environments and choice points live.

-T_s_i_z_e_[_k_m_g_]
    Limit  for  the  trail stack.    This  is  where  we keep  track  of
    assignments, so we can rollback on backtracking or exceptions.


22..44..44 RRuunnnniinngg ggooaallss ffrroomm tthhee ccoommmmaanndd lliinnee

-g _g_o_a_l
    _G_o_a_l  is executed just before entering the top level.  Default  is a
    predicate  which prints the  welcome message.   The welcome  message
    can be suppressed with  --quiet, but also with -g true.  _g_o_a_l can be
    a complex term.   In this case quotes are normally needed to protect
    it  from being expanded  by the  shell.   A safe way  to run a  goal
    non-interactively is here:

    ____________________________________________________________________|                                                                    |
    ||%_swipl_<options>_-g_go,halt_-t_'halt(1)'_________________________ ||

-t _g_o_a_l
    Use  _g_o_a_l  as interactive  top  level instead  of the  default  goal
    prolog/0.    _g_o_a_l can  be a  complex term.   If  the top-level  goal
    succeeds  SWI-Prolog exits  with status  0.   If it  fails the  exit
    status is 1.   If the top level raises an exception, this is printed
    as  an uncaught error  and the top  level is restarted.   This  flag
    also  determines the goal  started by break/0 and  abort/0.  If  you
    want  to stop  the user  from entering interactive  mode, start  the
    application with `-g goal' and give `halt' as top level.


22..44..55 CCoommppiillaattiioonn ooppttiioonnss

-c _f_i_l_e _._._.
    Compile files into an `intermediate code file'.  See section 2.10.

-o _o_u_t_p_u_t
    Used  in combination  with -c  or -b  to determine  output file  for
    compilation.


22..44..66 MMaaiinntteennaannccee ooppttiioonnss

The following options  are for system maintenance.   They are given  for
reference only.

-b _i_n_i_t_f_i_l_e _._._.-c _f_i_l_e _._._.
    Boot  compilation.   _i_n_i_t_f_i_l_e  _._._.   are compiled  by the  C-written
    bootstrap  compiler,  _f_i_l_e  _._._.    by  the normal  Prolog  compiler.
    System maintenance only.

-d _t_o_k_e_n_1_,_t_o_k_e_n_2_,_._._.
    Print  debug messages for  DEBUG statements tagged  with one of  the
    indicated  tokens.  Only has  effect if the system is compiled  with
    the -DO_DEBUG flag.  System maintenance only.


22..55 GGNNUU EEmmaaccss IInntteerrffaaccee

Unfortunately the  default Prolog mode  of GNU-Emacs  is not very  good.
There are several alternatives though:

  o http://turing.ubishops.ca/home/bruda/emacs-prolog/

  o http://www.logic.at/prolog/ediprolog/ediprolog.html

  o http://www.logic.at/prolog/pceprolog/pceprolog.html

  o http://www.logic.at/prolog/etrace/etrace.html


22..66 OOnnlliinnee HHeellpp

SWI-Prolog  provides an  online  help system  that covers  this  manual.
If  the  XPCE  graphics  system  is  available,   online  help  opens  a
graphical  window.     Otherwise  the  documentation  is  shown  in  the
Prolog  console.    The help  system  is  controlled by  the  predicates
below.   Note  that this  help system  only covers  the core  SWI-Prolog
manual.  The website provides an integrated manual  that covers the core
system as  well as  all standard  extension packages.    It is  possible
to  install  the  SWI-Prolog website  locally  by  cloning  the  website
repository git://www.swi-prolog.org/home/pl/git/plweb.git and  following
the instructions in the README file.


hheellpp
    Equivalent to help(help/1).


hheellpp((_+_W_h_a_t))
    Show specified part of the manual.  _W_h_a_t is one of:

          <_N_a_m_e>/<_A_r_i_t_y> Give help on specified predicate
          <_N_a_m_e>         Give  help on  named  predicate with  any
                         arity or  C interface function  with that
                         name
          <_S_e_c_t_i_o_n>      Display  specified  section.      Section
                         numbers are dash-separated  numbers:  2-3
                         refers  to  section 2.3  of  the  manual.

                         Section   numbers  are   obtained   using
                         apropos/1.

    Examples:

       ?- help(assert).     Give help on predicate assert
       ?- help(3-4).        Display section 3.4 of the manual
       ?- help('PL_retry'). Give    help   on    interface   function
                            PL_retry()

    See  also apropos/1 and the SWI-Prolog home page  at http://www.swi-
    prolog.org, which provides  a FAQ, an HTML version of the manual for
    online browsing, and HTML and PDF versions for downloading.


aapprrooppooss((_+_P_a_t_t_e_r_n))
    Display all predicates,  functions and sections that have _P_a_t_t_e_r_n in
    their  name or summary  description.   Lowercase letters in  _P_a_t_t_e_r_n
    also match a corresponding uppercase letter.  Example:

            ?- apropos(file).  Display   predicates,   functions
                               and  sections  that  have  `file'
                               (or  `File',  etc.)     in  their
                               summary description.


eexxppllaaiinn((_+_T_o_E_x_p_l_a_i_n))
    Give an explanation on  the given `object'.  The argument may be any
    Prolog  data object.   If  the argument is  an atom,  a term of  the
    form  _N_a_m_e_/_A_r_i_t_y or a term of the form  _M_o_d_u_l_e_:_N_a_m_e_/_A_r_i_t_y, explain/1
    describes  the predicate as well as possible references to it.   See
    also gxref/0.


eexxppllaaiinn((_+_T_o_E_x_p_l_a_i_n_, _-_E_x_p_l_a_n_a_t_i_o_n))
    Unify  _E_x_p_l_a_n_a_t_i_o_n with an explanation for _T_o_E_x_p_l_a_i_n.   Backtracking
    yields further explanations.


22..77 CCoommmmaanndd lliinnee hhiissttoorryy

SWI-Prolog  offers a  query substitution  mechanism similar  to what  is
seen in Unix shells.  The availability of this  feature is controlled by
set_prolog_flag/2,  using the history Prolog  flag.  By default,  history
is available  if the  Prolog flag  readline is false.    To enable  this
feature, remembering the  last 50 commands, put the following  into your
startup file (see section 2.2):

________________________________________________________________________|                                                                        |
|:-|set_prolog_flag(history,_50)._______________________________________ |  |

The history  system allows the  user to compose  new queries from  those
typed  before and  remembered by  the  system.   The  available  history
commands are  shown in  table 2.1.   History  expansion is  not done  if
these sequences appear in quoted atoms or strings.
             ______________________________________________
             | !!.   |Repeat last query                     |
             | !nr.  |Repeat query numbered <_n_r>            |

             | !str. |Repeat last query starting with <_s_t_r> |
             | h.    |Show history of commands              |
             |_!h.___|Show_this_list_______________________ |

                      Table 2.1:  History commands


22..88 RReeuussee ooff ttoopp--lleevveell bbiinnddiinnggss

Bindings resulting  from the  successful execution of  a top-level  goal
are asserted in a database _i_f _t_h_e_y _a_r_e _n_o_t _t_o_o _l_a_r_g_e.   These values may
be reused in  further top-level queries as $Var.   If the same  variable
name is used  in a subsequent query  the system associates the  variable
with the latest binding.  Example:
________________________________________________________________________|                                                                        |
|1 ?- maplist(plus(1), "hello", X).                                      |
|X = [105,102,109,109,112].                                              |
|                                                                        |

|2 ?- format('~s~n', [$X]).                                              |
|ifmmp                                                                   |
|true.                                                                   |
|                                                                        |
|3|?-___________________________________________________________________ | |

                Figure 2.1:  Reusing top-level bindings

Note that variables may be set by executing =/2:

________________________________________________________________________|                                                                        |
|6 ?- X = statistics.                                                    |

|X = statistics.                                                         |
|                                                                        |
|7 ?- $X.                                                                |
|28.00 seconds cpu time for 183,128 inferences                           |
|4,016 atoms, 1,904 functors, 2,042 predicates, 52 modules               |
|55,915 byte codes; 11,239 external references                           |
|                                                                        |
|                      Limit    Allocated       In use                   |

|Heap         :                                624,820 Bytes             |
|Local  stack :    2,048,000        8,192          404 Bytes             |
|Global stack :    4,096,000       16,384          968 Bytes             |
|Trail  stack :    4,096,000        8,192          432 Bytes             |
|true.|_________________________________________________________________ |     |


22..99 OOvveerrvviieeww ooff tthhee DDeebbuuggggeerr

SWI-Prolog has  a 6-port  tracer, extending the  standard 4-port  tracer
[Byrd, 1980, Clocksin & Melish, 1987]  with two additional  ports.   The
optional  _u_n_i_f_y  port  allows the  user  to  inspect  the  result  after
unification of the head.  The _e_x_c_e_p_t_i_o_n port  shows exceptions raised by
throw/1 or one of the built-in predicates.  See section 4.10.

The standard  ports are called call,  exit, redo, fail  and unify.   The
tracer is started  by the trace/0 command,  when a spy point is  reached
and the system is in debugging mode (see spy/1 and  debug/0), or when an
exception is raised that is not caught.

The interactive top-level  goal trace/0 means ``trace the next  query''.
The tracer shows the  port, displaying the port name, the  current depth
of the  recursion and the goal.   The goal  is printed using the  Prolog
predicate  write_term/2.     The style  is  defined  by the  Prolog  flag
debugger_write_options and can be modified using this flag or  using the
w, p and d commands of the tracer.
________________________________________________________________________|                                                                        |
|min_numlist([H|T], Min) :-                                              |
|        min_numlist(T, H, Min).                                         |
|                                                                        |

|min_numlist([], Min, Min).                                              |
|min_numlist([H|T], Min0, Min) :-                                        |
|        Min1 is min(H, Min0),                                           |
||_______min_numlist(T,_Min1,_Min)._____________________________________ ||

________________________________________________________________________|                                                                        |

|1 ?- visible(+all), leash(-exit).                                       |
|true.                                                                   |
|                                                                        |
|2 ?- trace, min_numlist([3, 2], X).                                     |
|   Call: (7) min_numlist([3, 2], _G0) ? creep                           |

|   Unify: (7) min_numlist([3, 2], _G0)                                  |
|   Call: (8) min_numlist([2], 3, _G0) ? creep                           |
|   Unify: (8) min_numlist([2], 3, _G0)                                  |
|^  Call: (9) _G54 is min(2, 3) ? creep                                  |
|^  Exit: (9) 2 is min(2, 3)                                             |
|   Call: (9) min_numlist([], 2, _G0) ? creep                            |
|   Unify: (9) min_numlist([], 2, 2)                                     |
|   Exit: (9) min_numlist([], 2, 2)                                      |

|   Exit: (8) min_numlist([2], 3, 2)                                     |
|   Exit: (7) min_numlist([3, 2], 2)                                     |
|X|=_2._________________________________________________________________ | |

Figure  2.2:   Example trace  of the  program above  showing all  ports.
The  lines marked  ^ indicate  calls  to _t_r_a_n_s_p_a_r_e_n_t  predicates.    See
section 6.

On _l_e_a_s_h_e_d  _p_o_r_t_s (set  with the  predicate leash/1,  default are  call,
exit, redo and  fail) the user is prompted  for an action.  All  actions
are single-character commands  which are executed wwiitthhoouutt waiting for  a
return, unless the command line option -tty is active.  Tracer options:

+ ((SSppyy))
    Set a spy point (see spy/1) on the current predicate.

- ((NNoo ssppyy))
    Remove the spy point (see nospy/1) from the current predicate.

/ ((FFiinndd))
    Search  for a port.   After the  `/', the user  can enter a line  to
    specify  the port to  search for.   This line consists  of a set  of
    letters  indicating the  port type,  followed by  an optional  term,
    that  should unify with  the goal run by  the port.   If no term  is
    specified  it is taken as a variable, searching for any port  of the
    specified  type.  If an atom is given, any goal whose  functor has a
    name equal to that atom matches.  Examples:

            /f               Search for any fail port

            /fe solve        Search for a  fail or exit  port of
                             any goal with name solve
            /c solve(a, _)   Search for a call to  solve/2 whose
                             first argument is a variable or the
                             atom a
            /a member(_, _)  Search for  any  port on  member/2.
                             This is equivalent to setting a spy

                             point on member/2.

. ((RReeppeeaatt ffiinndd))
    Repeat the last find command (see `/').

A ((AAlltteerrnnaattiivveess))
    Show all goals that have alternatives.

C ((CCoonntteexxtt))
    Toggle  `Show Context'.   If on, the context  module of the goal  is
    displayed between square brackets (see section 6).  Default is off.

L ((LLiissttiinngg))
    List the current predicate with listing/1.

a ((AAbboorrtt))
    Abort Prolog execution (see abort/0).

b ((BBrreeaakk))
    Enter a Prolog break environment (see break/0).

c ((CCrreeeepp))
    Continue execution, stop at next port.  (Also return, space).

d ((DDiissppllaayy))
    Set  the max_depth(_D_e_p_t_h) option of debugger_write_options,  limiting
    the  depth  to which  terms are  printed.    See also  the  w and  p
    options.

e ((EExxiitt))
    Terminate Prolog (see halt/0).

f ((FFaaiill))
    Force failure of the current goal.

g ((GGooaallss))
    Show the list of  parent goals (the execution stack).  Note that due
    to  tail recursion optimization a  number of parent goals might  not
    exist any more.

h ((HHeellpp))
    Show available options (also `?').

i ((IIggnnoorree))
    Ignore the current goal, pretending it succeeded.

l ((LLeeaapp))
    Continue execution, stop at next spy point.

n ((NNoo ddeebbuugg))
    Continue execution in `no debug' mode.

p ((PPrriinntt))
    Set  the Prolog  flag debugger_write_options to  [quoted(true), por-
    tray(true), max_depth(10), priority(699)].  This is the default.

r ((RReettrryy))
    Undo  all actions (except for database and I/O actions) back  to the
    call  port of  the current  goal and  resume execution  at the  call
    port.

s ((SSkkiipp))
    Continue  execution,  stop  at the  next  port  of tthhiiss  goal  (thus
    skipping all calls to children of this goal).

u ((UUpp))
    Continue  execution, stop at the next port of tthhee ppaarreenntt  goal (thus
    skipping  this goal and all calls to  children of this goal).   This
    option is useful to stop tracing a failure driven loop.

w ((WWrriittee))
    Set  the  Prolog flag  debugger_write_options to  [quoted(true), at-
    tributes(write), priority(699)], bypassing portray/1, etc.

The ideal  4-port model [Byrd, 1980] as  described in many Prolog  books
[Clocksin & Melish, 1987] is not visible in many  Prolog implementations
because  code  optimisation   removes  part  of  the  choice  and   exit
points.   Backtrack points  are not shown if  either the goal  succeeded
deterministically or its alternatives were removed using the cut.   When
running in  debug mode (debug/0) choice  points are only destroyed  when
removed by the cut.   In debug mode, last call optimisation  is switched
off.

Reference information to  all predicates available for manipulating  the
debugger is in section 4.37.


22..1100 CCoommppiillaattiioonn


22..1100..11 DDuurriinngg pprrooggrraamm ddeevveellooppmmeenntt

During  program development,  programs  are  normally loaded  using  the
list abbreviation  (?- [load].).   It is common  practice to organise  a
project as a collection  of source files and a _l_o_a_d _f_i_l_e, a  Prolog file
containing only use_module/[1,2] or ensure_loaded/1 directives, possibly
with a definition of the _e_n_t_r_y _p_o_i_n_t of the  program, the predicate that
is  normally used  to start  the program.    This file  is often  called
load.pl.  If the entry point is called _g_o, a typical session starts as:

________________________________________________________________________|                                                                        |
|% swipl                                                                 |

|<banner>                                                                |
|                                                                        |
|1 ?- [load].                                                            |
|<compilation messages>                                                  |
|true.                                                                   |
|                                                                        |
|2 ?- go.                                                                |
|<program|interaction>__________________________________________________ |        |

When  using  Windows,  the  user  may  open  load.pl  from  the  Windows
explorer, which will cause swipl-win.exe to be started  in the directory
holding load.pl.   Prolog loads load.pl  before entering the top  level.
If Prolog is started from an interactive shell, one  may choose the type
swipl -s load.pl.


22..1100..22 FFoorr rruunnnniinngg tthhee rreessuulltt

There are  various options if  you want to make  your program ready  for
real usage.   The best  choice depends on whether  the program is to  be
used only  on machines  holding the SWI-Prolog  development system,  the
size of the program, and the operating system (Unix vs. Windows).


22..1100..22..11 UUssiinngg PPrroollooggSSccrriipptt

A Prolog source  file can be used directly  as a Unix program using  the
Unix  #! magic  start.   The  same mechanism  is  useful for  specifying
additional parameters for  running a Prolog file  on Windows.  The  Unix
#! magic is allowed because  if the first letter of a Prolog file  is #,
the first line is treated as a comment.  To create  a Prolog script, use
one of the two alternatives below as first line.   The first can be used
to bind  a script to  a specific Prolog  installation, while the  latter
uses the default prolog installed in $PATH.

________________________________________________________________________|                                                                        |
|\verb$#!/path/to/swipl$                                                 |

|\verb$#!/usr/bin/env|swipl$____________________________________________ |                    |

The interpretation of  arguments to the executable in the  _H_a_s_h_B_a_n_g line
differs between  Unix-derived systems.    For portability,  the #!  must
be followed  immediately with  an absolute  path to  the executable  and
should have none or one argument.  Neither the  executable path, nor the
argument shall use quotes or spaces.  When started  this way, the Prolog
flag argv  contains the command  line arguments  that follow the  script
invocation.  Below is a simple script doing expression evaluation:

________________________________________________________________________|                                                                        |
|#!/usr/bin/env swipl                                                    |
|                                                                        |
|:- initialization main.                                                 |
|                                                                        |
|eval :-                                                                 |

|        current_prolog_flag(argv, Argv),                                |
|        concat_atom(Argv, ' ', SingleArg),                              |
|        term_to_atom(Term, SingleArg),                                  |
|        Val is Term,                                                    |
|        format('~w~n', [Val]).                                          |
|                                                                        |
|main :-                                                                 |
|        catch(eval, E, (print_message(error, E), fail)),                |

|        halt.                                                           |
|main :-                                                                 |
||_______halt(1)._______________________________________________________ ||

And here are two example runs:

________________________________________________________________________|                                                                        |
|% ./eval 1+2                                                            |
|3                                                                       |

|% ./eval foo                                                            |
|ERROR: is/2: Arithmetic: `foo/0' is not a function                      |
|%|_____________________________________________________________________ | |

The Windows version simply ignores the #! line.


22..1100..22..22 CCrreeaattiinngg aa sshheellll ssccrriipptt

With  the introduction  of _P_r_o_l_o_g_S_c_r_i_p_t  (see section  2.10.2.1),  using
shell scripts  as explained  in this  section has  become redundant  for
most applications.

Especially on  Unix systems  and not-too-large  applications, writing  a
shell script  that simply  loads your  application and  calls the  entry
point is  often a  good choice.    A skeleton  for the  script is  given
below, followed by the Prolog code to obtain the program arguments.

________________________________________________________________________|                                                                        |
|#!/bin/sh                                                               |

|                                                                        |
|base=<absolute-path-to-source>                                          |
|PL=swipl                                                                |
|                                                                        |
|exec|$PL_-q_-f_"$base/load"_--_________________________________________ |    |

________________________________________________________________________|                                                                        |
|:- initialization go.                                                   |
|                                                                        |
|go :-                                                                   |
|        current_prolog_flag(argv, Arguments),                           |
|        go(Arguments).                                                  |

|                                                                        |
|go(Args) :-                                                             |
||_______...____________________________________________________________ ||

On Windows  systems, similar  behaviour can  be achieved  by creating  a
shortcut to Prolog, passing the proper options or writing a .bat file.


22..1100..22..33 CCrreeaattiinngg aa ssaavveedd ssttaattee

For  larger programs,  as  well as  for programs  that are  required  to
run  on systems  that  do not  have  the SWI-Prolog  development  system
installed,  creating a  saved  state is  the  best solution.    A  saved
state  is  created using  qsave_program/[1,2]  or the  -c  command  line
option.     A saved  state  is  a  file  containing  machine-independent
intermediate code in a  format dedicated for fast loading.   Optionally,
the emulator  may be integrated  in the saved  state, creating a  single
file, but machine-dependent,  executable.  This process is  described in
chapter 11.


22..1100..22..44 CCoommppiillaattiioonn uussiinngg tthhee --cc ccoommmmaanndd lliinnee ooppttiioonn

This mechanism loads a series of Prolog source files  and then creates a
saved state as qsave_program/2 does.  The command syntax is:

________________________________________________________________________|                                                                        |
|%|swipl_[option_...]_[-o_output]_-c_file.pl_...________________________ | |

The  _o_p_t_i_o_n_s argument  are  options to  qsave_program/2 written  in  the
format below.    The option names  and their  values are described  with
qsave_program/2.

    --_o_p_t_i_o_n_-_n_a_m_e=_o_p_t_i_o_n_-_v_a_l_u_e

For  example,  to  create  a  stand-alone   executable  that  starts  by
executing main/0  and for which  the source  is loaded through  load.pl,
use the command

________________________________________________________________________|                                                                        |
|%|swipl_--goal=main_--stand_alone=true_-o_myprog_-c_load.pl____________ | |

This performs exactly the same as executing

________________________________________________________________________|                                                                        |
|% swipl                                                                 |

|<banner>                                                                |
|                                                                        |
|?- [load].                                                              |
|?- qsave_program(myprog,                                                |
|                 [ goal(main),                                          |
|                   stand_alone(true)                                    |
|                 ]).                                                    |
|?-|halt._______________________________________________________________ |  |


22..1111 EEnnvviirroonnmmeenntt CCoonnttrrooll ((PPrroolloogg ffllaaggss))

The  predicates  current_prolog_flag/2 and  set_prolog_flag/2 allow  the
user  to examine  and modify  the execution  environment.   It  provides
access  to whether  optional  features are  available on  this  version,
operating  system, foreign  code  environment, command  line  arguments,
version,  as well  as runtime  flags to  control  the runtime  behaviour
of  certain  predicates  to  achieve  compatibility  with  other  Prolog
environments.


ccuurrrreenntt__pprroolloogg__ffllaagg((_?_K_e_y_, _-_V_a_l_u_e))                                  _[_I_S_O_]
    The  predicate current_prolog_flag/2defines an interface  to instal-
    lation  features:  options  compiled in, version,  home, etc.   With
    both  arguments unbound, it will generate all defined  Prolog flags.
    With  `Key' instantiated, it unifies  the value of the Prolog  flag.
    Flag  values are typed.   Flags marked as  bool can have the  values
    true  or false.  Some Prolog flags are not defined in  all versions,
    which  is  normally indicated  in the  documentation  below as  _`_`_i_f
    _p_r_e_s_e_n_t  _a_n_d _t_r_u_e_'_'.  A boolean  Prolog flag is true iff  the Prolog
    flag  is present aanndd  the _V_a_l_u_e is  the atom true.   Tests for  such
    flags should be written as below:

    ____________________________________________________________________|                                                                    |
    |         (   current_prolog_flag(windows, true)                     |

    |         ->  <Do MS-Windows things>                                 |
    |         ;   <Do normal things>                                     |
    ||________)_________________________________________________________ ||

    Some  Prolog  flags are  scoped to  a  source file.    This  implies
    that  if they  are set  using a directive  inside a  file, the  flag
    value encountered when  loading of the file started is restored when
    loading  of the file is completed.   Currently, the following  flags
    are scoped to the source file:  generate_debug_info and optimise.

    A  new thread (see section 9) _c_o_p_i_e_s all flags from the  thread that
    created the new thread  (its _p_a_r_e_n_t).  As a consequence, modifying a
    flag inside a thread does not affect other threads.

    aacccceessss__lleevveell _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         This flag  defines  a normal  `user'  view (user,  default)  or
         a `system'  view.   In  system view  all system  code is  fully
         accessible as  if  it was  normal user  code.    In user  view,
         certain operations are not permitted and some  details are kept
         invisible.   We  leave the exact  consequences undefined,  but,
         for example, system code can be traced using  system access and
         system predicates can be redefined.

    aaddddrreessss__bbiittss _(_i_n_t_e_g_e_r_)
         Address size  of the  hosting  machine.   Typically  32 or  64.
         Except for the maximum  stack limit, this has few  implications
         to the user.  See also the Prolog flag arch.

    aaggcc__mmaarrggiinn _(_i_n_t_e_g_e_r_, _c_h_a_n_g_e_a_b_l_e_)
         If this amount  of atoms possible  garbage atoms exist  perform
         atom garbage  collection at  the  first opportunity.    Initial
         value is  10,000.    May  be changed.    A  value of  0  (zero)
         disables atom garbage collection.  See also PL_register_atom().

    aappppllee _(_b_o_o_l_)
         If present and  true, the operating  system is MacOSX.  Defined
         if the C  compiler used to  compile this version of  SWI-Prolog
         defines __APPLE__.    Note that the  unix is  also defined  for
         MacOSX.

    aallllooww__ddoott__iinn__aattoomm _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true (default  false),  dots  may be  embedded  into  atoms
         that are  not quoted and  start with  a letter.   The  embedded
         dot _m_u_s_t  be followed by  an identifier continuation  character
         (i.e.,  letter, digit  or  underscore).    The dot  is  allowed
         in  identifiers  in many  languages,  which  can  make  this  a
         useful flag for defining  DSLs.  Note that this  conflicts with
         cascading functional notation.   For example,  Post.meta.author
         is read as .(Post, 'meta.author' if this flag is set to true.

    aallllooww__vvaarriiaabbllee__nnaammee__aass__ffuunnccttoorr _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true  (default  is false),  Functor(arg) is  read  as if  it
         were written 'Functor'(arg).  Some applications  use the Prolog
         read/1  predicate for  reading  an  application-defined  script
         language.   In these  cases, it is  often difficult to  explain
         to  non-Prolog users  of  the  application that  constants  and
         functions can only  start with a  lowercase letter.   Variables
         can be  turned into atoms  starting with  an uppercase atom  by
         calling read_term/2 using the option variable_names and binding
         the variables to their name.   Using this feature, F(x)  can be
         turned into valid syntax for such script languages.   Suggested
         by Robert van Engelen.  SWI-Prolog specific.

    aarrggvv _(_l_i_s_t_, _c_h_a_n_g_e_a_b_l_e_)
         List is a  list of atoms  representing the application  command
         line  arguments.     Application  command  line  arguments  are
         those  that  have _n_o_t  been  processed  by  Prolog  during  its
         initialization.   Note that Prolog's argument processing  stops
         at -- or the first non-option argument.  See also os_argv.

    aarrcchh _(_a_t_o_m_)
         Identifier for  the  hardware and  operating system  SWI-Prolog
         is running  on.   Used to  select foreign files  for the  right
         architecture.  See also section 10.2.3 and file_search_path/2.

    aassssoocciiaatteedd__ffiillee _(_a_t_o_m_)
         Set if  Prolog  was started  with a  prolog  file as  argument.
         Used by e.g., edit/0 to edit the initial file.

    aauuttoollooaadd _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default) autoloading of library functions is enabled.

    bbaacckk__qquuootteess _(_c_o_d_e_s_,_c_h_a_r_s_,_s_t_r_i_n_g_,_s_y_m_b_o_l___c_h_a_r_, _c_h_a_n_g_e_a_b_l_e_)
         Defines the term-representation for back-quoted material.   The
         default is  codes.    If --traditional  is given,  the  default
         is symbol_char, which allows  using ` in operators composed  of
         symbols..  See also section 5.2.

    bboouunnddeedd _(_b_o_o_l_)
         ISO Prolog  flag.   If  true, integer  representation is  bound
         by  min_integer and max_integer.    If  false integers  can  be
         arbitrarily large and  the min_integer and max_integer are  not
         present.  See section 4.26.2.1.

    bbrreeaakk__lleevveell _(_i_n_t_e_g_e_r_)
         Current break-level.   The initial top level (started  with -t)
         has value 0.   See break/0.   This flag is absent from  threads
         that are not running a top-level loop.

    cc__cccc _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Name of the  C compiler used to  compile SWI-Prolog.   Normally
         either gcc or cc.  See section 10.5.

    cc__ccffllaaggss _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         CFLAGS used to compile SWI-Prolog.  See section 10.5.

    cc__llddffllaaggss _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         LDFLAGS used to link SWI-Prolog.  See section 10.5.

    cc__lliibbss _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Libraries needed  to  link executables  that embed  SWI-Prolog.
         Typically -lswipl if the  SWI-Prolog kernel is a shared  (DLL).
         If the  SWI-Prolog kernel  is in  a static  library, this  flag
         also contains the dependencies.

    cc__lliibbppllssoo _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Libraries needed  to link  extensions (shared  object, DLL)  to
         SWI-Prolog.   Typically  empty on  ELF systems  and -lswipl  on
         COFF-based systems.  See section 10.5.

    cchhaarr__ccoonnvveerrssiioonn _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         Determines  whether  character  conversion  takes  place  while
         reading terms.  See also char_conversion/2.

    cchhaarraacctteerr__eessccaappeess _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true  (default),  read/1 interprets  \  escape sequences  in
         quoted atoms and strings.  May be changed.   This flag is local
         to the module in which it is changed.

    ccoolloonn__sseettss__ccaalllliinngg__ccoonntteexxtt _(_b_o_o_l_)
         Using the construct <_m_o_d_u_l_e>:<_g_o_a_l> sets the _c_a_l_l_i_n_g _c_o_n_t_e_x_t for
         executing <_g_o_a_l>.    This  flag is  defined by  ISO/IEC 13211-2
         (Prolog modules standard).  See section 6.

    ccoolloorr__tteerrmm _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         This flag is managed  by library ansi_term, which is loaded  at
         startup if the two conditions  below are both true.   Note that
         this implies that  setting this flag  to false from the  system
         or  personal  initialization file  (see  section  2.2  disables
         colored output.   The predicate message_property/2 can be  used
         to control  the actual  color scheme depending  in the  message
         type passed to print_message/2.

           o stream_property(current_output, tty(true))

           o \+ current_prolog_flag(color_term, false)

    ccoommppiillee__mmeettaa__aarrgguummeennttss _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Experimental  flag  that  controls  compilation   of  arguments
         passed to meta-calls marked `0'  or `^' (see meta_predicate/1).
         Supported values are:

         ffaallssee
             (default).  Meta-arguments are passed verbatim.

         ccoonnttrrooll
             Compile  meta-arguments  that  contain  control  structures
             ((A,B),  (A;B),  (A->B;C),  etc.).    If  not  compiled  at
             compile  time, such arguments  are compiled to a  temporary
             clause  before  execution.    Using  this  option  enhances
             performance  of  processing  complex  meta-goals  that  are
             known at compile time.

         ttrruuee
             Also  compile references to normal  user predicates.   This
             harms  performance (a  little), but enhances  the power  of
             poor-mens consistency check used  by make/0 and implemented
             by list_undefined/0.

         aallwwaayyss
             Always  create  an  intermediate clause,  even  for  system
             predicates.     This  prepares  for  replacing  the  normal
             head  of the generated predicate  with a special  reference
             (similar   to  database  references  as   used  by,   e.g.,
             assert/2)  that provides  direct access  to the  executable
             code,  thus  avoiding  runtime  lookup  of  predicates  for
             meta-calling.

    ccoommppiilleedd__aatt _(_a_t_o_m_)
         Describes when the  system has been  compiled.  Only  available
         if  the C  compiler used  to  compile SWI-Prolog  provides  the
         __DATE__and __TIME__macros.

    ccoonnssoollee__mmeennuu _(_b_o_o_l_)
         Set  to true  in swipl-win.exe  to  indicate that  the  console
         supports menus.  See also section 4.33.3.

    ccppuu__ccoouunntt _(_i_n_t_e_g_e_r_, _c_h_a_n_g_e_a_b_l_e_)
         Number of physical  CPUs or cores in the  system.  The flag  is
         marked read-write both to allow pretending the  system has more
         or less processors.   See also thread_setconcurrency/2 and  the
         library thread.   This flag is  not available on systems  where
         we do not  know how to get  the number of CPUs.   This flag  is
         not included in a saved state (see qsave_program/1).

    ddddee _(_b_o_o_l_)
         Set  to  true  if this  instance  of  Prolog  supports  DDE  as
         described in section 4.41.

    ddeebbuugg _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         Switch debugging  mode  on/off.   If  debug  mode is  activated
         the system traps encountered  spy points (see spy/1) and  trace
         points (see  trace/1).    In addition,  last-call  optimisation
         is disabled and the  system is more conservative in  destroying
         choice points to simplify debugging.

         Disabling these optimisations can  cause the system to run  out
         of memory on  programs that behave  correctly if debug mode  is
         off.

    ddeebbuugg__oonn__eerrrroorr _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true,  start  the  tracer  after   an  error  is  detected.
         Otherwise just continue  execution.   The goal that raised  the
         error  will normally  fail.    See  also fileerrors/2  and  the
         Prolog flag report_error.   May be changed.   Default is  true,
         except for the runtime version.

    ddeebbuuggggeerr__wwrriittee__ooppttiioonnss _(_t_e_r_m_, _c_h_a_n_g_e_a_b_l_e_)
         This  argument is  given  as  option-list to  write_term/2  for
         printing goals by the debugger.   Modified by the `w',  `p' and
         `<N> d' commands  of the debugger.   Default is  [quoted(true),
         portray(true), max_depth(10), attributes(portray)].

    ddeebbuuggggeerr__sshhooww__ccoonntteexxtt _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true, show  the context module while printing a  stack-frame
         in the  tracer.   Normally controlled using  the `C' option  of
         the tracer.

    ddiiaalleecctt _(_a_t_o_m_)
         Fixed to swi.   The code below  is a reliable and portable  way
         to detect SWI-Prolog.

         _______________________________________________________________|                                                               |
         |is_dialect(swi) :-                                             |

         ||_______catch(current_prolog_flag(dialect,_swi),__,_fail).____ ||

    ddoouubbllee__qquuootteess _(_c_o_d_e_s_,_c_h_a_r_s_,_a_t_o_m_,_s_t_r_i_n_g_, _c_h_a_n_g_e_a_b_l_e_)
         This flag  determines how  double  quoted strings  are read  by
         Prolog  and  is  ---like character_escapes  and  back_quotes---
         maintained for  each  module.   The  default is  string,  which
         produces  a  string   as  described  in   section  5.2.      If
         --traditional is  given, the default  is codes, which  produces
         a list of  character codes, integers  that represent a  Unicode
         code-point.  The  value chars produces a list  of one-character
         atoms  and the  value  atom makes  double  quotes the  same  as
         single quotes, creating a atom.  See also section 5.

    eeddiittoorr _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Determines the  editor used  by edit/1.   See  section 4.5  for
         details on selecting the editor used.

    eemmaaccss__iinnffeerriioorr__pprroocceessss _(_b_o_o_l_)
         If  true,  SWI-Prolog is  running  as an  _i_n_f_e_r_i_o_r  _p_r_o_c_e_s_s  of
         (GNU/X-)Emacs.   SWI-Prolog  assumes this  is the  case if  the
         environment variable EMACS is t and INFERIOR is yes.

    eennccooddiinngg _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Default encoding  used for  opening files in  text mode.    The
         initial  value  is   deduced  from  the   environment.      See
         section 2.18.1 for details.

    eexxeeccuuttaabbllee _(_a_t_o_m_)
         Pathname of the running executable.  Used by qsave_program/2 as
         default emulator.

    eexxiitt__ssttaattuuss _(_i_n_t_e_g_e_r_)
         Set  by  halt/1  to  its  argument,   making  the  exit  status
         available to hooks registered with at_halt/1.

    ffiillee__nnaammee__vvaarriiaabblleess _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true  (default  false),  expand  $_v_a_r_n_a_m_e   and  ~  in  ar-
         guments  of  built-in  predicates  that  accept  a   file  name
         (open/3, exists_file/1,  access_file/2,  etc.).   The  predicate
         expand_file_name/2 can be used to expand environment  variables
         and  wildcard patterns.    This  Prolog  flag is  intended  for
         backward compatibility with older versions of SWI-Prolog.

    ggcc _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default), the garbage collector is active.   If false,
         neither garbage collection,  nor stack shifts will take  place,
         even not on explicit request.  May be changed.

    ggeenneerraattee__ddeebbuugg__iinnffoo _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true  (default) generate  code  that can  be debugged  using
         trace/0, spy/1, etc.   Can be set to false using  the -nodebug.
         This  flag is  scoped  within  a source  file.    Many  of  the
         libraries  have  :- set_prolog_flag(generate_debug_info, false)
         to hide their details from a normal trace.

    ggmmpp__vveerrssiioonn _(_i_n_t_e_g_e_r_)
         If  Prolog is  linked  with  GMP,  this flag  gives  the  major
         version of the GMP library used.  See also section 10.4.8.

    gguuii _(_b_o_o_l_)
         Set to true if XPCE is around and can be used for graphics.

    hhiissttoorryy _(_i_n_t_e_g_e_r_, _c_h_a_n_g_e_a_b_l_e_)
         If _i_n_t_e_g_e_r >0,  support Unix csh(1)-like  history as described
         in section  2.7.    Otherwise,  only support  reusing  commands
         through the command  line editor.   The default is to set  this
         Prolog flag  to 0  if a command  line editor  is provided  (see
         Prolog flag readline) and 15 otherwise.

    hhoommee _(_a_t_o_m_)
         SWI-Prolog's  notion  of  the  home  directory.      SWI-Prolog
         uses  its  home   directory  to  find   its  startup  file   as
         <_h_o_m_e>/boot32.prc(32-bit machines) or <_h_o_m_e>/boot64.prc (64-bit
         machines) and to find its library as <_h_o_m_e>/library.

    hhwwnndd _(_i_n_t_e_g_e_r_)
         In swipl-win.exe, this  refers to the MS-Windows window  handle
         of the console window.

    iinntteeggeerr__rroouunnddiinngg__ffuunnccttiioonn _(_d_o_w_n_,_t_o_w_a_r_d___z_e_r_o_)
         ISO Prolog flag  describing rounding by  // and rem  arithmetic
         functions.  Value depends on the C compiler used.

    iissoo _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         Include some weird ISO compatibility that is  incompatible with
         normal SWI-Prolog behaviour.   Currently  it has the  following
         effect:

           o The  //2 (float division) _a_l_w_a_y_s  returns a float, even  if
             applied to integers that can be divided.

           o In  the standard order  of terms (see  section 4.7.1),  all
             floats are before all integers.

           o atom_length/2 yields a type error if the  first argument is
             a number.

           o clause/[2,3]  raises  a  permission  error  when  accessing
             static predicates.

           o abolish/[1,2]  raises  a permission  error  when  accessing
             static predicates.

           o Syntax is closer to the ISO standard:

               {{  Unquoted commas and  bars appearing  as atoms are  not
                  allowed.    Instead  of  f(,,a)  now  write  f(',',a).
                  Unquoted  commas   can  only  be   used  to   separate
                  arguments in  functional notation  and list  notation,
                  and  as  a  conjunction  operator.      Unquoted  bars
                  can only  appear  within lists  to separate  head  and
                  tail,  like [Head|Tail],  and  as infix  operator  for
                  alternation in grammar rules, like a --> b | c.

               {{  Within functional  notation  and list  notation  terms
                  must  have priority  below  1000.    That  means  that
                  rules and  control constructs  appearing as  arguments
                  need  bracketing.    A  term  like  [a :- b, c].  must
                  now  be  disambiguated   to  mean  [(a :- b), c].   or
                  [(a :- b, c)].

               {{  Operators appearing  as  operands must  be  bracketed.
                  Instead   of   X == -, true.   write   X == (-), true.
                  Currently, this is not entirely enforced.

               {{  Backslash-escaped newlines  are interpreted  according
                  to the ISO standard.  See section 2.15.2.1.

    llaarrggee__ffiilleess _(_b_o_o_l_)
         If present and  true, SWI-Prolog has  been compiled with  _l_a_r_g_e
         _f_i_l_e _s_u_p_p_o_r_t  (LFS) and  is capable of  accessing files  larger
         than 2GB on 32-bit hardware.  Large file support  is default on
         installations built using configure that support it  and may be
         switched off using the configure option --disable-largefile.

    llaasstt__ccaallll__ooppttiimmiissaattiioonn _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         Determines whether  or not last-call  optimisation is  enabled.
         Normally  the  value  of this  flag  is  the  negation  of  the
         debug flag.   As  programs may  run out of  stack if  last-call
         optimisation is  omitted, it is  sometimes necessary to  enable
         it during debugging.

    mmaaxx__aarriittyy _(_u_n_b_o_u_n_d_e_d_)
         ISO  Prolog  flag describing  there  is  no  maximum  arity  to
         compound terms.

    mmaaxx__iinntteeggeerr _(_i_n_t_e_g_e_r_)
         Maximum integer value  if integers are _b_o_u_n_d_e_d.   See also  the
         flag bounded and section 4.26.2.1.

    mmaaxx__ttaaggggeedd__iinntteeggeerr _(_i_n_t_e_g_e_r_)
         Maximum integer value represented as a `tagged' value.   Tagged
         integers  require  one word  storage.     Larger  integers  are
         represented as `indirect  data' and require significantly  more
         space.

    mmiinn__iinntteeggeerr _(_i_n_t_e_g_e_r_)
         Minimum integer value  if integers are _b_o_u_n_d_e_d.   See also  the
         flag bounded and section 4.26.2.1.

    mmiinn__ttaaggggeedd__iinntteeggeerr _(_i_n_t_e_g_e_r_)
         Start of the tagged-integer value range.

    ooccccuurrss__cchheecckk _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         This  flag  controls  unification  that  creates   an  infinite
         tree  (also called  _c_y_c_l_i_c _t_e_r_m)  and  can have  three  values.
         Using  false  (default),  unification  succeeds,   creating  an
         infinite  tree.       Using   true,   unification  behaves   as
         unify_with_occurs_check/2, failing  silently.   Using error,  an
         attempt to  create  a cyclic  term results  in an  occurs_check
         exception.  The latter is intended  for debugging unintentional
         creations of  cyclic terms.   Note that this  flag is a  global
         flag modifying fundamental behaviour  of Prolog.  Changing  the
         flag from its default  may cause libraries to stop  functioning
         properly.

    ooppeenn__sshhaarreedd__oobbjjeecctt _(_b_o_o_l_)
         If  true,  open_shared_object/2 and  friends  are  implemented,
         providing access  to shared  libraries (.so  files) or  dynamic
         link libraries (.DLL files).

    ooppttiimmiissee _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true, compile in optimised mode.  The initial  value is true
         if Prolog  was started with the  -O command line  option.   The
         optimise flag is scoped to a source file.

         Currently   optimised  compilation   implies   compilation   of
         arithmetic, and  deletion of redundant  true/0 that may  result
         from expand_goal/2.

         Later versions might imply various other optimisations  such as
         integrating small  predicates into  their callers,  eliminating
         constant expressions and other predictable constructs.   Source
         code  optimisation is  never  applied  to predicates  that  are
         declared dynamic (see dynamic/1).

    ooss__aarrggvv _(_l_i_s_t_, _c_h_a_n_g_e_a_b_l_e_)
         List  is  a  list  of  atoms  representing   the  command  line
         arguments used  to invoke  SWI-Prolog.   Please  note that  aallll
         arguments are included in the  list returned.  See argv  to get
         the application options.

    ppiidd _(_i_n_t_)
         Process identifier of  the running Prolog  process.   Existence
         of this flag is implementation-defined.

    ppiippee _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true,  open(pipe(command), mode, Stream),   etc.  are  sup-
         ported.    Can  be  changed to  disable  the use  of  pipes  in
         applications testing this feature.  Not recommended.

    pprriinntt__wwrriittee__ooppttiioonnss _(_t_e_r_m_, _c_h_a_n_g_e_a_b_l_e_)
         Specifies  the options  for write_term/2  used by  print/1  and
         print/2.

    pprroommpptt__aalltteerrnnaattiivveess__oonn _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Determines prompting for alternatives in the Prolog  top level.
         Default  is  determinism,  which  implies  the  system  prompts
         for alternatives  if the  goal succeeded  while leaving  choice
         points.   Many classical Prolog  systems behave as  groundness:
         they prompt for alternatives if and only if  the query contains
         variables.

    qqccoommppiillee _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         This  option  provides  the  default  for  the  qcompile(_+_A_t_o_m)
         option of load_files/2.

    rreeaaddlliinnee _(_b_o_o_l_)
         If true, SWI-Prolog is linked with the readline library.   This
         is  done by  default  if you  have  this library  installed  on
         your system.    It  is also  true for  the Win32  swipl-win.exe
         version of SWI-Prolog, which realises a subset  of the readline
         functionality.

    rreessoouurrccee__ddaattaabbaassee _(_a_t_o_m_)
         Set to the absolute filename of the attached state.   Typically
         this is the file boot32.prc, the file specified with  -x or the
         running executable.  See also resource/3.

    rreeppoorrtt__eerrrroorr _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true, print  error messages; otherwise  suppress them.   May
         be changed.  See also  the debug_on_errorProlog flag.   Default
         is true, except for the runtime version.

    rruunnttiimmee _(_b_o_o_l_)
         If present and  true, SWI-Prolog is  compiled with -DO_RUNTIME,
         disabling various  useful development  features (currently  the
         tracer and profiler).

    ssaannddbbooxxeedd__llooaadd _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true  (default  false), load_files/2  calls hooks  to  allow
         library(sandbox) to verify the safety of directives.

    ssaavveedd__pprrooggrraamm _(_b_o_o_l_)
         If present  and  true, Prolog  has been  started  from a  state
         saved with qsave_program/[1,2].

    sshhaarreedd__oobbjjeecctt__eexxtteennssiioonn _(_a_t_o_m_)
         Extension used  by  the operating  system for  shared  objects.
         .so for  most Unix  systems and  .dll for  Windows.   Used  for
         locating  files using  the  file_type  executable.    See  also
         absolute_file_name/3.

    sshhaarreedd__oobbjjeecctt__sseeaarrcchh__ppaatthh _(_a_t_o_m_)
         Name of the environment  variable used by the system  to search
         for shared objects.

    ssiiggnnaallss _(_b_o_o_l_)
         Determine  whether Prolog  is  handling signals  (software  in-
         terrupts).   This  flag is  false if  the hosting  OS does  not
         support signal handling  or the command line option  -nosignals
         is active.  See section 10.4.21.1 for details.

    ssttrreeaamm__ttyyppee__cchheecckk _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Defines whether  and  how strictly  the system  validates  that
         byte I/O  should not be  applied to text  streams and text  I/O
         should not be applied to binary streams.  Values  are false (no
         checking),  true (full  checking) and  loose.   Using  checking
         mode loose  (default), the  system accepts byte  I/O from  text
         stream that use ISO  Latin-1 encoding and accepts writing  text
         to binary streams.

    ssyysstteemm__tthhrreeaadd__iidd _(_i_n_t_)
         Available  in  multithreaded  version  (see  section  9)  where
         the  operating  system  provides  system-wide   integer  thread
         identifiers.    The  integer  is  the  thread  identifier  used
         by the  operating system  for  the calling  thread.   See  also
         thread_self/1.

    ttiimmeezzoonnee _(_i_n_t_e_g_e_r_)
         Offset in seconds  west of GMT of the  current time zone.   Set
         at initialization  time from the  timezone variable  associated
         with the POSIX tzset() function.  See also convert_time/2.

    ttoopplleevveell__pprriinntt__aannoonn _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true,  top-level variables starting  with an  underscore (_)
         are printed normally.   If false they are hidden.  This  may be
         used to hide bindings in complex queries from the top level.

    ttoopplleevveell__pprriinntt__ffaaccttoorriizzeedd _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default false)  show the internal sharing of  subterms
         in  the  answer  substitution.     The  example  below  reveals
         internal  sharing   of  leaf  nodes   in  _r_e_d_-_b_l_a_c_k  _t_r_e_e_s   as
         implemented by the rbtrees predicate rb_new/1:

         _______________________________________________________________|                                                               |
         |?- set_prolog_flag(toplevel_print_factorized, true).           |
         |?- rb_new(X).                                                  |
         |X = t(_S1, _S1), % where                                       |
         ||____S1_=_black('',__G387,__G388,_'').________________________ ||

         If this flag  is false, the % where  notation is still used  to
         indicate cycles as illustrated below.  This  example also shows
         that the implementation reveals the internal cycle  length, and
         _n_o_t the minimal cycle  length.  Cycles of different  length are
         indistinguishable in Prolog (as illustrated by S == R).

         _______________________________________________________________|                                                               |

         |?- S = s(S), R = s(s(R)), S == R.                              |
         |S = s(S),                                                      |
         |R|=_s(s(R)).__________________________________________________ | |

    aannsswweerr__wwrriittee__ooppttiioonnss _(_t_e_r_m_, _c_h_a_n_g_e_a_b_l_e_)
         This  argument is  given  as  option-list to  write_term/2  for
         printing  results  of  queries.     Default  is  [quoted(true),
         portray(true), max_depth(10), attributes(portray)].

    ttoopplleevveell__pprroommpptt _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Define the prompt  that is used  by the interactive top  level.
         The following ~ (tilde) sequences are replaced:

         _____________________________________________________________________~m_T_y_p_e _i_n module if not user (see module/1)

          ~l  _B_r_e_a_k _l_e_v_e_l if not 0 (see break/0)
          ~d  _D_e_b_u_g_g_i_n_g _s_t_a_t_e if not normal execution (see debug/0, trace/0)
         _~!___H_i_s_t_o_r_y__e_v_e_n_t_if_history_is_enabled_(see_flag_history)__________

    ttoopplleevveell__vvaarr__ssiizzee _(_i_n_t_, _c_h_a_n_g_e_a_b_l_e_)
         Maximum  size counted  in  literals of  a  term returned  as  a
         binding for a variable  in a top-level query that is  saved for
         re-use using the $ variable reference.  See section 2.8.

    ttrraaccee__ggcc _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default  false), garbage collections and  stack-shifts
         will be reported on the terminal.  May be changed.   Values are
         reported in bytes  as G+T, where G  is the global stack  value
         and T  the trail stack  value.   `Gained' describes the  number
         of bytes reclaimed.   `used' the  number of bytes on the  stack
         after GC and `free'  the number of bytes allocated, but  not in
         use.  Below is an example output.

         _______________________________________________________________|                                                               |
         |% GC: gained 236,416+163,424 in 0.00 sec;                      |
         ||_____used_13,448+5,808;_free_72,568+47,440___________________ ||

    ttrraaddiittiioonnaall _(_b_o_o_l_)
         Available in  SWI-Prolog version  7.    If true,  `traditional'
         mode  has  been  selected  using  --traditional.      See  also
         section 5.

    ttttyy__ccoonnttrrooll _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         Determines whether  the terminal  is switched to  raw mode  for
         get_single_char/1,  which also  reads the user  actions for  the
         trace.  May be set.  See also the +/-tty command line option.

    uunniixx _(_b_o_o_l_)
         If present  and  true,  the operating  system is  some  version
         of Unix.    Defined  if the  C compiler  used  to compile  this
         version of  SWI-Prolog either  defines __unix__  or unix.    On
         other systems this flag is  not available.  See also  apple and
         windows.

    uunnkknnoowwnn _(_f_a_i_l_,_w_a_r_n_i_n_g_,_e_r_r_o_r_, _c_h_a_n_g_e_a_b_l_e_)
         Determines  the behaviour  if  an  undefined procedure  is  en-
         countered.    If  fail,  the  predicate  fails silently.     If
         warn,  a warning  is printed,  and  execution continues  as  if
         the predicate  was  not defined,  and  if error  (default),  an
         existence_error exception is  raised.   This flag  is local  to
         each  module and  inherited  from the  module's  _i_m_p_o_r_t_-_m_o_d_u_l_e.
         Using default setup,  this implies that normal modules  inherit
         the flag  from  user, which  in turn  inherit  the value  error
         from system.   The  user may  change the flag  for module  user
         to  change the  default  for  all application  modules  or  for
         a  specific module.     It  is strongly  advised  to  keep  the
         error default and  use dynamic/1 and/or multifile/1 to  specify
         possible non-existence of a predicate.

    uunnllooaadd__ffoorreeiiggnn__lliibbrraarriieess _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If true (default  false), unload all loaded foreign  libraries.
         Default is  false  because modern  OSes reclaim  the  resources
         anyway and  unloading  the foreign  code may  cause  registered
         hooks to point to no longer existing data or code.

    uusseerr__ffllaaggss _(_A_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Define  the  behaviour  of  set_prolog_flag/2 if  the  flag  is
         not  known.    Values are  silent,  warning  and  error.    The
         first two  create  the flag  on-the-fly,  where warning  prints
         a  message.    The  value  error is  consistent  with  ISO:  it
         raises an existence  error and does not  create the flag.   See
         also create_prolog_flag/3.  The  default is silent, but  future
         versions may  change that.   Developers  are encouraged to  use
         another value and ensure  proper use of create_prolog_flag/3 to
         create flags for their library.

    vveerrbboossee _(_A_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         This flag is used by print_message/2.  If its  value is silent,
         messages of type informational and banner are suppressed.   The
         -q switches the value from the initial normal to silent.

    vveerrbboossee__aauuttoollooaadd _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true the  normal  consult  message  will be  printed  if  a
         library is autoloaded.  By default this  message is suppressed.
         Intended to be used for debugging purposes.

    vveerrbboossee__llooaadd _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Determines  messages printed  for  loading  (compiling)  Prolog
         files.    Current  values are  full  (print  a message  at  the
         start and  end of each  file loaded),  normal (print a  message
         at the  end of  each file loaded),  brief (print  a message  at
         end of  loading the  toplevel file),  and  silent (no  messages
         are printed,  default).   The  value of this  flag is  normally
         controlled by the option silent(_B_o_o_l) provided by load_files/2.

    vveerrbboossee__ffiillee__sseeaarrcchh _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true  (default   false),  print  messages  indicating   the
         progress   of  absolute_file_name/[2,3]  in   locating   files.
         Intended for  debugging  complicated file-search  paths.    See
         also file_search_path/2.

    vveerrssiioonn _(_i_n_t_e_g_e_r_)
         The version identifier is an integer with value:

                          10000_*Major+ 100_*Minor+_P_a_t_c_h

         Note  that  in   releases  up  to   2.7.10  this  Prolog   flag
         yielded an atom  holding the three  numbers separated by  dots.
         The  current representation  is  much easier  for  implementing
         version-conditional statements.

    vveerrssiioonn__ddaattaa _(_s_w_i_(_M_a_j_o_r_, _M_i_n_o_r_, _P_a_t_c_h_, _E_x_t_r_a_)_)
         Part of the  dialect compatibility layer;  see also the  Prolog
         flag dialect and section 14.   _E_x_t_r_a provides platform-specific
         version information.  Currently it is simply unified to [].

    vveerrssiioonn__ggiitt _(_a_t_o_m_)
         Available if created from  a git repository.   See git-describe
         for details.

    wwaarrnn__oovveerrrriiddee__iimmpplliicciitt__iimmppoorrtt _(_b_o_o_l_, _c_h_a_n_g_e_a_b_l_e_)
         If  true (default),  a  warning  is printed  if  an  implicitly
         imported predicate  is clobbered by  a local  definition.   See
         use_module/1 for details.

    wwiinnddoowwss _(_b_o_o_l_)
         If present and true, the operating system  is an implementation
         of Microsoft  Windows (NT/2000/XP, etc.).    This flag is  only
         available on MS-Windows based versions.

    wwrriittee__aattttrriibbuutteess _(_a_t_o_m_, _c_h_a_n_g_e_a_b_l_e_)
         Defines how  write/1  and friends  write attributed  variables.
         The option values are  described with the attributes option  of
         write_term/3.  Default is ignore.

    wwrriittee__hheellpp__wwiitthh__oovveerrssttrriikkee _(_b_o_o_l_)
         Internal flag used  by help/1 when writing  to a terminal.   If
         present  and true  it prints  bold  and underlined  text  using
         _o_v_e_r_s_t_r_i_k_e.

    xxppccee _(_b_o_o_l_)
         Available  and set  to  true if  the  XPCE graphics  system  is
         loaded.

    xxppccee__vveerrssiioonn _(_a_t_o_m_)
         Available and set to the version of the loaded XPCE system.


sseett__pprroolloogg__ffllaagg((_:_K_e_y_, _+_V_a_l_u_e))                                      _[_I_S_O_]
    Define  a new  Prolog flag or  change its value.    _K_e_y is an  atom.
    If  the flag is a system-defined flag that is not  marked _c_h_a_n_g_e_a_b_l_e
    above,  an  attempt to  modify the flag  yields a  permission_error.
    If  the  provided _V_a_l_u_e  does not  match  the type  of the  flag,  a
    type_error is raised.

    Some  flags (e.g.,  unknown) are maintained  on a per-module  basis.
    The addressed module is determined by the _K_e_y argument.

    In  addition  to  ISO,  SWI-Prolog allows  for  user-defined  Prolog
    flags.   The type of the  flag is determined from the  initial value
    and  cannot be changed  afterwards.   Defined types are boolean  (if
    the  initial value is one  of false, true, on  or off), atom if  the
    initial value is any  other atom, integer if the value is an integer
    that  can be expressed as a 64-bit signed value.  Any  other initial
    value  results  in an  untyped  flag that  can represent  any  valid
    Prolog term.

    The  behaviour when _K_e_y  denotes a non-existent  key depends on  the
    Prolog  flag user_flags.   The default is  to define them  silently.
    New code is encouraged to use create_prolog_flag/3 for portability.


ccrreeaattee__pprroolloogg__ffllaagg((_+_K_e_y_, _+_V_a_l_u_e_, _+_O_p_t_i_o_n_s))                         _[_Y_A_P_]
    Create  a  new Prolog  flag.    The ISO  standard does  not  foresee
    creation  of  new flags,  but many  libraries  introduce new  flags.
    _O_p_t_i_o_n_s is a list of the options below.  See also user_flags.

    aacccceessss((_+_A_c_c_e_s_s))
         Define access rights for  the flag.  Values  are read_write  and
         read_only.  The default is read_write.

    ttyyppee((_+_A_t_o_m))
         Define a type restriction.  Possible values  are boolean, atom,
         integer,  float and  term.    The  default is  determined  from
         the initial  value.  Note  that term restricts  the term to  be
         ground.

    kkeeeepp((_+_B_o_o_l_e_a_n))
         If true, to not modify  the flag if it already exists.   Other-
         wise (default), this predicate  behaves as set_prolog_flag/2 if
         the flag already exists.


22..1122 AAnn oovveerrvviieeww ooff hhooookk pprreeddiiccaatteess

SWI-Prolog provides a large number of hooks, mainly  to control handling
messages, debugging,  startup, shut-down, macro-expansion,  etc.   Below
is  a  summary  of  all  defined  hooks  with  an  indication  of  their
portability.

  o _p_o_r_t_r_a_y_/_1
    Hook into write_term/3 to alter the way terms are printed (ISO).

  o _m_e_s_s_a_g_e___h_o_o_k_/_3
    Hook  into  print_message/2 to  alter the  way system  messages  are
    printed (Quintus/SICStus).

  o _m_e_s_s_a_g_e___p_r_o_p_e_r_t_y_/_2
    Hook  into  print_message/2  that  defines  prefix,  output  stream,
    color, etc.

  o _l_i_b_r_a_r_y___d_i_r_e_c_t_o_r_y_/_1
    Hook  into  absolute_file_name/3 to define  new library  directories
    (most Prolog systems).

  o _f_i_l_e___s_e_a_r_c_h___p_a_t_h_/_2
    Hook   into   absolute_file_name/3  to  define   new  search   paths
    (Quintus/SICStus).

  o _t_e_r_m___e_x_p_a_n_s_i_o_n_/_2
    Hook  into  load_files/2  to  modify  read  terms  before  they  are
    compiled (macro-processing) (most Prolog systems).

  o _g_o_a_l___e_x_p_a_n_s_i_o_n_/_2
    Same as term_expansion/2 for individual goals (SICStus).

  o _p_r_o_l_o_g___l_o_a_d___f_i_l_e_/_2
    Hook  into  load_files/2  to  load other  data  formats  for  Prolog
    sources  from `non-file' resources.   The load_files/2 predicate  is
    the ancestor of consult/1, use_module/1, etc.

  o _p_r_o_l_o_g___e_d_i_t_:_l_o_c_a_t_e_/_3
    Hook into edit/1 to locate objects (SWI).

  o _p_r_o_l_o_g___e_d_i_t_:_e_d_i_t___s_o_u_r_c_e_/_1
    Hook into edit/1 to call an internal editor (SWI).

  o _p_r_o_l_o_g___e_d_i_t_:_e_d_i_t___c_o_m_m_a_n_d_/_2
    Hook into edit/1 to define the external editor to use (SWI).

  o _p_r_o_l_o_g___l_i_s_t___g_o_a_l_/_1
    Hook  into the tracer  to list the  code associated to a  particular
    goal (SWI).

  o _p_r_o_l_o_g___t_r_a_c_e___i_n_t_e_r_c_e_p_t_i_o_n_/_4
    Hook into the tracer to handle trace events (SWI).

  o _p_r_o_l_o_g_:_d_e_b_u_g___c_o_n_t_r_o_l___h_o_o_k_/_1
    Hook  in spy/1, nospy/1, nospyall/0 and debugging/0 to  extend these
    control predicates to higher-level libraries.

  o _p_r_o_l_o_g_:_h_e_l_p___h_o_o_k_/_1
    Hook in help/0, help/1 and apropos/1 to extend the help system.

  o _r_e_s_o_u_r_c_e_/_3
    Define a new resource (not really a hook, but similar) (SWI).

  o _e_x_c_e_p_t_i_o_n_/_3
    Old  attempt  to  a  generic  hook mechanism.     Handles  undefined
    predicates (SWI).

  o _a_t_t_r___u_n_i_f_y___h_o_o_k_/_2
    Unification  hook for attributed variables.   Can be defined in  any
    module.  See section 7.1 for details.


22..1133 AAuuttoommaattiicc llooaaddiinngg ooff lliibbrraarriieess

If ---at runtime--- an  undefined predicate is trapped, the  system will
first try to import the predicate from the module's  default module (see
section 6.9.   If  this fails the _a_u_t_o  _l_o_a_d_e_r is activated.   On  first
activation an  index to  all library  files in  all library  directories
is  loaded  in  core  (see library_directory/1,  file_search_path/2  and
reload_library_index/0).   If the  undefined predicate can be located  in
one of the libraries, that library file is  automatically loaded and the
call to the (previously  undefined) predicate is restarted.   By default
this mechanism loads  the file silently.   The current_prolog_flag/2 key
verbose_autoload is provided  to get verbose loading.   The Prolog  flag
autoload can be used to enable/disable the autoload system.

Autoloading  only handles  (library) source  files that  use the  module
mechanism  described  in  chapter  6.     The  files   are  loaded  with
use_module/2 and only the  trapped undefined predicate is imported  into
the  module where  the undefined  predicate was  called.   Each  library
directory  must hold  a file  INDEX.pl  that contains  an index  to  all
library files  in the directory.    This file consists  of lines of  the
following format:

________________________________________________________________________|                                                                        |
|index(Name,|Arity,_Module,_File).______________________________________ |           |

The  predicate make/0  updates the  autoload  index.   It  searches  for
all library directories (see library_directory/1 and file_search_path/2)
holding the file MKINDEX.pl or INDEX.pl.  If the  current user can write
or create the file INDEX.pl  and it does not exist or is older  than the
directory or one of its files, the index for  this directory is updated.
If the  file MKINDEX.pl  exists, updating  is achieved  by loading  this
file,  normally  containing  a  directive calling  make_library_index/2.
Otherwise make_library_index/1is  called, creating an index for all *.pl
files containing a module.

Below is an example creating an indexed library directory.

________________________________________________________________________|                                                                        |

|% mkdir ~/lib/prolog                                                    |
|% cd ~/lib/prolog                                                       |
|%|swipl_-g_true_-t_'make_library_index(.)'_____________________________ | |

If  there  is  more  than  one  library  file   containing  the  desired
predicate, the following search schema is followed:

 1. If  there is a  library file  that defines the  module in which  the
    undefined predicate is trapped, this file is used.

 2. Otherwise  library files  are considered  in the  order they  appear
    in  the  library_directory/1  predicate  and  within  the  directory
    alphabetically.


aauuttoollooaadd__ppaatthh((_+_D_i_r_A_l_i_a_s))
    Add  _D_i_r_A_l_i_a_s to  the  libraries that  are used  by the  autoloader.
    This  extends  the  search path  autoload  and reloads  the  library
    index.  For example:

    ____________________________________________________________________|                                                                    |
    ||:-_autoload_path(library(http)).__________________________________ ||

    If   this  call  appears  as   a  directive,  it  is   term-expanded
    into  a clause  for user:file_search_path/2 and  a directive  calling
    reload_library_index/0.   This keeps  source information and  allows
    for removing this directive.


mmaakkee__lliibbrraarryy__iinnddeexx((_+_D_i_r_e_c_t_o_r_y))
    Create  an index for this  directory.  The  index is written to  the
    file  'INDEX.pl' in the specified directory.   Fails with a  warning
    if the directory does not exist or is write protected.


mmaakkee__lliibbrraarryy__iinnddeexx((_+_D_i_r_e_c_t_o_r_y_, _+_L_i_s_t_O_f_P_a_t_t_e_r_n_s))
    Normally  used in  MKINDEX.pl, this  predicate creates INDEX.pl  for
    _D_i_r_e_c_t_o_r_y,  indexing all files that  match one of the file  patterns
    in _L_i_s_t_O_f_P_a_t_t_e_r_n_s.

    Sometimes  library packages consist  of one public  load file and  a
    number  of files used by  this load file, exporting predicates  that
    should not be used  directly by the end user.  Such a library can be
    placed  in a sub-directory of  the library and the files  containing
    public  functionality can  be  added to  the index  of the  library.
    As  an  example we  give the  XPCE library's  MKINDEX.pl,  including
    the  public  functionality of  trace/browse.pl to  the  autoloadable
    predicates for the XPCE package.

    ____________________________________________________________________|                                                                    |
    | :- make_library_index('.',                                         |

    |                       [ '*.pl',                                    |
    |                         'trace/browse.pl'                          |
    ||______________________])._________________________________________ ||


rreellooaadd__lliibbrraarryy__iinnddeexx
    Force  reloading  the  index  after modifying  the  set  of  library
    directories   by   changing  the   rules  for   library_directory/1,
    file_search_path/2,  adding  or  deleting  INDEX.pl  files.     This
    predicate   does   _n_o_t   update  the   INDEX.pl   files.       Check
    make_library_index/[1,2] and make/0 for updating the index files.

    Normally, the index  is reloaded automatically if a predicate cannot
    be  found  in the  index  and the  set  of library  directories  has
    changed.   Using reload_library_index/0 is necessary if  directories
    are removed or the order of the library directories is changed.

When  creating an  executable  using either  qsave_program/2 or  the  -c
command  line options,  it is  necessarry to  load  all predicates  that
would  normally  be  autoloaded  explicitly.     This  is  discussed  in
section 11.  See autoload/0.


22..1144 GGaarrbbaaggee CCoolllleeccttiioonn

SWI-Prolog provides garbage collection, last-call optimization  and atom
garbage collection.   These features  are controlled using Prolog  flags
(see current_prolog_flag/2).


22..1155 TThhee SSWWII--PPrroolloogg ssyynnttaaxx

SWI-Prolog  syntax is  close to  ISO-Prolog  standard syntax,  which  is
based on  the Edinburgh  Prolog syntax.    A formal  description can  be
found in  the ISO standard  document.  For  an informal introduction  we
refer to  Prolog text books (see  section 1) and  online tutorials.   In
addition  to the  differences  from the  ISO standard  documented  here,
SWI-Prolog  offers several  extensions, some  of which  also extend  the
syntax.  See section 5 for more information.


22..1155..11 IISSOO SSyynnttaaxx SSuuppppoorrtt

This section lists various extensions w.r.t. the ISO Prolog syntax.


22..1155..11..11 PPrroocceessssoorr CChhaarraacctteerr SSeett

The processor character  set specifies the class of each  character used
for parsing Prolog  source text.   Character classification is fixed  to
Unicode.  See also section 2.18.


22..1155..22 NNeesstteedd ccoommmmeennttss

SWI-Prolog  allows  for  nesting /* ...*/  comments.     Where  the  ISO
standard accepts  /* .../* ...*/ as  a comment,  SWI-Prolog will  search
for  a terminating  */.    This is  useful if  some  code with  /* ...*/
comment statements  in it should  be commented out.   This  modification
also  avoids unintended  commenting  in  the example  below,  where  the
closing */ of the first comment has been forgotten.

________________________________________________________________________|                                                                        |
|/* comment                                                              |

|                                                                        |
|code                                                                    |
|                                                                        |
|/* second comment */                                                    |
|                                                                        |
|code                                                                    |
||______________________________________________________________________ ||


22..1155..22..11 CChhaarraacctteerr EEssccaappee SSyynnttaaxx

Within quoted atoms (using single quotes:   '<atom>') special characters
are  represented using  escape sequences.    An escape  sequence is  led
in  by the  backslash  (\) character.    The  list of  escape  sequences
is compatible  with the ISO standard  but contains some extensions,  and
the interpretation of numerically specified characters  is slightly more
flexible to improve compatibility.  Undefined escape  characters raise a
syntax_error exception.

\a
    Alert character.  Normally the ASCII character 7 (beep).

\b
    Backspace character.

\c
    No  output.    All input  characters  up to  but not  including  the
    first  non-layout  character  are skipped.     This allows  for  the
    specification  of pretty-looking long lines.  Not supported  by ISO.
    Example:

    ____________________________________________________________________|                                                                    |
    | format('This is a long line that looks better if it was \c         |

    ||_______split_across_multiple_physical_lines_in_the_input')________ ||

\<NEWLINE>
    When  in  ISO  mode  (see  the Prolog  flag  iso),  only  skip  this
    sequence.    In native mode,  white space  that follows the  newline
    is  skipped as well and a  warning is printed, indicating that  this
    construct  is deprecated and  advising to use \c.   We advise  using
    \c  or putting  the layout  _b_e_f_o_r_e the  \, as  shown below.    Using
    \c  is supported  by various other  Prolog implementations and  will
    remain  supported by SWI-Prolog.  The style shown below is  the most
    compatible solution.

    ____________________________________________________________________|                                                                    |

    | format('This is a long line that looks better if it was \          |
    ||split_across_multiple_physical_lines_in_the_input')_______________ ||

    instead of

    ____________________________________________________________________|                                                                    |
    | format('This is a long line that looks better if it was\           |
    ||_split_across_multiple_physical_lines_in_the_input')______________ ||

\e
    Escape character (ASCII 27).  Not ISO, but widely supported.

\f
    Form-feed character.

\n
    Next-line character.

\r
    Carriage-return only (i.e., go back to the start of the line).

\s
    Space  character.    Intended  to  allow  writing 0'\s  to  get  the
    character code of the space character.  Not ISO.

\t
    Horizontal tab character.

\v
    Vertical tab character (ASCII 11).

\xXX..\
    Hexadecimal  specification  of  a  character.    The  closing  \  is
    obligatory   according  to  the  ISO   standard,  but  optional   in
    SWI-Prolog  to   enhance  compatibility  with  the  older  Edinburgh
    standard.   The code \xa\3 emits the character 10  (hexadecimal `a')
    followed  by `3'.  Characters specified this way are  interpreted as
    Unicode characters.  See also \u.

\uXXXX
    Unicode  character specification  where the  character is  specified
    using  _e_x_a_c_t_l_y 4 hexadecimal  digits.  This  is an extension to  the
    ISO  standard,  fixing two  problems.   First,  where  \x defines  a
    numeric  character code,  it doesn't  specify the  character set  in
    which  the  character should  be interpreted.    Second,  it is  not
    needed to use the idiosyncratic closing \ ISO Prolog syntax.

\UXXXXXXXX
    Same as \uXXXX, but using 8 digits to cover the whole Unicode set.

\40
    Octal   character  specification.     The  rules  and   remarks  for
    hexadecimal specifications apply to octal specifications as well.

\\
    Escapes  the backslash itself.  Thus, '\\' is an atom  consisting of
    a single \.

\'
    Single  quote.  Note that '\'' and '''' both describe the  atom with
    a single ', i.e., '\'' == '''' is true.

\"
    Double quote.

\`
    Back quote.

Character        escaping       is        only       available        if
current_prolog_flag(character_escapes, true) is active (default).    See
current_prolog_flag/2.    Character  escapes  conflict with  writef/2  in
two  ways:   \40  is  interpreted as  decimal  40 by  writef/2,  but  as
octal  40 (decimal  32) by  read.   Also,  the writef/2  sequence \l  is
illegal.   It is advised to  use the more widely supported  format/[2,3]
predicate instead.   If  you insist upon  using writef/2, either  switch
character_escapes to false, or use double \\, as in writef('\\l').


22..1155..22..22 SSyynnttaaxx ffoorr nnoonn--ddeecciimmaall nnuummbbeerrss

SWI-Prolog  implements  both  Edinburgh  and  ISO   representations  for
non-decimal numbers.   According to  Edinburgh syntax, such numbers  are
written as <_r_a_d_i_x>'<number>, where <_r_a_d_i_x> is a number between 2 and 36.
ISO defines binary,  octal and hexadecimal numbers using 0[bxo]<_n_u_m_b_e_r>.
For example:  A is 0b100 \/ 0xf00  is a valid expression.   Such numbers
are always unsigned.


22..1155..22..33 UUssiinngg ddiiggiitt ggrroouuppss iinn llaarrggee iinntteeggeerrss

SWI-Prolog  supports   splitting  long   integers  into  _d_i_g_i_t   _g_r_o_u_p_s.
Digit  groups   can  be   separated  with  the   sequence  <_u_n_d_e_r_s_c_o_r_e>,
<_o_p_t_i_o_n_a_l _w_h_i_t_e _s_p_a_c_e>.   If the  <_r_a_d_i_x> is 10  or lower, they  may also
be separated  with exactly  one space.   The  following all express  the
integer 1 million:

________________________________________________________________________|                                                                        |
|1_000_000                                                               |

|1 000 000                                                               |
|1_000_/*more*/000|_____________________________________________________ |                 |

Integers can be printed using this notation with format/2,  using the ~I
format specifier.  For example:

________________________________________________________________________|                                                                        |
|?- format('~I', [1000000]).                                             |
|1_000_000|_____________________________________________________________ |         |

The  current  syntax  has been  proposed  by  Ulrich  Neumerkel  on  the
SWI-Prolog mailinglist.


22..1155..22..44 UUnniiccooddee PPrroolloogg ssoouurrccee

The ISO standard  specifies the Prolog syntax  in ASCII characters.   As
SWI-Prolog supports Unicode  in source files we must extend  the syntax.
This  section describes  the implication  for  the source  files,  while
writing international source files is described in section 3.1.3.

The  SWI-Prolog Unicode  character classification  is  based on  version
6.0.0  of the  Unicode  standard.    Please  note  that char_type/2  and
friends, intended  to be used with all  text except Prolog source  code,
is based on the C library locale-based classification routines.

  o _Q_u_o_t_e_d _a_t_o_m_s _a_n_d _s_t_r_i_n_g_s
    Any  character  of  any script  can  be  used in  quoted  atoms  and
    strings.      The  escape  sequences  \uXXXX  and   \UXXXXXXXX  (see
    section 2.15.2.1) were  introduced to specify Unicode code points in
    ASCII files.

  o _A_t_o_m_s _a_n_d _V_a_r_i_a_b_l_e_s
    We  handle  them in  one item  as they  are closely  related.    The
    Unicode  standard  defines  a  syntax for  identifiers  in  computer
    languages.   In this syntax identifiers start with ID_Start followed
    by  a sequence of ID_Continue codes.  Such sequences are  handled as
    a  single token  in SWI-Prolog.    The token  is a  _v_a_r_i_a_b_l_e iff  it
    starts with  an uppercase character or an underscore (_).  Otherwise
    it  is an atom.   Note  that many languages do  not have the  notion
    of  character case.  In such languages variables _m_u_s_t be  written as
    _name.

  o _W_h_i_t_e _s_p_a_c_e
    All  characters marked as separators (Z*) in the Unicode  tables are
    handled as layout characters.

  o _C_o_n_t_r_o_l _a_n_d _u_n_a_s_s_i_g_n_e_d _c_h_a_r_a_c_t_e_r_s
    Control  and unassigned  (C*) characters produce  a syntax error  if
    encountered outside quoted atoms/strings and outside comments.

  o _O_t_h_e_r _c_h_a_r_a_c_t_e_r_s
    The  first 128 characters follow the  ISO Prolog standard.   Unicode
    symbol  and punctuation characters (general category S* and  P*) act
    as  glueing symbol  characters (i.e.,  just  like ==:   an  unquoted
    sequence of symbol characters are combined into an atom).

    Other  characters (this is mainly No:  _a _n_u_m_e_r_i_c _c_h_a_r_a_c_t_e_r  _o_f _o_t_h_e_r
    _t_y_p_e) are currently handled as `solo'.


22..1155..22..55 SSiinngglleettoonn vvaarriiaabbllee cchheecckkiinngg

A _s_i_n_g_l_e_t_o_n  _v_a_r_i_a_b_l_e is  a variable  that appears  only one  time in  a
clause.   It can always be  replaced by _, the  _a_n_o_n_y_m_o_u_s variable.   In
some cases,  however, people  prefer to give  the variable a  name.   As
mistyping a variable is a common mistake, Prolog  systems generally give
a  warning (controlled  by style_check/1)  if a  variable is  used  only
once.   The system can  be informed that a  variable is meant to  appear
once by _s_t_a_r_t_i_n_g it with  an underscore, e.g., _Name.  Please  note that
any variable,  except plain _, shares  with variables of the same  name.
The term  t(_X, _X) is equivalent  to t(X, X),  which is _d_i_f_f_e_r_e_n_t  from
t(_, _).

As  Unicode requires  variables  to start  with  an underscore  in  many
languages, this schema  needs to be extended.   First we define the  two
classes of named variables.

  o _N_a_m_e_d _s_i_n_g_l_e_t_o_n _v_a_r_i_a_b_l_e_s
    Named  singletons start with  a double underscore  (__) or a  single
    underscore followed by an uppercase letter, e.g., __var or _Var.

  o _N_o_r_m_a_l _v_a_r_i_a_b_l_e_s
    All other variables are  `normal' variables.  Note this makes _var a
    normal variable.

Any normal variable appearing  exactly once in the clause _a_n_d  any named
singleton variables appearing  more than once are  reported.  Below  are
some examples  with warnings in  the right column.   Singleton  messages
can be suppressed using the style_check/1 directive.

___________________________________________________________________________
| test(_).      |                                                         |

| test(_a).     |Singleton variables:  [_a]                                 |
| test(_12).    |Singleton variables:  [_12]                                |
| test(A).     |Singleton variables:  [A]                                 |
| test(_A).     |                                                         |
| test(__a).    |                                                         |
| test(_, _).   |                                                         |
| test(_a, _a). |                                                         |

| test(__a, __a).S|ingleton-marked variables appearing more than once:  [__a] |
| test(_A, _A). |Singleton-marked variables appearing more than once:  [_A] |
|_test(A,_A).__|__________________________________________________________|_

SSeemmaannttiicc ssiinngglleettoonnss

Starting with  version 6.5.1,  SWI-Prolog has  _s_y_n_t_a_c_t_i_c _s_i_n_g_l_e_t_o_n_s  and
_s_e_m_a_n_t_i_c  _s_i_n_g_l_e_t_o_n_s.    The first  are  checked  by read_clause/3  (and
read_term/3 using  the  option singletons(_w_a_r_n_i_n_g)).    The  latter  are
generated by the compiler  for variables that appear alone in  a _b_r_a_n_c_h.
For  example, in  the  code below  the  variable _X  is not  a  _s_y_n_t_a_c_t_i_c
singleton,  but the variable  _X does  not communicate  any bindings  and
replacing _X with _does not change the semantics.

________________________________________________________________________|                                                                        |

|test :-                                                                 |
|        (   test_1(X)                                                   |
|        ;   test_2(X)                                                   |
||_______)._____________________________________________________________ ||


22..1166 RRaattiioonnaall ttrreeeess ((ccyycclliicc tteerrmmss))

SWI-Prolog  supports  rational  trees,  also   known  as  cyclic  terms.
`Supports'  is  so  defined  that  most   relevant  built-in  predicates
terminate  when faced  with rational  trees.    Almost all  SWI-Prolog's
built-in term  manipulation predicates process terms  in a time that  is
linear to the amount of memory used to represent the  term on the stack.
The following set  of predicates safely handles rational trees:   =../2,
==/2,  =@=/2,  =/2, @</2 , @=</2,  @>=/2,  @>/2,  \==/2,  \=@=/2,  \=/2,
acyclic_term/1, bagof/3,  compare/3, copy_term/2, cyclic_term/1,  dif/2,
duplicate_term/2,   findall/3,  ground/1,   term_hash/2,   numbervars/3,
numbervars/4,    recorda/3,   recordz/3,    setof/3,    subsumes_term/2,
term_variables/2,   throw/1,   unify_with_occurs_check/2,    unifiable/3,
when/2, write/1 (and related predicates) .

In  addition,  some built-ins  recognise  rational  trees and  raise  an
appropriate exception.    Arithmetic evaluation belongs  to this  group.
The  compiler (asserta/1,  etc.)   also  raises  an exception.    Future
versions may  support rational  trees.   Predicates  that could  provide
meaningful processing  of rational  trees raise  a representation_error.
Predicates for  which rational trees  have no meaningful  interpretation
raise a type_error.  For example:

________________________________________________________________________|                                                                        |
|1 ?- A = f(A), asserta(a(A)).                                           |

|ERROR: asserta/1: Cannot represent due to `cyclic_term'                 |
|2 ?- A = 1+A, B is A.                                                   |
|ERROR: is/2: Type error: `expression' expected, found                   |
||____________`@(S_1,[S_1=1+S_1])'_(cyclic_term)________________________ ||


22..1177 JJuusstt--iinn--ttiimmee ccllaauussee iinnddeexxiinngg

SWI-Prolog  provides `just-in-time'  indexing over  multiple  arguments.
`Just-in-time' means that  clause indexes are not built by  the compiler
(or asserta/1  for dynamic predicates),  but on the  first call to  such
a predicate  where an  index might  help (i.e.,  a call  where at  least
one argument is  instantiated).  This  section describes the rules  used
by the  indexing logic.   Note that  this logic is  not `set in  stone'.
The indexing  capabilities of  the system  will change.   Although  this
inevitably leads  to some regressing  on some  particular use cases,  we
strive to avoid significant slowdowns.

The  list below  describes  the  clause selection  process  for  various
predicates and  calls.   The  alternatives are considered  in the  order
they are presented.

  o _S_p_e_c_i_a_l _p_u_r_p_o_s_e _c_o_d_e
    Currently two special  cases are recognised by the compiler:  static
    code  with exactly one clause and static code with two  clauses, one
    where  the first argument is the  empty list ([]) and one where  the
    first argument is a non-empty list ([_|_]).

  o _L_i_n_e_a_r _s_c_a_n _o_n _f_i_r_s_t _a_r_g_u_m_e_n_t
    The  principal clause list maintains  a _k_e_y for the first  argument.
    An  indexing  key is  either  a constant  or a  functor  (name/arity
    reference).    Calls with  an instantiated first  argument and  less
    than  10  clauses perform  a  linear scan  for a  possible  matching
    clause using this index key.

  o _H_a_s_h _l_o_o_k_u_p
    If  none of the  above applies, the  system considers the  available
    hash  tables for which  the corresponding argument is  instantiated.
    If  a table is  found with acceptable  characteristics, it is  used.
    Otherwise,  there  are  two cases.    First,  if  no hash  table  is
    available  for the instantiated  arguments, it assesses the  clauses
    for  all instantiated arguments and  selects the best candidate  for
    creating  a  hash table.    Arguments  that  cannot be  indexed  are
    flagged  to avoid repeated  scanning.   Second, if  there is a  hash
    table  for an indexed argument but it has poor  characteristics, the
    system  scans other  instantiated arguments  to see  whether it  can
    create  a better hash table.   The system maintains a bit  vector on
    each  table in which it marks arguments that are less  suitable than
    the argument to which the table belongs.

    Clauses  that have  a variable  at an  otherwise indexable  argument
    must  be linked into all hash  buckets.  Currently, predicates  that
    have  more than  10% such clauses  for a  specific argument are  not
    considered for indexing on that argument.

    Disregarding  variables, the suitability of an argument  for hashing
    is  expressed as the  number of unique  indexable values divided  by
    the  standard deviation of the  number of duplicate values for  each
    value plus one.

    The  indexes of  dynamic  predicates are  deleted if  the number  of
    clauses  is  doubled  since its  creation  or reduced  below  1/4th.
    The  JIT  approach  will  recreate  a suitable  index  on  the  next
    call.    Indexes  of running  predicates cannot  be deleted.    They
    are  added to a  `removed index list'  associated to the  predicate.
    Dynamic  predicates  maintain  a counter  for  the number  of  goals
    running  the predicate (a predicate can `run' multiple times  due to
    recursion,  open choice  points, and  multiple threads) and  destroy
    removed  indexes if this count drops  to zero.  Outdated indexes  of
    static  predicates (e.g.,  due to  reconsult or enlarging  multifile
    predicates) are reclaimed by garbage_collect_clauses/0.


22..1177..11 FFuuttuurree ddiirreeccttiioonnss

  o The  current  indexing  system  is largely  prepared  for  secondary
    indexes.   This  implies that if there  are many clauses that  match
    a  given  key, the  system  could (JIT)  create a  secondary  index.
    This  secondary index could exploit another argument or, if  the key
    denotes a functor, an argument inside the compound term.

  o The  `special cases' can  be extended.   This is notably  attractive
    for  static predicates  with a  relatively small  number of  clauses
    where a hash lookup is too costly.


22..1177..22 IInnddeexxiinngg aanndd ppoorrttaabbiilliittyy

The base-line functionality of Prolog implementations  provides indexing
on constants and functor (name/arity) on the first argument.   This must
be your  assumption if wide  portability of  your program is  important.
This can typically be  achieved by exploiting term_hash/2 or term_hash/4
and/or  maintaining  multiple  copies  of  a  predicate  with  reordered
arguments and wrappers that update all  implementations (assert/retract)
and selects the appropriate implementation (query).

YAP  provides  full  JIT  indexing,   including  indexing  arguments  of
compound terms.   YAP's indexing has been the inspiration  for enhancing
SWI-Prolog's indexing capabilities.


22..1188 WWiiddee cchhaarraacctteerr ssuuppppoorrtt

SWI-Prolog  supports _w_i_d_e  _c_h_a_r_a_c_t_e_r_s, characters  with character  codes
above  255 that  cannot be  represented in  a single  _b_y_t_e.    _U_n_i_v_e_r_s_a_l
_C_h_a_r_a_c_t_e_r  _S_e_t (UCS)  is the  ISO/IEC 10646  standard  that specifies  a
unique 31-bit unsigned  integer for any character  in any language.   It
is  a superset  of  16-bit  Unicode, which  in  turn  is a  superset  of
ISO  8859-1 (ISO  Latin-1),  a  superset  of US-ASCII.  UCS  can  handle
strings  holding  characters  from  multiple  languages,  and  character
classification (uppercase, lowercase, digit, etc.)   and operations such
as case conversion are unambiguously defined.

For this reason SWI-Prolog has two representations for  atoms and string
objects (see  section 5.2).   If  the text  fits in ISO  Latin-1, it  is
represented as  an array  of 8-bit characters.    Otherwise the text  is
represented as an array of 32-bit numbers.   This representational issue
is completely  transparent to  the Prolog user.    Users of the  foreign
language  interface as  described in  chapter 10  sometimes  need to  be
aware of these issues though.

Character coding comes into  view when characters of strings need  to be
read from  or written to file  or when they  have to be communicated  to
other software  components using  the foreign  language interface.    In
this section we only deal with I/O through streams,  which includes file
I/O as well as I/O through network sockets.


22..1188..11 WWiiddee cchhaarraacctteerr eennccooddiinnggss oonn ssttrreeaammss

Although  characters   are  uniquely  coded   using  the  UCS   standard
internally, streams  and files are byte  (8-bit) oriented and there  are
a variety of  ways to represent the larger  UCS codes in an 8-bit  octet
stream.   The most popular  one, especially in  the context of the  web,
is UTF-8.   Bytes 0 ... 127 represent simply the  corresponding US-ASCII
character, while bytes 128  ... 255 are used for multi-byte  encoding of
characters placed  higher in the  UCS space.   Especially on  MS-Windows
the 16-bit  Unicode standard,  represented by  pairs of  bytes, is  also
popular.

Prolog I/O streams  have a property called _e_n_c_o_d_i_n_g which  specifies the
used encoding that  influences get_code/2 and put_code/2 as well as  all
the other text I/O predicates.

The  default  encoding  for  files  is  derived  from  the  Prolog  flag
encoding,  which   is  initialised  from  the  environment.      If  the
environment variable  LANG ends  in "UTF-8", this  encoding is  assumed.
Otherwise  the  default   is  text  and  the  translation  is   left  to
the  wide-character functions  of  the C  library.    The  encoding  can
be  specified  explicitly  in load_files/2  for  loading  Prolog  source
with  an  alternative encoding,   open/4 when  opening  files  or  using
set_stream/2 on  any open  stream.    For Prolog  source  files we  also
provide the  encoding/1 directive  that can  be used  to switch  between
encodings that  are compatible  with US-ASCII (ascii,  iso_latin_1,  utf8
and  many  locales).     See  also  section  3.1.3  for  writing  Prolog
files  with non-US-ASCII  characters  and  section 2.15.2.4  for  syntax
issues.  For additional information and Unicode  resources, please visit
http://www.unicode.org/.

SWI-Prolog currently defines and supports the following encodings:

oocctteett
    Default  encoding for binary streams.  This causes the stream  to be
    read and written fully untranslated.

aasscciiii
    7-bit  encoding  in 8-bit  bytes.   Equivalent  to  iso_latin_1,  but
    generates errors and warnings on encountering values above 127.

iissoo__llaattiinn__11
    8-bit  encoding supporting many Western languages.  This  causes the
    stream to be read and written fully untranslated.

tteexxtt
    C  library default locale encoding for  text files.  Files are  read
    and  written using the C library functions mbrtowc()  and wcrtomb().
    This may be the  same as one of the other locales, notably it may be
    the  same as iso_latin_1 for Western languages  and utf8 in a  UTF-8
    context.

uuttff88
    Multi-byte encoding of full UCS, compatible with ascii.  See above.

uunniiccooddee__bbee
    Unicode  _B_i_g  _E_n_d_i_a_n.     Reads  input  in  pairs  of  bytes,   most
    significant byte first.  Can only represent 16-bit characters.

uunniiccooddee__llee
    Unicode  _L_i_t_t_l_e  _E_n_d_i_a_n.    Reads input  in  pairs of  bytes,  least
    significant byte first.  Can only represent 16-bit characters.

Note that not all encodings can represent all characters.   This implies
that  writing text  to a  stream  may cause  errors because  the  stream
cannot represent these characters.   The behaviour of a stream  on these
errors can  be controlled  using set_stream/2.   Initially the  terminal
stream writes the  characters using Prolog escape sequences while  other
streams generate an I/O exception.


22..1188..11..11 BBOOMM:: BByyttee OOrrddeerr MMaarrkk

From section  2.18.1, you may  have got the  impression that text  files
are  complicated.   This  section  deals with  a related  topic,  making
life  often easier  for the  user, but  providing another  worry to  the
programmer.   BBOOMM or  _B_y_t_e _O_r_d_e_r _M_a_r_k_e_r is  a technique for  identifying
Unicode text files as well  as the encoding they use.  Such  files start
with  the Unicode  character 0xFEFF,  a non-breaking,  zero-width  space
character.   This is a pretty unique  sequence that is not likely to  be
the start of  a non-Unicode file and uniquely distinguishes  the various
Unicode file  formats.   As it is  a zero-width  blank, it even  doesn't
produce any output.  This solves all problems, or ...

Some formats start  off as US-ASCII and  may contain some encoding  mark
to  switch to  UTF-8, such  as the  encoding="UTF-8" in  an XML  header.
Such formats often  explicitly forbid the use  of a UTF-8 BOM. In  other
cases there  is additional  information revealing  the encoding,  making
the use of a BOM redundant or even illegal.

The BOM  is handled by  SWI-Prolog open/4 predicate.   By default,  text
files are  probed for  the BOM when  opened for reading.    If a BOM  is
found, the  encoding is  set accordingly and  the property bom(_t_r_u_e)  is
available through stream_property/2.   When opening a file for  writing,
writing a BOM can be requested using the option bom(_t_r_u_e) with open/4.


22..1199 SSyysstteemm lliimmiittss


22..1199..11 LLiimmiittss oonn mmeemmoorryy aarreeaass

SWI-Prolog has  a number of  memory areas which are  only enlarged to  a
certain  limit.   The  internal data  representation  limits the  local,
global  and  trail  stack to  128  MB  on  32-bit  processors,  or  more
generally  to 2 to the power bits-per-pointer - 5  bytes.    Considering
that almost  all modern  hardware can  deal with this  amount of  memory
with  ease,  the default  limits  are set  to  their maximum  on  32-bit
hardware.   The representation limits can easily exceed  physical memory
on 64-bit hardware.   The default  limits on 64-bit hardware are  double
that of  32-bit hardware, which  allows for storing  the same amount  of
(Prolog) data.

The limits can  be changed from the command  line as well as at  runtime
using set_prolog_stack/2.   The table below shows these areas.  The first
column gives  the option  name to  modify the  size of  the area.    The
option character is  immediately followed by a number and  optionally by
a  k or  m.   With  k or  no unit  indicator, the  value is  interpreted
in Kbytes  (1024 bytes);  with  m, the  value is  interpreted in  Mbytes
(10241* 024 bytes).

The  PrologScript facility  described  in  section 2.10.2.1  provides  a
mechanism for  specifying options with  the load file.   On Windows  the
default stack  sizes are controlled  using the  Windows registry on  the
key  HKEY_CURRENT_USER\Software\SWI\Prolog using  the  names  localSize,
globalSize and trailSize.   The value is a DWORD expressing  the default
stack size  in Kbytes.   A  GUI for modifying  these values is  provided
using the XPCE package.  To use this, start the  XPCE manual tools using
manpce/0, after which you find _P_r_e_f_e_r_e_n_c_e_s in the _F_i_l_e menu.

Considering portability,  applications that need  to modify the  default
limits are advised to do so using set_prolog_stack/2.
        _________________________________________________________
        |_Option_|Default_|Area_name____|Description____________|_||-L||128Mlloocc||aallTssttaacckkhe||||local|stack|is used

        |        |                      to  store   the  execu- |              |           ||
        |        |                      tion  environments   of |              |           ||
        |        |                      procedure  invocations. |              |           ||
        |        |                      The  space for  an  en- |              |           ||
        |        |                      vironment is  reclaimed |              |           ||
        |        |                      when  it  fails,  exits |              |           ||
        |        |                      without leaving  choice |              |           ||
        |        |                      points,   the  alterna- |              |           ||
        |        |                      tives are cut  off with |              |           ||
        |        |                                              |              |           ||

        |        |                      the  !/0  predicate  or |              |           ||
        |        |                      no  choice points  have |              |           ||
        |        |                      been created  since the |              |           ||
        |        |                      invocation and the last |              |           ||
        |        |                      subclause  is   started |              |           ||
        |        |                      (last  call   optimisa- |              |           ||
        ||       ||      |             ||tion).                  ||             |           ||

        |   -G   |128M   |gglloobbaall ssttaacckk ||Theusglobaled stacktois store| terms
        |        |       |             ||created during Prolog's |
        |        |       |             ||execution.    Terms  on |
        |        |       |             ||                        |
        |        |       |             ||this stack will  be re- |
        |        |       |             ||claimed by backtracking |
        |        |       |             ||to a  point before  the |
        |        |       |             ||term  was   created  or |
        |        |       |             ||by  garbage  collection |

        |        |       |             ||(provided  the term  is |
        ||       ||      ||            ||no||longer referenced).  ||
        |   -T   |128M   |ttrraaiill ssttaacckk  ||Theusetraild stackto isstore|  as-
        |        |       |             ||signments during execu- |
        |        |       |             ||                        |
        |        |       |             ||tion.   Entries on this |
        |        |       |             ||stack remain  alive un- |

        |        |       |             ||til backtracking before |
        |        |       |             ||the  point of  creation |
        |        |       |             ||or the  garbage collec- |
        |        |       |             ||tor determines they are |
        |________|_______|_____________||no_longer_needed._______|_

                        Table 2.2:  Memory areas


22..1199..11..11 TThhee hheeaapp

With  the heap,  we  refer  to the  memory  area  used by  malloc()  and
friends.  SWI-Prolog uses the area to store  atoms, functors, predicates
and  their clauses,  records and  other dynamic  data.    No limits  are
imposed on the addresses returned by malloc() and friends.


22..1199..22 OOtthheerr LLiimmiittss

CCllaauusseess  The only  limit  on  clauses  is their  arity  (the  number  of
    arguments  to the head),  which is  limited to 1024.   Raising  this
    limit is easy and relatively cheap; removing it is harder.

AAttoommss aanndd SSttrriinnggss  SWI-Prolog has no  limits on the  sizes of atoms  and
    strings.    read/1  and  its derivatives,  however,  normally  limit
    the  number  of newlines  in  an  atom or  string  to 6  to  improve
    error  detection  and recovery.    This  can  be switched  off  with
    style_check/1.

    The  number  of  atoms  is  limited  to  16777216  (16M)  on  32-bit
    machines.   On  64-bit machines  this is virtually  unlimited.   See
    also section 10.4.2.1.

MMeemmoorryy aarreeaass  On 32-bit hardware, SWI-Prolog data is packed in  a 32-bit
    word,  which contains  both type and  value information.   The  size
    of  the various memory areas  is limited to 128  MB for each of  the
    areas,  except  for the  program heap,  which is  not limited.    On
    64-bit hardware there are no meaningful limits.

NNeessttiinngg ooff tteerrmmss  Most built-in  predicates  that process  Prolog  terms
    create  an explicitly  managed  stack and  perform optimization  for
    processing  the last  argument of  a term.   This  implies they  can
    process  deeply nested  terms at  constant and  low usage  of the  C
    stack,  and the  system raises  a resource  error if  no more  stack
    can  be  allocated.   Currently  only read/1  and  write/1 (and  all
    variations  thereof) still use the C stack and may cause  the system
    to  crash  in an  uncontrolled way  (i.e., not  mapped  to a  Prolog
    exception that can be caught).

IInntteeggeerrss  On  most systems  SWI-Prolog  is  compiled  with  support  for
    unbounded  integers by means  of the GNU GMP  library.  In  practice
    this  means that integers are bound by  the global stack size.   Too
    large  integers cause a resource_error.   On systems that lack  GMP,
    integers are 64-bit on 32- as well as 64-bit machines.

    Integers  up to the value of  the max_tagged_integerProlog  flag are
    represented  more  efficiently on  the  stack.   For  integers  that
    appear  in clauses, the value (below  max_tagged_integeror not)  has
    little impact on the size of the clause.

FFllooaattiinngg ppooiinntt nnuummbbeerrss  Floating  point  numbers   are  represented   as
    C-native double precision floats, 64-bit IEEE on most machines.


22..1199..33 RReesseerrvveedd NNaammeess

The boot compiler  (see -b option) does  not support the module  system.
As large parts of  the system are written in Prolog itself we  need some
way to  avoid name clashes  with the  user's predicates, database  keys,
etc.   Like Edinburgh C-Prolog [Pereira, 1986] all predicates,  database
keys, etc., that should be hidden from the user start  with a dollar ($)
sign.


22..2200 SSWWII--PPrroolloogg aanndd 6644--bbiitt mmaacchhiinneess

Most of  today's 64-bit  platforms are  capable of  running both  32-bit
and  64-bit applications.    This asks  for some  clarifications on  the
advantages and drawbacks of 64-bit addressing for (SWI-)Prolog.


22..2200..11 SSuuppppoorrtteedd ppllaattffoorrmmss

SWI-Prolog can  be compiled  for a 32-  or 64-bit  address space on  any
system with a suitable  C compiler.  Pointer arithmetic is based  on the
type (u)intptr_t from stdint.h, with suitable emulation on MS-Windows.


22..2200..22 CCoommppaarriinngg 3322-- aanndd 6644--bbiittss PPrroolloogg

Most of Prolog's memory usage consists of pointers.   This indicates the
primary drawback:   Prolog memory  usage almost  doubles when using  the
64-bit addressing  model.   Using  more memory means  copying more  data
between CPU and main memory, slowing down the system.

What then  are the advantages?   First  of all, SWI-Prolog's  addressing
of the  Prolog stacks  does not  cover the  whole address  space due  to
the  use of  _t_y_p_e _t_a_g  _b_i_t_s and  _g_a_r_b_a_g_e _c_o_l_l_e_c_t_i_o_n  _f_l_a_g_s.   On  32-bit
hardware the stacks  are limited to 128 MB each.   This tends to  be too
low for demanding applications  on modern hardware.  On  64-bit hardware
the limit is 232 times higher, exceeding the  addressing capabilities of
today's CPUs and operating systems.  This implies  Prolog can be started
with stack sizes that use the full capabilities of your hardware.

Multi-threaded applications  profit much more  because every thread  has
its  own  set of  stacks.     The  Prolog stacks  start  small  and  are
dynamically  expanded  (see section  2.19.1).     The C  stack  is  also
dynamically expanded,  but the  maximum size is  _r_e_s_e_r_v_e_d when a  thread
is started.   Using 100  threads at the maximum  default C stack of  8Mb
(Linux) costs 800Mb virtual memory!

The  implications  of  theoretical performance  loss  due  to  increased
memory  bandwidth implied  by exchanging  wider pointers  depend on  the
design of  the hardware.   We only  have data for  the popular IA32  vs.
AMD64 architectures.  Here, it appears that the  loss is compensated for
by an  instruction set that has  been optimized for modern  programming.
In particular, the AMD64 has more registers and  the relative addressing
capabilities  have been  improved.    Where  we  see a  10%  performance
degradation when placing the SWI-Prolog kernel in a  Unix shared object,
we cannot find a measurable difference on AMD64.


22..2200..33 CChhoooossiinngg bbeettwweeeenn 3322-- aanndd 6644--bbiitt PPrroolloogg

For those  cases where  we can  choose between  32 and  64 bits,  either
because the hardware and OS support both or because  we can still choose
the hardware and OS, we give guidelines for this decision.

First of  all, if SWI-Prolog  needs to be linked  against 32- or  64-bit
native libraries,  there  is no choice  as it  is not  possible to  link
32- and  64-bit code into  a single  executable.   Only if all  required
libraries are available  in both sizes and  there is no clear reason  to
use either do the different characteristics of Prolog become important.

Prolog  applications that  require  more than  the  128 MB  stack  limit
provided in 32-bit  addressing mode must use  the 64-bit edition.   Note
however that the limits  must be doubled to accommodate the  same Prolog
application.

If the system is  tight on physical memory, 32-bit Prolog has  the clear
advantage of using only slightly more than half of  the memory of 64-bit
Prolog.   This argument applies as long  as the application fits in  the
_v_i_r_t_u_a_l _a_d_d_r_e_s_s  _s_p_a_c_e of  the machine.   The  virtual address space  of
32-bit hardware is 4GB, but in many cases the  operating system provides
less to user applications.

The  only  standard  SWI-Prolog library  adding  significantly  to  this
calculation is  the RDF  database provided by  the _s_e_m_w_e_b  package.   It
uses approximately 80 bytes per triple on 32-bit hardware  and 150 bytes
on 64-bit hardware.  Details depend on how  many different resources and
literals appear  in the dataset  as well  as desired additional  literal
indexes.

Summarizing,  if applications  are small  enough to  fit comfortably  in
virtual  and physical  memory, simply  take the  model used  by most  of
the applications  on the OS.  If applications require  more than 128  MB
per  stack,  use the  64-bit  edition.    If applications  approach  the
size  of physical  memory, fit  in the  128 MB  stack limit  and fit  in
virtual memory, the 32-bit version has clear advantages.   For demanding
applications  on 64-bit  hardware  with  more than  about  6GB  physical
memory the 64-bit model is the model of choice.


CChhaapptteerr 33..  IINNIITTIIAALLIISSIINNGG AANNDD MMAANNAAGGIINNGG AA PPRROOLLOOGG PPRROOJJEECCTT

Prolog text-books  give you  an overview of  the Prolog  language.   The
manual tells  you what predicates  are provided in  the system and  what
they do.   This  chapter explains how  to run  a project.   There is  no
ultimate `right'  way to  do this.   Over  the years  we developed  some
practice in  this area and  SWI-Prolog's commands  are there to  support
this practice.   This chapter  describes the conventions and  supporting
commands.

The first two sections (section 3.1 and section 3.2)  only require plain
Prolog.    The remainder  discusses the  use of  the built-in  graphical
tools that require the XPCE graphical library installed on your system.


33..11 TThhee pprroojjeecctt ssoouurrccee ffiilleess

Organisation  of  source files  depends  largely  on the  size  of  your
project.    If  you  are doing  exercises  for  a Prolog  course  you'll
normally use one  file for each exercise.   If you have a small  project
you'll work with one directory holding a couple of  files and some files
to link  it all together.    Even bigger projects  will be organised  in
sub-projects, each using its own directory.


33..11..11 FFiillee NNaammeess aanndd LLooccaattiioonnss


33..11..11..11 FFiillee NNaammee EExxtteennssiioonnss

The  first  consideration  is what  extension  to  use  for  the  source
files.   Tradition  calls for  .pl, but  conflicts with  Perl force  the
use  of  another  extension on  systems  where  extensions  have  global
meaning,  such as  MS-Windows.    On  such systems  .pro is  the  common
alternative.    On  MS-Windows,  the  alternative  extension  is  stored
in the  registry key HKEY_CURRENT_USER/Software/SWI/Prolog/fileExtension
or HKEY_LOCAL_MACHINE/Software/SWI/Prolog/fileExtension.   All  versions
of  SWI-Prolog  load files  with  the  extension  .pl as  well  as  with
the  registered  alternative  extension  without  explicitly  specifying
the  extension.    For  portability  reasons we  propose  the  following
convention:

IIff tthheerree iiss nnoo ccoonnfflliicctt  because  you   do   not   use   a   conflicting
    application  or the system does not force a unique  relation between
    extension and application, use .pl.

WWiitthh aa ccoonnfflliicctt  choose .pro and  use this extension  for the files  you
    want  to load  through your file  manager.   Use .pl  for all  other
    files for maximal portability.


33..11..11..22 PPrroojjeecctt DDiirreeccttoorriieess

Large projects  are generally composed of  sub-projects, each using  its
own directory or  directory structure.   If nobody else will ever  touch
your files  and you  use only  one computer,  there is  little to  worry
about, but this is rarely the case with a large project.

To   improve   portability,   SWI-Prolog   uses   the   POSIX   notation
for  filenames,   which  uses   the  forward   slash  (/)  to   separate
directories.   Just  before reaching  the file  system, SWI-Prolog  uses
prolog_to_os_filename/2to  convert the filename to the conventions  used
by  the hosting  operating system.    It is  _s_t_r_o_n_g_l_y  advised to  write
paths using the  /, especially on systems  using the \ for this  purpose
(MS-Windows).  Using  \ violates the portability rules and  requires you
to _d_o_u_b_l_e the \ due to the Prolog quoted-atom escape rules.

Portable  code should  use  prolog_to_os_filename/2to  convert  computed
paths  into system  paths  when constructing  commands for  shell/1  and
friends.


33..11..11..33 SSuubb--pprroojjeeccttss uussiinngg sseeaarrcchh ppaatthhss

Thanks to Quintus, Prolog adapted an extensible  mechanism for searching
files using file_search_path/2.   This mechanism allows for  comfortable
and readable specifications.

Suppose  you  have  extensive  library  packages  on  graph  algorithms,
set  operations and  GUI  primitives.    These sub-projects  are  likely
candidates for re-use in future projects.  A good choice  is to create a
directory with sub-directories for each of these sub-projects.

Next,  there are  three options.    One is  to add  the sub-projects  to
the directory  hierarchy of the current  project.   Another is to use  a
completely dislocated  directory.  Third,  the sub-project can be  added
to  the SWI-Prolog  hierarchy.    Using  local installation,  a  typical
file_search_path/2is:

________________________________________________________________________|                                                                        |
|:- prolog_load_context(directory, Dir),                                 |

|   asserta(user:file_search_path(myapp, Dir)).                          |
|                                                                        |
|user:file_search_path(graph, myapp(graph)).                             |
|user:file_search_path(ui,|___myapp(ui))._______________________________ |                         |

When  using sub-projects  in the  SWI-Prolog hierarchy,  one should  use
the path  alias swi as basis.   For  a system-wide installation, use  an
absolute path.

Extensive sub-projects  with a  small well-defined API  should define  a
load  file with  calls to  use_module/1 to  import the  various  library
components and export the API.


33..11..22 PPrroojjeecctt SSppeecciiaall FFiilleess

There are  a number of  tasks you typically carry  out on your  project,
such as  loading it, creating a  saved state, debugging  it, etc.   Good
practice  on large  projects is  to  define small  files that  hold  the
commands to execute such a task, name this file after  the task and give
it a  file extension  that makes  starting easy  (see section  3.1.1.1).
The task _l_o_a_d is generally central to these tasks.   Here is a tentative
list:

  o load.pl
    Use  this file  to set  up the  environment (Prolog  flags and  file
    search  paths) and load the sources.  Quite commonly this  file also
    provides  convenient predicates  to parse command  line options  and
    start the application.

  o run.pl
    Use  this file to start the application.  Normally it  loads load.pl
    in  silent-mode,  and  calls one  of  the starting  predicates  from
    load.pl.

  o save.pl
    Use this file to  create a saved state of the application by loading
    load.pl  and calling qsave_program/2 to generate a saved  state with
    the proper options.

  o debug.pl
    Loads  the program for  debugging.   In addition to loading  load.pl
    this  file defines rules for portray/1 to modify printing  rules for
    complex  terms and customisation rules for the debugger  and editing
    environment.  It may start some of these tools.


33..11..33 IInntteerrnnaattiioonnaall ssoouurrccee ffiilleess

As  discussed  in   section  2.18,  SWI-Prolog  supports   international
character  handling.   Its  internal encoding  is  UNICODE. I/O  streams
convert  to/from this  internal  format.    This section  discusses  the
options for source files not in US-ASCII.

SWI-Prolog  can  read  files  in  any  of  the  encodings  described  in
section 2.18.    Two encodings  are of particular  interest.   The  text
encoding  deals with  the  current  _l_o_c_a_l_e,  the default  used  by  this
computer for  representing text files.   The encodings  utf8, unicode_le
and unicode_be are _U_N_I_C_O_D_E encodings:  they can represent---in  the same
file---characters of  virtually any known language.   In addition,  they
do so unambiguously.

If one wants to represent non US-ASCII text as Prolog  terms in a source
file, there are several options:

  o _U_s_e _e_s_c_a_p_e _s_e_q_u_e_n_c_e_s
    This approach describes  NON-ASCII as sequences of the form \_o_c_t_a_l\.
    The  numerical argument is interpreted as a UNICODE character.   The
    resulting  Prolog file is  strict 7-bit US-ASCII,  but if there  are
    many NON-ASCII characters it becomes very unreadable.

  o _U_s_e _l_o_c_a_l _c_o_n_v_e_n_t_i_o_n_s
    Alternatively  the file  may be specified  using local  conventions,
    such  as the EUC  encoding for Japanese text.   The disadvantage  is
    portability.  If  the file is moved to another machine, this machine
    must  use the same _l_o_c_a_l_e  or the file is  unreadable.  There is  no
    elegant  way if files  from multiple locales  must be united in  one
    application  using this technique.   In other words, it is  fine for
    local projects in countries with uniform locale conventions.

  o _U_s_i_n_g _U_T_F_-_8 _f_i_l_e_s
    The best way  to specify source files with many NON-ASCII characters
    is definitely the use  of UTF-8 encoding.  Prolog can be notified of
    this encoding in  two ways, using a UTF-8 _B_O_M (see section 2.18.1.1)
    or  using  the directive  :- encoding(utf8).  Many of  today's  text
    editors,  including PceEmacs,  are capable  of editing UTF-8  files.
    Projects  that were started using local conventions can  be re-coded
    using  the Unix iconv  tool or often  using commands offered by  the
    editor.


33..22 UUssiinngg mmoodduulleess

Modules have  been debated fiercely  in the Prolog world.   Despite  all
counter-arguments we feel they are extremely useful because:

  o _T_h_e_y _h_i_d_e _l_o_c_a_l _p_r_e_d_i_c_a_t_e_s
    This  is the reason they were invented  in the first place.   Hiding
    provides  two  features.    They  allow  for short  predicate  names
    without  worrying  about  conflicts.    Given  the  flat  name-space
    introduced  by modules, they  still require meaningful module  names
    as well as meaningful names for exported predicates.

  o _T_h_e_y _d_o_c_u_m_e_n_t _t_h_e _i_n_t_e_r_f_a_c_e
    Possibly  more important than avoiding name conflicts is  their role
    in  documenting  which part  of the  file is  for  public usage  and
    which  is  private.    When  editing a  module  you may  assume  you
    can  reorganise anything except  the name and  the semantics of  the
    exported predicates without worrying.

  o _T_h_e_y _h_e_l_p _t_h_e _e_d_i_t_o_r
    The  PceEmacs built-in editor  does on-the-fly cross-referencing  of
    the  current module, colouring predicates based on their  origin and
    usage.    Using modules,  the editor  can quickly find  out what  is
    provided  by the imported  modules by reading  just the first  term.
    This  allows it to  indicate in real-time  which predicates are  not
    used or not defined.

Using modules  is generally  easy.   Only if  you write  meta-predicates
(predicates reasoning about  other predicates) that are exported from  a
module is a  good understanding required of  the resolution of terms  to
predicates inside a module.  Here is a typical example from readutil.

________________________________________________________________________|                                                                        |

|:- module(read_util,                                                    |
|          [ read_line_to_codes/2,       % +Fd, -Codes                   |
|            read_line_to_codes/3,       % +Fd, -Codes, ?Tail            |
|            read_stream_to_codes/2,     % +Fd, -Codes                   |
|            read_stream_to_codes/3,     % +Fd, -Codes, ?Tail            |

|            read_file_to_codes/3,       % +File, -Codes, +Options       |
|            read_file_to_terms/3        % +File, -Terms, +Options       |
||_________]).__________________________________________________________ ||


33..33 TThhee tteesstt--eeddiitt--rreellooaadd ccyyccllee

SWI-Prolog  does  not  enforce  the  use  of  a  particular  editor  for
writing  Prolog source  code.   Editors  are  complicated programs  that
must  be  mastered in  detail  for  real  productive programming.     If
you  are familiar  with  a specific  editor  you  should not  be  forced
to change.    You may  specify your  favourite editor  using the  Prolog
flag editor,  the environment variable EDITOR  or by defining rules  for
prolog_edit:edit_source/1 (see section 4.5).

The use of  a built-in editor, which  is selected by setting the  Prolog
flag  editor to  pce_emacs,  has  advantages.   The  XPCE _e_d_i_t_o_r  object,
around which the built-in  PceEmacs is built, can be opened as  a Prolog
stream allowing analysis of your source by the real Prolog system.


33..33..11 LLooccaattiinngg tthhiinnggss ttoo eeddiitt

The central  predicate for  editing something is  edit/1, an  extensible
front-end  that searches  for objects  (files, predicates,  modules,  as
well as XPCE classes  and methods) in the Prolog database.   If multiple
matches are  found it  provides a choice.    Together with the  built-in
completion on atoms  bound to the TAB key  this provides a quick way  to
edit objects:

________________________________________________________________________|                                                                        |
|?- edit(country).                                                       |

|Please select item to edit:                                             |
|                                                                        |
|  1 chat:country/10      '/staff/jan/lib/prolog/chat/countr.pl':16      |
|  2 chat:country/1       '/staff/jan/lib/prolog/chat/world0.pl':72      |
|                                                                        |
|Your|choice?___________________________________________________________ |    |


33..33..22 EEddiittiinngg aanndd iinnccrreemmeennttaall ccoommppiillaattiioonn

One of  the nice features  of Prolog  is that the  code can be  modified
while  the program  is running.    Using  pure Prolog  you  can trace  a
program,  find it  is misbehaving,  enter  a _b_r_e_a_k  _e_n_v_i_r_o_n_m_e_n_t,  modify
the  source code,  reload it  and finally  do _r_e_t_r_y  on the  misbehaving
predicate  and  try  again.      This  sequence  is  not   uncommon  for
long-running programs.    For faster  programs one  will normally  abort
after understanding  the misbehaviour,  edit the source,  reload it  and
try again.

One of the nice features of SWI-Prolog is the  availability of make/0, a
simple predicate that checks  all loaded source files to see  which ones
you have modified.  It then reloads these  files, considering the module
from which  the file  was loaded  originally.   This greatly  simplifies
the trace-edit-verify development cycle.  For example,  after the tracer
reveals there is something wrong with prove/3, you do:

________________________________________________________________________|                                                                        |
|?-|edit(prove).________________________________________________________ |  |

Now  edit the  source,  possibly switching  to  other files  and  making
multiple changes.   After finishing,  invoke make/0, either through  the
editor UI (Compile/Make (Control-C Control-M)) or on the  top level, and
watch the files being reloaded.

________________________________________________________________________|                                                                        |

|?- make.                                                                |
|%|show_compiled_into_photo_gallery_0.03_sec,_3,360_bytes_______________ | |


33..44 UUssiinngg tthhee PPcceeEEmmaaccss bbuuiilltt--iinn eeddiittoorr


33..44..11 AAccttiivvaattiinngg PPcceeEEmmaaccss

Initially edit/1  uses the  editor specified in  the EDITOR  environment
variable.   There are two ways to  force it to use the built-in  editor.
One is to  set the Prolog flag editor  to pce_emacs and the other is  by
starting the editor explicitly using the emacs/[0,1] predicates.


33..44..22 BBlluuffffiinngg tthhrroouugghh PPcceeEEmmaaccss

PceEmacs closely  mimics Richard Stallman's  GNU-Emacs commands,  adding
features from  modern window-based  editors to make  it more  acceptable
for beginners.

At the  basis, PceEmacs  maps keyboard sequences  to methods defined  on
the extended  _e_d_i_t_o_r object.   Some frequently  used commands are,  with
their key-binding, presented  in the menu bar above each  editor window.
A complete  overview of the  bindings for the  current _m_o_d_e is  provided
through Help/Show key bindings (Control-h Control-b).


33..44..22..11 EEddiitt mmooddeess

Modes  are the  heart of  (Pce)Emacs.   Modes  define dedicated  editing
support for  a particular kind  of (source)  text.   For our purpose  we
want _P_r_o_l_o_g _m_o_d_e.   There are various  ways to make PceEmacs use  Prolog
mode for a file.

  o _U_s_i_n_g _t_h_e _p_r_o_p_e_r _e_x_t_e_n_s_i_o_n
    If  the file  ends in .pl  or the  selected alternative (e.g.  .pro)
    extension, Prolog mode is selected.

  o _U_s_i_n_g #!/path/to/.../swipl
    If  the  file  is a  _P_r_o_l_o_g  _S_c_r_i_p_t  file, starting  with  the  line
    #!/path/to/swipl _o_p_t_i_o_n_s, Prolog  mode is selected regardless of the
    extension.

  o _U_s_i_n_g -*- Prolog -*-
    If the above sequence  appears in the first line of the file (inside
    a Prolog comment) Prolog mode is selected.

  o _E_x_p_l_i_c_i_t _s_e_l_e_c_t_i_o_n
    Finally,  using  File/Mode/Prolog  you  can switch  to  Prolog  mode
    explicitly.


33..44..22..22 FFrreeqquueennttllyy uusseedd eeddiittoorr ccoommmmaannddss

Below we list a few important commands and how to activate them.

  o _C_u_t_/_C_o_p_y_/_P_a_s_t_e
    These  commands  follow Unix/X11  traditions.    You're best  suited
    with  a three-button mouse.   After  selecting using the  left-mouse
    (double-click  uses word-mode  and triple  line-mode), the  selected
    text   is  _a_u_t_o_m_a_t_i_c_a_l_l_y  copied  to  the  clipboard   (X11  primary
    selection  on  Unix).   _C_u_t  is achieved  using the  DEL  key or  by
    typing something else at  the location.  _P_a_s_t_e is achieved using the
    middle-mouse  (or wheel) button.   If you don't have a  middle-mouse
    button,  pressing the  left- and  right-button at the  same time  is
    interpreted  as a middle-button click.   If nothing helps, there  is
    the Edit/Paste menu entry.  Text is pasted at the caret location.

  o _U_n_d_o
    Undo  is bound to the GNU-Emacs Control-_ as well as  the MS-Windows
    Control-Z sequence.

  o _A_b_o_r_t
    Multi-key sequences can be aborted at any stage using Control-G.

  o _F_i_n_d
    Find  (Search) is  started  using Control-S  (forward) or  Control-R
    (backward).    PceEmacs  implements  _i_n_c_r_e_m_e_n_t_a_l _s_e_a_r_c_h.    This  is
    difficult  to use for  novices, but very  powerful once you get  the
    clue.    After one  of the above  start keys,  the system  indicates
    search  mode in  the status  line.   As  you are  typing the  search
    string, the system  searches for it, extending the search with every
    character you type.   It illustrates the current match using a green
    background.

    If  the target  cannot be found,  PceEmacs warns  you and no  longer
    extends  the search  string.   During search,  some characters  have
    special  meaning.  Typing anything but these characters  commits the
    search, re-starting normal edit mode.  Special commands are:

    Control-S
         Search forwards for next.

    Control-R
         Search backwards for next.

    Control-W
         Extend search to next word boundary.

    Control-G
         Cancel search, go back to where it started.

    ESC
         Commit search, leaving caret at found location.

    Backspace
         Remove a character from the search string.

  o _D_y_n_a_m_i_c _A_b_b_r_e_v_i_a_t_i_o_n
    Also  called _d_a_b_b_r_e_v, dynamic  abbreviation is an important  feature
    of Emacs clones to  support programming.  After typing the first few
    letters  of an identifier, you may press Alt-/, causing  PceEmacs to
    search  backwards for  identifiers that  start the same  and use  it
    to  complete the text  you typed.   A second Alt-/ searches  further
    backwards.    If  there are  no  hits before  the caret,  it  starts
    searching  forwards.   With  some practice, this  system allows  for
    entering  code  very fast  with nice  and  readable identifiers  (or
    other difficult long words).

  o _O_p_e_n _(_a _f_i_l_e_)
    Is  called File/Find  file (Control-x Control-f).    By default  the
    file  is loaded into the current window.   If you want to  keep this
    window,  press Alt-s or click the little icon at the bottom  left to
    make the window _s_t_i_c_k_y.

  o _S_p_l_i_t _v_i_e_w
    Sometimes  you want to look at two places  in the same file.   To do
    this,  use Control-x 2 to create  a new window pointing to  the same
    file.   Do not worry, you  can edit as well as move around  in both.
    Control-x 1 kills all other windows running on the same file.

These are the most commonly used commands.  In  section 3.4.3 we discuss
specific support for dealing with Prolog source code.


33..44..33 PPrroolloogg MMooddee

In  the  previous  section  (section  3.4.2)  we  explained  the  basics
of  PceEmacs.    Here we  continue with  Prolog-specific  functionality.
Possibly  the most  interesting is  _S_y_n_t_a_x _h_i_g_h_l_i_g_h_t_i_n_g.    Unlike  most
editors  where  this  is  based  on  simple  patterns,  PceEmacs  syntax
highlighting  is  achieved   by  Prolog  itself  actually  reading   and
interpreting the  source as you  type it.   There  are three moments  at
which PceEmacs checks (part of) the syntax.

  o _A_f_t_e_r _t_y_p_i_n_g _a .
    After  typing a . that  is not preceded  by a _s_y_m_b_o_l character,  the
    system  assumes you completed a clause,  tries to find the start  of
    this  clause and verifies the syntax.   If this process succeeds  it
    colours  the elements  of the  clause according to  the rules  given
    below.    Colouring is  done using  information from  the last  full
    check  on this file.  If it fails, the syntax error  is displayed in
    the status line and the clause is not coloured.

  o _A_f_t_e_r _t_h_e _c_o_m_m_a_n_d Control-c Control-s
    Acronym  for CCheck SSyntax, it performs the same checks as  above for
    the  clause surrounding the caret.  On a syntax error,  however, the
    caret is moved to the expected location of the error.

  o _A_f_t_e_r _p_a_u_s_i_n_g _f_o_r _t_w_o _s_e_c_o_n_d_s
    After  a short  pause (2  seconds), PceEmacs opens  the edit  buffer
    and  reads it  as a  whole, creating  an index  of defined,  called,
    dynamic,  imported and exported predicates.  After  completing this,
    it  re-reads the file and colours  all clauses and calls with  valid
    syntax.

  o _A_f_t_e_r _t_y_p_i_n_g Control-l Control-l
    The  Control-l command re-centers the window (scrolls the  window to
    make  the caret  the center  of the window).    Typing this  command
    twice starts the same process as above.

TThhee ccoolloouurr sscchheemmaa

itself  is  defined  in  emacs/prolog_colour.     The  colouring  can  be
extended and  modified using multifile  predicates.   Please check  this
source file for  details.  In  general, underlined objects have a  popup
(right-mouse button)  associated with  common commands  such as  viewing
the  documentation or  source.    BBoolldd  text  is  used to  indicate  the
definition of  objects (typically predicates  when using plain  Prolog).
Other colours follow intuitive conventions.  See table 3.4.3.
          _____________________________________________________
          |______________________Clauses_______________________|
          | Blue bold  |Head of an exported predicate          |
          | Red bold   |Head of a predicate that is not called |

          |_Black_bold_|Head_of_remaining_predicates___________|
          |______________Calls_in_the_clause_body______________|
          | Blue       |Call to built-in or imported predicate |
          | Red        |Call to undefined predicate            |
          |_Purple_____|Call_to_dynamic_predicate______________|
          |___________________Other_entities___________________|

          | Dark green |Comment                                |
          | Dark blue  |Quoted atom or string                  |
          |_Brown______|Variable_______________________________|

                     Table 3.1:  Colour conventions

LLaayyoouutt ssuuppppoorrtt Layout  is not `just nice',  it is _e_s_s_e_n_t_i_a_l for  writing
readable code.   There is  much debate on  the proper layout of  Prolog.
PceEmacs, being  a rather  small project,  supports only one  particular
style for layout.  Below are examples of typical constructs.

________________________________________________________________________|                                                                        |
|head(arg1, arg2).                                                       |

|                                                                        |
|head(arg1, arg2) :- !.                                                  |
|                                                                        |
|head(Arg1, arg2) :- !,                                                  |
|        call1(Arg1).                                                    |
|                                                                        |
|head(Arg1, arg2) :-                                                     |

|        (   if(Arg1)                                                    |
|        ->  then                                                        |
|        ;   else                                                        |
|        ).                                                              |
|                                                                        |
|head(Arg1) :-                                                           |
|        (   a                                                           |
|        ;   b                                                           |

|        ).                                                              |
|                                                                        |
|head :-                                                                 |
|        a(many,                                                         |
|          long,                                                         |
|          arguments(with,                                               |
|                    many,                                               |

|                    more),                                              |
|          and([ a,                                                      |
|                long,                                                   |
|                list,                                                   |
|                with,                                                   |
|                a,                                                      |
|              | tail                                                    |
||_____________]))._____________________________________________________ ||

PceEmacs uses the  same conventions as GNU-Emacs.   The TAB key  indents
the current  line according  to the  syntax rules.    Alt-q indents  all
lines  of the  current clause.    It provides  support for  head,  calls
(indented 1  tab), if-then-else, disjunction  and argument lists  broken
across multiple lines as illustrated above.


33..44..33..11 FFiinnddiinngg yyoouurr wwaayy aarroouunndd

The command Alt-.   extracts name and arity from the caret  location and
jumps (after conformation  or edit) to the definition of  the predicate.
It does  so based on the  source-location database of loaded  predicates
also used  by edit/1.   This makes locating  predicates reliable if  all
sources are loaded and up-to-date (see make/0).

In addition,  references to files  in use_module/[1,2], consult/1,  etc.
are red if the file cannot be found and underlined blue  if the file can
be loaded.  A popup allows for opening the referenced file.


33..55 TThhee GGrraapphhiiccaall DDeebbuuggggeerr

SWI-Prolog  offers  two  debuggers.     One  is   the  traditional  text
console-based  4-port Prolog  tracer  and the  other is  a  window-based
source  level  debugger.     The  window-based  debugger  requires  XPCE
installed.   It operates  based on  the prolog_trace_interception/4 hook
and other low-level functionality described in chapter 13.

Window-based tracing provides a much better overview due  to the eminent
relation to your source code, a clear list of  named variables and their
bindings as well  as a graphical overview  of the call and choice  point
stack.  There are  some drawbacks though.  Using a textual trace  on the
console, one can scroll  back and examine the past, while  the graphical
debugger just presents a (much better) overview of the current state.


33..55..11 IInnvvookkiinngg tthhee wwiinnddooww--bbaasseedd ddeebbuuggggeerr

Whether the  text-based or window-based debugger  is used is  controlled
using  the predicates  guitracer/0 and  noguitracer/0.   Entering  debug
mode  is controlled  using  the normal  predicates  for this:    trace/0
and  spy/1.   In  addition, PceEmacs  prolog mode  provides the  command
Prolog/Break  at (Control-c b)  to insert  a break-point  at a  specific
location in the source code.

The graphical tracer is  particulary useful for debugging threads.   The
tracer must be loaded from the main thread before it can  be used from a
background thread.


gguuiittrraacceerr
    This  predicate  installs the  above-mentioned hooks  that  redirect
    tracing  to  the  window-based  environment.    No  window  appears.
    The  debugger window  appears as actual  tracing is started  through
    trace/0,  by hitting a spy point  defined by spy/1 or a  break point
    defined using the PceEmacs command Prolog/Break at (Control-c b).


nnoogguuiittrraacceerr
    Disable  the hooks  installed by  guitracer/0,  reverting to  normal
    text console-based tracing.


ggttrraaccee
    Utility defined as guitracer,trace.


ggddeebbuugg
    Utility defined as guitracer,debug.


ggssppyy((_+_P_r_e_d_i_c_a_t_e))
    Utility defined as guitracer,spy(Predicate).


33..66 TThhee PPrroolloogg NNaavviiggaattoorr

Another  tool is  the  _P_r_o_l_o_g  _N_a_v_i_g_a_t_o_r.    This  tool can  be  started
from  PceEmacs  using the  command  Browse/Prolog  navigator,  from  the
GUI  debugger or  using  the  programmatic IDE  interface  described  in
section 3.8.


33..77 CCrroossss--rreeffeerreenncceerr

A cross-referencer  is a tool that  examines the caller-callee  relation
between predicates, and, using this information  to explicate dependency
relations between source  files, finds calls to non-existing  predicates
and predicates  for which no  callers can be  found.   Cross-referencing
is useful during program development, reorganisation,  clean-up, porting
and  other program  maintenance tasks.    The dynamic  nature of  Prolog
makes the  task non-trivial.    Goals can be  created dynamically  using
call/1  after construction  of a  goal term.    Abstract  interpretation
can find  some of  these calls,  but they  can also  come from  external
communication,  making  it  impossible  to  predict  the  callee.     In
other  words, the  cross-referencer has  only  partial understanding  of
the program,  and its  results are  necessarily incomplete.   Still,  it
provides valuable information to the developer.

SWI-Prolog's cross-referencer  is split into  two parts.   The  standard
Prolog  library prolog_xref  is an  extensible library  for  information
gathering  described in  section 12.25,  and the  XPCE library  pce_xref
provides a graphical front-end for the  cross-referencer described here.
We  demonstrate the  tool on  CHAT80, a  natural  language question  and
answer system by Fernando C.N. Pereira and David H.D. Warren.


ggxxrreeff
    Run  cross-referencer on  all currently loaded  files and present  a
    graphical  overview of  the result.   As  the predicate operates  on
    the  currently loaded application it  must be run after loading  the
    application.

The lleefftt wwiinnddooww (see  figure ????) provides browsers for loaded  files and
predicates.   To  avoid long file  paths, the  file hierarchy has  three
main branches.  The first is the current  directory holding the sources.
The  second is  marked  alias, and  below  it are  the  file-search-path
aliases  (see file_search_path/2 and  absolute_file_name/3).    Here  you
find files  loaded from  the system as  well as  modules of the  program
loaded from  other locations  using the file  search path.   All  loaded
files  that fall  outside these  categories are  below  the last  branch
called /.    Files where  the system found  suspicious dependencies  are
marked  with an  exclamation mark.    This  also holds  for  directories
holding such files.  Clicking on a file opens a  _F_i_l_e _i_n_f_o window in the
right pane.

The FFiillee iinnffoo  window shows a file,  its main properties, its  undefined
and not-called predicates  and its import and export relations  to other
files  in the  project.   Both  predicates and  files can  be opened  by
clicking  on them.    The number  of callers  in a  file  for a  certain
predicate is  indicated with  a blue  underlined number.   A  left-click
will open a list and allow editing the calling predicate.

The DDeeppeennddeenncciieess  (see figure ????) window  displays a graphical  overview
of dependencies  between files.   Using the  background menu a  complete
graph of the project can be created.  It is  also possible to drag files
onto the  graph window and  use the menu on  the nodes to  incrementally
expand the  graph.   The underlined  blue text  indicates the number  of
predicates used in the destination file.  Left-clicking  opens a menu to
open the definition or select one of the callers.

MMoodduullee  aanndd nnoonn--mmoodduullee  ffiilleess The  cross-referencer threads  module  and
non-module  project files  differently.    Module  files  have  explicit
import  and  export   relations  and  the  tool  shows  the   usage  and
consistency of the relations.   Using the Header menu command,  the tool
creates a  consistent import list  for the module  that can be  included
in the  file.   The tool computes the  dependency relations between  the
non-module files.   If  the user  wishes to convert  the project into  a
module-based one,  the Header  command generates  an appropriate  module
header and import list.  Note that the  cross-referencer may have missed
dependencies  and does  not  deal with  meta-predicates defined  in  one
module and called in another.  Such problems must be resolved manually.

SSeettttiinnggss The  following settings  can be  controlled  from the  settings
menu:

WWaarrnn aauuttoollooaadd
    By  default disabled.   If enabled, modules that require  predicates
    to  be  autoloaded are  flagged with  a warning  and  the file  info
    window of a module shows the required autoload predicates.

WWaarrnn nnoott ccaalllleedd
    If  enabled (default),  the file  overview shows an  alert icon  for
    files that have predicates that are not called.


33..88 AAcccceessssiinngg tthhee IIDDEE ffrroomm yyoouurr pprrooggrraamm

Over the years a collection of IDE components have  been developed, each
with its own interface.   In addition, some of these  components require
each  other, and  loading  IDE components  must be  on demand  to  avoid
the IDE  being part of  a saved state (see  qsave_program/2).   For  this
reason, access to the  IDE is concentrated on a single  interface called
prolog_ide/1:


pprroolloogg__iiddee((_+_A_c_t_i_o_n))
    This  predicate ensures the  IDE-enabling XPCE component is  loaded,
    creates  the XPCE class _p_r_o_l_o_g___i_d_e and sends  _A_c_t_i_o_n to its one  and
    only instance @prolog_ide.  _A_c_t_i_o_n is one of the following:

    ooppeenn__nnaavviiggaattoorr((_+_D_i_r_e_c_t_o_r_y))
         Open  the Prolog  Navigator  (see  section 3.6)  in  the  given
         _D_i_r_e_c_t_o_r_y.

    ooppeenn__ddeebbuugg__ssttaattuuss
         Open a window to edit spy and trace points.

    ooppeenn__qquueerryy__wwiinnddooww
         Open  a  little  window  to  run  Prolog  queries  from  a  GUI
         component.

    tthhrreeaadd__mmoonniittoorr
         Open a graphical  window indicating existing threads and  their
         status.

    ddeebbuugg__mmoonniittoorr
         Open a graphical front-end for the debug  library that provides
         an overview of the topics and catches messages.

    xxrreeff
         Open  a  graphical  front-end  for  the  cross-referencer  that
         provides an overview of predicates and their callers.


33..99 SSuummmmaarryy ooff tthhee IIDDEE

The  SWI-Prolog  development   environment  consists  of  a  number   of
interrelated but  not (yet) integrated  tools.   Here is  a list of  the
most important features and tips.

  o _A_t_o_m _c_o_m_p_l_e_t_i_o_n
    The  console  completes a  partial atom  on the  TAB  key and  shows
    alternatives on the command Alt-?.

  o _U_s_e edit/1 _f_o_r _f_i_n_d_i_n_g _l_o_c_a_t_i_o_n_s
    The  command edit/1 takes the name  of a file, module, predicate  or
    other  entity registered  through extensions and  starts the  user's
    preferred editor at the right location.

  o _S_e_l_e_c_t _e_d_i_t_o_r
    External   editors  are  selected   using  the  EDITOR   environment
    variable,  by setting  the Prolog  flag editor, or  by defining  the
    hook prolog_edit:edit_source/1.

  o _U_p_d_a_t_e _P_r_o_l_o_g _a_f_t_e_r _e_d_i_t_i_n_g
    Using make/0, all files you have edited are re-loaded.

  o _P_c_e_E_m_a_c_s
    Offers  syntax highlighting and checking based on  real-time parsing
    of the editor's buffer, layout support and navigation support.

  o _U_s_i_n_g _t_h_e _g_r_a_p_h_i_c_a_l _d_e_b_u_g_g_e_r
    The   predicates  guitracer/0   and  noguitracer/0  switch   between
    traditional  text-based and window-based debugging.   The tracer  is
    activated  using the trace/0, spy/1  or menu items from PceEmacs  or
    the Prolog Navigator.

  o _T_h_e _P_r_o_l_o_g _N_a_v_i_g_a_t_o_r
    Shows  the file structure and structure inside the file.   It allows
    for loading files, editing, setting spy points, etc.


CChhaapptteerr 44..  BBUUIILLTT--IINN PPRREEDDIICCAATTEESS


44..11 NNoottaattiioonn ooff PPrreeddiiccaattee DDeessccrriippttiioonnss

We have  tried to  keep the  predicate descriptions  clear and  concise.
First,  the predicate  name is  printed in  bold face,  followed by  the
arguments  in italics.    Arguments are  preceded by  a mode  indicator.
There  is  no  complete agreement  on  mode  indicators  in  the  Prolog
community.  We use the following definitions:

        _________________________________________________________++Argument must  be ground,  i.e., the  argument may

             not contain a variable anywhere.
         +   Argument must  be  fully  instantiated to  a  term
             that satisfies the type.   This is not necessarily
             _g_r_o_u_n_d, e.g., the term [_] is a _l_i_s_t, although its

             only member is unbound.
         -   Argument  is   an   _o_u_t_p_u_t  argument.       Unless
             specified  otherwise,  output arguments  need  not
             to  be   unbound.       For  example,   the   goal
             findall(X, Goal, [T]) is good style and equivalent
             to  findall(X, Goal, Xs), Xs = [T] Note  that  the
             _d_e_t_e_r_m_i_n_i_s_m  specification,  e.g.,   ``det''  only
             applies if this argument is unbound.

         --  Argument  must be  unbound.    Typically  used  by
             predicates that  create `something'  and return  a
             handle to the created object, such as open/3 which
             creates a _s_t_r_e_a_m.
         ?   Argument  must   be  bound   to  a  _p_a_r_t_i_a_l   _t_e_r_m
             of   the   indicated  type.        Note   that   a
             variable  is   a  partial   term  for  any   type.

             Think  of   the  argument   as  either  _i_n_p_u_t   or
             _o_u_t_p_u_t  or   _b_o_t_h   input  and   output.       For
             example,  in stream_property(S, reposition(Bool)),
             the reposition part of  the term is input  and the
             uninstantiated _B_o_o_l is output.
         :   Argument is  a meta-argument.    Implies +.    See
             chapter 6 for more information on module handling.
         @   Argument is not  further instantiated.   Typically

             used for type tests.
         !   Argument contains a mutable structure  that may be
        _____modified_using_setarg/3_or_nb_setarg/3._____________

Referring  to a  predicate in  running text  is done  using a  _p_r_e_d_i_c_a_t_e
_i_n_d_i_c_a_t_o_r.     The  canonical and  most  generic  form  of  a  predicate
indicator is a term <_m_o_d_u_l_e>:<_n_a_m_e>/<_a_r_i_t_y>.  If the module is  irrelevant
(built-in  predicate)  or  can  be  inferred  from  the  context  it  is
often  omitted.    Compliant  to the  ISO  standard  draft on  DCG  (see
section 4.12),  SWI-Prolog also allows  for [<_m_o_d_u_l_e>]:<_n_a_m_e>//<_a_r_i_t_y>  to
refer to  a grammar rule.   For  all non-negative arity,  <_n_a_m_e>//<_a_r_i_t_y>
is  the  same as  <_n_a_m_e>/<_a_r_i_t_y>+2,  regardless  of  whether or  not  the
referenced  predicate is  defined or  can  be used  as a  grammar  rule.
The  //-notation can  be used  in all  places  that traditionally  allow
for a  predicate indicator,  e.g.,  the module  declaration, spy/1,  and
dynamic/1.


44..22 CChhaarraacctteerr rreepprreesseennttaattiioonn

In  traditional (Edinburgh)  Prolog,  characters are  represented  using
_c_h_a_r_a_c_t_e_r _c_o_d_e_s.   Character codes are  integer indices into a  specific
character set.    Traditionally the  character set  was 7-bit  US-ASCII.
8-bit  character sets  have  been allowed  for  a long  time,  providing
support for national  character sets, of which iso-latin-1  (ISO 8859-1)
is applicable to many Western languages.

ISO Prolog introduces three types, two of which  are used for characters
and one for accessing binary streams (see open/4).  These types are:

  o _c_o_d_e
    A  _c_h_a_r_a_c_t_e_r _c_o_d_e  is an  integer representing  a single  character.
    As  files  may  use  multi-byte encoding  for  supporting  different
    character  sets (utf-8 encoding for example), reading a code  from a
    text file is in general not the same as reading a byte.

  o _c_h_a_r
    Alternatively,   characters  may  be  represented  as  _o_n_e_-_c_h_a_r_a_c_t_e_r
    _a_t_o_m_s.   This is a natural representation, hiding  encoding problems
    from the programmer as well as providing much easier debugging.

  o _b_y_t_e
    Bytes are used for accessing binary streams.

In  SWI-Prolog, character  codes are  _a_l_w_a_y_s the  Unicode equivalent  of
the encoding.   That is,  if get_code/1 reads from  a stream encoded  as
KOI8-R (used  for the Cyrillic alphabet),  it returns the  corresponding
Unicode  code points.    Similarly,  assembling or  disassembling  atoms
using  atom_codes/2  interprets the  codes  as  Unicode  points.     See
section 2.18.1 for details.

To ease the pain  of the two character representations (code  and char),
SWI-Prolog's built-in  predicates dealing  with character  data work  as
flexible as  possible:   they accept  data in  any of  these formats  as
long as  the interpretation  is unambiguous.   In  addition, for  output
arguments  that are  instantiated,  the  character is  extracted  before
unification.  This  implies that the following two calls  are identical,
both testing whether the next input character is an a.

________________________________________________________________________|                                                                        |

|peek_code(Stream, a).                                                   |
|peek_code(Stream,|97)._________________________________________________ |                 |

The  two character  representations are  handled by  a  large number  of
built-in predicates,  all of which are  ISO-compatible.  For  converting
between  code  and  character  there  is  char_code/2.     For  breaking
atoms and numbers into  characters there are atom_chars/2, atom_codes/2,
number_chars/2 and number_codes/2.   For character I/O on streams  there
are  get_char/[1,2],  get_code/[1,2],  get_byte/[1,2],  peek_char/[1,2],
peek_code/[1,2],  peek_byte/[1,2],  put_code/[1,2],  put_char/[1,2]  and
put_byte/[1,2].  The Prolog flag double_quotes controls how text between
double quotes is interpreted.


44..33 LLooaaddiinngg PPrroolloogg ssoouurrccee ffiilleess

This section deals  with loading Prolog source  files.  A Prolog  source
file is a plain  text file containing a Prolog program or  part thereof.
Prolog source files come in three flavours:

 AA ttrraaddiittiioonnaall   Prolog  source   file  contains   Prolog  clauses   and
    directives,  but no  _m_o_d_u_l_e _d_e_c_l_a_r_a_t_i_o_n  (see module/1).   They  are
    normally  loaded using consult/1  or ensure_loaded/1.  Currently,  a
    non-module file can only be loaded into a single module.

 AA mmoodduullee   Prolog source file  starts with a module  declaration.   The
    subsequent  Prolog code  is loaded  into the  specified module,  and
    only  the  _e_x_p_o_r_t_e_d predicates  are made  available  to the  context
    loading  the  module.     Module  files  are  normally  loaded  with
    use_module/[1,2].  See chapter 6 for details.

 AAnn iinncclluuddee   Prolog  source  file   is  loaded   using  the   include/1
    directive,  textually  including  Prolog  text into  another  Prolog
    source.   A file may be  included into multiple source files  and is
    typically  used to share _d_e_c_l_a_r_a_t_i_o_n_s  such as multifile or  dynamic
    between source files.

Prolog  source files  are  located using  absolute_file_name/3 with  the
following options:

________________________________________________________________________|                                                                        |

|locate_prolog_file(Spec, Path) :-                                       |
|        absolute_file_name(Spec,                                        |
|                           [ file_type(prolog),                         |
|                             access(read)                               |
|                           ],                                           |

||__________________________Path).______________________________________ ||

The file_type(_p_r_o_l_o_g) option is  used to determine the extension of  the
file using  prolog_file_type/2.    The default extension  is .pl.    _S_p_e_c
allows  for the  _p_a_t_h _a_l_i_a_s  construct defined  by absolute_file_name/3.
The most commonly used path alias is library(_L_i_b_r_a_r_y_F_i_l_e).   The example
below  loads the  library  file  ordsets.pl (containing  predicates  for
manipulating ordered sets).

________________________________________________________________________|                                                                        |
|:-|use_module(library(ordsets))._______________________________________ |  |

SWI-Prolog   recognises    grammar   rules    (DCG)   as   defined    in
[Clocksin & Melish, 1987].     The  user  may   define  additional  com-
pilation  of  the   source  file  by  defining  the  dynamic   multifile
predicates  term_expansion/2,  term_expansion/4,   goal_expansion/2  and
goal_expansion/4.    It  is  not  allowed  to  use  assert/1,  retract/1
or  any other  database  predicate in  term_expansion/2 other  than  for
local computational  purposes.   Code  that needs  to create  additional
clauses must  use compile_aux_clauses/1.   See  library(apply_macros)  for
an example.

A _d_i_r_e_c_t_i_v_e  is an  instruction to the  compiler.   Directives are  used
to  set  (predicate) properties  (see  section  4.14),  set  flags  (see
set_prolog_flag/2)  and load files (this section).  Directives  are terms
of the form :- <_t_e_r_m>..  Here are some examples:

________________________________________________________________________|                                                                        |
|:- use_module(library(lists)).                                          |
|:- dynamic                                                              |

||_______store/2.________________%_Name,_Value__________________________ ||

The  directive initialization/1  can  be used  to run  arbitrary  Prolog
goals.   The specified goal is started  _a_f_t_e_r loading the file in  which
it appears has completed.

SWI-Prolog compiles  code as it  is read from  the file, and  directives
are  executed as  _g_o_a_l_s.   This  implies that  directives  may call  any
predicate that  has been defined  before the  point where the  directive
appears.  It also accepts ?- <_t_e_r_m>.as a synonym.

SWI-Prolog   does   not   have   a   separate   reconsult/1   predicate.
Reconsulting  is  implied automatically  by  the  fact that  a  file  is
consulted which is already loaded.

Advanced topics are handled in subsequent sections:   mutually dependent
files  (section 4.3.2.1),  multithreaded loading  (section 4.3.2.2)  and
reloading running code (section 4.3.2.3).

The core  of the  family of  loading predicates  is load_files/2.    The
predicates  consult/1, ensure_loaded/1,  use_module/1, use_module/2  and
reexport/1  pass the  file argument  directly to  load_files/2 and  pass
additional options as expressed in the table 4.1:
         _______________________________________________________PPrreeddiiccaatteeiiffmmuusstt__bbee__mmoodduulleeiimmppoorrtt

         ______________________________________________________________________________________________________________consult/1truefalseall
          ensure_loaded/1 not_loaded      false         all

          use_module/1    not_loaded       true         all
          use_module/2    not_loaded       true      specified
          reexport/1      not_loaded       true         all
         _reexport/2______not_loaded_______true______specified__

Table  4.1:   Properties of  the file-loading  predicates.   The  _i_m_p_o_r_t
column specifies what is imported if the loaded file is a module file.


llooaadd__ffiilleess((_:_F_i_l_e_s))
    Equivalent  to  load_files(_F_i_l_e_s_,  _[_]).    Same  as  consult/1,  See
    load_files/2 for supported options.


llooaadd__ffiilleess((_:_F_i_l_e_s_, _+_O_p_t_i_o_n_s))
    The  predicate load_files/2 is the parent  of all the other  loading
    predicates  except for include/1.   It  currently supports a  subset
    of  the options of Quintus load_files/2.   _F_i_l_e_s is either a  single
    source  file or a  list of source  files.   The specification for  a
    source  file is handed to absolute_file_name/2.  See  this predicate
    for  the supported expansions.   _O_p_t_i_o_n_s is a list of options  using
    the format _O_p_t_i_o_n_N_a_m_e(_O_p_t_i_o_n_V_a_l_u_e).

    The following options are currently supported:

    aauuttoollooaadd((_B_o_o_l))
         If true (default  false), indicate that  this load is a  _d_e_m_a_n_d
         load.   This  implies that,  depending  on the  setting of  the
         Prolog flag  verbose_autoload, the  load action  is printed  at
         level informational  or silent.   See also  print_message/2 and
         current_prolog_flag/2.

    ddeerriivveedd__ffrroomm((_F_i_l_e))
         Indicate that the  loaded file is derived  from _F_i_l_e.  Used  by
         make/0 to  time-check and  load the original  file rather  than
         the derived file.

    ddiiaalleecctt((_+_D_i_a_l_e_c_t))
         Load _F_i_l_e_s with  enhanced compatibility with the target  Prolog
         system  identified  by  _D_i_a_l_e_c_t.    See  expects_dialect/1  and
         section 14 for details.

    eennccooddiinngg((_E_n_c_o_d_i_n_g))
         Specify the way  characters are encoded in  the file.   Default
         is taken  from the Prolog  flag encoding.   See section  2.18.1
         for details.

    eexxppaanndd((_B_o_o_l))
         If true, run the  filenames through expand_file_name/2 and load
         the returned  files.   Default is false,  except for  consult/1
         which is intended  for interactive use.   Flexible location  of
         files is defined by file_search_path/2.

    ffoorrmmaatt((_+_F_o_r_m_a_t))
         Used to  specify  the file  format  if data  is loaded  from  a
         stream using  the stream(_S_t_r_e_a_m)  option.   Default is  source,
         loading  Prolog source  text.    If  qlf,  load QLF  data  (see
         qcompile/1).

    iiff((_C_o_n_d_i_t_i_o_n))
         Load the  file only  if the specified  condition is  satisfied.
         The value  true loads the  file unconditionally, changed  loads
         the file  if it  was  not loaded  before or  has been  modified
         since it  was loaded the  last time,  and not_loaded loads  the
         file if it was not loaded before.

    iimmppoorrttss((_I_m_p_o_r_t))
         Specify what  to import from  the loaded module.   The  default
         for use_module/1  is all.   _I_m_p_o_r_t  is passed  from the  second
         argument  of use_module/2.    Traditionally  it  is a  list  of
         predicate indicators to import.  As part  of the SWI-Prolog/YAP
         integration,  we  also  support  _P_r_e_d  as   _N_a_m_e  to  import  a
         predicate under another name.  Finally, _I_m_p_o_r_t can  be the term
         except(_E_x_c_e_p_t_i_o_n_s),  where _E_x_c_e_p_t_i_o_n_s  is a  list of  predicate
         indicators that  specify predicates  that are  _n_o_t imported  or
         _P_r_e_d as  _N_a_m_e terms  to denote renamed  predicates.   See  also
         reexport/2 and use_module/2.

         If _I_m_p_o_r_t  equals  all,  all operators  are imported  as  well.
         Otherwise,  operators  are _n_o_t  imported.    Operators  can  be
         imported selectively by adding terms op(_P_r_i_,_A_s_s_o_c_,_N_a_m_e)  to the
         _I_m_p_o_r_t list.    If such  a term  is  encountered, all  exported
         operators that unify with  this term are imported.   Typically,
         this  construct will  be used  with  all arguments  unbound  to
         import  all operators  or  with only  _N_a_m_e  bound to  import  a
         particular operator.

    mmooddiiffiieedd((_T_i_m_e_S_t_a_m_p))
         Claim that the source was loaded at  _T_i_m_e_S_t_a_m_p without checking
         the source.  This  option is intended to be used  together with
         the  stream(_I_n_p_u_t) option,  for  example after  extracting  the
         time from an HTTP server or database.

    mmoodduullee((_+_M_o_d_u_l_e))
         Load the indicated file  into the given module, overruling  the
         module name  specified in  the :- module(Name, ...)  directive.
         This currently  serves two  purposes:   (1)  allow loading  two
         module  files  that specify  the  same  module  into  the  same
         process and  force and  (2):  force  loading source  code in  a
         specific module,  even  if  the code  provides its  own  module
         name.  Experimental.

    mmuusstt__bbee__mmoodduullee((_B_o_o_l))
         If true,  raise an  error if  the file  is not  a module  file.
         Used by use_module/[1,2].

    qqccoommppiillee((_A_t_o_m))
         How to  deal  with quick-load-file  compilation by  qcompile/1.
         Values are:

         nneevveerr
             Default.  Do not use qcompile unless called explicitly.

         aauuttoo
             Use qcompile for all writeable files.  See comment below.

         llaarrggee
             Use  qcompile if  the file is  `large'.   Currently,  files
             larger than 100 Kbytes are considered large.

         ppaarrtt
             If this  load_file/2 appears in a directive of a  file that
             is  compiled into Quick Load  Format using qcompile/1,  the
             contents  of the argument  files are  included in the  .qlf
             file instead of the loading directive.

         If this option is not present, it uses the value  of the Prolog
         flag qcompile as default.

    rreeddeeffiinnee__mmoodduullee((_+_A_c_t_i_o_n))
         Defines what to do if  a file is loaded that provides  a module
         that is  already loaded from another  file.   _A_c_t_i_o_n is one  of
         false (default), which prints an error and refuses  to load the
         file, or  true, which  uses unload_file/1 on  the old file  and
         then proceeds  loading the new  file.   Finally, there is  ask,
         which starts interaction with  the user.  ask is  only provided
         if the stream user_input is associated with a terminal.

    rreeeexxppoorrtt((_B_o_o_l))
         If true re-export the  imported predicate.  Used  by reexport/1
         and reexport/2.

    rreeggiisstteerr((_B_o_o_l))
         If false, do not register the load location and options.   This
         option is used by make/0 and load_hotfixes/1 to avoid polluting
         the load-context database.  See source_file_property/2.

    ssaannddbbooxxeedd((_B_o_o_l))
         Load the  file in  _s_a_n_d_b_o_x_e_d mode.   This  option controls  the
         flag sandboxed_load.   The  only meaningful value  for _B_o_o_l  is
         true.  Using false while the Prolog flag is set  to true raises
         a permission error.

    ssccooppee__sseettttiinnggss((_B_o_o_l))
         Scope style_check/1 and expects_dialect/1to  the file and files
         loaded from  the file after  the directive.   Default is  true.
         The system and  user initialization files  (see -f and -F)  are
         loading with scope_settings(_f_a_l_s_e).

    ssiilleenntt((_B_o_o_l))
         If  true, load  the  file  without printing  a  message.    The
         specified  value is  the  default for  all  files loaded  as  a
         result of loading the specified files.  This  option writes the
         Prolog flag verbose_load with the negation of _B_o_o_l.

    ssttrreeaamm((_I_n_p_u_t))
         This SWI-Prolog  extension compiles  the data  from the  stream
         _I_n_p_u_t.   If this option  is used, _F_i_l_e_s  must be a single  atom
         which is  used to identify  the source  location of the  loaded
         clauses  as well  as  to remove  all  clauses  if the  data  is
         reconsulted.

         This  option  is   added  to  allow  compiling  from   non-file
         locations such as databases, the web, the  _u_s_e_r (see consult/1)
         or other servers.  It can be combined with  format(_q_l_f) to load
         QLF data from a stream.

    The  load_files/2 predicate  can be  hooked to  load  other data  or
    data  from objects  other than  files.   See  prolog_load_file/2 for
    a  description and  http/http_load  for an  example.   All hooks  for
    load_files/2 are documented in section 13.8.


ccoonnssuulltt((_:_F_i_l_e))
    Read  _F_i_l_e  as  a  Prolog source  file.    Calls  to  consult/1  may
    be  abbreviated by  just typing  a number  of filenames  in a  list.
    Examples:

            ?- consult(load).     % consult load or load.pl
            ?- [library(lists)].  % load library lists
            ?- [user].            % Type program on the terminal

    The  predicate  consult/1  is  equivalent  to  load_files(File, []),
    except for handling  the special file user, which reads clauses from
    the  terminal.  See  also the stream(_I_n_p_u_t) option  of load_files/2.
    Abbreviation  using ?- [file1,file2].  does _n_o_t work  for the  empty
    list  ([]).    This facility  is implemented  by  defining the  list
    as  a predicate.    Applications  may only  rely on  using the  list
    abbreviation at the Prolog toplevel and in directives.


eennssuurree__llooaaddeedd((_:_F_i_l_e))
    If the file  is not already loaded, this is equivalent to consult/1.
    Otherwise,   if  the  file  defines  a  module,  import  all  public
    predicates.    Finally,  if the  file is  already loaded,  is not  a
    module  file, and the context module is not the global  user module,
    ensure_loaded/1 will call consult/1.

    With  this  semantics,  we  hope to  get  as close  as  possible  to
    the  clear  semantics  without  the presence  of  a  module  system.
    Applications using modules should consider using use_module/[1,2].

    Equivalent to load_files(Files, [if(not_loaded)]).


iinncclluuddee((_+_F_i_l_e))                                                    _[_I_S_O_]
    Textually  include the  content of  _F_i_l_e in  the file  in which  the
    _d_i_r_e_c_t_i_v_e :- include(File). appears.   The include construct is only
    honoured  if it appears as  a directive in a  source file.   _T_e_x_t_u_a_l
    include (similar to  C/C++ #include) is obviously useful for sharing
    declarations  such as dynamic/1 or  multifile/1 by including a  file
    with directives from multiple files that use these predicates.

    Textual  including  files  that  contain clauses  is  less  obvious.
    Normally,  in SWI-Prolog,  clauses are  _o_w_n_e_d by the  file in  which
    they  are defined.    This information is  used to  _r_e_p_l_a_c_e the  old
    definition  after  the  file  has beeen  modified  and  is  reloaded
    by,  e.g.,  make/0.   As  we understand  it,  include/1 is  intended
    to  include  the  same  file  multiple times.     Including  a  file
    holding  clauses  multiple  times into  the  same module  is  rather
    meaningless  as it just  duplicates the same  clauses.  Including  a
    file  holding clauses in multiple modules does not suffer  from this
    problem,  but  leads to  multiple equivalent  _c_o_p_i_e_s of  predicates.
    Using  use_module/1 can achieve  the same  result while _s_h_a_r_i_n_g  the
    predicates.

    Despite  these  observations,  various  projects seem  to  be  using
    include/1  to load  files holding  clauses,  typically loading  them
    only once.   Such usage would allow replacement by, e.g., consult/1.
    Unfortunately,   the same  project  might  use  include/1  to  share
    directives.     Another  example  of  a  limitation  of  mapping  to
    consult/1  is that  if the  clauses of a  predicate are  distributed
    over  two  included  files, discontiguous/1  is  appropriate,  while
    if  they are  distributed over  two  consulted files,  one must  use
    multifile/1.

    To   accommodate   included  files   holding   clauses,   SWI-Prolog
    distinguishes  between  the source  location of  a  clause (in  this
    case  the included file)  and the _o_w_n_e_r of  a clause (the file  that
    includes  the file  holding the  clause).   The  source location  is
    used  by,  e.g.,  edit/1,  the  graphical tracer,  etc.,  while  the
    owner  is used to  determine which clauses  are removed if the  file
    is  modified.    Relevant information  is found  with the  following
    predicates:

      o  source_file/2 describes the owner relation.

      o  predicate_property/2 describes  the  source  location  (of  the
         first clause).

      o  clause_property/2 provides access to both source and ownership.

      o  source_file_property/2 can be used  to query include  relation-
         ships between files.


rreeqquuiirree((_+_L_i_s_t_O_f_N_a_m_e_A_n_d_A_r_i_t_y))
    Declare  that  this file/module  requires the  specified  predicates
    to  be defined ``with  their commonly accepted  definition''.   This
    predicate  originates from  the Prolog portability  layer for  XPCE.
    It  is intended to provide a portable mechanism for  specifying that
    this module requires the specified predicates.

    The implementation normally  first verifies whether the predicate is
    already defined.   If not, it will search the libraries and load the
    required library.

    SWI-Prolog, having autoloading,  does nnoott load the library.  Instead
    it  creates a  procedure header  for the  predicate if  it does  not
    exist.    This will flag  the predicate  as `undefined'.   See  also
    check/0 and autoload/0.


eennccooddiinngg((_+_E_n_c_o_d_i_n_g))
    This  directive can appear anywhere in  a source file to define  how
    characters  are  encoded in  the remainder  of  the file.    It  can
    be  used in  files that  are encoded  with a  superset of  US-ASCII,
    currently UTF-8 and ISO Latin-1.  See also section 2.18.1.


mmaakkee
    Consult  all source  files that  have been changed  since they  were
    consulted.   It checks _a_l_l  loaded source files:  files loaded  into
    a  compiled state using pl -c ...  and files loaded using  consult/1
    or  one  of  its  derivatives.    The  predicate  make/0  is  called
    after  edit/1, automatically reloading all  modified files.  If  the
    user  uses an  external editor  (in  a separate  window), make/0  is
    normally  used to update  the program after  editing.  In  addition,
    make/0  updates the  autoload indices  (see section  2.13) and  runs
    list_undefined/0  from  the check  library  to report  on  undefined
    predicates.


lliibbrraarryy__ddiirreeccttoorryy((_?_A_t_o_m))
    Dynamic  predicate used  to specify  library directories.    Default
    ./lib,  ~/lib/prolog and  the system's library  (in this order)  are
    defined.    The user  may add library  directories using  assertz/1,
    asserta/1  or remove system defaults  using retract/1.   Deprecated.
    New code should use file_search_path/2.


ffiillee__sseeaarrcchh__ppaatthh((_+_A_l_i_a_s_, _?_P_a_t_h))
    Dynamic  predicate used to specify `path aliases'.  This  feature is
    best described using an example.  Given the definition:

    ____________________________________________________________________|                                                                    |
    ||file_search_path(demo,_'/usr/lib/prolog/demo').___________________ ||

    the  file specification demo(myfile)  will be expanded to  /usr/lib/
    prolog/demo/myfile.   The second  argument of file_search_path/2 may
    be another alias.

    Below  is the  initial definition  of the file  search path.    This
    path  implies swi(<_P_a_t_h>) and  refers to  a file  in the  SWI-Prolog
    home   directory.     The  alias  foreign(<_P_a_t_h>) is   intended  for
    storing   shared  libraries  (.so  or   .DLL  files).     See   also
    use_foreign_library/1.

    ____________________________________________________________________|                                                                    |

    | user:file_search_path(library, X) :-                               |
    |         library_directory(X).                                      |
    | user:file_search_path(swi, Home) :-                                |
    |         current_prolog_flag(home, Home).                           |
    | user:file_search_path(foreign, swi(ArchLib)) :-                    |
    |         current_prolog_flag(arch, Arch),                           |

    |         atom_concat('lib/', Arch, ArchLib).                        |
    | user:file_search_path(foreign, swi(lib)).                          |
    | user:file_search_path(path, Dir) :-                                |
    |         getenv('PATH', Path),                                      |
    |         (   current_prolog_flag(windows, true)                     |
    |         ->  atomic_list_concat(Dirs, (;), Path)                    |
    |         ;   atomic_list_concat(Dirs, :, Path)                      |
    |         ),                                                         |

    ||________member(Dir,_Dirs).________________________________________ ||

    The  file_search_path/2expansion  is used by all loading  predicates
    as well as by absolute_file_name/[2,3].

    The  Prolog  flag verbose_file_search can  be set  to  true to  help
    debugging Prolog's search for files.


eexxppaanndd__ffiillee__sseeaarrcchh__ppaatthh((_+_S_p_e_c_, _-_P_a_t_h))                            _[_n_o_n_d_e_t_]
    Unifies  _P_a_t_h with all possible expansions of the  filename specifi-
    cation _S_p_e_c.  See also absolute_file_name/3.


pprroolloogg__ffiillee__ttyyppee((_?_E_x_t_e_n_s_i_o_n_, _?_T_y_p_e))
    This  dynamic multifile predicate defined in module  user determines
    the  extensions considered by file_search_path/2.  _E_x_t_e_n_s_i_o_n is  the
    filename  extension without the  leading dot,  and _T_y_p_e denotes  the
    type  as used  by the file_type(_T_y_p_e) option  of file_search_path/2.
    Here is the initial definition of prolog_file_type/2:

    ____________________________________________________________________|                                                                    |
    | user:prolog_file_type(pl,       prolog).                           |

    | user:prolog_file_type(Ext,      prolog) :-                         |
    |         current_prolog_flag(associate, Ext),                       |
    |         Ext \== pl.                                                |
    | user:prolog_file_type(qlf,      qlf).                              |
    | user:prolog_file_type(Ext,      executable) :-                     |
    ||________current_prolog_flag(shared_object_extension,_Ext).________ ||

    Users can add  extensions for Prolog source files to avoid conflicts
    (for  example with perl)  as well as  to be compatible with  another
    Prolog  implementation.      We  suggest  using  .pro  for  avoiding
    conflicts  with perl.   Overriding the  system definitions can  stop
    the system from finding libraries.


ssoouurrccee__ffiillee((_?_F_i_l_e))
    True  if _F_i_l_e is a loaded Prolog source file.  _F_i_l_e  is the absolute
    and canonical path to the source file.


ssoouurrccee__ffiillee((_:_P_r_e_d_, _?_F_i_l_e))
    True  if the  predicate specified  by _P_r_e_d  is owned  by file  _F_i_l_e,
    where  _F_i_l_e  is an  absolute path  name  (see absolute_file_name/2).
    Can  be used with any  instantiation pattern, but the database  only
    maintains  the  source file  for  each  predicate.    If _P_r_e_d  is  a
    _m_u_l_t_i_f_i_l_e  predicate  this predicate  succeeds  for all  files  that
    contribute  clauses to  _P_r_e_d.   See  also clause_property/2.    Note
    that  the relation between files and predicates is  more complicated
    if  include/1 is used.    The predicate describes  the _o_w_n_e_r of  the
    predicate.  See include/1 for details.


ssoouurrccee__ffiillee__pprrooppeerrttyy((_?_F_i_l_e_, _?_P_r_o_p_e_r_t_y))
    True  when _P_r_o_p_e_r_t_y  is a  property of  the loaded  file _F_i_l_e.    If
    _F_i_l_e  is non-var, it can be  a file specification that is  valid for
    load_files/2.  Defined properties are:

    ddeerriivveedd__ffrroomm((_O_r_i_g_i_n_a_l_, _O_r_i_g_i_n_a_l_M_o_d_i_f_i_e_d))
         _F_i_l_e was  generated  from the  file  _O_r_i_g_i_n_a_l, which  was  last
         modified at time  _O_r_i_g_i_n_a_l_M_o_d_i_f_i_e_d at the  time it was  loaded.
         This  property  is available  if  _F_i_l_e  was  loaded  using  the
         derived_from(_O_r_i_g_i_n_a_l) option to load_files/2.

    iinncclluuddeess((_I_n_c_l_u_d_e_d_F_i_l_e_, _I_n_c_l_u_d_e_d_F_i_l_e_M_o_d_i_f_i_e_d))
         _F_i_l_e  used  include/1  to  include  _I_n_c_l_u_d_e_d_F_i_l_e.     The  last
         modified time of  _I_n_c_l_u_d_e_d_F_i_l_e was _I_n_c_l_u_d_e_d_F_i_l_e_M_o_d_i_f_i_e_d at  the
         time it was included.

    iinncclluuddeedd__iinn((_M_a_s_t_e_r_F_i_l_e_, _L_i_n_e))
         _F_i_l_e was included into _M_a_s_t_e_r_F_i_l_e from line _L_i_n_e.   This is the
         inverse of the includes property.

    llooaadd__ccoonntteexxtt((_M_o_d_u_l_e_, _L_o_c_a_t_i_o_n_, _O_p_t_i_o_n_s))
         _M_o_d_u_l_e is the module into  which the file was loaded.   If _F_i_l_e
         is a  module, this  is the  module into which  the exports  are
         imported.   Otherwise it is the  module into which the  clauses
         of the  non-module file  are loaded.    _L_o_c_a_t_i_o_n describes  the
         file location  from which the file  was loaded.   It is  either
         a term  <_f_i_l_e>:<_l_i_n_e> or the  atom user if  the file  was loaded
         from the terminal or  another unknown source.  _O_p_t_i_o_n_s  are the
         options  passed to  load_files/2.    Note that  all  predicates
         to load  files  are mapped  to load_files/2,  using the  option
         argument to specify the exact behaviour.

    mmooddiiffiieedd((_S_t_a_m_p))
         File modification time when _F_i_l_e  was loaded.  This is  used by
         make/0 to find files whose modification time  is different from
         when it was loaded.

    mmoodduullee((_M_o_d_u_l_e))
         _F_i_l_e is a module file that declares the module _M_o_d_u_l_e.


uunnllooaadd__ffiillee((_+_F_i_l_e))
    Remove  all clauses  loaded from  _F_i_l_e.   If _F_i_l_e  loaded a  module,
    clear  the module's export list  and disassociate it from the  file.
    _F_i_l_e  is a canonical filename or a file indicator that is  valid for
    load_files/2.

    This  predicate should be used with care.  The  multithreaded nature
    of  SWI-Prolog makes removing  static code unsafe.   Attempts to  do
    this  should be  reserved for  development or  situations where  the
    application  can guarantee  that none of  the clauses associated  to
    _F_i_l_e are active.


pprroolloogg__llooaadd__ccoonntteexxtt((_?_K_e_y_, _?_V_a_l_u_e))
    Obtain  context  information during  compilation.    This  predicate
    can  be  used   from  directives  appearing  in  a  source  file  to
    get   information  about  the   file  being  loaded.      See   also
    source_location/2 and if/1.  The following keys are defined:

    ______________________________________________________________________
    |__KKeeyy________________________||DDeessccrriippttiioonn________________________________________________________________________________||__
    || module         |Module into which file is loaded                   |
    | source         |File being  loaded.  If the system is processing an|
    |                |included file, the value is the _m_a_i_n file.  Returns|

    |                |the original Prolog file when loading a .qlf file. |
    | file           |Similar  to  source,  but  returns  the  file being|
    |                |included when called while an include file is being|
    |                |processed                                          |
    | stream         |Stream identifier (see current_input/1)            |
    | directory      |Directory in which source lives                    |
    | dialect        |Compatibility mode.  See expects_dialect/1.        |

    | term_position  |Start   position   of  last   term  read.       See|
    |                |also   stream_property/2  (position   property  and|
    |                |stream_position_data/3.                            |
    | variable_names |A list of  `_N_a_m_e = _V_a_r' of the last term read.  See|
    |                |read_term/2for details.                            |
    | script         |Boolean  that indicates whether the  file is loaded|
    |________________|as_a_script_file_(see_-s)__________________________|_

    The  directory is commonly used to  add rules to file_search_path/2,
    setting    up   a    search    path   for    finding   files    with
    absolute_file_name/3.  For example:

    ____________________________________________________________________|                                                                    |
    | :- dynamic user:file_search_path/2.                                |
    | :- multifile user:file_search_path/2.                              |
    |                                                                    |

    | :- prolog_load_context(directory, Dir),                            |
    |    asserta(user:file_search_path(my_program_home, Dir)).           |
    |                                                                    |
    |     ...                                                            |
    |     absolute_file_name(my_program_home('README.TXT'), ReadMe,      |
    |                        [ access(read) ]),                          |
    ||____...___________________________________________________________ ||


ssoouurrccee__llooccaattiioonn((_-_F_i_l_e_, _-_L_i_n_e))
    If the last term  has been read from a physical file (i.e., not from
    the file user or  a string), unify _F_i_l_e with an absolute path to the
    file  and _L_i_n_e with the  line number in the  file.  New code  should
    use prolog_load_context/2.


aatt__hhaalltt((_:_G_o_a_l))
    Register  _G_o_a_l to  be run  from PL_cleanup(), which  is called  when
    the  system  halts.     The  hooks are  run  in  the  reverse  order
    they  were registered  (FIFO). Success or  failure executing a  hook
    is  ignored.    If the  hook  raises an  exception this  is  printed
    using  print_message/2.   An attempt  to call halt/[0,1] from a  hook
    is  ignored.    Hooks  may call  cancel_halt/1, causing  halt/0  and
    PL_halt(_0)  to print a  message indicating  that halting the  system
    has been cancelled.


ccaanncceell__hhaalltt((_+_R_e_a_s_o_n))
    If  this predicate is called from a  hook registered with at_halt/1,
    halting Prolog is  cancelled and an informational message is printed
    that  includes _R_e_a_s_o_n.   This  is used by  the development tools  to
    cancel  halting the system  if the editor  has unsafed data and  the
    user decides to cancel.


::-- iinniittiiaalliizzaattiioonn((_:_G_o_a_l))                                          _[_I_S_O_]
    Call  _G_o_a_l _a_f_t_e_r  loading the  source file in  which this  directive
    appears  has been completed.    In addition, _G_o_a_l  is executed if  a
    saved state created using qsave_program/1 is restored.

    The  ISO  standard  only allows  for  using  :- Term if  _T_e_r_m  is  a
    _d_i_r_e_c_t_i_v_e.  This  means that arbitrary goals can only be called from
    a directive by  means of the initialization/1 directive.  SWI-Prolog
    does not enforce this rule.

    The   initialization/1  directive  must   be  used  to  do   program
    initialization  in  saved states  (see  qsave_program/1).    A  saved
    state  contains the predicates,  Prolog flags and operators  present
    at  the moment  the state was  created.   Other resources  (records,
    foreign  resources, etc.)  must be recreated  using initialization/1
    directives or from the entry goal of the saved state.

    Up  to SWI-Prolog 5.7.11, _G_o_a_l was executed immediately  rather than
    after  loading  the  program text  in  which the  directive  appears
    as  dictated  by  the  ISO  standard.    In  many  cases  the  exact
    moment  of  execution  is  irrelevant,  but  there  are  exceptions.
    For  example,  load_foreign_library/1 must be  executed  immediately
    to  make  the loaded  foreign  predicates available  for  exporting.
    SWI-Prolog  now  provides  the  directive  use_foreign_library/1  to
    ensure  immediate  loading   as  well  as  loading  after  restoring
    a   saved  state.       If   the  system   encounters  a   directive
    :- initialization(load_foreign_library(...)),   it  will  load   the
    foreign  library  immediately and  issue a  warning  to update  your
    code.    This behaviour  can be  extended by  providing clauses  for
    the  multifile hook  predicate prolog:initialize_now(_T_e_r_m_,  _A_d_v_i_c_e),
    where  _A_d_v_i_c_e is an  atom that  gives advice on  how to resolve  the
    compatibility issue.


iinniittiiaalliizzaattiioonn((_:_G_o_a_l_, _+_W_h_e_n))
    Similar to initialization/1,  but allows for specifying when _G_o_a_l is
    executed while loading the program text:

    nnooww
         Execute _G_o_a_l immediately.

    aafftteerr__llooaadd
         Execute _G_o_a_l after loading program  text.  This is the  same as
         initialization/1.

    rreessttoorree
         Do not execute  _G_o_a_l while loading  the program, but _o_n_l_y  when
         restoring a state.


ccoommppiilliinngg
    True  if the system is compiling source files with the -c  option or
    qcompile/1  into an intermediate code file.  Can be used  to perform
    conditional code  optimisations in term_expansion/2(see  also the -O
    option) or to omit execution of directives during compilation.


44..33..11 CCoonnddiittiioonnaall ccoommppiillaattiioonn aanndd pprrooggrraamm ttrraannssffoorrmmaattiioonn

ISO  Prolog  defines   no  way  for  program  transformations  such   as
macro  expansion  or   conditional  compilation.     Expansion   through
term_expansion/2 and expand_term/2 can be  seen as part of the  de-facto
standard.   This mechanism  can do  arbitrary translation between  valid
Prolog terms  read from the  source file to Prolog  terms handed to  the
compiler.   As  term_expansion/2 can return a  list, the  transformation
does not need to be term-to-term.

Various  Prolog  dialects  provide the  analogous  goal_expansion/2  and
expand_goal/2 that  allow  for  translation of  individual  body  terms,
freeing the user of the task to disassemble each clause.


tteerrmm__eexxppaannssiioonn((_+_T_e_r_m_1_, _-_T_e_r_m_2))
    Dynamic  and  multifile  predicate,  normally  not defined.     When
    defined  by the user all terms  read during consulting are given  to
    this predicate.   If the predicate succeeds Prolog will assert _T_e_r_m_2
    in  the database rather than the read term (_T_e_r_m_1).  _T_e_r_m_2  may be a
    term  of the form ?- Goal.  or :- Goal.   _G_o_a_l is then treated as  a
    directive.   If _T_e_r_m_2  is a list, all  terms of the list are  stored
    in  the database or  called (for directives).   If  _T_e_r_m_2 is of  the
    form  below, the system will assert _C_l_a_u_s_e and record  the indicated
    source location with it:

         '$source_location'(<_F_i_l_e>, <_L_i_n_e>):<_C_l_a_u_s_e>

    When compiling a  module (see chapter 6 and the directive module/2),
    expand_term/2  will first try  term_expansion/2 in the module  being
    compiled  to  allow  for term  expansion  rules  that are  local  to
    a  module.     If  there  is  no  local  definition,  or  the  local
    definition  fails  to translate  the  term,  expand_term/2 will  try
    term_expansion/2  in module user.    For compatibility with  SICStus
    and  Quintus Prolog,  this feature  should not  be used.   See  also
    expand_term/2, goal_expansion/2 and expand_goal/2.


eexxppaanndd__tteerrmm((_+_T_e_r_m_1_, _-_T_e_r_m_2))
    This  predicate is  normally called  by the compiler  on terms  read
    from  the  input to  perform preprocessing.    It  consists of  four
    steps, where each step processes the output of the previous step.

     1.  Test  conditional  compilation  directives  and  translate  all
         input to []  if we are in  a `false branch' of the  conditional
         compilation.  See section 4.3.1.2.

     2.  Call term_expansion/2.   This predicate is  first tried in  the
         module that is being compiled and then in the module user.

     3.  Call DCG expansion (dcg_translate_rule/2).

     4.  Call expand_goal/2 on each body term that appears in the output
         of the previous steps.


ggooaall__eexxppaannssiioonn((_+_G_o_a_l_1_, _-_G_o_a_l_2))
    Like  term_expansion/2,  goal_expansion/2  provides  for  macro  ex-
    pansion  of  Prolog source  code.    Between  expand_term/2 and  the
    actual  compilation, the body of clauses analysed and the  goals are
    handed  to expand_goal/2, which  uses the goal_expansion/2 hook to do
    user-defined expansion.

    The  predicate goal_expansion/2 is first  called in the module  that
    is  being compiled, and then on the user module.  If _G_o_a_l  is of the
    form  _M_o_d_u_l_e:_G_o_a_l where _M_o_d_u_l_e is instantiated,  goal_expansion/2 is
    called on _G_o_a_l using rules from module _M_o_d_u_l_e followed by user.

    Only  goals  appearing  in  the  body  of  clauses  when  reading  a
    source  file are  expanded using  this mechanism, and  only if  they
    appear  literally in  the clause,  or as  an argument  to a  defined
    meta-predicate  that is annotated using  `0' (see meta_predicate/1).
    Other cases need a real predicate definition.


eexxppaanndd__ggooaall((_+_G_o_a_l_1_, _-_G_o_a_l_2))
    This  predicate  is  normally  called by  the  compiler  to  perform
    preprocessing  using  goal_expansion/2.    The  predicate computes  a
    fixed-point  by applying  transformations  until there  are no  more
    changes.     If  optimisation  is enabled  (see  -O  and  optimise),
    expand_goal/2 simplifies  the result by  removing unneeded calls  to
    true/0 and fail/0 as well as unreachable branches.


ccoommppiillee__aauuxx__ccllaauusseess((_+_C_l_a_u_s_e_s))
    Compile  clauses  on behalf  of  goal_expansion/2.    This  predicate
    compiles  the argument clauses  into static predicates,  associating
    the predicates with  the current file but avoids changing the notion
    of current predicate and therefore discontiguous warnings.


ddccgg__ttrraannssllaattee__rruullee((_+_I_n_, _-_O_u_t))
    This  predicate performs the translation of a term  Head-->Body into
    a  normal Prolog  clause.    Normally this  functionality should  be
    accessed using expand_term/2.


vvaarr__pprrooppeerrttyy((_+_V_a_r_, _?_P_r_o_p_e_r_t_y))
    True  when _P_r_o_p_e_r_t_y  is a  property of _V_a_r.    These properties  are
    available  during goal- and term-expansion.  Defined  properties are
    below.    Future  versions are  likely to  provide more  properties,
    such  as  whether  the  variable  is  a  singleton  or  whether  the
    variable  is referenced  in the  remainder of the  term.   See  also
    goal_expansion/2.

    ffrreesshh((_B_o_o_l))
         Bool has  the value _t_r_u_e  if the variable  is guaranteed to  be
         unbound at  entry of the  goal, otherwise  its value is  _f_a_l_s_e.
         This implies that  the variable first  appears in this goal  or
         a previous appearance was  in a negation (\+/1) or  a different
         branch of a disjunction.

    nnaammee((_N_a_m_e))
         True when variable appears with the given name in the source.


44..33..11..11 PPrrooggrraamm ttrraannssffoorrmmaattiioonn wwiitthh ssoouurrccee llaayyoouutt iinnffoo

This sections documents extended versions of  the program transformation
predicates that also transform the source layout information.   Extended
layout information is currently processed, but unused.   Future versions
will use for the following enhancements:

  o More precise locations of warnings and errors

  o More reliable setting of breakpoints

  o More reliable source layout information in the graphical debugger.


eexxppaanndd__ggooaall((_+_G_o_a_l_1_, _?_L_a_y_o_u_t_1_, _-_G_o_a_l_2_, _-_L_a_y_o_u_t_2))


ggooaall__eexxppaannssiioonn((_+_G_o_a_l_1_, _?_L_a_y_o_u_t_1_, _-_G_o_a_l_2_, _-_L_a_y_o_u_t_2))


eexxppaanndd__tteerrmm((_+_T_e_r_m_1_, _?_L_a_y_o_u_t_1_, _-_T_e_r_m_2_, _-_L_a_y_o_u_t_2))


tteerrmm__eexxppaannssiioonn((_+_T_e_r_m_1_, _?_L_a_y_o_u_t_1_, _-_T_e_r_m_2_, _-_L_a_y_o_u_t_2))


ddccgg__ttrraannssllaattee__rruullee((_+_I_n_, _?_L_a_y_o_u_t_I_n_, _-_O_u_t_, _-_L_a_y_o_u_t_O_u_t))
    These  versions  are called  _b_e_f_o_r_e their  2-argument  counterparts.
    The   input  layout  term  is  either  a  variable  (if   no  layout
    information  is  available)  or  a  term  carrying  detailed  layout
    information as returned by the subterm_positions of read_term/2.


44..33..11..22 CCoonnddiittiioonnaall ccoommppiillaattiioonn

Conditional   compilation    builds   on    the   same   principle    as
term_expansion/2,   goal_expansion/2  and  the   expansion  of   grammar
rules to compile sections of the source code conditionally.   One of the
reasons for introducing  conditional compilation is to simplify  writing
portable code.  See  section 14 for more information.  Here is  a simple
example:

________________________________________________________________________|                                                                        |
|:- if(\+source_exports(library(lists), suffix/2)).                      |

|                                                                        |
|suffix(Suffix, List) :-                                                 |
|        append(_, Suffix, List).                                        |
|                                                                        |
|:-|endif.______________________________________________________________ |  |

Note that  these directives  can only  appear as separate  terms in  the
input.  Typical usage scenarios include:

  o Load different libraries on different dialects.

  o Define a predicate if it is missing as a system predicate.

  o Realise  totally different implementations for a particular  part of
    the code due to different capabilities.

  o Realise different configuration options for your software.


::-- iiff((_:_G_o_a_l))
    Compile  subsequent  code  only if  _G_o_a_l  succeeds.    For  enhanced
    portability,  _G_o_a_l is  processed by expand_goal/2 before  execution.
    If an error  occurs, the error is printed and processing proceeds as
    if _G_o_a_l has failed.


::-- eelliiff((_:_G_o_a_l))
    Equivalent to :- else.  :-if(Goal).  ...  :- endif. In a sequence as
    below,  the section below the first matching elif is processed.   If
    no test succeeds, the else branch is processed.

    ____________________________________________________________________|                                                                    |
    | :- if(test1).                                                      |

    | section_1.                                                         |
    | :- elif(test2).                                                    |
    | section_2.                                                         |
    | :- elif(test3).                                                    |
    | section_3.                                                         |
    | :- else.                                                           |
    | section_else.                                                      |
    ||:-_endif._________________________________________________________ ||


::-- eellssee
    Start `else' branch.


::-- eennddiiff
    End of conditional compilation.


44..33..22 LLooaaddiinngg ffiilleess,, aaccttiivvee ccooddee aanndd tthhrreeaaddss

Traditionally,  Prolog environments  allow for  reloading files  holding
currently  active code.    In particular,  the following  sequence is  a
valid use of the development environment:

  o Trace a goal

  o Find unexpected behaviour of a predicate

  o Enter a _b_r_e_a_k using the bb command

  o Fix the sources and reload them using make/0

  o Exit the break, _r_e_t_r_y using the rr command

Goals running  during the  reload keep  running on  the old  definition,
while new  goals use  the reloaded definition,  which is  why the  _r_e_t_r_y
must be used _a_f_t_e_r the reload.  This implies  that clauses of predicates
that are  active during  the reload  cannot be  reclaimed.   Normally  a
small amount of dead clauses should not be an  issue during development.
Such clauses can be reclaimed with garbage_collect_clauses/0.


ggaarrbbaaggee__ccoolllleecctt__ccllaauusseess
    Clean  up all _d_i_r_t_y predicates,  where dirty predicates are  defined
    to  be predicates  that have  both old  and new  definitions due  to
    reloading  a  source  file while  the  predicate  was active.     Of
    course,  predicates that are  active using garbage_collect_clauses/0
    cannot  be reclaimed and remain _d_i_r_t_y.  Predicates are,  like atoms,
    shared resources and  therefore all threads are suspended during the
    execution of this predicate.


44..33..22..11 CCoommppiillaattiioonn ooff mmuuttuuaallllyy ddeeppeennddeenntt ccooddee

Large  programs are  generally  split into  multiple  files.    If  file
A  accesses  predicates from  file  B  which accesses  predicates  from
file  A,  we  consider  this a  mutual  or  circular  dependency.    If
traditional load predicates  (e.g., consult/1) are used to  include file
B  from A  and  A  from B,  loading  either file  results  in  a loop.
This is  because consult/1  is mapped to  load_files/2 using the  option
if(true)(_.)    Such programs  are  typically loaded  using a  _l_o_a_d  _f_i_l_e
that consults  all required (non-module)  files.   If modules are  used,
the dependencies are  made explicit using use_module/1 statements.   The
use_module/1 predicate,  however, maps to  load_files/2 with the  option
if(not_loaded)(_.)  A use_module/1 on an already loaded file merely makes
the public predicates of the used module available.

Summarizing,  mutual  dependency  of source  files  is  fully  supported
with no  precautions when  using modules.   Modules  can use each  other
in  an arbitrary  dependency graph.    When using  consult/1,  predicate
dependencies  between loaded  files  can  still be  arbitrary,  but  the
consult relations between files must be a proper tree.


44..33..22..22 CCoommppiillaattiioonn wwiitthh mmuullttiippllee tthhrreeaaddss

This  section  discusses compiling  files  for  the  first time.     For
reloading, see section 4.3.2.3.

In older versions, compilation  was thread-safe due to a global  _l_o_c_k in
load_files/2 and the code  dealing with _a_u_t_o_l_o_a_d_i_n_g (see section  2.13).
Besides  unnecessary  stalling  when  multiple  threads  trap  unrelated
undefined  predicates,  this  easily  leads  to  deadlocks,  notably  if
threads are started from an initialization/1 directive.

Starting with  version 5.11.27, the autoloader  is no longer locked  and
multiple threads can compile files concurrently.   This requires special
precautions  only if  multiple threads  wish to  load the  same file  at
the same  time.   Therefore,  load_files/2 checks automatically  whether
some  other thread  is already  loading the  file.   If  not, it  starts
loading the file.   If another thread  is already loading the file,  the
thread blocks until the  other thread finishes loading the file.   After
waiting,  and if the  file is  a module file,  it will  make the  public
predicates available.

Note that this  schema does not prevent deadlocks under  all situations.
Consider two  mutually dependent (see  section 4.3.2.1)  module files A
and B, where  thread 1 starts loading A  and thread 2 starts loading B
at the same  time.  Both threads  will deadlock when trying to load  the
used module.

The current implementation  does not detect such cases and  the involved
threads  will freeze.     This problem  can  be  avoided if  a  mutually
dependent  collection of  files is  always loaded  from  the same  start
file.


44..33..22..33 RReellooaaddiinngg rruunnnniinngg ccooddee

This section discusses _n_o_t _r_e_-loading of code.   Initial loading of code
is discussed in section 4.3.2.2.

As of version 5.5.30, there is basic thread-safety  for reloading source
files while  other threads are  executing code  defined in these  source
files.   Reloading a file freezes  all threads after marking the  active
predicates originating from  the file being reloaded.   The threads  are
resumed after the file  has been loaded.  In addition,  after completing
loading the outermost file, the system runs garbage_collect_clauses/0.

What does that mean?   Unfortunately it does _n_o_t mean we  can `hot-swap'
modules.   Consider the case where thread  A is executing the recursive
predicate P.   We `fix'  P and reload.   The already  running goals for
P  continue to  run the  old definition,  but new  recursive calls  will
use the  new definition!   Many  similar cases  can be constructed  with
dependent predicates.

It provides  some basic  security for reloading  files in  multithreaded
applications during development.  In the above scenario  the system does
not crash  uncontrolled, but behaves  like any broken  program:  it  may
return the wrong bindings, wrong truth value or raise an exception.

Future versions  may have  an `update now'  facility.   Such a  facility
can be implemented  on top of the _l_o_g_i_c_a_l  _u_p_d_a_t_e _v_i_e_w.  It would  allow
threads to do a controlled update between processing independent jobs.


44..33..33 QQuuiicckk llooaadd ffiilleess

SWI-Prolog supports compilation of individual or  multiple Prolog source
files into `Quick Load  Files'.  A `Quick Load File' (.qlf  file) stores
the contents of the file in a precompiled format.

These files load considerably faster than source files  and are normally
more compact.   They are machine-independent  and may thus be loaded  on
any  implementation of  SWI-Prolog.   Note,  however,  that clauses  are
stored as virtual  machine instructions.   Changes to the compiler  will
generally make old compiled files unusable.

Quick Load Files  are created using qcompile/1.   They are loaded  using
consult/1  or one  of  the other  file-loading predicates  described  in
section 4.3.  If  consult/1 is given an explicit .pl file, it  will load
the Prolog  source.   When given  a .qlf  file, it will  load the  file.
When no extension is specified, it will load the  .qlf file when present
and the .pl file otherwise.


qqccoommppiillee((_:_F_i_l_e))
    Takes  a file specification as consult/1, etc., and, in  addition to
    the  normal compilation, creates a _Q_u_i_c_k  _L_o_a_d _F_i_l_e from _F_i_l_e.   The
    file  extension of this  file is .qlf.   The  basename of the  Quick
    Load File is the same as the input file.

    If   the   file  contains   `:- consult(_+_F_i_l_e)',   `:- [_+_F_i_l_e]'   or
    `:- load_files(_+_F_i_l_e, [qcompile(part), ...])'  statements,  the  re-
    ferred  files  are  compiled  into  the  same  .qlf  file.     Other
    directives will be stored  in the .qlf file and executed in the same
    fashion as when loading the .pl file.

    For  term_expansion/2,  the same rules  as described in section  2.10
    apply.

    Conditional  execution   or  optimisation  may  test  the  predicate
    compiling/0.

    Source  references (source_file/2) in the  Quick Load File refer  to
    the Prolog source file from which the compiled code originates.


qqccoommppiillee((_:_F_i_l_e_, _+_O_p_t_i_o_n_s))
    As  qcompile/1,  but  processes  additional options  as  defined  by
    load_files/2.


44..44 EEddiittoorr IInntteerrffaaccee

SWI-Prolog  offers an  extensible  interface which  allows the  user  to
edit objects  of the program:   predicates,  modules, files,  etc.   The
editor interface is  implemented by edit/1 and consists of  three parts:
_l_o_c_a_t_i_n_g, _s_e_l_e_c_t_i_n_g and _s_t_a_r_t_i_n_g the editor.  Any of  these parts may be
customized.  See section 4.4.1.

The built-in  edit specifications for  edit/1 (see prolog_edit:locate/3)
are described in the table below:

   ___________________________________________________________________
   |__________________________________________FFuullllyy__ssppeecciiffiieedd__oobbjjeeccttss____________________________________________||
   || <_M_o_d_u_l_e>:<_N_a_m_e>/<_A_r_i_t_y>R|efers to a predicate                   |
   | module(<_M_o_d_u_l_e>)      |Refers to a module                       |
   | file(<_P_a_t_h>)          |Refers to a file                         |

   |_source_file(<_P_a_t_h>)___R|efers_to_a_loaded_source_file___________|_
   |__________________________________________AAmmbbiigguuoouuss__ssppeecciiffiiccaattiioonnss__________________________________________||
   || <_N_a_m_e>/<_A_r_i_t_y>        R|efers to this predicate in any module   |
   | <_N_a_m_e>                |Refers to (1) the  named predicate in any|
   |                       |module  with any  arity,  (2) a  (source)|
   |_______________________|file,_or_(3)_a_module.___________________|_


eeddiitt((_+_S_p_e_c_i_f_i_c_a_t_i_o_n))
    First,  exploit prolog_edit:locate/3 to translate  _S_p_e_c_i_f_i_c_a_t_i_o_n into
    a  list  of  _L_o_c_a_t_i_o_n_s.    If there  is  more than  one  `hit',  the
    user  is  asked  to select  from  the  locations found.     Finally,
    prolog_edit:edit_source/1  is used  to  invoke the  user's  preferred
    editor.   Typically, edit/1 can  be handed the name of  a predicate,
    module, basename of a file, XPCE class, XPCE method, etc.


eeddiitt
    Edit the `default' file  using edit/1.  The default file is the file
    loaded  with the  command line option  -s or, in  Windows, the  file
    loaded by double-clicking from the Windows shell.


44..44..11 CCuussttoommiizziinngg tthhee eeddiittoorr iinntteerrffaaccee

The predicates described in  this section are _h_o_o_k_s that can  be defined
to  disambiguate  specifications  given  to  edit/1,  find  the  related
source, and open an editor at the given source location.


pprroolloogg__eeddiitt::llooccaattee((_+_S_p_e_c_, _-_F_u_l_l_S_p_e_c_, _-_L_o_c_a_t_i_o_n))
    Where  _S_p_e_c is  the  specification provided  through edit/1.    This
    multifile  predicate is used to enumerate locations where  an object
    satisfying  the given _S_p_e_c can be  found.  _F_u_l_l_S_p_e_c is unified  with
    the  complete specification  for the  object.   This distinction  is
    used  to allow for ambiguous specifications.   For example, if  _S_p_e_c
    is  an atom, which appears as the  basename of a loaded file  and as
    the  name of a  predicate, _F_u_l_l_S_p_e_c will  be bound to file(_P_a_t_h)  or
    _N_a_m_e/_A_r_i_t_y.

    _L_o_c_a_t_i_o_n  is a list of attributes  of the location.  Normally,  this
    list  will contain the term  file(_F_i_l_e) and, if available, the  term
    line(_L_i_n_e).


pprroolloogg__eeddiitt::llooccaattee((_+_S_p_e_c_, _-_L_o_c_a_t_i_o_n))
    Same  as prolog_edit:locate/3,  but only  deals with fully  specified
    objects.


pprroolloogg__eeddiitt::eeddiitt__ssoouurrccee((_+_L_o_c_a_t_i_o_n))
    Start  editor on _L_o_c_a_t_i_o_n.   See prolog_edit:locate/3 for the  format
    of  a  location term.    This multifile  predicate  is normally  not
    defined.  If it succeeds, edit/1 assumes the editor is started.

    If  it fails, edit/1 uses  its internal defaults, which are  defined
    by  the Prolog flag editor  and/or the environment variable  EDITOR.
    The  following  rules apply.     If the  Prolog  flag editor  is  of
    the  format $<_n_a_m_e>,  the  editor is  determined by  the environment
    variable  <_n_a_m_e>.   Else, if this flag  is pce_emacs or built_in _a_n_d
    XPCE  is  loaded or  can  be loaded,  the  built-in Emacs  clone  is
    used.  Else,  if the environment EDITOR is set, this editor is used.
    Finally,  vi  is used  as default  on Unix  systems  and notepad  on
    Windows.

    See  the  default  user  preferences  file  dotfiles/dotswiplrc  for
    examples.


pprroolloogg__eeddiitt::eeddiitt__ccoommmmaanndd((_+_E_d_i_t_o_r_, _-_C_o_m_m_a_n_d))
    Determines  how _E_d_i_t_o_r is  to be invoked using  shell/1.  _E_d_i_t_o_r  is
    the  determined editor  (see edit_source/1), without  the full  path
    specification,  and without  a possible (.exe)  extension.   _C_o_m_m_a_n_d
    is  an atom describing the command.   The following %-sequences  are
    replaced in _C_o_m_m_a_n_d before the result is handed to shell/1:

              ________________________________________________
              | %e |Replaced by the (OS) command name of  the |
              |    |editor                                    |

              | %f |Replaced by the  (OS) full  path name  of |
              |    |the file                                  |
              |_%d_|Replaced_by_the_line_number_______________|

    If  the  editor can  deal with  starting at  a specified  line,  two
    clauses  should be provided.   The first pattern invokes the  editor
    with  a line number, while the second is used if the line  number is
    unknown.

    The  default contains definitions for  vi, emacs, emacsclient,  vim,
    notepad* and  wordpad*.   Starred editors do not provide  starting at
    a given line number.

    Please contribute your specifications to bugs@swi-prolog.org.


pprroolloogg__eeddiitt::llooaadd
    Normally  an  undefined multifile  predicate.    This predicate  may
    be  defined to  provide  loading hooks  for user  extensions to  the
    edit  module.   For example,  XPCE provides the  code below to  load
    swi_edit,  containing definitions to locate  classes and methods  as
    well as to bind this package to the PceEmacs built-in editor.

    ____________________________________________________________________|                                                                    |
    | :- multifile prolog_edit:load/0.                                   |

    |                                                                    |
    | prolog_edit:load :-                                                |
    ||________ensure_loaded(library(swi_edit))._________________________ ||


44..55 LLiisstt tthhee pprrooggrraamm,, pprreeddiiccaatteess oorr ccllaauusseess


lliissttiinngg((_:_P_r_e_d))
    List  predicates specified by  _P_r_e_d.  _P_r_e_d  may be a predicate  name
    (atom),  which lists  all predicates with  this name, regardless  of
    their  arity.  It  can also be a predicate  indicator (<_n_a_m_e>/<_a_r_i_t_y>
    or <_n_a_m_e>//<_a_r_i_t_y>),  possibly qualified with a module.  For example:
    ?- listing(lists:member/2)..

    A  listing is produced by  enumerating the clauses of the  predicate
    using  clause/2  and printing  each  clause using  portray_clause/1.
    This implies that the  variable names are generated (_A, _B, ...)  and
    the layout is defined by rules in portray_clause/1.


lliissttiinngg
    List  all predicates from the calling  module using listing/1.   For
    example,  ?- listing. lists clauses in  the default user module  and
    ?- lists:listing. lists the clauses in the module lists.


ppoorrttrraayy__ccllaauussee((_+_C_l_a_u_s_e))
    Pretty  print a  clause.   A clause  should be specified  as a  term
    `<_H_e_a_d> :- <_B_o_d_y>'.    Facts are  represented as  `<_H_e_a_d> :- true'  or
    simply  <_H_e_a_d>.  Variables  in the clause are written as  A, B, ....
    Singleton variables are written as _.  See also portray_clause/2.


ppoorrttrraayy__ccllaauussee((_+_S_t_r_e_a_m_, _+_C_l_a_u_s_e))
    Pretty print a clause to _S_t_r_e_a_m.  See portray_clause/1 for details.


44..66 VVeerriiffyy TTyyppee ooff aa TTeerrmm

Type  tests  are  semi-deterministic  predicates  that  succeed  if  the
argument satisfies  the requested type.    Type-test predicates have  no
error  condition and  do  not instantiate  their  argument.    See  also
library error.


vvaarr((_@_T_e_r_m))                                                        _[_I_S_O_]
    True if _T_e_r_m currently is a free variable.


nnoonnvvaarr((_@_T_e_r_m))                                                     _[_I_S_O_]
    True if _T_e_r_m currently is not a free variable.


iinntteeggeerr((_@_T_e_r_m))                                                    _[_I_S_O_]
    True if _T_e_r_m is bound to an integer.


ffllooaatt((_@_T_e_r_m))                                                      _[_I_S_O_]
    True if _T_e_r_m is bound to a floating point number.


rraattiioonnaall((_@_T_e_r_m))
    True  if _T_e_r_m  is  bound to  a rational  number.   Rational  numbers
    include integers.


rraattiioonnaall((_@_T_e_r_m_, _-_N_u_m_e_r_a_t_o_r_, _-_D_e_n_o_m_i_n_a_t_o_r))
    True  if  _T_e_r_m  is  a  rational  number  with  given  _N_u_m_e_r_a_t_o_r  and
    _D_e_n_o_m_i_n_a_t_o_r.   The _N_u_m_e_r_a_t_o_r and _D_e_n_o_m_i_n_a_t_o_r are in  canonical form,
    which  means _D_e_n_o_m_i_n_a_t_o_r  is  a positive  integer and  there are  no
    common divisors between _N_u_m_e_r_a_t_o_r and _D_e_n_o_m_i_n_a_t_o_r.


nnuummbbeerr((_@_T_e_r_m))                                                     _[_I_S_O_]
    True if _T_e_r_m is bound to an integer or floating point number.


aattoomm((_@_T_e_r_m))                                                       _[_I_S_O_]
    True if _T_e_r_m is bound to an atom.


bblloobb((_@_T_e_r_m_, _?_T_y_p_e))
    True if _T_e_r_m is a _b_l_o_b of type _T_y_p_e.  See section 10.4.7.


ssttrriinngg((_@_T_e_r_m))
    True  if _T_e_r_m is bound  to a string.   Note that string here  refers
    to  the built-in  atomic type  string as described  in section  5.2.
    Starting  with version  7, the syntax  for a  string object is  text
    between  double quotes, such as "hello".   See also the  Prolog flag
    double_quotes.


aattoommiicc((_@_T_e_r_m))                                                     _[_I_S_O_]
    True  if _T_e_r_m is bound (i.e.,  not a variable) and is  not compound.
    Thus, atomic acts as if defined by:

    ____________________________________________________________________|                                                                    |
    | atomic(Term) :-                                                    |

    |         nonvar(Term),                                              |
    ||________\+_compound(Term).________________________________________ ||

    SWI-Prolog  defines the following atomic datatypes:   atom (atom/1),
    string  (string/1),   integer  (integer/1),  floating  point  number
    (float/1)  and blob  (blob/2).   In addition,  the symbol []  (empty
    list) is atomic, but not an atom.  See section 5.1.


ccoommppoouunndd((_@_T_e_r_m))                                                   _[_I_S_O_]
    True  if _T_e_r_m  is bound  to a  compound term.    See also  functor/3
    =../2, compound_name_arity/3 and compound_name_arguments/3.


ccaallllaabbllee((_@_T_e_r_m))                                                   _[_I_S_O_]
    True  if _T_e_r_m is  bound to  an atom or  a compound term.   This  was
    intended  as a type-test for arguments to call/1 and call/2..   Note
    that callable only tests  the _s_u_r_f_a_c_e _t_e_r_m.  Terms such as (22,true)
    are  considered callable, but  cause call/1 to  raise a type  error.
    Module-qualification  of meta-argument (see  meta_predicate/1)  using
    :/2  causes callable to succeed on any meta-argument.   Consider the
    program and query below:

    ____________________________________________________________________|                                                                    |
    | :- meta_predicate p(0).                                            |

    |                                                                    |
    | p(G) :- callable(G), call(G).                                      |
    |                                                                    |
    | ?- p(22).                                                          |
    | ERROR: Type error: `callable' expected, found `22'                 |
    | ERROR: In:                                                         |
    ||ERROR:____[6]_p(user:22)__________________________________________ ||


ggrroouunndd((_@_T_e_r_m))                                                     _[_I_S_O_]
    True if _T_e_r_m holds no free variables.


ccyycclliicc__tteerrmm((_@_T_e_r_m))
    True  if _T_e_r_m contains cycles, i.e. is  an infinite term.   See also
    acyclic_term/1 and section 2.16.


aaccyycclliicc__tteerrmm((_@_T_e_r_m))                                                _[_I_S_O_]
    True  if  _T_e_r_m  does  not contain  cycles,  i.e.  can  be  processed
    recursively   in  finite   time.      See  also   cyclic_term/1  and
    section 2.16.


44..77 CCoommppaarriissoonn aanndd UUnniiffiiccaattiioonn ooff TTeerrmmss

Although unification is  mostly done implicitly while matching the  head
of a predicate, it is also provided by the predicate =/2.


_?_T_e_r_m_1 = _?_T_e_r_m_2                                                   _[_I_S_O_]
    Unify  _T_e_r_m_1 with _T_e_r_m_2.   True  if the unification  succeeds.   For
    behaviour  on cyclic  terms see the  Prolog flag  occurs_check.    It
    acts as if defined by the following fact:

    ____________________________________________________________________|                                                                    |
    ||=(Term,_Term).____________________________________________________ ||


_@_T_e_r_m_1 \= _@_T_e_r_m_2                                                  _[_I_S_O_]
    Equivalent to \+Term1 = Term2.  See also dif/2.


44..77..11 SSttaannddaarrdd OOrrddeerr ooff TTeerrmmss

Comparison and  unification of arbitrary  terms.   Terms are ordered  in
the so-called ``standard order''.  This order is defined as follows:

 1. _V_a_r_i_a_b_l_e_s <_N_u_m_b_e_r_s <_S_t_r_i_n_g_s <_A_t_o_m_s <_C_o_m_p_o_u_n_d _T_e_r_m_s

 2. Variables  are  sorted  by  address.     Attaching  attributes  (see
    section 7.1) does not affect the ordering.

 3. _N_u_m_b_e_r_s are compared  by value.  Mixed integer/float are compared as
    floats.   If the  comparison is equal,  the float is considered  the
    smaller  value.   If the  Prolog flag iso  is defined, all  floating
    point numbers precede all integers.

 4. _S_t_r_i_n_g_s are compared alphabetically.

 5. _A_t_o_m_s are compared alphabetically.

 6. _C_o_m_p_o_u_n_d  terms are  first checked  on  their arity,  then on  their
    functor  name  (alphabetically)  and finally  recursively  on  their
    arguments, leftmost argument first.


_@_T_e_r_m_1 == _@_T_e_r_m_2                                                  _[_I_S_O_]
    True if _T_e_r_m_1 is  equivalent to _T_e_r_m_2.  A variable is only identical
    to a sharing variable.


_@_T_e_r_m_1 \== _@_T_e_r_m_2                                                 _[_I_S_O_]
    Equivalent to \+Term1 == Term2.


_@_T_e_r_m_1 @< _@_T_e_r_m_2                                                  _[_I_S_O_]
    True if _T_e_r_m_1 is before _T_e_r_m_2 in the standard order of terms.


_@_T_e_r_m_1 @=< _@_T_e_r_m_2                                                 _[_I_S_O_]
    True if both terms  are equal (==/2) or _T_e_r_m_1 is before _T_e_r_m_2 in the
    standard order of terms.


_@_T_e_r_m_1 @> _@_T_e_r_m_2                                                  _[_I_S_O_]
    True if _T_e_r_m_1 is after _T_e_r_m_2 in the standard order of terms.


_@_T_e_r_m_1 @>= _@_T_e_r_m_2                                                 _[_I_S_O_]
    True  if both terms are equal (==/2) or _T_e_r_m_1 is after _T_e_r_m_2  in the
    standard order of terms.


ccoommppaarree((_?_O_r_d_e_r_, _@_T_e_r_m_1_, _@_T_e_r_m_2))                                   _[_I_S_O_]
    Determine or test  the _O_r_d_e_r between two terms in the standard order
    of terms.  _O_r_d_e_r is one of <, >  or =, with the obvious meaning.


44..77..22 SSppeecciiaall uunniiffiiccaattiioonn aanndd ccoommppaarriissoonn pprreeddiiccaatteess

This   section   describes  special   purpose   variations   on   Prolog
unification.    The  predicate unify_with_occurs_check/2 provides  sound
unification  and  is  part   of  the  ISO  standard.      The  predicate
subsumes_term/2 defines `one-sided unification'  and is part of the  ISO
proposal established  in Edinburgh (2010).    Finally, unifiable/3 is  a
`what-if' version of unification that is often used as  a building block
in constraint reasoners.


uunniiffyy__wwiitthh__ooccccuurrss__cchheecckk((_+_T_e_r_m_1_, _+_T_e_r_m_2))                             _[_I_S_O_]
    As  =/2, but  using _s_o_u_n_d  _u_n_i_f_i_c_a_t_i_o_n.   That is,  a variable  only
    unifies  to  a term  if  this term  does  not contain  the  variable
    itself.  To illustrate this, consider the two queries below.

    ____________________________________________________________________|                                                                    |
    | 1 ?- A = f(A).                                                     |

    | A = f(A).                                                          |
    | 2 ?- unify_with_occurs_check(A, f(A)).                             |
    ||false.____________________________________________________________ ||

    The  first statement creates a  _c_y_c_l_i_c _t_e_r_m, also called a  _r_a_t_i_o_n_a_l
    _t_r_e_e.    The second  executes logically sound  unification and  thus
    fails.   Note that the behaviour of unification through =/2  as well
    as implicit unification  in the head can be changed using the Prolog
    flag occurs_check.

    The   SWI-Prolog  implementation   of  unify_with_occurs_check/2  is
    cycle-safe  and only  guards against  _c_r_e_a_t_i_n_g  cycles, not  against
    cycles  that may already be present in  one of the arguments.   This
    is illustrated in the following two queries:

    ____________________________________________________________________|                                                                    |
    | ?- X = f(X), Y = X, unify_with_occurs_check(X, Y).                 |
    | X = Y, Y = f(Y).                                                   |
    | ?- X = f(X), Y = f(Y), unify_with_occurs_check(X, Y).              |

    ||X_=_Y,_Y_=_f(Y).__________________________________________________ ||

    Some  other  Prolog systems  interpret  unify_with_occurs_check/2 as
    if  defined  by  the clause  below,  causing  failure on  the  above
    two  queries.   Direct use  of acyclic_term/1 is  portable and  more
    appropriate for such applications.

    ____________________________________________________________________|                                                                    |
    ||unify_with_occurs_check(X,X)_:-_acyclic_term(X).__________________ ||


_+_T_e_r_m_1 =@= _+_T_e_r_m_2
    True  if  _T_e_r_m_1 is  a  _v_a_r_i_a_n_t of  (or _s_t_r_u_c_t_u_r_a_l_l_y  _e_q_u_i_v_a_l_e_n_t  to)
    _T_e_r_m_2.   Testing  for a variant  is weaker than equivalence  (==/2),
    but  stronger  than unification  (=/2).    Two terms  A  and B  are
    variants  iff there  exists a renaming  of the variables  in A that
    makes A equivalent (==) to B  and vice versa.  Examples:

          1       a =@= A       false
          2       A =@= B       true
          3  x(A,A) =@= x(B,C)  false
          4  x(A,A) =@= x(B,B)  true
          5  x(A,A) =@= x(A,B)  false

          6  x(A,B) =@= x(C,D)  true
          7  x(A,B) =@= x(B,A)  true
          8  x(A,B) =@= x(C,A)  true

    A term is always  a variant of a copy of itself.  Term copying takes
    place  in, e.g.,  copy_term/2,  findall/3 or  proving a clause  added
    with asserta/1.   In the pure Prolog world (i.e., without attributed
    variables),  =@=/2 behaves  as if  defined below.   With  attributed
    variables,  variant of the attributes  is tested rather than  trying
    to satisfy the constraints.

    ____________________________________________________________________|                                                                    |
    | A =@= B :-                                                         |
    |         copy_term(A, Ac),                                          |
    |         copy_term(B, Bc),                                          |
    |         numbervars(Ac, 0, N),                                      |
    |         numbervars(Bc, 0, N),                                      |

    ||________Ac_==_Bc._________________________________________________ ||

    The  SWI-Prolog  implementation  is  cycle-safe and  can  deal  with
    variables that are shared  between the left and right argument.  Its
    performance  is  comparable to  ==/2, both  on  success and  (early)
    failure.

    This  predicate is known by the name variant/2 in some  other Prolog
    systems.    Be aware  of possible  differences in  semantics if  the
    arguments contain attributed variables or share variables.


_+_T_e_r_m_1 \=@= _+_T_e_r_m_2
    Equivalent to `\+Term1 =@= Term2'.  See =@=/2 for details.


ssuubbssuummeess__tteerrmm((_@_G_e_n_e_r_i_c_, _@_S_p_e_c_i_f_i_c))                                 _[_I_S_O_]
    True  if _G_e_n_e_r_i_c can be made equivalent to _S_p_e_c_i_f_i_c by  only binding
    variables  in  _G_e_n_e_r_i_c.   The  current  implementation performs  the
    unification  and ensures that  the variable set  of _S_p_e_c_i_f_i_c is  not
    changed  by the unification.   On success, the bindings are  undone.
    This predicate respects constraints.


tteerrmm__ssuubbssuummeerr((_+_S_p_e_c_i_a_l_1_, _+_S_p_e_c_i_a_l_2_, _-_G_e_n_e_r_a_l))
    _G_e_n_e_r_a_l  is  the most  specific  term that  is a  generalisation  of
    _S_p_e_c_i_a_l_1 and _S_p_e_c_i_a_l_2.  The implementation can handle cyclic terms.


uunniiffiiaabbllee((_@_X_, _@_Y_, _-_U_n_i_f_i_e_r))
    If  _X and _Y  can unify,  unify _U_n_i_f_i_e_r with  a list of  _V_a_r = _V_a_l_u_e,
    representing  the  bindings required  to make  _X  and _Y  equivalent.
    This  predicate can handle cyclic  terms.  Attributed variables  are
    handled as normal variables.  Associated hooks are _n_o_t executed.


??==((_@_T_e_r_m_1_, _@_T_e_r_m_2))
    Succeeds  if  the  syntactic equality  of  _T_e_r_m_1  and _T_e_r_m_2  can  be
    decided  safely,  i.e.  if the  result  of Term1 == Term2  will  not
    change  due to further instantiation of either term.  It  behaves as
    if defined by ?=(X,Y) :- \+ unifiable(X,Y,[_|_]).


44..88 CCoonnttrrooll PPrreeddiiccaatteess

The predicates of  this section implement control structures.   Normally
the constructs in this  section, except for repeat/0, are  translated by
the compiler.   Please  note that complex goals  passed as arguments  to
meta-predicates such  as findall/3 below cause  the goal to be  compiled
to a  temporary location before  execution.   It is  faster to define  a
sub-predicate (i.e. one_character_atoms/1 in the example below) and make
a call to this simple predicate.

________________________________________________________________________|                                                                        |
|one_character_atoms(As) :-                                              |

||_______findall(A,_(current_atom(A),_atom_length(A,_1)),_As).__________ ||


ffaaiill                                                              _[_I_S_O_]
    Always  fail.   The  predicate fail/0  is translated  into a  single
    virtual machine instruction.


ffaallssee                                                             _[_I_S_O_]
    Same as fail, but the name has a more declarative connotation.


ttrruuee                                                              _[_I_S_O_]
    Always  succeed.  The predicate  true/0 is translated into a  single
    virtual machine instruction.


rreeppeeaatt                                                            _[_I_S_O_]
    Always succeed, provide an infinite number of choice points.


!                                                                 _[_I_S_O_]
    Cut.     Discard  all  choice  points  created  since  entering  the
    predicate  in which the cut appears.  In other words, _c_o_m_m_i_t  to the
    clause  in which  the  cut appears  _a_n_d discard  choice points  that
    have  been created by goals  to the left of  the cut in the  current
    clause.    Meta calling is  opaque to the  cut.   This implies  that
    cuts that appear  in a term that is subject to meta-calling (call/1)
    only  affect choice  points created by  the meta-called  term.   The
    following control structures are transparent to the cut:   ;/2, ->/2
    and *->/2 .  Cuts appearing in the _c_o_n_d_i_t_i_o_n part of ->/2 and  *->/2
    are  opaque to the cut.   The table below explains the scope  of the
    cut  with examples.    _P_r_u_n_e_s  here means  ``prunes X  choice point
    created by X''.

            t0 :- (a, !, b).               % prunes a/0 and t0/0
            t1 :- (a, !, fail ; b).        % prunes a/0 and t1/0
            t2 :- (a -> b, !  ; c).        % prunes b/0 and t2/0
            t3 :- call((a, !, fail ; b)).  % prunes a/0
            t4 :- \+(a, !, fail).          % prunes a/0


_:_G_o_a_l_1 , _:_G_o_a_l_2                                                   _[_I_S_O_]
    Conjunction.   True if both `Goal1'  and `Goal2' can be proved.   It
    is  defined as follows (this definition  does not lead to a loop  as
    the second comma is handled by the compiler):

    ____________________________________________________________________|                                                                    |
    ||Goal1,_Goal2_:-_Goal1,_Goal2._____________________________________ ||


_:_G_o_a_l_1 ; _:_G_o_a_l_2                                                   _[_I_S_O_]
    The `or' predicate is defined as:

    ____________________________________________________________________|                                                                    |
    | Goal1 ; _Goal2 :- Goal1.                                           |
    ||_Goal1_;_Goal2_:-_Goal2.__________________________________________ ||


_:_G_o_a_l_1 | _:_G_o_a_l_2
    Equivalent  to ;/2.    Retained for compatibility  only.   New  code
    should use ;/2.


_:_C_o_n_d_i_t_i_o_n -> _:_A_c_t_i_o_n                                             _[_I_S_O_]
    If-then  and  If-Then-Else.    The  ->/2  construct commits  to  the
    choices  made  at  its  left-hand  side,  destroying  choice  points
    created  inside the  clause (by  ;/2), or  by goals  called by  this
    clause.   Unlike !/0, the choice  point of the predicate as  a whole
    (due  to multiple clauses)  is nnoott destroyed.   The combination  ;/2
    and ->/2  acts as if defined as:

    ____________________________________________________________________|                                                                    |
    | If -> Then; _Else :- If, !, Then.                                  |
    | If -> _Then; Else :- !, Else.                                      |

    ||If_->_Then_:-_If,_!,_Then.________________________________________ ||

    Please  note that (If -> Then) acts  as (If -> Then ; ffaaiill),  making
    the  construct _f_a_i_l if the condition fails.  This  unusual semantics
    is part of the ISO and all de-facto Prolog standards.


_:_C_o_n_d_i_t_i_o_n *-> _:_A_c_t_i_o_n _; _:_E_l_s_e
    This  construct implements  the so-called `soft-cut'.   The  control
    is  defined as follows:   If _C_o_n_d_i_t_i_o_n succeeds  at least once,  the
    semantics  is the same  as (_C_o_n_d_i_t_i_o_n, _A_c_t_i_o_n).   If _C_o_n_d_i_t_i_o_n  does
    not  succeed, the  semantics is that  of (\+ _C_o_n_d_i_t_i_o_n,  _E_l_s_e).   In
    other  words, if _C_o_n_d_i_t_i_o_n succeeds at least once, simply  behave as
    the conjunction of _C_o_n_d_i_t_i_o_n and _A_c_t_i_o_n, otherwise execute _E_l_s_e.

    The  construct _A *-> _B, i.e.  without an _E_l_s_e branch, is  translated
    as the normal conjunction _A, _B.


\+ _:_G_o_a_l                                                          _[_I_S_O_]
    True  if `Goal' cannot  be proven (mnemonic:   + refers to  _p_r_o_v_a_b_l_e
    and  the backslash  (\)  is normally  used to  indicate negation  in
    Prolog).


44..99 MMeettaa--CCaallll PPrreeddiiccaatteess

Meta-call predicates  are used to  call terms  constructed at run  time.
The basic meta-call mechanism offered by SWI-Prolog is  to use variables
as a  subclause (which  should of  course be bound  to a  valid goal  at
runtime).   A  meta-call is  slower than a  normal call  as it  involves
actually searching the database at runtime for the  predicate, while for
normal calls this search is done at compile time.


ccaallll((_:_G_o_a_l))                                                       _[_I_S_O_]
    Invoke  _G_o_a_l as a  goal.   Note that clauses  may have variables  as
    subclauses, which is identical to call/1.


ccaallll((_:_G_o_a_l_, _+_E_x_t_r_a_A_r_g_1_, _._._.))                                      _[_I_S_O_]
    Append  _E_x_t_r_a_A_r_g_1_, _E_x_t_r_a_A_r_g_2_,  _._._.   to  the argument  list of  _G_o_a_l
    and  call the result.   For  example, call(plus(1), 2, X) will  call
    plus(1, 2, X), binding _X to 3.

    The  call/[2..]     construct is  handled  by  the compiler.     The
    predicates   call/[2-8]  are   defined  as  real   (meta-)predicates
    and   are  available  to  inspection   through  current_predicate/1,
    predicate_property/2,  etc.    Higher  arities  are handled  by  the
    compiler  and runtime system, but the predicates are  not accessible
    for inspection.


aappppllyy((_:_G_o_a_l_, _+_L_i_s_t))
    Append  the  members of  _L_i_s_t  to the  arguments  of _G_o_a_l  and  call
    the  resulting term.    For example:   apply(plus(1), [2, X])  calls
    plus(1, 2, X).   New code  should use call/[2..]   if the length  of
    _L_i_s_t is fixed.


nnoott((_:_G_o_a_l))
    True  if _G_o_a_l cannot  be proven.   Retained for compatibility  only.
    New code should use \+/1.


oonnccee((_:_G_o_a_l))                                                       _[_I_S_O_]
    Defined as:

    ____________________________________________________________________|                                                                    |
    | once(Goal) :-                                                      |
    ||________Goal,_!.__________________________________________________ ||

    once/1  can  in  many  cases  be replaced  with  ->/2.     The  only
    difference  is how the  cut behaves  (see !/0).   The following  two
    clauses are identical:

    ____________________________________________________________________|                                                                    |
    | 1) a :- once((b, c)), d.                                           |
    ||2)_a_:-_b,_c_->_d.________________________________________________ ||


iiggnnoorree((_:_G_o_a_l))
    Calls  _G_o_a_l  as once/1,  but succeeds,  regardless  of whether  _G_o_a_l
    succeeded or not.  Defined as:

    ____________________________________________________________________|                                                                    |
    | ignore(Goal) :-                                                    |
    |         Goal, !.                                                   |
    ||ignore(_).________________________________________________________ ||


ccaallll__wwiitthh__ddeepptthh__lliimmiitt((_:_G_o_a_l_, _+_L_i_m_i_t_, _-_R_e_s_u_l_t))
    If  _G_o_a_l can be proven  without recursion deeper than _L_i_m_i_t  levels,
    call_with_depth_limit/3 succeeds,  binding  _R_e_s_u_l_t  to  the  deepest
    recursion  level  used  during the  proof.    Otherwise,  _R_e_s_u_l_t  is
    unified  with depth_limit_exceeded  if the limit was exceeded  during
    the  proof,  or the  entire predicate  fails if  _G_o_a_l fails  without
    exceeding _L_i_m_i_t.

    The  depth  limit  is guarded  by  the  internal machinery.     This
    may  differ from the  depth computed based  on a theoretical  model.
    For  example, true/0  is translated into  an inline virtual  machine
    instruction.   Also, repeat/0 is not implemented as below, but  as a
    non-deterministic foreign predicate.

    ____________________________________________________________________|                                                                    |
    | repeat.                                                            |

    | repeat :-                                                          |
    ||________repeat.___________________________________________________ ||

    As  a result,  call_with_depth_limit/3may  still loop infinitely  on
    programs  that should  theoretically finish  in finite time.    This
    problem  can be cured by  using Prolog equivalents to such  built-in
    predicates.

    This   predicate   may  be   used  for   theorem   provers  to   re-
    alise   techniques   like   _i_t_e_r_a_t_i_v_e   _d_e_e_p_e_n_i_n_g.        See   also
    call_with_inference_limit/3.   It was  implemented after  discussion
    with Steve Moyle smoyle@ermine.ox.ac.uk.


ccaallll__wwiitthh__iinnffeerreennccee__lliimmiitt((_:_G_o_a_l_, _+_L_i_m_i_t_, _-_R_e_s_u_l_t))
    Equivalent  to call(_G_o_a_l), but limits  the number of inferences  _f_o_r
    _e_a_c_h _s_o_l_u_t_i_o_n _o_f _G_o_a_l..  Execution may terminate as follows:

      o  If  _G_o_a_l does  _n_o_t  terminate  before the  inference  limit  is
         exceeded, _G_o_a_l  is aborted  by injecting  the exception  infer-
         ence_limit_exceeded  into its execution.   After termination  of
         _G_o_a_l, _R_e_s_u_l_t is unified with the atom inference_limit_exceeded.
         _O_t_h_e_r_w_i_s_e,

      o  If _G_o_a_l fails, call_with_inference_limit/3fails.

      o  If _G_o_a_l  succeeds _w_i_t_h_o_u_t  _a _c_h_o_i_c_e  _p_o_i_n_t,  _R_e_s_u_l_t is  unified
         with !.

      o  If _G_o_a_l succeeds  _w_i_t_h _a _c_h_o_i_c_e  _p_o_i_n_t, _R_e_s_u_l_t is unified  with
         true.

      o  If  _G_o_a_l   throws  an   exception,   call_with_inference_limit/3
         re-throws the exception.

    An  inference is defined as a call  or redo on a predicate.   Please
    note  that  some  primitive  built-in  predicates  are  compiled  to
    virtual  machine instructions for which inferences are  not counted.
    The  execution of predicates  defined in  other languages (e.g.,  C,
    C++)  count  as  a single  inference.    This  includes  potentially
    expensive built-in predicates such as sort/2.

    Calls  to this predicate  may be nested.   An  inner call that  sets
    the  limit below the current is honoured.  An inner call  that would
    terminate  after the  current limit  does not  change the  effective
    limit.  See also call_with_depth_limit/3 and call_with_time_limit/2.


sseettuupp__ccaallll__cclleeaannuupp((_:_S_e_t_u_p_, _:_G_o_a_l_, _:_C_l_e_a_n_u_p))
    Calls  (once(Setup), Goal).     If  _S_e_t_u_p  succeeds,   _C_l_e_a_n_u_p  will
    be  called  exactly   once  after  _G_o_a_l  is  finished:    either  on
    failure,  deterministic  success,  commit, or  an  exception.    The
    execution  of _S_e_t_u_p is  protected from asynchronous interrupts  like
    call_with_time_limit/2 (package clib) or  thread_signal/2.   In  most
    uses,  _S_e_t_u_p will  perform temporary  side-effects required by  _G_o_a_l
    that are finally undone by _C_l_e_a_n_u_p.

    Success  or failure  of _C_l_e_a_n_u_p  is  ignored, and  choice points  it
    created are destroyed  (as once/1).  If _C_l_e_a_n_u_p throws an exception,
    this is executed as normal.

    Typically, this predicate  is used to cleanup permanent data storage
    required to execute _G_o_a_l,  close file descriptors, etc.  The example
    below  provides a  non-deterministic search  for a term  in a  file,
    closing the stream as needed.

    ____________________________________________________________________|                                                                    |
    | term_in_file(Term, File) :-                                        |

    |         setup_call_cleanup(open(File, read, In),                   |
    |                            term_in_stream(Term, In),               |
    |                            close(In) ).                            |
    |                                                                    |
    | term_in_stream(Term, In) :-                                        |
    |         repeat,                                                    |
    |         read(In, T),                                               |
    |         (   T == end_of_file                                       |

    |         ->  !, fail                                                |
    |         ;   T = Term                                               |
    ||________).________________________________________________________ ||

    Note  that it is impossible  to implement this predicate in  Prolog.
    The  closest approximation would be to  read all terms into a  list,
    close  the  file and  call member/2.    Without setup_call_cleanup/3
    there  is  no way  to  gain  control if  the  choice point  left  by
    repeat/0 is removed by a cut or an exception.

    setup_call_cleanup/3  can also  be used  to  test determinism  of  a
    goal, providing a portable alternative to deterministic/1:

    ____________________________________________________________________|                                                                    |
    | ?- setup_call_cleanup(true,(X=1;X=2), Det=yes).                    |
    |                                                                    |
    | X = 1 ;                                                            |

    |                                                                    |
    | X = 2,                                                             |
    ||Det_=_yes_;_______________________________________________________ ||

    This  predicate is  under consideration for  inclusion into the  ISO
    standard.   For compatibility with other Prolog  implementations see
    call_cleanup/2.


sseettuupp__ccaallll__ccaattcchheerr__cclleeaannuupp((_:_S_e_t_u_p_, _:_G_o_a_l_, _+_C_a_t_c_h_e_r_, _:_C_l_e_a_n_u_p))
    Similar  to setup_call_cleanup(_S_e_t_u_p_, _G_o_a_l_, _C_l_e_a_n_u_p)  with additional
    information  on the reason  for calling _C_l_e_a_n_u_p.   Prior to  calling
    _C_l_e_a_n_u_p, _C_a_t_c_h_e_r unifies  with the termination code (see below).  If
    this unification fails, _C_l_e_a_n_u_p is _n_o_t called.

    eexxiitt
         _G_o_a_l succeeded without leaving any choice points.

    ffaaiill
         _G_o_a_l failed.

    !
         _G_o_a_l succeeded with choice  points and these are now  discarded
         by the execution of a cut (or other pruning of  the search tree
         such as if-then-else).

    eexxcceeppttiioonn((_E_x_c_e_p_t_i_o_n))
         _G_o_a_l raised the given _E_x_c_e_p_t_i_o_n.

    eexxtteerrnnaall__eexxcceeppttiioonn((_E_x_c_e_p_t_i_o_n))
         _G_o_a_l succeeded with choice  points and these are now  discarded
         due to an exception.  For example:

         _______________________________________________________________|                                                               |

         |?- setup_call_catcher_cleanup(true, (X=1;X=2),                 |
         |                              Catcher, writeln(Catcher)),      |
         |   throw(ball).                                                |
         |external_exception(ball)                                       |
         |ERROR:|Unhandled_exception:_Unknown_message:_ball_____________ |      |


ccaallll__cclleeaannuupp((_:_G_o_a_l_, _:_C_l_e_a_n_u_p))
    Same  as setup_call_cleanup(_t_r_u_e_, _G_o_a_l_,  _C_l_e_a_n_u_p).  This is  provided
    for  compatibility with  a  number of  other Prolog  implementations
    only.     Do not  use  call_cleanup/2 if  you  perform  side-effects
    prior  to calling  that will  be undone by  _C_l_e_a_n_u_p.   Instead,  use
    setup_call_cleanup/3 with an  appropriate first argument to  perform
    those side-effects.


ccaallll__cclleeaannuupp((_:_G_o_a_l_, _+_C_a_t_c_h_e_r_, _:_C_l_e_a_n_u_p))
    Same  as  setup_call_catcher_cleanup(_t_r_u_e_, _G_o_a_l_,  _C_a_t_c_h_e_r_,  _C_l_e_a_n_u_p).
    The same warning as for call_cleanup/2 applies.


44..1100 IISSOO ccoommpplliiaanntt EExxcceeppttiioonn hhaannddlliinngg

SWI-Prolog defines the predicates catch/3 and throw/1  for ISO compliant
raising  and catching  of exceptions.    In  the current  implementation
(as  of 4.0.6),  most of  the built-in  predicates generate  exceptions,
but some obscure predicates  merely print a message, start  the debugger
and fail,  which was  the normal  behaviour before  the introduction  of
exceptions.


ccaattcchh((_:_G_o_a_l_, _+_C_a_t_c_h_e_r_, _:_R_e_c_o_v_e_r))                                  _[_I_S_O_]
    Behaves  as call/1 if  no exception is  raised when executing  _G_o_a_l.
    If  an exception is  raised using throw/1  while _G_o_a_l executes,  and
    the  _G_o_a_l is the innermost goal  for which _C_a_t_c_h_e_r unifies with  the
    argument  of throw/1, all choice  points generated by _G_o_a_l are  cut,
    the  system backtracks to the start of catch/3 while  preserving the
    thrown exception term, and _R_e_c_o_v_e_r is called as in call/1.

    The  overhead of  calling a  goal through catch/3  is comparable  to
    call/1.   Recovery from an  exception is much slower, especially  if
    the exception term is large due to the copying thereof.


tthhrrooww((_+_E_x_c_e_p_t_i_o_n))                                                 _[_I_S_O_]
    Raise  an exception.   The  system looks  for the innermost  catch/3
    ancestor  for which _E_x_c_e_p_t_i_o_n unifies  with the _C_a_t_c_h_e_r argument  of
    the catch/3 call.  See catch/3 for details.

    ISO  demands that  throw/1 make  a copy  of _E_x_c_e_p_t_i_o_n,  walk up  the
    stack  to a catch/3  call, backtrack  and try to  unify the copy  of
    _E_x_c_e_p_t_i_o_n  with _C_a_t_c_h_e_r.   SWI-Prolog  delays backtracking until  it
    actually  finds a  matching catch/3  goal.   The  advantage is  that
    we  can start  the  debugger at  the first  possible location  while
    preserving  the entire  exception context  if there  is no  matching
    catch/3  goal.   This approach  can lead  to different behaviour  if
    _G_o_a_l  and _C_a_t_c_h_e_r of catch/3 call shared variables.  We  assume this
    to  be highly unlikely and could not think of a scenario  where this
    is useful.

    In  addition to explicit calls to throw/1, many  built-in predicates
    throw  exceptions directly from C.  If the _E_x_c_e_p_t_i_o_n term cannot  be
    copied  due to lack of stack space, the following actions  are tried
    in order:

     1.  If  the  exception  is  of  the  form  error(_F_o_r_m_a_l_,  _I_m_p_l_e_m_e_n_-
         _t_a_t_i_o_n_D_e_f_i_n_e_d),  try   to  raise  the  exception  without   the
         _I_m_p_l_e_m_e_n_t_a_t_i_o_n_D_e_f_i_n_e_d part.

     2.  Try to raise error(resource_error_(_s_t_a_c_k_)_, _g_l_o_b_a_l).

     3.  Abort (see abort/0).

    If  an exception is  raised in a call-back  from C (see chapter  10)
    and  not caught in the same  call-back, PL_next_solution()fails  and
    the exception context can be retrieved using PL_exception().


44..1100..11 DDeebbuuggggiinngg aanndd eexxcceeppttiioonnss

Before  the introduction  of exceptions  in SWI-Prolog  a runtime  error
was handled  by printing  an error  message, after  which the  predicate
failed.  If the  Prolog flag debug_on_errorwas in effect  (default), the
tracer was switched on.  The combination of the  error message and trace
information is generally sufficient to locate the error.

With exception handling,  things are different.   A programmer may  wish
to trap an  exception using catch/3 to avoid  it reaching the user.   If
the exception  is not handled  by user code,  the interactive top  level
will trap it to prevent termination.

If  we  do  not  take  special  precautions,   the  context  information
associated with an  unexpected exception (i.e., a programming  error) is
lost.   Therefore, if an exception is  raised which is not caught  using
catch/3 and  the top level is  running, the error  will be printed,  and
the system will enter trace mode.

If the system  is in a non-interactive  call-back from foreign code  and
there is no catch/3  active in the current context, it  cannot determine
whether or  not the  exception will  be caught by  the external  routine
calling Prolog.   It  will then  base its behaviour  on the Prolog  flag
debug_on_error:

  o _c_u_r_r_e_n_t___p_r_o_l_o_g___f_l_a_g_(_d_e_b_u_g___o_n___e_r_r_o_r_, _f_a_l_s_e_)
    The  exception does  not trap the  debugger and  is returned to  the
    foreign  routine  calling Prolog,  where it  can  be accessed  using
    PL_exception().  This is the default.

  o _c_u_r_r_e_n_t___p_r_o_l_o_g___f_l_a_g_(_d_e_b_u_g___o_n___e_r_r_o_r_, _t_r_u_e_)
    If the exception is  not caught by Prolog in the current context, it
    will trap the tracer to help analyse the context of the error.

While looking for the  context in which an exception takes place,  it is
advised to switch on  debug mode using the predicate debug/0.   The hook
prolog_exception_hook/4 can be used to add more debugging  facilities to
exceptions.   An  example is the  library http/http_error, generating  a
full stack trace on errors in the HTTP server library.


44..1100..22 TThhee eexxcceeppttiioonn tteerrmm

Built-in  predicates  generate exceptions  using  a  term  error(_F_o_r_m_a_l_,
_C_o_n_t_e_x_t).    The  first argument  is  the  `formal' description  of  the
error,  specifying the class  and generic  defined context  information.
When applicable,  the ISO  error term definition  is used.   The  second
part  describes some  additional context  to help  the programmer  while
debugging.    In its  most  generic form  this  is a  term of  the  form
context(_N_a_m_e_/_A_r_i_t_y_,  _M_e_s_s_a_g_e), where _N_a_m_e/_A_r_i_t_y  describes the  built-in
predicate  that raised  the error,  and _M_e_s_s_a_g_e  provides an  additional
description of the error.  Any part of this structure  may be a variable
if no information was present.


44..1100..33 PPrriinnttiinngg mmeessssaaggeess

The  predicate print_message/2 is  used to  print  a message  term in  a
human-readable format.   The  other predicates  from this section  allow
the user  to refine and extend  the message system.   A common usage  of
print_message/2 is to  print error messages from  exceptions.  The  code
below prints  errors encountered during the  execution of _G_o_a_l,  without
further propagating the exception and without starting the debugger.

________________________________________________________________________|                                                                        |
|        ...,                                                            |

|        catch(Goal, E,                                                  |
|              ( print_message(error, E),                                |
|                fail                                                    |
|              )),                                                       |
||_______...____________________________________________________________ ||

Another common  use is  to define  message_hook/3 for printing  messages
that are normally _s_i_l_e_n_t, suppressing messages,  redirecting messages or
make something happen in addition to printing the message.


pprriinntt__mmeessssaaggee((_+_K_i_n_d_, _+_T_e_r_m))
    The  predicate print_message/2 is used  by the system and  libraries
    to  print  messages.   _K_i_n_d  describes the  nature  of the  message,
    while  _T_e_r_m is a Prolog term  that describes the content.   Printing
    messages  through  this indirection  instead  of using  format/3  to
    the  stream user_error allows displaying the message appropriate  to
    the  application (terminal, logfile,  graphics), acting on  messages
    based on  their content instead of a string (see message_hook/3) and
    creating  language specific  versions  of the  messages.   See  also
    section 4.10.3.1.  The following message kinds are known:

    bbaannnneerr
         The system banner message.   Banner messages can  be suppressed
         by setting the Prolog flag verbose to silent.

    ddeebbuugg((_T_o_p_i_c))
         Message from library(debug).  See debug/3.

    eerrrroorr
         The  message indicates  an  erroneous  situation.    This  kind
         is used  to  print uncaught  exceptions of  type  error(_F_o_r_m_a_l_,
         _C_o_n_t_e_x_t).  See section introduction (section 4.10.3).

    hheellpp
         User requested help message, for example after  entering `h' or
         `?'  to a prompt.

    iinnffoorrmmaattiioonn
         Information that  is requested  by  the user.    An example  is
         statistics/0.

    iinnffoorrmmaattiioonnaall
         Typically messages  of events are  progres that are  considered
         useful to  a developer.   Such  messages can  be suppressed  by
         setting the Prolog flag verbose to silent.

    ssiilleenntt
         Message that is normally not printed.   Applications may define
         message_hook/3 to act upon such messages.

    ttrraaccee
         Messages from the (command line) tracer.

    wwaarrnniinngg
         The message indicates something dubious that is  not considered
         fatal.       For   example,   discontiguous   predicates   (see
         discontiguous/1).

    The predicate  print_message/2first translates the  _T_e_r_m into a list
    of  `message lines' (see print_message_lines/3 for details).   Next,
    it calls  the hook message_hook/3to allow the  user to intercept the
    message.   If message_hook/3fails it prints  the message unless _K_i_n_d
    is silent.

    The  print_message/2  predicate  and  its  rules  are  in  the  file
    <_p_l_h_o_m_e>/boot/messages.pl,   which  may   be   inspected  for   more
    information  on the error messages and related error terms.   If you
    need  to write messages from your own predicates, it  is recommended
    to  reuse the existing message terms if applicable.  If  no existing
    message  term  is  applicable,  invent  a fairly  unique  term  that
    represents  the event and define a rule for the  multifile predicate
    prolog:message//1.    See section 4.10.3.1  for a deeper  discussion
    and examples.

    See also message_to_string/2.


pprriinntt__mmeessssaaggee__lliinneess((_+_S_t_r_e_a_m_, _+_P_r_e_f_i_x_, _+_L_i_n_e_s))
    Print a  message (see print_message/2) that has  been translated to a
    list of message elements.  The elements of this list are:

    <_F_o_r_m_a_t>--<_A_r_g_s>
         Where  _F_o_r_m_a_t  is  an  atom  and  _A_r_g_s  is  a  list  of  format
         arguments.  Handed to format/3.

    fflluusshh
         If this  appears as the  last element,  _S_t_r_e_a_m is flushed  (see
         flush_output/1) and  no  final  newline  is generated.     This
         is  combined  with  a  subsequent  message  that   starts  with
         at_same_line to complete the line.

    aatt__ssaammee__lliinnee
         If this  appears as  first element,  no prefix  is printed  for
         the first line  and the line position  is not forced to 0  (see
         format/1, ~N).

    aannssii((_+_A_t_t_r_i_b_u_t_e_s_, _+_F_o_r_m_a_t_, _+_A_r_g_s))
         This message  may  be intercepted  by means  of  the hook  pro-
         log:message_line_element/2.   The  library ansi_term  implements
         this  hook  to  achieve  coloured  output.     If   it  is  not
         intercepted it invokes format(_S_t_r_e_a_m_, _F_o_r_m_a_t_, _A_r_g_s).

    nnll
         A new line is started.  If the message is  not complete, _P_r_e_f_i_x
         is printed before the remainder of the message.

    bbeeggiinn((_K_i_n_d_, _V_a_r))
    eenndd((_V_a_r))
         The entire message is  headed by begin(_K_i_n_d_, _V_a_r) and  ended by
         end(_V_a_r).  This feature is used  by, e.g., library ansi_term to
         colour entire messages.

    <_F_o_r_m_a_t>
         Handed to format/3 as  format(_S_t_r_e_a_m_, _F_o_r_m_a_t_, _[_]).   Deprecated
         because it  is ambiguous  if _F_o_r_m_a_t  collides with  one of  the
         atomic commands.

    See also print_message/2 and message_hook/3.


mmeessssaaggee__hhooookk((_+_T_e_r_m_, _+_K_i_n_d_, _+_L_i_n_e_s))
    Hook  predicate that may be defined in the module user  to intercept
    messages  from  print_message/2.    _T_e_r_m  and _K_i_n_d  are the  same  as
    passed to  print_message/2.  _L_i_n_e_s is a  list of format statements as
    described with print_message_lines/3.  See also message_to_string/2.

    This predicate must  be defined dynamic and multifile to allow other
    modules defining clauses for it too.


tthhrreeaadd__mmeessssaaggee__hhooookk((_+_T_e_r_m_, _+_K_i_n_d_, _+_L_i_n_e_s))
    As  message_hook/3,  but this  predicate  is  local to  the  calling
    thread   (see  thread_local/1).      This  hook  is  called   _b_e_f_o_r_e
    message_hook/3.    The  `pre-hook'  is  indented to  catch  messages
    they  may be produced by  calling some goal without affecting  other
    threads.


mmeessssaaggee__pprrooppeerrttyy((_+_K_i_n_d_, _?_P_r_o_p_e_r_t_y))
    This  hook can be  used to define  additional message kinds and  the
    way they are displayed.  The following properties are defined:

    ccoolloorr((_-_A_t_t_r_i_b_u_t_e_s))
         Print  message   using   ANSI  terminal   attributes.       See
         ansi_format/3 for details.   Here is an example, printing  help
         messages in blue:

         _______________________________________________________________|                                                               |

         |:- multifile user:message_property/2.                          |
         |                                                               |
         |user:message_property(help,|color([fg(blue)]))._______________ |                           |

    pprreeffiixx((_-_P_r_e_f_i_x))
         Prefix printed before  each line.   This argument is handed  to
         format/3.  The  default is '~N'. For example, messages  of kind
         warning use '~NWarning: '.

    llooccaattiioonn__pprreeffiixx((_+_L_o_c_a_t_i_o_n_, _-_F_i_r_s_t_P_r_e_f_i_x_, _-_C_o_n_t_i_n_u_e_P_r_e_f_i_x))
         Used for printing messages  that are related to a  source loca-
         tion.   Currently, _L_o_c_a_t_i_o_n is a  term _F_i_l_e:_L_i_n_e.   _F_i_r_s_t_P_r_e_f_i_x
         is the  prefix for the  first line  and _-_C_o_n_t_i_n_u_e_P_r_e_f_i_x is  the
         prefix for continuation  lines.   For example, the default  for
         errors is

         _______________________________________________________________|                                                               |
         |location_prefix(File:Line,                                     |
         ||_______________'~NERROR:_~w:~d:'-[File,Line],_'~N\t')).______ ||

    ssttrreeaamm((_-_S_t_r_e_a_m))
         Stream to which to print the message.  Default is user_error.

    wwaaiitt((_-_S_e_c_o_n_d_s))
         Amount of time to wait after printing the message.   Default is
         not to wait.


pprroolloogg::mmeessssaaggee__lliinnee__eelleemmeenntt((_+_S_t_r_e_a_m_, _+_T_e_r_m))
    This  hook is called to print  the individual elements of a  message
    from  print_message_lines/3.    This hook  is used  by e.g.,  library
    ansi_term to colour messages on ANSI-capable terminals.


mmeessssaaggee__ttoo__ssttrriinngg((_+_T_e_r_m_, _-_S_t_r_i_n_g))
    Translates a message term into a string object (see section 5.2).


vveerrssiioonn
    Write  the SWI-Prolog banner message as well as  additional messages
    registered  using version/1.    This is  the default  _i_n_i_t_i_a_l_i_z_a_t_i_o_n
    _g_o_a_l which can be modified using -g.


vveerrssiioonn((_+_M_e_s_s_a_g_e))
    Register  additional messages  to  be printed  by version/0.    Each
    registered message is  handed to the message translation DCG and can
    thus  be defined using the hook prolog:message//1.  If  not defined,
    it is simply printed.


44..1100..33..11 PPrriinnttiinngg ffrroomm lliibbrraarriieess

Libraries should _n_o_t  use format/3 or other output predicates  directly.
Libraries that  print informational output directly  to the console  are
hard to use from code that depend on your textual output,  such as a CGI
script.   The predicates  in section 4.10.3 define  the API for  dealing
with  messages.   The  idea behind  this is  that a  library that  wants
to provide  information about its status,  progress, events or  problems
calls print_message/2.  The first argument is the _l_e_v_e_l.   The supported
levels  are described  with print_message/2.    Libraries typically  use
informational and  warning, while  libraries should  use exceptions  for
errors (see throw/1, type_error/2, etc.).

The  second  argument is  an  arbitrary  Prolog term  that  carries  the
information  of the  message,  but  _n_o_t the  precise  text.    The  text
is defined  by the  grammar rule  prolog:message//1.   This  distinction
is made  to allow  for translations  and to allow  hooks processing  the
information in  a different  way (e.g., to  translate progress  messages
into a progress bar).

For example,  suppose we  have a  library that must  download data  from
the Internet (e.g.,  based on http_open/3).  The library wants  to print
the progress  after each  downloaded file.   The  code below  is a  good
skeleton:

________________________________________________________________________|                                                                        |
|download_urls(List) :-                                                  |
|        length(List, Total),                                            |
|        forall(nth1(I, List, URL),                                      |

|               (   download_url(URL),                                   |
|                   print_message(informational,                         |
||________________________________download_url(URL,_I,_Total))))._______ ||

The programmer  can now  specify the  default textual  output using  the
rule below.   Note that this  rule may be in  the same file or  anywhere
else.   Notably,  the application may  come with  several rule sets  for
different languages.    This, and  the user-hook example  below are  the
reason  to represent  the  message as  a  compound  term rather  than  a
string.    This is  similar  to using  message numbers  in  non-symbolic
languages.    The documentation  of print_message_lines/3 describes  the
elements that may appear in the output list.

________________________________________________________________________|                                                                        |
|:- multifile                                                            |
|        prolog:message//1.                                              |
|                                                                        |

|prolog:message(download_url(URL, I, Total)) -->                         |
|        { Perc is round(I*100/Total) },                                 |
||_______[_'Downloaded_~w;_~D_from_~D_(~d%)'-[URL,_I,_Total,_Perc]_].___ ||

A _u_s_e_r  of the library  may define rules for  message_hook/3.   The  rule
below acts on  the message content.   Other applications can act on  the
message level  and, for example,  popup a message  box for warnings  and
errors.

________________________________________________________________________|                                                                        |
|:- multifile user:message_hook/3.                                       |
|                                                                        |
|message_hook(download_url(URL, I, Total), _Kind, _Lines) :-             |
||_______<send_this_information_to_a_GUI_component>_____________________ ||

In addition, using the command line option -q, the  user can disable all
_i_n_f_o_r_m_a_t_i_o_n_a_l messages.


44..1111 HHaannddlliinngg ssiiggnnaallss

As  of   version  3.1.0,   SWI-Prolog   is  able   to  handle   software
interrupts  (signals) in  Prolog as  well as  in foreign  (C) code  (see
section 10.4.13).

Signals are used to handle internal errors (execution  of a non-existing
CPU  instruction,  arithmetic  domain  errors,  illegal  memory  access,
resource  overflow, etc.),  as  well as  for dealing  with  asynchronous
interprocess communication.

Signals  are  defined  by  the POSIX  standard  and  part  of  all  Unix
machines.    The  MS-Windows  Win32  provides  a subset  of  the  signal
handling routines, lacking the vital functionality to raise  a signal in
another thread for achieving asynchronous interprocess  (or interthread)
communication (Unix kill() function).


oonn__ssiiggnnaall((_+_S_i_g_n_a_l_, _-_O_l_d_, _:_N_e_w))
    Determines  the reaction on  _S_i_g_n_a_l.   _O_l_d is  unified with the  old
    behaviour, while the behaviour  is switched to _N_e_w.  As with similar
    environment  control  predicates,  the  current value  is  retrieved
    using on_signal(Signal, Current, Current).

    The  action  description  is  an  atom  denoting  the  name  of  the
    predicate  that will be called if _S_i_g_n_a_l arrives.   on_signal/3 is a
    meta-predicate, which implies that <_M_o_d_u_l_e>:<_N_a_m_e>  refers to <_N_a_m_e>/1
    in  module <_M_o_d_u_l_e>.  The handler  is called with a single argument:
    the  name of the signal  as an atom.   The Prolog names for  signals
    are explained below.

    Two  predicate names  have special  meaning.   throw implies  Prolog
    will  map  the  signal  onto  a Prolog  exception  as  described  in
    section  4.10.   default resets the  handler to the settings  active
    before SWI-Prolog manipulated the handler.

    Signals  bound   to  a  foreign  function  through  PL_signal()  are
    reported using the term $foreign_function(_A_d_d_r_e_s_s).

    After  receiving a signal mapped to throw, the exception  raised has
    the following structure:

         error(signal(<SigName>, <SigNum>), <_C_o_n_t_e_x_t>)

    The  signal  names are  defined  by the  POSIX standard  as  symbols
    of  the form  SIG<SIGNAME>.   The Prolog  name for a  signal is  the
    lowercase version  of <SIGNAME>.  The predicate current_signal/3 may
    be used to map between names and signals.

    Initially,  some  signals  are  mapped to  throw,  while  all  other
    signals  are default.    The following signals  throw an  exception:
    fpe, alrm, xcpu, xfsz and vtalrm.


ccuurrrreenntt__ssiiggnnaall((_?_N_a_m_e_, _?_I_d_, _?_H_a_n_d_l_e_r))
    Enumerate  the  currently defined  signal  handling.   _N_a_m_e  is  the
    signal  name,  _I_d is  the numerical  identifier and  _H_a_n_d_l_e_r is  the
    currently defined handler (see on_signal/3).


44..1111..11 NNootteess oonn ssiiggnnaall hhaannddlliinngg

Before  deciding  to deal  with  signals  in  your  application,  please
consider the following:

  o _P_o_r_t_a_b_i_l_i_t_y
    On MS-Windows, the  signal interface is severely limited.  Different
    Unix  brands support  different sets  of signals,  and the  relation
    between  signal name  and number may  vary.   Currently, the  system
    only  supports  signals numbered  1  to 32.    Installing  a  signal
    outside  the limited set of supported signals in  MS-Windows crashes
    the application.

  o _S_a_f_e_t_y
    Immediately delivered signals  (see below) are unsafe.  This implies
    that  foreign  functions called  from a  handler  cannot safely  use
    the  SWI-Prolog API and  cannot use C  longjmp().  Handlers  defined
    as  throw are  unsafe.   Handlers defined  to call  a predicate  are
    safe.   Note that the  predicate can call throw/1, but  the delivery
    is delayed until Prolog is in a safe state.

    The  C-interface described  in section 10.4.13  provides the  option
    PL_SIGSYNC to select either safe synchronous  or unsafe asynchronous
    delivery.

  o _T_i_m_e _o_f _d_e_l_i_v_e_r_y
    Using throw or  a foreign handler, signals are delivered immediately
    (as  defined by the OS). When using a Prolog predicate,  delivery is
    delayed  to a safe moment.   Blocking system calls or foreign  loops
    may cause long delays.   Foreign code can improve on that by calling
    PL_handle_signals().

    Signals are blocked when the garbage collector is active.


44..1122 DDCCGG GGrraammmmaarr rruulleess

Grammar rules form  a comfortable interface to  _d_i_f_f_e_r_e_n_c_e _l_i_s_t_s.   They
are designed  both to support  writing parsers that  build a parse  tree
from a list of characters or tokens and for generating  a flat list from
a term.

Grammar rules  look like  ordinary clauses  using -->/2  for  separating
the head  and body rather than  :-/2.   Expanding grammar rules is  done
by expand_term/2, which adds  two additional arguments to each term  for
representing the difference list.

The  body of  a grammar  rule  can contain  three  types of  terms.    A
callable term  is interpreted as a  reference to a  grammar rule.   Code
between  {...}  is  interpreted  as  plain  Prolog  code,  and  finally,
a  list  is  interpreted  as  a  sequence  of  _l_i_t_e_r_a_l_s.     The  Prolog
control-constructs  (\+/1, ->/2 , ;//2,  ,/2  and !/0)  can be  used  in
grammar rules.

We  illustrate the  behaviour by  defining  a rule  set for  parsing  an
integer.

________________________________________________________________________|                                                                        |
|integer(I) -->                                                          |

|        digit(D0),                                                      |
|        digits(D),                                                      |
|        { number_codes(I, [D0|D])                                       |
|        }.                                                              |
|                                                                        |
|digits([D|T]) -->                                                       |
|        digit(D), !,                                                    |
|        digits(T).                                                      |

|digits([]) -->                                                          |
|        [].                                                             |
|                                                                        |
|digit(D) -->                                                            |
|        [D],                                                            |
|        { code_type(D, digit)                                           |
||_______}._____________________________________________________________ ||

Grammar rule sets are called using the built-in  predicates phrase/2 and
phrase/3:


pphhrraassee((_:_D_C_G_B_o_d_y_, _?_L_i_s_t))
    Equivalent to phrase(_D_C_G_B_o_d_y, _I_n_p_u_t_L_i_s_t, []).


pphhrraassee((_:_D_C_G_B_o_d_y_, _?_L_i_s_t_, _?_R_e_s_t))
    True  when _D_C_G_B_o_d_y applies  to the difference  _L_i_s_t/_R_e_s_t.   Although
    _D_C_G_B_o_d_y  is typically a _c_a_l_l_a_b_l_e  term that denotes a grammar  rule,
    it can be any term that is valid as the body of a DCG rule.

    The  example  below   calls  the  rule  set  integer//1  defined  in
    section  4.12 and available  from library(dcg/basics), binding  _R_e_s_t
    to the remainder of the input after matching the integer.

    ____________________________________________________________________|                                                                    |
    | ?- [library(dcg/basics)].                                          |

    | ?- atom_codes('42 times', Codes),                                  |
    |    phrase(integer(X), Codes, Rest).                                |
    | X = 42                                                             |
    ||Rest_=_[32,_116,_105,_109,_101,_115]______________________________ ||

    The  next example  exploits a complete  body.   Given the  following
    definition of digit_weight//1, we can pose the query below.

    ____________________________________________________________________|                                                                    |
    | digit_weight(W) -->                                                |
    |         [D],                                                       |

    ||________{_code_type(D,_digit(W))_}._______________________________ ||

    ____________________________________________________________________|                                                                    |
    | ?- atom_codes('Version 3.4', Codes),                               |

    |    phrase(("Version ",                                             |
    |            digit_weight(Major),".",digit_weight(Minor)),           |
    |           Codes).                                                  |
    | Major = 3,                                                         |
    ||Minor_=_4.________________________________________________________ ||

    The  SWI-Prolog implementation  of phrase/3 verifies  that the  _L_i_s_t
    and  _R_e_s_t arguments are unbound, bound  to the empty list or  a list
    _c_o_n_s  _c_e_l_l.    Other  values raise  a  type error.    The  predicate
    call_dcg/3 is provided to use grammar rules with  terms that are not
    lists.

    Note  that  the syntax  for  lists of  codes changed  in  SWI-Prolog
    version  7 (see section  5.2).   If a DCG  body is translated,  both
    "text"  and `text` is  a valid code-list  literal in version  7.   A
    version  7 string  ("text")  is nnoott  acceptable for  the second  and
    third  arguments of phrase/3.   This is typically not a problem  for
    applications  as the  input of a  DCG rarely  appears in the  source
    code.  For  testing in the toplevel, one must use double quoted text
    in versions prior to 7 and back quoted text in version 7 or later.

    See  also  portray_text/1,  which can  be  used to  print  lists  of
    character  codes  as   a  string  to  the  top  level  and  debugger
    to   facilitate  debugging  DCGs   that  process  character   codes.
    The  library  apply_macros  compiles phrase/3  if  the  argument  is
    sufficiently  instantiated,  eliminating  the  runtime  overhead  of
    translating _D_C_G_B_o_d_y and meta-calling.


ccaallll__ddccgg((_:_D_C_G_B_o_d_y_, _?_S_t_a_t_e_0_, _?_S_t_a_t_e))
    As  phrase/3, but  without type  checking _S_t_a_t_e_0  and _S_t_a_t_e.    This
    allows  for  using  DCG  rules  for  threading  an  arbitrary  state
    variable.   This  predicate was introduced  after type checking  was
    added to phrase/3.

    A  portable  solution  for threading  state  through  a DCG  can  be
    implemented  by  wrapping  the state  in  a  list and  use  the  DCG
    push-back  facility.  Subsequently, the following predicates  may be
    used to access and modify the state:

    ____________________________________________________________________|                                                                    |
    | state(S), [S] --> [S].                                             |

    ||state(S0,_S),_[S]_-->_[S0]._______________________________________ ||

As stated  above, grammar  rules are a  general interface to  difference
lists.  To illustrate, we show a DCG-based implementation of reverse/2:

________________________________________________________________________|                                                                        |
|reverse(List, Reversed) :-                                              |
|        phrase(reverse(List), Reversed).                                |
|                                                                        |

|reverse([])    --> [].                                                  |
|reverse([H|T])|-->_reverse(T),_[H].____________________________________ |              |


44..1133 DDaattaabbaassee

SWI-Prolog offers  three different database mechanisms.   The first  one
is  the common  assert/retract  mechanism  for manipulating  the  clause
database.    As facts  and clauses  asserted using  assert/1  or one  of
its derivatives  become part  of the program,  these predicates  compile
the term  given to them.    retract/1 and retractall/1  have to unify  a
term and  therefore have to  decompile the program.   For these  reasons
the assert/retract  mechanism is  expensive.   On the  other hand,  once
compiled, queries to the database are faster than  querying the recorded
database discussed below.  See also dynamic/1.

The second way of  storing arbitrary terms in the database is  using the
`recorded database'.  In this database terms are  associated with a _k_e_y.
A key can be an atom, small integer or term.  In  the last case only the
functor and  arity determine the  key.   Each key has  a chain of  terms
associated with it.   New terms  can be added either  at the head or  at
the tail of this chain.

Following the Edinburgh tradition, SWI-Prolog provides  database keys to
clauses and records in the recorded database.  As  of 5.9.10, these keys
are  represented by  non-textual atoms  (`blobs',  see section  10.4.7),
which makes accessing the database through references safe.

The third mechanism is a special-purpose one.   It associates an integer
or atom with  a key, which is  an atom, integer or  term.  Each key  can
only have one atom or integer associated with it.


aabboolliisshh((_:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r))                                      _[_I_S_O_]
    Removes  all clauses of a  predicate with functor _F_u_n_c_t_o_r and  arity
    _A_r_i_t_y  from  the  database.    All  predicate  attributes  (dynamic,
    multifile,  index, etc.)  are  reset to their defaults.   Abolishing
    an  imported predicate only removes  the import link; the  predicate
    will keep its old definition in its definition module.

    According  to the  ISO standard,  abolish/1 can only  be applied  to
    dynamic  procedures.    This is  odd, as  for  dealing with  dynamic
    procedures  there  is  already  retract/1 and  retractall/1.     The
    abolish/1  predicate was introduced  in DEC-10 Prolog precisely  for
    dealing  with static procedures.  In SWI-Prolog, abolish/1  works on
    static procedures, unless the Prolog flag iso is set to true.

    It  is advised  to use  retractall/1 for  erasing all  clauses of  a
    dynamic predicate.


aabboolliisshh((_+_N_a_m_e_, _+_A_r_i_t_y))
    Same  as abolish(_N_a_m_e_/_A_r_i_t_y).   The predicate abolish/2 conforms  to
    the Edinburgh standard, while abolish/1 is ISO compliant.


ccooppyy__pprreeddiiccaattee__ccllaauusseess((_:_F_r_o_m_, _:_T_o))
    Copy  all clauses of predicate  _F_r_o_m to _T_o.   The predicate _T_o  must
    be  dynamic or  undefined.   If _T_o  is undefined, it  is created  as
    a  dynamic predicate  holding a copy  of the  clauses of _F_r_o_m.    If
    _T_o  is a dynamic  predicate, the  clauses of _F_r_o_m  are added (as  in
    assertz/1)  to the clauses of  _T_o.  _T_o  and _F_r_o_m must have the  same
    arity.    Acts as if  defined by the  program below,  but at a  much
    better performance by avoiding decompilation and compilation.

    ____________________________________________________________________|                                                                    |
    | copy_predicate_clauses(From, To) :-                                |

    |         head(From, MF:FromHead),                                   |
    |         head(To, MT:ToHead),                                       |
    |         FromHead =.. [_|Args],                                     |
    |         ToHead =.. [_|Args],                                       |
    |         forall(clause(MF:FromHead, Body),                          |
    |                assertz(MT:ToHead, Body)).                          |
    |                                                                    |
    | head(From, M:Head) :-                                              |

    |         strip_module(From, M, Name/Arity),                         |
    ||________functor(Head,_Name,_Arity)._______________________________ ||


rreeddeeffiinnee__ssyysstteemm__pprreeddiiccaattee((_+_H_e_a_d))
    This  directive  may be  used  both in  module  user and  in  normal
    modules to redefine  any system predicate.  If the system definition
    is  redefined in  module user,  the  new definition  is the  default
    definition  for  all sub-modules.    Otherwise  the redefinition  is
    local  to the module.   The system definition remains in the  module
    system.

    Redefining   system   predicate   facilitates  the   definition   of
    compatibility packages.  Use in other contexts is discouraged.


rreettrraacctt((_+_T_e_r_m))                                                    _[_I_S_O_]
    When  _T_e_r_m  is an  atom  or a  term  it is  unified with  the  first
    unifying  fact or clause  in the database.   The  fact or clause  is
    removed from the database.


rreettrraaccttaallll((_+_H_e_a_d))                                                 _[_I_S_O_]
    All  facts or  clauses in the  database for  which the _h_e_a_d  unifies
    with  _H_e_a_d are removed.  If  _H_e_a_d refers to a predicate that  is not
    defined, it is implicitly  created as a dynamic predicate.  See also
    dynamic/1.


aasssseerrttaa((_+_T_e_r_m))                                                    _[_I_S_O_]
    Assert  a  fact  or  clause in  the  database.    _T_e_r_m  is  asserted
    as  the  first  fact  or  clause  of  the  corresponding  predicate.
    Equivalent  to assert/1,  but _T_e_r_m  is asserted as  first clause  or
    fact  of  the predicate.     If the  program  space for  the  target
    module  is   limited  (see  set_module/1),   asserta/1  can  raise  a
    resource_error(_p_r_o_g_r_a_m___s_p_a_c_e).


aasssseerrttzz((_+_T_e_r_m))                                                    _[_I_S_O_]
    Equivalent to asserta/1,  but _T_e_r_m is asserted as the last clause or
    fact of the predicate.


aasssseerrtt((_+_T_e_r_m))
    Equivalent  to  assertz/1.     Deprecated:    new  code  should  use
    assertz/1.


aasssseerrttaa((_+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Asserts  a clause as asserta/1  and unifies _R_e_f_e_r_e_n_c_e with a  handle
    to  this clause.   The handle  can be used  to access this  specific
    clause using clause/3 and erase/1.


aasssseerrttzz((_+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Equivalent  to  asserta/1,  asserting the  new  clause as  the  last
    clause of the predicate.


aasssseerrtt((_+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Equivalent  to  assertz/2.     Deprecated:    new  code  should  use
    assertz/2.


rreeccoorrddaa((_+_K_e_y_, _+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Assert  _T_e_r_m in  the recorded  database under  key _K_e_y.    _K_e_y is  a
    small  integer (range min_tagged_integer ...max_tagged_integer,  atom
    or compound term.   If the key is a compound term, only the name and
    arity  define the key.   _R_e_f_e_r_e_n_c_e is unified with an opaque  handle
    to the record (see erase/1).


rreeccoorrddaa((_+_K_e_y_, _+_T_e_r_m))
    Equivalent to recorda(_K_e_y, _T_e_r_m,  _).


rreeccoorrddzz((_+_K_e_y_, _+_T_e_r_m_, _-_R_e_f_e_r_e_n_c_e))
    Equivalent to recorda/3, but  puts the _T_e_r_m at the tail of the terms
    recorded under _K_e_y.


rreeccoorrddzz((_+_K_e_y_, _+_T_e_r_m))
    Equivalent to recordz(_K_e_y, _T_e_r_m,  _).


rreeccoorrddeedd((_?_K_e_y_, _?_V_a_l_u_e_, _?_R_e_f_e_r_e_n_c_e))
    True  if _V_a_l_u_e  is recorded  under _K_e_y  and has  the given  database
    _R_e_f_e_r_e_n_c_e.     If  _R_e_f_e_r_e_n_c_e  is  given,  this  predicate  is  semi-
    deterministic.   Otherwise, it must be considered non-deterministic.
    If neither _R_e_f_e_r_e_n_c_e  nor _K_e_y is given, the triples are generated as
    in the code snippet below.  See also current_key/1.

    ____________________________________________________________________|                                                                    |
    |         current_key(Key),                                          |

    ||________recorded(Key,_Value,_Reference)___________________________ ||


rreeccoorrddeedd((_+_K_e_y_, _-_V_a_l_u_e))
    Equivalent to recorded(_K_e_y, _V_a_l_u_e,  _).


eerraassee((_+_R_e_f_e_r_e_n_c_e))
    Erase  a  record  or  clause  from  the  database.     _R_e_f_e_r_e_n_c_e  is
    a  db-reference  returned  by recorda/3,  recordz/3  or  recorded/3,
    clause/3,  assert/2, asserta/2 or assertz/2.   Fail silently if  the
    referenced object no longer exists.


iinnssttaannccee((_+_R_e_f_e_r_e_n_c_e_, _-_T_e_r_m))
    Unify  _T_e_r_m with  the referenced clause  or database  record.   Unit
    clauses are represented as _H_e_a_d :- true.


ffllaagg((_+_K_e_y_, _-_O_l_d_, _+_N_e_w))
    _K_e_y is an atom,  integer or term.  As with the recorded database, if
    _K_e_y is a term,  only the name and arity are used to locate the flag.
    Unify  _O_l_d with the old  value associated with _K_e_y.   If the key  is
    used  for the first time  _O_l_d is unified with  the integer 0.   Then
    store  the value  of _N_e_w, which  should be an  integer, float,  atom
    or  arithmetic expression, under  _K_e_y.   flag/3 is a fast  mechanism
    for  storing simple facts  in the  database.   The flag database  is
    shared  between threads and updates  are atomic, making it  suitable
    for generating unique integer counters.


44..1133..11 UUppddaattee vviieeww

Traditionally,  Prolog systems  used  the _i_m_m_e_d_i_a_t_e  _u_p_d_a_t_e _v_i_e_w:    new
clauses  became   visible  to   predicates  backtracking  over   dynamic
predicates   immediately,  and   retracted   clauses  became   invisible
immediately.

Starting with  SWI-Prolog 3.3.0 we  adhere to  the _l_o_g_i_c_a_l _u_p_d_a_t_e  _v_i_e_w,
where backtrackable predicates that enter the definition  of a predicate
will not  see any changes  (either caused by  assert/1 or retract/1)  to
the  predicate.    This view  is the  ISO  standard, the  most  commonly
used and  the most  `safe'.   Logical  updates are  realised by  keeping
reference counts  on predicates and  _g_e_n_e_r_a_t_i_o_n information on  clauses.
Each change  to the database  causes an increment  of the generation  of
the database.  Each  goal is tagged with the generation in which  it was
started.   Each  clause is flagged  with the  generation it was  created
in as  well as the  generation it was  erased from.   Only clauses  with
a `created'  ...`erased' interval  that encloses the  generation of  the
current goal are considered visible.


44..1133..22 IInnddeexxiinngg ddaattaabbaasseess

The indexing capabilities  of SWI-Prolog are described in section  2.17.
Summarizing,  SWI-Prolog creates  indexes for  any applicable  argument,
but only on  one argument, and does  not index on arguments of  compound
terms.  The  predicates below provide building blocks to  circumvent the
limitations of the current indexing system.

Programs that aim  at portability should consider  using term_hash/2 and
term_hash/4 to design their  database such that indexing on constant  or
functor (name/arity reference) on the first argument is sufficient.


tteerrmm__hhaasshh((_+_T_e_r_m_, _-_H_a_s_h_K_e_y))                                         _[_d_e_t_]
    If  _T_e_r_m is a  ground term (see ground/1),  _H_a_s_h_K_e_y is unified  with
    a  positive integer  value that may  be used  as a hash  key to  the
    value.    If _T_e_r_m  is not ground,  the predicate  leaves _H_a_s_h_K_e_y  an
    unbound  variable.   Hash  keys are  in the  range 0:::16;777; 215, the
    maximal  integer that can  be stored efficiently  on both 32 and  64
    bit platforms.

    This  predicate may  be  used to  build hash  tables as  well as  to
    exploit argument indexing to find complex terms more quickly.

    The  hash key does not rely on temporary information  like addresses
    of  atoms and  may be  assumed constant  over different  invocations
    and  versions of SWI-Prolog.   Hashes differ between big and  little
    endian machines.  The term_hash/2 predicate is cycle-safe.


tteerrmm__hhaasshh((_+_T_e_r_m_, _+_D_e_p_t_h_, _+_R_a_n_g_e_, _-_H_a_s_h_K_e_y))                         _[_d_e_t_]
    As  term_hash/2, but  only considers  _T_e_r_m to  the specified  _D_e_p_t_h.
    The  top-level term has  depth 1, its arguments  have depth 2,  etc.
    That  is, _D_e_p_t_h =0  hashes nothing;  _D_e_p_t_h= 1 hashes  atomic values
    or  the functor  and arity of  a compound term,  not its  arguments;
    _D_e_p_t_h =2 also indexes the immediate arguments, etc.

    _H_a_s_h_K_e_y  is in the range  [0:::_R_a_n_g_e-1].   _R_a_n_g_e must be  in the range
    [1:::2147483647]


vvaarriiaanntt__sshhaa11((_+_T_e_r_m_, _-_S_H_A_1))                                         _[_d_e_t_]
    Compute  a  SHA1-hash from  _T_e_r_m.    The hash  is represented  as  a
    40-byte  hexadecimal atom.    Unlike term_hash/2  and friends,  this
    predicate  produces a hash  key for non-ground terms.   The hash  is
    invariant  over  variable-renaming (see  =@=/2) and  constants  over
    different invocations of Prolog.

    This  predicate raises an exception when trying to compute  the hash
    on  a cyclic  term or  attributed term.   Attributed  terms are  not
    handled  because subsumes_chk/2 is not  considered well defined  for
    attributed  terms.    Cyclic terms  are not  supported because  this
    would  require  establishing a  canonical cycle.    That  is,  given
    A=[a_A]  and B=[a,a_B], _A and _B should produce the same hash.   This
    is not (yet) implemented.

    This  hash was developed  for lookup of  solutions to a goal  stored
    in  a table.   By using a  cryptographic hash, heuristic  algorithms
    can  often ignore the possibility of hash collisions and  thus avoid
    storing the goal term itself as well as testing using =@=/2.


44..1144 DDeeccllaarriinngg pprreeddiiccaattee pprrooppeerrttiieess

This  section  describes  directives  which  manipulate   attributes  of
predicate   definitions.      The   functors   dynamic/1,   multifile/1,
discontiguous/1 and public/1 are operators of priority  1150 (see op/3),
which implies  that the list  of predicates they involve  can just be  a
comma-separated list:

________________________________________________________________________|                                                                        |
|:- dynamic                                                              |

|        foo/0,                                                          |
||_______baz/2._________________________________________________________ ||

In SWI-Prolog all  these directives are just  predicates.  This  implies
they can also  be called by a program.   Do not rely on this  feature if
you want to maintain portability to other Prolog implementations.


ddyynnaammiicc _:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_, _._._.                                  _[_I_S_O_]
    Informs  the interpreter  that  the definition  of the  predicate(s)
    may  change during execution (using assert/1 and/or retract/1).   In
    the  multithreaded version,  the clauses  of dynamic predicates  are
    shared  between the threads.  The  directive thread_local/1 provides
    an  alternative where each  thread has its  own clause list for  the
    predicate.   Dynamic predicates can be turned into static ones using
    compile_predicates/1.


ccoommppiillee__pprreeddiiccaatteess((_:_L_i_s_t_O_f_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_s))
    Compile  a list of specified  dynamic predicates (see dynamic/1  and
    assert/1)  into  normal static  predicates.    This call  tells  the
    Prolog  environment  the  definition  will not  change  anymore  and
    further  calls  to assert/1  or retract/1  on  the named  predicates
    raise  a permission error.  This predicate is designed to  deal with
    parts  of  the program  that are  generated at  runtime  but do  not
    change during the remainder of the program execution.


mmuullttiiffiillee _:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_, _._._.                                _[_I_S_O_]
    Informs  the system that the  specified predicate(s) may be  defined
    over  more than one  file.  This  stops consult/1 from redefining  a
    predicate when a new definition is found.


ddiissccoonnttiigguuoouuss _:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_, _._._.                            _[_I_S_O_]
    Informs  the system that the  clauses of the specified  predicate(s)
    might not be together in the source file.  See also style_check/1.


ppuubblliicc _:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_, _._._.
    Instructs  the cross-referencer  that the predicate  can be  called.
    It  has no semantics.   The public declaration can be queried  using
    predicate_property/2.   The public/1  directive does _n_o_t export  the
    predicate  (see module/1  and export/1).   The  public directive  is
    used for (1) direct  calls into the module from, e.g., foreign code,
    (2)  direct calls into the module from other modules, or (3)  flag a
    predicate  as being called if the call is generated  by meta-calling
    constructs that are not analysed by the cross-referencer.


44..1155 EExxaammiinniinngg tthhee pprrooggrraamm


ccuurrrreenntt__aattoomm((_-_A_t_o_m))
    Successively unifies _A_t_o_m with  all atoms known to the system.  Note
    that  current_atom/1 always succeeds if  _A_t_o_m is instantiated to  an
    atom.


ccuurrrreenntt__bblloobb((_?_B_l_o_b_, _?_T_y_p_e))
    Examine the type or  enumerate blobs of the given _T_y_p_e.  Typed blobs
    are  supported through  the foreign language  interface for  storing
    arbitrary  BLOBs  (Binary  Large  Object)  or  handles  to  external
    entities.  See section 10.4.7 for details.


ccuurrrreenntt__ffuunnccttoorr((_?_N_a_m_e_, _?_A_r_i_t_y))
    Successively unifies _N_a_m_e  with the name and _A_r_i_t_y with the arity of
    functors known to the system.


ccuurrrreenntt__ffllaagg((_-_F_l_a_g_K_e_y))
    Successively  unifies  _F_l_a_g_K_e_y with  all keys  used  for flags  (see
    flag/3).


ccuurrrreenntt__kkeeyy((_-_K_e_y))
    Successively  unifies  _K_e_y  with  all keys  used  for  records  (see
    recorda/3, etc.).


ccuurrrreenntt__pprreeddiiccaattee((_:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r))                             _[_I_S_O_]
    True  if _P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r  is a  currently defined predicate.    A
    predicate  is  considered  defined if  it  exists in  the  specified
    module,  is  imported  into  the module  or  is defined  in  one  of
    the  modules from  which the  predicate will  be imported  if it  is
    called  (see  section  6.9).    Note  that current_predicate/1  does
    _n_o_t  succeed  for predicates  that  can be  _a_u_t_o_l_o_a_d_e_d.    See  also
    current_predicate/2 and predicate_property/2.

    If  _P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r is  not fully specified,  the predicate  only
    generates  values  that  are defined  in  or already  imported  into
    the  target module.   Generating  all callable predicates  therefore
    requires  enumerating modules  using current_module/1.    Generating
    predicates   callable  in  a   given  module  requires   enumerating
    the  import  modules  using  import_module/2  and  the  autoloadable
    predicates using the predicate_property/2 autoload.


ccuurrrreenntt__pprreeddiiccaattee((_?_N_a_m_e_, _:_H_e_a_d))
    Classical  pre-ISO implementation of current_predicate/1, where  the
    predicate  is represented by the head  term.  The advantage is  that
    this  can be used for checking  the existence of a predicate  before
    calling it without the need for functor/3:

    ____________________________________________________________________|                                                                    |
    | call_if_exists(G) :-                                               |

    |         current_predicate(_, G),                                   |
    ||________call(G).__________________________________________________ ||

    Because  of this intended  usage, current_predicate/2 also  succeeds
    if  the predicate can  be autoloaded.   Unfortunately, checking  the
    autoloader  makes  this  predicate relatively  slow,  in  particular
    because a failed  lookup of the autoloader will cause the autoloader
    to verify that its index is up-to-date.


pprreeddiiccaattee__pprrooppeerrttyy((_:_H_e_a_d_, _?_P_r_o_p_e_r_t_y))
    True  when _H_e_a_d refers  to a predicate  that has property  _P_r_o_p_e_r_t_y.
    With  sufficiently  instantiated  _H_e_a_d,  predicate_property/2  tries
    to  resolve  the   predicate  the  same  way  as  calling  it  would
    do:    if  the  predicate  is  not  defined  it  scans  the  default
    modules  (see default_module/2)  and finally  tries the  autoloader.
    Unlike  calling,   failure  to  find  the  target  predicate  causes
    predicate_property/2 to fail silently.  If  _H_e_a_d is not sufficiently
    bound,   only  currently   locally  defined  and  already   imported
    predicates are  enumerated.  See current_predicate/1 for enumerating
    all  predicates.   A common issue  concerns _g_e_n_e_r_a_t_i_n_g all  built-in
    predicates.  This can be achieved using the code below:

    ____________________________________________________________________|                                                                    |
    | generate_built_in(Name/Arity) :-                                   |

    |     predicate_property(system:Head, built_in),                     |
    |     functor(Head, Name, Arity),                                    |
    ||____\+_sub_atom(Name,_0,__,__,_$).___%_discard_reserved_names_____ ||

    _P_r_o_p_e_r_t_y is one of:

    aauuttoollooaadd((_F_i_l_e))
         True if  the predicate can  be autoloaded  from the file  _F_i_l_e.
         Like undefined, this property is _n_o_t generated.

    bbuuiilltt__iinn
         True if the predicate is locked as a built-in predicate.   This
         implies it cannot be redefined in its definition  module and it
         can normally not be seen in the tracer.

    ddyynnaammiicc
         True  if assert/1  and  retract/1 may  be  used to  modify  the
         predicate.  This property is set using dynamic/1.

    eexxppoorrtteedd
         True if  the predicate  is in the  public list  of the  context
         module.

    iimmppoorrtteedd__ffrroomm((_M_o_d_u_l_e))
         Is true if  the predicate is  imported into the context  module
         from module _M_o_d_u_l_e.

    ffiillee((_F_i_l_e_N_a_m_e))
         Unify  _F_i_l_e_N_a_m_e with  the  name of  the  source file  in  which
         the predicate  is  defined.    See also  source_file/2 and  the
         property line_count.   Note that this  reports the file of  the
         first clause of  a predicate.   A more robust interface can  be
         achieved using nth_clause/3 and clause_property/2.

    ffoorreeiiggnn
         True if the predicate is defined in the C language.

    iinnddeexxeedd((_I_n_d_e_x_e_s))
         _I_n_d_e_x_e_s  is  a  list  of  additional  (hash)   indexes  on  the
         predicate.  Each  element of the list is a  term _A_r_g_S_p_e_c-_I_n_d_e_x.
         Currently _A_r_g_S_p_e_c is an integer denoting the  argument position
         and _I_n_d_e_x  is  a term  hash(_B_u_c_k_e_t_s_, _S_p_e_e_d_u_p_,  _I_s_L_i_s_t).    Here
         _B_u_c_k_e_t_s is  the number of  buckets in the  hash and _S_p_e_e_d_u_p  is
         the expected speedup  relative to trying all clauses  linearly.
         _I_s_L_i_s_t indicates that  a list is  created for all clauses  with
         the same key.  This is currently not used.

    iinntteerrpprreetteedd
         True if  the predicate is defined  in Prolog.   We return  true
         on this because, although the code is actually  compiled, it is
         completely transparent, just like interpreted code.

    iissoo
         True if the predicate  is covered by the ISO  standard (ISO/IEC
         13211-1).

    lliinnee__ccoouunntt((_L_i_n_e_N_u_m_b_e_r))
         Unify _L_i_n_e_N_u_m_b_e_r with  the line number  of the first clause  of
         the predicate.   Fails if the predicate is not  associated with
         a file.   See also source_file/2.   See also the file  property
         above, notably the reference to clause_property/2.

    mmuullttiiffiillee
         True if there may  be multiple (or no) files  providing clauses
         for the predicate.  This property is set using multifile/1.

    mmeettaa__pprreeddiiccaattee((_H_e_a_d))
         If  the  predicate  is  declared  as  a   meta-predicate  using
         meta_predicate/1,  unify  _H_e_a_d with  the  head-pattern.     The
         head-pattern  is  a  compound  term  with  the  same  name  and
         arity as  the predicate where  each argument of  the term is  a
         meta-predicate specifier.  See meta_predicate/1 for details.

    nnooddeebbuugg
         Details of the predicate are  not shown by the debugger.   This
         is the default  for built-in predicates.   User predicates  can
         be compiled this way using the Prolog flag generate_debug_info.

    nnoottrraaccee
         Do not show ports of this predicate in the debugger.

    nnuummbbeerr__ooff__ccllaauusseess((_C_l_a_u_s_e_C_o_u_n_t))
         Unify _C_l_a_u_s_e_C_o_u_n_t to the number of clauses  associated with the
         predicate.  Fails for foreign predicates.

    nnuummbbeerr__ooff__rruulleess((_R_u_l_e_C_o_u_n_t))
         Unify  _R_u_l_e_C_o_u_n_t  to the  number  of  clauses  associated  with
         the  predicate.   A  _r_u_l_e  is defined  as  a clauses  that  has
         a body  that  is not  just true  (i.e.,  a _f_a_c_t).    Fails  for
         foreign predicates.   This property is used to  avoid analysing
         predicates with only facts in prolog_codewalk.

    ppuubblliicc
         Predicate  is  declared public  using  public/1.     Note  that
         without further  definition, public  predicates are  considered
         undefined and this property is _n_o_t reported.

    qquuaassii__qquuoottaattiioonn__ssyynnttaaxx((_T))
         he  predicate (with  arity  4)  is declared  to  provide  quasi
         quotation syntax with quasi_quotation_syntax/1.

    ssttaattiicc
         The  definition  can  _n_o_t  be  modified  using   assertz/1  and
         friends.   This property  is the opposite  from dynamic,  i.e.,
         for each defined  predicate, either static  or dynamic is  true
         but never both.

    tthhrreeaadd__llooccaall
         If  true (only  possible  on  the multithreaded  version)  each
         thread has its  own clauses for the  predicate.  This  property
         is set using thread_local/1.

    ttrraannssppaarreenntt
         True  if  the  predicate  is  declared  transparent  using  the
         module_transparent/1 or meta_predicate/1 declaration.   In  the
         latter case the property meta_predicate(_H_e_a_d) is also provided.
         See chapter 6 for details.

    uunnddeeffiinneedd
         True if a procedure definition block for  the predicate exists,
         but there are no clauses for it and it is  not declared dynamic
         or multifile.   This  is true  if the predicate  occurs in  the
         body of  a loaded  predicate, an  attempt to call  it has  been
         made via  one of  the meta-call predicates,  the predicate  has
         been declared as  e.g., a meta-predicate  or the predicate  had
         a definition in  the past.   See the library package check  for
         example usage.

    vviissiibbllee
         True when predicate can  be called without raising a  predicate
         existence  error.    This  means  that  the  predicate  is  (1)
         defined, (2) can be  inherited from one of the  default modules
         (see default_module/2) or (3) can be autoloaded.  The behaviour
         is logically  consistent iff the  property visible is  provided
         explicitly.   If  the property  is left  unbound, only  defined
         predicates are enumerated.

    vvoollaattiillee
         If true,  the  clauses are  not  saved into  a saved  state  by
         qsave_program/[1,2].  This property is set using volatile/1.


ddwwiimm__pprreeddiiccaattee((_+_T_e_r_m_, _-_D_w_i_m))
    `Do  What I  Mean'  (`dwim') support  predicate.   _T_e_r_m  is a  term,
    whose  name and arity are used  as a predicate specification.   _D_w_i_m
    is  instantiated with the most general term built from _N_a_m_e  and the
    arity  of a defined predicate  that matches the predicate  specified
    by  _T_e_r_m in the `Do  What I Mean' sense.   See dwim_match/2 for  `Do
    What  I Mean' string matching.   Internal system predicates are  not
    generated,  unless the  access level  is system  (see access_level).
    Backtracking provides all alternative matches.


ccllaauussee((_:_H_e_a_d_, _?_B_o_d_y))                                              _[_I_S_O_]
    True  if  _H_e_a_d can  be unified  with  a clause  head and  _B_o_d_y  with
    the  corresponding  clause  body.    Gives  alternative  clauses  on
    backtracking.  For facts, _B_o_d_y is unified with the atom _t_r_u_e.


ccllaauussee((_:_H_e_a_d_, _?_B_o_d_y_, _?_R_e_f_e_r_e_n_c_e))
    Equivalent  to  clause/2,   but  unifies  _R_e_f_e_r_e_n_c_e  with  a  unique
    reference to the  clause (see also assert/2, erase/1).  If _R_e_f_e_r_e_n_c_e
    is  instantiated to a reference the  clause's head and body will  be
    unified with _H_e_a_d and _B_o_d_y.


nntthh__ccllaauussee((_?_P_r_e_d_, _?_I_n_d_e_x_, _?_R_e_f_e_r_e_n_c_e))
    Provides  access to  the clauses  of a predicate  using their  index
    number.    Counting  starts at  1.   If  _R_e_f_e_r_e_n_c_e  is specified  it
    unifies  _P_r_e_d with the  most general term  with the same  name/arity
    as  the predicate  and _I_n_d_e_x with  the index  number of the  clause.
    Otherwise  the name  and arity  of _P_r_e_d  are used  to determine  the
    predicate.   If  _I_n_d_e_x is provided,  _R_e_f_e_r_e_n_c_e will be unified  with
    the  clause  reference.   If  _I_n_d_e_x  is unbound,  backtracking  will
    yield  both the  indexes and the  references of  all clauses of  the
    predicate.  The following example finds the 2nd clause of append/3:

    ____________________________________________________________________|                                                                    |
    | ?- use_module(library(lists)).                                     |

    | ...                                                                |
    | ?- nth_clause(append(_,_,_), 2, Ref), clause(Head, Body, Ref).     |
    | Ref = <clause>(0x994290),                                          |
    | Head = lists:append([_G23|_G24], _G21, [_G23|_G27]),               |
    ||Body_=_append(_G24,__G21,__G27).__________________________________ ||


ccllaauussee__pprrooppeerrttyy((_+_C_l_a_u_s_e_R_e_f_, _-_P_r_o_p_e_r_t_y))
    Queries  properties  of   a  clause.     _C_l_a_u_s_e_R_e_f  is  a  reference
    to   a   clause   as   produced   by   clause/3,   nth_clause/3   or
    prolog_frame_attribute/3.  Unlike most other predicates  that access
    clause references,  clause_property/2may be used  to get information
    about erased clauses that  have not yet been reclaimed.  _P_r_o_p_e_r_t_y is
    one of the following:

    ffiillee((_F_i_l_e_N_a_m_e))
         Unify _F_i_l_e_N_a_m_e with  the name of the  file in which the  clause
         textually appears.   Fails if the clause is created  by loading
         a  file (e.g.,  clauses  added  using  assertz/1).    See  also
         source.

    lliinnee__ccoouunntt((_L_i_n_e_N_u_m_b_e_r))
         Unify _L_i_n_e_N_u_m_b_e_r with the line number of the clause.   Fails if
         the clause is not associated to a file.

    ssiizzee((_S_i_z_e_I_n_B_y_t_e_s))
         True when  _S_i_z_e_I_n_B_y_t_e_s  is the  size that  the  clause uses  in
         memory  in bytes.    The  size  required  by a  predicate  also
         includes the predicate data  record, a linked list of  clauses,
         clause  selection  instructions  and  optionally  one  or  more
         clause indexes.

    ssoouurrccee((_F_i_l_e_N_a_m_e))
         Unify _F_i_l_e_N_a_m_e with  the name of  the source file that  created
         the clause.   This  is the  same as the  file property,  unless
         the file  is  loaded from  a file  that  is textually  included
         into source  using include/1.   In this  scenario, file is  the
         included file,  while the  source property refers  to the  _m_a_i_n
         file.

    ffaacctt
         True if the clause has no body.

    eerraasseedd
         True if  the  clause has  been erased,  but  not yet  reclaimed
         because it is referenced.

    pprreeddiiccaattee((_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r))
         _P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r denotes the  predicate to which this  clause
         belongs.    This  is needed  to  obtain information  on  erased
         clauses because the usual way to obtain  this information using
         clause/3 fails for erased clauses.

    mmoodduullee((_M_o_d_u_l_e))
         _M_o_d_u_l_e is the  context module used to  execute the body of  the
         clause.   For normal clauses,  this is the  same as the  module
         in which  the  predicate is  defined.    However, if  a  clause
         is compiled with  a module qualified  _h_e_a_d, the clause  belongs
         to the  predicate with the  qualified head,  while the body  is
         executed in the context  of the module in which the  clause was
         defined.


44..1166 IInnppuutt aanndd oouuttppuutt

SWI-Prolog provides two  different packages for input  and output.   The
native  I/O system  is  based on  the  ISO standard  predicates  open/3,
close/1 and  friends.   Being more widely portable  and equipped with  a
clearer and  more robust specification,  new code  is encouraged to  use
these predicates for manipulation of I/O streams.

Section 4.16.3  describes tell/1,  see/1 and friends,  providing I/O  in
the spirit  of the  traditional Edinburgh  standard.   These  predicates
are layered  on top  of the  ISO predicates.   Both  packages are  fully
integrated; the user may switch freely between them.


44..1166..11 PPrreeddeeffiinneedd ssttrreeaamm aalliiaasseess

Each  thread  has   five  stream  aliases:     user_input,   user_output,
user_error, current_input, and  current_output.   Newly created  threads
inherit  these  stream aliases  from  their  parent.    The  user_input,
user_output and  user_error aliases  of the  main  thread are  initially
bound to  the standard operating system  I/O streams (_s_t_d_i_n, _s_t_d_o_u_t  and
_s_t_d_e_r_r, normally  bound to the POSIX  file handles 0, 1  and 2).   These
aliases may be re-bound, for example if standard I/O  refers to a window
such as in  the swipl-win.exe GUI executable for  Windows.  They can  be
re-bound by  the user using set_prolog_IO/3 and set_stream/2 by  setting
the  alias of  a stream  (e.g,  set_stream(S, alias(user_output))).    An
example of  rebinding can be  found in library  prolog_server,  providing
a telnet service.   The aliases  current_input  and current_output  define
the source  and destination  for predicates  that do not  take a  stream
argument (e.g.,  read/1, write/1,  get_code/1, ...).   Initially,  these
are  bound to  the  same stream  as  user_input and  user_error.    They
are  re-bound by  see/1,  tell/1,  set_input/1 and  set_output/1.    The
current_output stream  is  also temporary  re-bound  by with_output_to/2
or  format/3 using  e.g., format(atom(A), ....    Note  that code  which
explicitly writes to the streams  user_output and  user_error will  not be
redirected by with_output_to/2.

CCoommppaattiibbiilliittyy Note  that  the  ISO  standard  only  defines  the  user_*
streams.   The `current' streams  can be accessed  using current_input/1
and current_output/1.  For example, an ISO compatible  implementation of
write/1 is

________________________________________________________________________|                                                                        |
|write(Term)|:-_current_output(Out),_write_term(Out,_Term)._____________ |           |

while SWI-Prolog additionally allows for

________________________________________________________________________|                                                                        |

|write(Term)|:-_write(current_output,_Term).____________________________ |           |


44..1166..22 IISSOO IInnppuutt aanndd OOuuttppuutt SSttrreeaammss

The  predicates described  in this  section provide  ISO compliant  I/O,
where streams are  explicitly created using the  predicate open/3.   The
resulting  stream  identifier is  then  passed  as a  parameter  to  the
reading and writing  predicates to specify the source or  destination of
the data.

This schema  is not  vulnerable to  filename and  stream ambiguities  as
well as changes to the working directory.  On the  other hand, using the
notion of  current-I/O simplifies reusability of  code without the  need
to pass arguments around.  E.g., see with_output_to/2.

SWI-Prolog streams are,  compatible with the ISO standard,  either input
or output streams.  To accommodate portability to  other systems, a pair
of streams  can be  packed into a  _s_t_r_e_a_m_-_p_a_i_r.   See  stream_pair/3 for
details.

SWI-Prolog stream  handles are unique symbols  that have no  syntactical
representation.  They are written as <stream>(hex-number),  which is not
valid input for read/1.   They are realised using a _b_l_o_b of  type stream
(see blob/2 and section 10.4.7).


ooppeenn((_+_S_r_c_D_e_s_t_, _+_M_o_d_e_, _-_-_S_t_r_e_a_m_, _+_O_p_t_i_o_n_s))                         _[_I_S_O_]
    True  when  _S_r_c_D_e_s_t can  be opened  in  _M_o_d_e and  _S_t_r_e_a_m is  an  I/O
    stream  to/from the  object.    _S_r_c_D_e_s_t is  normally the  name of  a
    file,  represented as  an atom  or string.    _M_o_d_e is  one of  read,
    write,  append or update.   Mode append opens the file  for writing,
    positioning  the file pointer  at the  end.   Mode update opens  the
    file  for writing, positioning the file pointer at the  beginning of
    the file without truncating  the file.  _S_t_r_e_a_m is either a variable,
    in  which case it is bound to an integer identifying the  stream, or
    an atom, in which case this atom will be the stream identifier.

    SWI-Prolog  also allows  _S_r_c_D_e_s_t to  be a  term pipe(_C_o_m_m_a_n_d).    In
    this  form, _C_o_m_m_a_n_d  is started as  a child process  and if _M_o_d_e  is
    write,  output written to  _S_t_r_e_a_m is sent  to the standard input  of
    _C_o_m_m_a_n_d.   Viso versa, if _M_o_d_e  is read, data written by  _C_o_m_m_a_n_d to
    the  standard output  may be  read from _S_t_r_e_a_m.    On Unix  systems,
    _C_o_m_m_a_n_d  is handed to popen() which hands it to the Unix shell.   On
    Windows,  _C_o_m_m_a_n_d is executed  directly.  See  also process_create/3
    from process.

    The following _O_p_t_i_o_n_s are recognised by open/4:

    aalliiaass((_A_t_o_m))
         Gives the  stream a name.   Below  is an example.   Be  careful
         with  this option  as  stream  names  are global.     See  also
         set_stream/2.

         _______________________________________________________________|                                                               |
         |?- open(data, read, Fd, [alias(input)]).                       |

         |                                                               |
         |        ...,                                                   |
         |        read(input, Term),                                     |
         ||_______...___________________________________________________ ||

    bboomm((_B_o_o_l))
         Check for a BOM (_B_y_t_e _O_r_d_e_r _M_a_r_k_e_r) or write one.   If omitted,
         the default  is true for  mode read and  false for mode  write.
         See also stream_property/2 and especially section  2.18.1.1 for
         a discussion of this feature.

    bbuuffffeerr((_B_u_f_f_e_r_i_n_g))
         Defines output  buffering.    The atom  full (default)  defines
         full buffering, line buffering  by line, and false implies  the
         stream is  fully unbuffered.   Smaller  buffering is useful  if
         another process or the user is waiting for the output  as it is
         being produced.   See also flush_output/[0,1].  This option  is
         not an ISO option.

    cclloossee__oonn__aabboorrtt((_B_o_o_l))
         If  true (default),  the  stream is  closed  on an  abort  (see
         abort/0).   If  false, the  stream is  not closed.    If it  is
         an output  stream, however,  it will  be flushed.   Useful  for
         logfiles and if  the stream is  associated to a process  (using
         the pipe/1 construct).

    ccrreeaattee((_+_L_i_s_t))
         Specifies how  a new  file is  created when  opening in  write,
         append or  update mode.   Currently,  _L_i_s_t is  a list of  atoms
         that describe  the permissions of  the created  file.   Defined
         values are below.  Not recognised values  are silently ignored,
         allowing for adding platform specific extensions to this set.

         rreeaadd
             Allow read access to the file.

         wwrriittee
             Allow write access to the file.

         eexxeeccuuttee
             Allow execution access to the file.

         ddeeffaauulltt
             Allow read and write access to the file.

         aallll
             Allow any access provided by the OS.

         Note that if _L_i_s_t is empty, the created file  has no associated
         access permissions.   The create options map to the  POSIX _m_o_d_e
         option of  open(), where read  map to 0444,  write to 0222  and
         execute to  0111.   On POSIX systems,  the final permission  is
         defined as (mode & ~umask).

    eennccooddiinngg((_E_n_c_o_d_i_n_g))
         Define the encoding used  for reading and writing text  to this
         stream.   The default  encoding for type  text is derived  from
         the Prolog  flag  encoding.   For  binary  streams the  default
         encoding  is octet.     For details  on  encoding  issues,  see
         section 2.18.1.

    eeooff__aaccttiioonn((_A_c_t_i_o_n))
         Defines  what  happens  if the  end  of  the  input  stream  is
         reached.  Action  eof_code  makes get0/1 and friends return  -1,
         and read/1 and friends return the atom end_of_file.  Repetitive
         reading keeps yielding the  same result.  Action error  is like
         eof_code, but repetitive  reading will  raise an error.    With
         action reset,  Prolog will  examine the file  again and  return
         more data if the file has grown.

    llooccaallee((_+_L_o_c_a_l_e))
         Set the locale that  is used by notably format/2 for  output on
         this stream.  See section 4.22.

    lloocckk((_L_o_c_k_i_n_g_M_o_d_e))
         Try to obtain a lock on the open file.  Default  is none, which
         does not lock the file.   The value read or shared  means other
         processes may  read the  file, but  not write  it.   The  value
         write or  exclusive means no  other process  may read or  write
         the file.

         Locks are  acquired through  the POSIX  function fcntl()  using
         the command F_SETLKW, which makes  a blocked call wait for  the
         lock to  be  released.    Please note  that fcntl()  locks  are
         _a_d_v_i_s_o_r_y and therefore  only other applications using the  same
         advisory locks  honour your  lock.   As there  are many  issues
         around locking  in  Unix, especially  related  to NFS  (network
         file  system), please  study  the  fcntl() manual  page  before
         trusting your locks!

         The lock option is a SWI-Prolog extension.

    ttyyppee((_T_y_p_e))
         Using type text (default), Prolog will write a text  file in an
         operating system compatible way.   Using type binary  the bytes
         will be read or written without any translation.   See also the
         option encoding.

    wwaaiitt((_B_o_o_l))
         This option  can be combined with  the lock option.   If  false
         (default  true), the  open  call  returns immediately  with  an
         exception if the file is locked.  The exception  has the format
         permission_error(_l_o_c_k_, _s_o_u_r_c_e___s_i_n_k_, _S_r_c_D_e_s_t).

    The  option reposition is not supported in SWI-Prolog.   All streams
    connected to a file may be repositioned.


ooppeenn((_+_S_r_c_D_e_s_t_, _+_M_o_d_e_, _-_-_S_t_r_e_a_m))                                   _[_I_S_O_]
    Equivalent to open/4 with an empty option list.


ooppeenn__nnuullll__ssttrreeaamm((_-_-_S_t_r_e_a_m))
    Open  an  output stream  that  produces no  output.    All  counting
    functions  are enabled on such a stream.  It can be  used to discard
    output  (like Unix  /dev/null) or exploit  the counting  properties.
    The  initial encoding of _S_t_r_e_a_m is utf8, enabling  arbitrary Unicode
    output.    The  encoding can  be changed  to  determine byte  counts
    of  the output  in a particular  encoding or  validate if output  is
    possible  in a  particular encoding.   For example,  the code  below
    determines the number of characters emitted when writing _T_e_r_m.

    ____________________________________________________________________|                                                                    |
    | write_length(Term, Len) :-                                         |

    |         open_null_stream(Out),                                     |
    |         write(Out, Term),                                          |
    |         character_count(Out, Len0),                                |
    |         close(Out),                                                |
    ||________Len_=_Len0._______________________________________________ ||


cclloossee((_+_S_t_r_e_a_m))                                                    _[_I_S_O_]
    Close  the specified stream.   If _S_t_r_e_a_m  is not open, an  existence
    error is  raised.  See stream_pair/3for  the implications of closing
    a _s_t_r_e_a_m _p_a_i_r.

    If  the closed stream is the current input, output or  error stream,
    the  stream alias is  bound to the  initial standard I/O streams  of
    the  process.  Calling close/1  on the initial standard I/O  streams
    of the process is  a no-op for an input stream and flushes an output
    stream without closing it.


cclloossee((_+_S_t_r_e_a_m_, _+_O_p_t_i_o_n_s))                                          _[_I_S_O_]
    Provides  close(_S_t_r_e_a_m_, _[_f_o_r_c_e_(_t_r_u_e_)_]) as the  only option.   Called
    this  way, any resource errors (such as write errors  while flushing
    the output buffer) are ignored.


ssttrreeaamm__pprrooppeerrttyy((_?_S_t_r_e_a_m_, _?_S_t_r_e_a_m_P_r_o_p_e_r_t_y))                          _[_I_S_O_]
    ISO  compatible  predicate  for  querying the  status  of  open  I/O
    streams.  _S_t_r_e_a_m_P_r_o_p_e_r_t_y is one of:

    aalliiaass((_A_t_o_m))
         If _A_t_o_m is bound,  test if the stream has the  specified alias.
         Otherwise unify _A_t_o_m with the first alias of the stream.

    bbuuffffeerr((_B_u_f_f_e_r_i_n_g))
         SWI-Prolog  extension  to query  the  buffering  mode  of  this
         stream.   _B_u_f_f_e_r_i_n_g is one of  full, line or  false.  See  also
         open/4.

    bbuuffffeerr__ssiizzee((_I_n_t_e_g_e_r))
         SWI-Prolog  extension to  query  the  size of  the  I/O  buffer
         associated to a  stream in bytes.   Fails if the stream is  not
         buffered.

    bboomm((_B_o_o_l))
         If present  and  true, a  BOM (_B_y_t_e  _O_r_d_e_r  _M_a_r_k) was  detected
         while opening the file for reading, or a BOM  was written while
         opening the stream.  See section 2.18.1.1 for details.

    cclloossee__oonn__aabboorrtt((_B_o_o_l))
         Determine  whether or  not  abort/0  closes  the stream.     By
         default streams are closed.

    cclloossee__oonn__eexxeecc((_B_o_o_l))
         Determine whether or  not the stream  is closed when  executing
         a new  process (exec()  in Unix,  CreateProcess() in  Windows).
         Default  is  to   close  streams.      This  maps  to   fcntl()
         F_SETFD  using  the  flag  FD_CLOEXEC   on  Unix  and  (negated)
         HANDLE_FLAG_INHERIT on Windows.

    eennccooddiinngg((_E_n_c_o_d_i_n_g))
         Query the encoding  used for text.   See section 2.18.1 for  an
         overview of wide character and encoding issues in SWI-Prolog.

    eenndd__ooff__ssttrreeaamm((_E))
         If _S_t_r_e_a_m is  an input stream,  unify _E with  one of the  atoms
         not, at or past.  See also at_end_of_stream/[0,1].

    eeooff__aaccttiioonn((_A))
         Unify _A with one of  eof_code,  reset or error.  See  open/4 for
         details.

    ffiillee__nnaammee((_A_t_o_m))
         If _S_t_r_e_a_m is  associated to a file,  unify _A_t_o_m to the name  of
         this file.

    ffiillee__nnoo((_I_n_t_e_g_e_r))
         If  the stream  is associated  with  a POSIX  file  descriptor,
         unify  _I_n_t_e_g_e_r  with   the  descriptor  number.      SWI-Prolog
         extension used  primarily  for integration  with foreign  code.
         See also Sfileno() from SWI-Stream.h.

    iinnppuutt
         True if _S_t_r_e_a_m has mode read.

    llooccaallee((_L_o_c_a_l_e))
         True when  _L_o_c_a_l_e is  the  current locale  associated with  the
         stream.  See section 4.22.

    mmooddee((_I_O_M_o_d_e))
         Unify  _I_O_M_o_d_e to  the  mode given  to  open/4 for  opening  the
         stream.   Values are:  read,  write, append and the  SWI-Prolog
         extension update.

    nneewwlliinnee((_N_e_w_l_i_n_e_M_o_d_e))
         One of posix or dos.   If dos, text streams will emit  \r\n for
         \n and discard \r from  input streams.  Default depends  on the
         operating system.

    nnlliinnkk((_-_C_o_u_n_t))
         Number of hard  links to the file.   This expresses the  number
         of `names'  the  file has.    Not  supported on  all  operating
         systems and the  value might be bogus.   See the  documentation
         of fstat() for your OS and the value st_nlink.

    oouuttppuutt
         True if _S_t_r_e_a_m has mode write, append or update.

    ppoossiittiioonn((_P_o_s))
         Unify  _P_o_s  with  the  current  stream  position.     A  stream
         position is an opaque term whose fields can  be extracted using
         stream_position_data/3.  See also set_stream_position/2.

    rreeppoossiittiioonn((_B_o_o_l))
         Unify _B_o_o_l with _t_r_u_e if  the position of the stream can  be set
         (see seek/4).   It is  assumed the position  can be set if  the
         stream has  a _s_e_e_k_-_f_u_n_c_t_i_o_n and  is not based  on a POSIX  file
         descriptor that is not associated to a regular file.

    rreepprreesseennttaattiioonn__eerrrroorrss((_M_o_d_e))
         Determines behaviour of  character output if the stream  cannot
         represent a  character.   For  example, an  ISO Latin-1  stream
         cannot represent  Cyrillic characters.   The  behaviour is  one
         of error (throw  an I/O error  exception), prolog (write  \...\
         escape code) or xml  (write &#...; XML character entity).   The
         initial mode is prolog  for the user streams and error  for all
         other streams.  See also section 2.18.1 and set_stream/2.

    ttiimmeeoouutt((_-_T_i_m_e))
         _T_i_m_e is the timeout currently associated with the stream.   See
         set_stream/2 with the same option.  If no timeout is specified,
         _T_i_m_e is unified to the atom infinite.

    ttyyppee((_T_y_p_e))
         Unify _T_y_p_e with text or binary.

    ttttyy((_B_o_o_l))
         This  property is  reported  with _B_o_o_l  equal  to true  if  the
         stream is associated with a terminal.  See also set_stream/2.


ccuurrrreenntt__ssttrreeaamm((_?_O_b_j_e_c_t_, _?_M_o_d_e_, _?_S_t_r_e_a_m))
    The  predicate current_stream/3 is  used to access  the status of  a
    stream  as well  as to generate  all open  streams.   _O_b_j_e_c_t is  the
    name  of the file opened  if the stream refers  to an open file,  an
    integer  file descriptor  if  the stream  encapsulates an  operating
    system  stream, or the  atom [] if the  stream refers to some  other
    object.  _M_o_d_e is one of read or write.


iiss__ssttrreeaamm((_+_T_e_r_m))
    True  if  _T_e_r_m is  a  stream name  or  valid stream  handle.    This
    predicate  realises a safe test for the existence of a  stream alias
    or handle.


ssttrreeaamm__ppaaiirr((_?_S_t_r_e_a_m_P_a_i_r_, _?_R_e_a_d_, _?_W_r_i_t_e))
    This  predicate can be used in mode (-,+,+) to create  a _s_t_r_e_a_m_-_p_a_i_r
    from  an input stream  and an output  stream.   Mode (+,-,-) can  be
    used  to get  access to the  underlying streams.   If  a stream  has
    already  been closed,  the corresponding  argument is left  unbound.
    If mode (+,-,-) is  used on a single stream, either _R_e_a_d or _W_r_i_t_e is
    unified  with the stream while  the other argument is left  unbound.
    This  behaviour simplifies  writing code that  must operate both  on
    streams and stream pairs.

    Stream-pairs  can be used  by all I/O  operations on streams,  where
    the  operation selects  the appropriate  member of  the pair.    The
    predicate  close/1 closes the still open  streams of the pair.   The
    output  stream  is closed  before  the input  stream.    If  closing
    the  output stream results  in an error,  the input stream is  still
    closed.    Success  is only  returned if  both  streams were  closed
    successfully.


sseett__ssttrreeaamm__ppoossiittiioonn((_+_S_t_r_e_a_m_, _+_P_o_s))                                 _[_I_S_O_]
    Set  the current  position  of _S_t_r_e_a_m  to _P_o_s.    _P_o_s is  a term  as
    returned  by  stream_property/2 using  the  position(_P_o_s)  property.
    See also seek/4.


ssttrreeaamm__ppoossiittiioonn__ddaattaa((_?_F_i_e_l_d_, _+_P_o_s_, _-_D_a_t_a))
    Extracts  information from  the opaque stream  position term as  re-
    turned  by stream_property/2 requesting the position(_P_o_s)  property.
    _F_i_e_l_d is  one of line_count, line_position, char_count or byte_count.
    See   also  line_count/2,  line_position/2,   character_count/2  and
    byte_count/2.


sseeeekk((_+_S_t_r_e_a_m_, _+_O_f_f_s_e_t_, _+_M_e_t_h_o_d_, _-_N_e_w_L_o_c_a_t_i_o_n))
    Reposition the current point  of the given _S_t_r_e_a_m.  _M_e_t_h_o_d is one of
    bof,  current or eof, indicating positioning relative to  the start,
    current  point or  end of  the underlying  object.   _N_e_w_L_o_c_a_t_i_o_n  is
    unified with the new offset, relative to the start of the stream.

    Positions  are  counted in  `units'.    A  unit is  1  byte,  except
    for  text files  using 2-byte  Unicode encoding (2  bytes) or  _w_c_h_a_r
    encoding  (sizeof(wchar_t)).    The  latter  guarantees  comfortable
    interaction  with  wide-character  text objects.     Otherwise,  the
    use  of  seek/4  on non-binary  files  (see  open/4) is  of  limited
    use,  especially when using  multi-byte text encodings (e.g.  UTF-8)
    or   multi-byte  newline  files  (e.g.   DOS/Windows).     On   text
    files,   SWI-Prolog  offers  reliable  backup  to  an  old  position
    using  stream_property/2  and set_stream_position/2.    Skipping  N
    character  codes is  achieved calling  get_code/2 N times  or using
    copy_stream_data/3,  directing the  output  to  a null  stream  (see
    open_null_stream/1).   If  the seek modifies  the current  location,
    the line number and character position in the line are set to 0.

    If the  stream cannot be repositioned, a permission_error is raised.
    If  applying  the  offset  would  result in  a  file  position  less
    than  zero, a  domain_error  is raised.   Behaviour  when seeking  to
    positions  beyond the size  of the underlying  object depend on  the
    object  and possibly  the operating  system.   The predicate  seek/4
    is  compatible  with Quintus  Prolog,  though the  error  conditions
    and  signalling is ISO  compliant.   See also  stream_property/2 and
    set_stream_position/2.


sseett__ssttrreeaamm((_+_S_t_r_e_a_m_, _+_A_t_t_r_i_b_u_t_e))
    Modify  an attribute  of an  existing stream.   _A_t_t_r_i_b_u_t_e  specifies
    the   stream  property  to  set.      If  stream  is  a  _p_a_i_r   (see
    stream_pair/3)  both streams are  modified, unless  the property  is
    only  meaningful  on one  of  the streams  or  setting both  is  not
    meaningful.    In particular,  eof_action  only applies  to the  _r_e_a_d
    stream,  representation_errors  only  applies to  the  _w_r_i_t_e  stream
    and  trying to  set alias or  line_position  on a  pair results in  a
    permission_error exception.  See also stream_property/2 and open/4.

    aalliiaass((_A_l_i_a_s_N_a_m_e))
         Set the  alias of  an  already created  stream.   If  _A_l_i_a_s_N_a_m_e
         is  the name  of  one  of the  standard  streams,  this  stream
         is rebound.    Thus,  set_stream(S, current_input) is the  same
         as  set_input/1,  and  by  setting  the  alias of  a  stream  to
         user_input, etc.,  all user  terminal input is  read from  this
         stream.  See also interactor/0.

    bbuuffffeerr((_B_u_f_f_e_r_i_n_g))
         Set the buffering mode  of an already created stream.   Buffer-
         ing is one of full, line or false.

    bbuuffffeerr__ssiizzee((_+_S_i_z_e))
         Set the  size of  the I/O buffer  of the  underlying stream  to
         _S_i_z_e bytes.

    cclloossee__oonn__aabboorrtt((_B_o_o_l))
         Determine whether or not the  stream is closed by abort/0.   By
         default, streams are closed.

    cclloossee__oonn__eexxeecc((_B_o_o_l))
         Set the close_on_exec property.  See stream_property/2.

    eennccooddiinngg((_A_t_o_m))
         Defines the  mapping  between bytes  and character  codes  used
         for the stream.   See  section 2.18.1 for supported  encodings.
         The value bom  causes the stream  to check whether the  current
         character  is a  Unicode  BOM  marker.    If a  BOM  marker  is
         found, the encoding  is set accordingly and the call  succeeds.
         Otherwise the call fails.

    eeooff__aaccttiioonn((_A_c_t_i_o_n))
         Set end-of-file handling to one of eof_code, reset or error.

    ffiillee__nnaammee((_F_i_l_e_N_a_m_e))
         Set the filename associated to  this stream.  This call  can be
         used to set the file for error locations  if _S_t_r_e_a_m corresponds
         to _F_i_l_e_N_a_m_e and  is not obtained  by opening the file  directly
         but, for example, through a network service.

    lliinnee__ppoossiittiioonn((_L_i_n_e_P_o_s))
         Set the line  position attribute of the  stream.  This  feature
         is  intended  to correct  position  management  of  the  stream
         after sending  a terminal escape  sequence (e.g., setting  ANSI
         character  attributes).     Setting  this  attribute  raises  a
         permission error if the stream does not record positions.   See
         line_position/2 and stream_property/2(property position).

    llooccaallee((_+_L_o_c_a_l_e))
         Change the locale of the stream.  See section 4.22.

    nneewwlliinnee((_N_e_w_l_i_n_e_M_o_d_e))
         Set input or output translation for newlines.   See correspond-
         ing stream_property/2 for details.  In addition to the detected
         modes, an input stream can  be set in mode detect.  It  will be
         set to dos if a \r character was removed.

    ttiimmeeoouutt((_S_e_c_o_n_d_s))
         This option can be  used to make streams generate  an exception
         if it  takes longer than  _S_e_c_o_n_d_s before  any new data  arrives
         at  the  stream.    The  value  _i_n_f_i_n_i_t_e  (default)  makes  the
         stream block  indefinitely.   Like wait_for_input/3, this  call
         only  applies  to streams  that  support  the  select()  system
         call.   For  further information  about  timeout handling,  see
         wait_for_input/3.  The exception is of the form

             error(timeout_error_(_r_e_a_d_, _S_t_r_e_a_m_)_, __)

    ttyyppee((_T_y_p_e))
         Set the type of the stream to one of text or binary.   See also
         open/4 and  the encoding  property of  streams.   Switching  to
         binary sets the encoding to octet.  Switching to  text sets the
         encoding to the default text encoding.

    rreeccoorrdd__ppoossiittiioonn((_B_o_o_l))
         Do/do  not  record  the  line  count  and  line  position  (see
         line_count/2 and line_position/2).

    rreepprreesseennttaattiioonn__eerrrroorrss((_M_o_d_e))
         Change the  behaviour  when writing  characters to  the  stream
         that  cannot  be  represented  by  the  encoding.     See  also
         stream_property/2 and section 2.18.1.

    ttttyy((_B_o_o_l))
         Modify whether Prolog  thinks there is  a terminal (i.e.  human
         interaction) connected  to this stream.    On Unix systems  the
         initial value  comes from isatty().   On  Windows, the  initial
         user streams are supposed to be associated to a terminal.   See
         also stream_property/2.


sseett__pprroolloogg__IIOO((_+_I_n_, _+_O_u_t_, _+_E_r_r_o_r))
    Prepare  the   given  streams  for  interactive  behaviour  normally
    associated  to  the  terminal.     _I_n  becomes  the  user_input  and
    current_input  of  the calling  thread.    _O_u_t  becomes  user_output
    and  current_output.    If _E_r_r_o_r  equals  _O_u_t an  unbuffered  stream
    is  associated to  the same  destination and  linked to  user_error.
    Otherwise  _E_r_r_o_r is used for  user_error.   Output buffering for  _O_u_t
    is  set  to line  and buffering  on _E_r_r_o_r  is disabled.    See  also
    prolog/0  and set_stream/2.  The  _c_l_i_b package provides the  library
    prolog_server, creating a TCP/IP server for  creating an interactive
    session to Prolog.


44..1166..33 EEddiinnbbuurrgghh--ssttyyllee II//OO

The  package for  implicit  input and  output destinations  is  (almost)
compatible with Edinburgh DEC-10 and C-Prolog.  The  reading and writing
predicates  refer to,  resp.,  the  _c_u_r_r_e_n_t  input and  output  streams.
Initially these  streams are  connected to  the terminal.   The  current
output stream is  changed using tell/1 or  append/1.  The current  input
stream  is changed  using see/1.    The stream's  current  value can  be
obtained using telling/1 for output and seeing/1 for input.

Source  and   destination  are   either  a  file,   user,   or  a   term
`pipe(_C_o_m_m_a_n_d)'.  The reserved stream name user refers  to the terminal.
In the predicate descriptions below we will  call the source/destination
argument  `_S_r_c_D_e_s_t'.    Below are  some examples  of  source/destination
specifications.

         ?- see(data).        % Start reading from file `data'.
         ?- tell(user).       % Start writing to the terminal.
         ?- tell(pipe(lpr)).  % Start writing to the printer.

Another example  of using  the pipe/1 construct  is shown  below.   Note
that  the  pipe/1  construct  is  not  part  of  Prolog's  standard  I/O
repertoire.

________________________________________________________________________|                                                                        |
|getwd(Wd) :-                                                            |
|        seeing(Old), see(pipe(pwd)),                                    |

|        collect_wd(String),                                             |
|        seen, see(Old),                                                 |
|        atom_codes(Wd, String).                                         |
|                                                                        |
|collect_wd([C|R]) :-                                                    |
|        get0(C), C \== -1, !,                                           |
|        collect_wd(R).                                                  |

|collect_wd([]).|_______________________________________________________ |               |

The  effect of  tell/1 is  not  undone on  backtracking, and  since  the
stream  handle is  not specified  explicitly in  further I/O  operations
when  using Edinburgh-style  I/O, you  may write  to unintended  streams
more  easily  than  when using  ISO  compliant  I/O.  For  example,  the
following query writes both "a" and "b" into the file `out' :

________________________________________________________________________|                                                                        |
|?-|(tell(out),_write(a),_false_;_write(b)),_told.______________________ |  |


CCoommppaattiibbiilliittyy nnootteess

Unlike Edinburgh  Prolog systems, telling/1  and seeing/1 do not  return
the  filename  of  the  current  input/output  but   rather  the  stream
identifier,  to  ensure  the  design  pattern   below  works  under  all
circumstances:

________________________________________________________________________|                                                                        |
|        ...,                                                            |
|        telling(Old), tell(x),                                          |
|        ...,                                                            |

|        told, tell(Old),                                                |
||_______...,___________________________________________________________ ||

The predicates tell/1 and see/1 first check for  user, the pipe(_c_o_m_m_a_n_d)
and a stream handle.  Otherwise, if the argument is  an atom it is first
compared to  open streams  associated to  a file with  _e_x_a_c_t_l_y the  same
name.   If such a stream exists,  created using tell/1 or see/1,  output
(input) is  switched to  the open  stream.   Otherwise a  file with  the
specified name is opened.

The behaviour is compatible with Edinburgh Prolog.   This is not without
problems.   Changing  directory,  non-file streams,  and multiple  names
referring to  the same file  easily lead to unexpected  behaviour.   New
code, especially  when managing multiple  I/O channels, should  consider
using the ISO I/O predicates defined in section 4.16.2.


sseeee((_+_S_r_c_D_e_s_t))
    Open  _S_r_c_D_e_s_t  for  reading  and  make it  the  current  input  (see
    set_input/1).  If _S_r_c_D_e_s_t is a stream  handle, just make this stream
    the  current input.    See the  introduction of  section 4.16.3  for
    details.


tteellll((_+_S_r_c_D_e_s_t))
    Open  _S_r_c_D_e_s_t  for  writing and  make  it  the current  output  (see
    set_output/1).    If _S_r_c_D_e_s_t  is  a stream  handle,  just make  this
    stream  the current output.  See the introduction of  section 4.16.3
    for details.


aappppeenndd((_+_F_i_l_e))
    Similar  to tell/1,  but positions the  file pointer  at the end  of
    _F_i_l_e  rather than truncating an existing  file.  The pipe  construct
    is not accepted by this predicate.


sseeeeiinngg((_?_S_r_c_D_e_s_t))
    Same  as  current_input/1,  except  that user  is  returned  if  the
    current  input  is the  stream user_input  to improve  compatibility
    with   traditional   Edinburgh   I/O.  See   the   introduction   of
    section 4.16.3 for details.


tteelllliinngg((_?_S_r_c_D_e_s_t))
    Same  as  current_output/1, except  that  user  is returned  if  the
    current  output is the  stream user_output to improve  compatibility
    with   traditional   Edinburgh   I/O.  See   the   introduction   of
    section 4.16.3 for details.


sseeeenn
    Close  the  current input  stream.   The  new  input stream  becomes
    user_input.


ttoolldd
    Close  the current  output stream.   The  new output stream  becomes
    user_output.


44..1166..44 SSwwiittcchhiinngg bbeettwweeeenn EEddiinnbbuurrgghh aanndd IISSOO II//OO

The predicates below can be used for switching between  the implicit and
the explicit stream-based I/O predicates.


sseett__iinnppuutt((_+_S_t_r_e_a_m))                                                 _[_I_S_O_]
    Set   the  current   input  stream   to  become  _S_t_r_e_a_m.       Thus,
    open(file, read, Stream), set_input(Stream)    is   equivalent    to
    see(file).


sseett__oouuttppuutt((_+_S_t_r_e_a_m))                                                _[_I_S_O_]
    Set  the  current  output  stream  to  become  _S_t_r_e_a_m.     See  also
    with_output_to/2.


ccuurrrreenntt__iinnppuutt((_-_S_t_r_e_a_m))                                             _[_I_S_O_]
    Get  the current input  stream.   Useful for  getting access to  the
    status predicates associated with streams.


ccuurrrreenntt__oouuttppuutt((_-_S_t_r_e_a_m))                                            _[_I_S_O_]
    Get the current output stream.


44..1166..55 WWrriittee oonnttoo aattoommss,, ccooddee--lliissttss,, eettcc..


wwiitthh__oouuttppuutt__ttoo((_+_O_u_t_p_u_t_, _:_G_o_a_l))
    Run  _G_o_a_l  as  once/1,  while  characters  written  to  the  current
    output  are sent to _O_u_t_p_u_t.   The predicate is  SWI-Prolog-specific,
    inspired  by  various posts  to  the mailinglist.    It  provides  a
    flexible  replacement for predicates  such as sformat/3,  swritef/3,
    term_to_atom/2, atom_number/2 converting numbers to atoms, etc.  The
    predicate format/3 accepts the same terms as output argument.

    Applications  should generally avoid creating atoms by  breaking and
    concatenating  other  atoms, as  the creation  of  large numbers  of
    intermediate  atoms generally leads  to poor performance, even  more
    so in multithreaded  applications.  This predicate supports creating
    difference  lists  from character  data efficiently.    The  example
    below defines the DCG rule term//1 to insert a term in the output:

    ____________________________________________________________________|                                                                    |
    | term(Term, In, Tail) :-                                            |

    |         with_output_to(codes(In, Tail), write(Term)).              |
    |                                                                    |
    | ?- phrase(term(hello), X).                                         |
    |                                                                    |
    ||X_=_[104,_101,_108,_108,_111]_____________________________________ ||

    AA SSttrreeaamm hhaannddllee oorr aalliiaass
         Temporarily switch current output  to the given stream.   Redi-
         rection using  with_output_to/2guarantees  the original  output
         is restored, also  if _G_o_a_l fails or  raises an exception.   See
         also call_cleanup/2.

    aattoomm((_-_A_t_o_m))
         Create an atom  from the emitted characters.   Please note  the
         remark above.

    ssttrriinngg((_-_S_t_r_i_n_g))
         Create a string object as defined in section 5.2.

    ccooddeess((_-_C_o_d_e_s))
         Create a list of  character codes from the emitted  characters,
         similar to atom_codes/2.

    ccooddeess((_-_C_o_d_e_s_, _-_T_a_i_l))
         Create a list of character codes as a difference list.

    cchhaarrss((_-_C_h_a_r_s))
         Create a list of  one-character atoms from the emitted  charac-
         ters, similar to atom_chars/2.

    cchhaarrss((_-_C_h_a_r_s_, _-_T_a_i_l))
         Create a list of one-character atoms as a difference list.


44..1177 SSttaattuuss ooff ssttrreeaammss


wwaaiitt__ffoorr__iinnppuutt((_+_L_i_s_t_O_f_S_t_r_e_a_m_s_, _-_R_e_a_d_y_L_i_s_t_, _+_T_i_m_e_O_u_t))
    Wait  for input on  one of the  streams in _L_i_s_t_O_f_S_t_r_e_a_m_s and  return
    a  list  of  streams  on  which input  is  available  in  _R_e_a_d_y_L_i_s_t.
    wait_for_input/3 waits  for at most  _T_i_m_e_O_u_t seconds.   _T_i_m_e_o_u_t  may
    be  specified as  a floating  point number to  specify fractions  of
    a  second.    If  _T_i_m_e_o_u_t  equals  infinite,  wait_for_input/3 waits
    indefinitely.

    This  predicate can be used  to implement timeout while reading  and
    to  handle  input from  multiple  sources.   The  following  example
    will  wait for input from the  user and an explicitly opened  second
    terminal.  On return, _I_n_p_u_t_s may hold user_input or _P_4 or both.

    ____________________________________________________________________|                                                                    |
    | ?- open('/dev/ttyp4', read, P4),                                   |

    ||___wait_for_input([user_input,_P4],_Inputs,_0).___________________ ||

    This  predicate  relies  on  the select()  call  on  most  operating
    systems.  On  Unix this call is implemented for any stream referring
    to  a file  handle, which  implies all OS-based  streams:   sockets,
    terminals,  pipes, etc.   On non-Unix systems select() is  generally
    only  implemented for socket-based  streams.   See also socket  from
    the clib package.

    Note  that wait_for_input/3 returns streams that have data  waiting.
    This  does  not  mean you  can,  for  example,  call read/2  on  the
    stream  without  blocking as  the stream  might  hold an  incomplete
    term.   The predicate set_stream/2 using the option timeout(_S_e_c_o_n_d_s)
    can  be used  to make  the stream generate  an exception  if no  new
    data  arrives within  the  timeout period.    Suppose two  processes
    communicate  by exchanging Prolog terms.   The following code  makes
    the server immune for clients that write an incomplete term:

    ____________________________________________________________________|                                                                    |
    |     ...,                                                           |
    |     tcp_accept(Server, Socket, _Peer),                             |
    |     tcp_open(Socket, In, Out),                                     |
    |     set_stream(In, timeout(10)),                                   |
    |     catch(read(In, Term), _, (close(Out), close(In), fail)),       |

    ||____...,__________________________________________________________ ||


bbyyttee__ccoouunntt((_+_S_t_r_e_a_m_, _-_C_o_u_n_t))
    Byte  position in _S_t_r_e_a_m.   For binary streams  this is the same  as
    character_count/2.   For text files the number may be  different due
    to  multi-byte encodings  or additional record  separators (such  as
    Control-M in Windows).


cchhaarraacctteerr__ccoouunntt((_+_S_t_r_e_a_m_, _-_C_o_u_n_t))
    Unify  _C_o_u_n_t with the  current character index.   For input  streams
    this  is the number  of characters read since  the open; for  output
    streams  this is the number of characters written.   Counting starts
    at 0.


lliinnee__ccoouunntt((_+_S_t_r_e_a_m_, _-_C_o_u_n_t))
    Unify  _C_o_u_n_t with the  number of  lines read or  written.   Counting
    starts at 1.


lliinnee__ppoossiittiioonn((_+_S_t_r_e_a_m_, _-_C_o_u_n_t))
    Unify  _C_o_u_n_t with the position on the current line.  Note  that this
    assumes  the position  is 0 after  the open.   Tabs  are assumed  to
    be  defined on each  8-th character, and  backspaces are assumed  to
    reduce the count by one, provided it is positive.


44..1188 PPrriimmiittiivvee cchhaarraacctteerr II//OO

See section 4.2 for an overview of supported character representations.


nnll                                                                _[_I_S_O_]
    Write  a newline character  to the current output  stream.  On  Unix
    systems nl/0 is equivalent to put(10).


nnll((_+_S_t_r_e_a_m))                                                       _[_I_S_O_]
    Write a newline to _S_t_r_e_a_m.


ppuutt((_+_C_h_a_r))
    Write  _C_h_a_r  to the  current  output  stream.    _C_h_a_r is  either  an
    integer  expression evaluating  to a  character code or  an atom  of
    one  character.   Deprecated.    New code  should use  put_char/1 or
    put_code/1.


ppuutt((_+_S_t_r_e_a_m_, _+_C_h_a_r))
    Write _C_h_a_r to _S_t_r_e_a_m.  See put/1 for details.


ppuutt__bbyyttee((_+_B_y_t_e))                                                    _[_I_S_O_]
    Write a single byte  to the output.  _B_y_t_e must be an integer between
    0 and 255.


ppuutt__bbyyttee((_+_S_t_r_e_a_m_, _+_B_y_t_e))                                           _[_I_S_O_]
    Write  a single byte to _S_t_r_e_a_m.   _B_y_t_e must be an integer  between 0
    and 255.


ppuutt__cchhaarr((_+_C_h_a_r))                                                    _[_I_S_O_]
    Write  a  character to  the  current output,  obeying  the  encoding
    defined  for the current  output stream.   Note that this may  raise
    an  exception if the encoding of the output stream  cannot represent
    _C_h_a_r.


ppuutt__cchhaarr((_+_S_t_r_e_a_m_, _+_C_h_a_r))                                           _[_I_S_O_]
    Write  a  character to  _S_t_r_e_a_m,  obeying  the encoding  defined  for
    _S_t_r_e_a_m.   Note that this may  raise an exception if the  encoding of
    _S_t_r_e_a_m cannot represent _C_h_a_r.


ppuutt__ccooddee((_+_C_o_d_e))                                                    _[_I_S_O_]
    Similar  to put_char/1,  but using  a _c_h_a_r_a_c_t_e_r  _c_o_d_e.    _C_o_d_e is  a
    non-negative integer.   Note that this may raise an exception if the
    encoding of the output stream cannot represent _C_o_d_e.


ppuutt__ccooddee((_+_S_t_r_e_a_m_, _+_C_o_d_e))                                           _[_I_S_O_]
    Same as put_code/1 but directing _C_o_d_e to _S_t_r_e_a_m.


ttaabb((_+_A_m_o_u_n_t))
    Write  _A_m_o_u_n_t spaces on  the current output  stream.  _A_m_o_u_n_t  should
    be  an  expression   that  evaluates  to  a  positive  integer  (see
    section 4.26).


ttaabb((_+_S_t_r_e_a_m_, _+_A_m_o_u_n_t))
    Write _A_m_o_u_n_t spaces to _S_t_r_e_a_m.


fflluusshh__oouuttppuutt                                                       _[_I_S_O_]
    Flush  pending output on current  output stream.   flush_output/0 is
    automatically  generated by  read/1 and derivatives  if the  current
    input stream is user and the cursor is not at the left margin.


fflluusshh__oouuttppuutt((_+_S_t_r_e_a_m))                                              _[_I_S_O_]
    Flush  output on the specified stream.  The stream must be  open for
    writing.


ttttyyfflluusshh
    Flush pending output on stream user.  See also flush_output/[0,1].


ggeett__bbyyttee((_-_B_y_t_e))                                                    _[_I_S_O_]
    Read the current input  stream and unify the next byte with _B_y_t_e (an
    integer  between 0  and 255).   _B_y_t_e is  unified with  -1 on end  of
    file.


ggeett__bbyyttee((_+_S_t_r_e_a_m_, _-_B_y_t_e))                                           _[_I_S_O_]
    Read  the  next byte  from _S_t_r_e_a_m  and unify  _B_y_t_e  with an  integer
    between 0 and 255.


ggeett__ccooddee((_-_C_o_d_e))                                                    _[_I_S_O_]
    Read  the current  input stream  and unify _C_o_d_e  with the  character
    code  of the  next character.   _C_o_d_e is  unified with  -1 on end  of
    file.  See also get_char/1.


ggeett__ccooddee((_+_S_t_r_e_a_m_, _-_C_o_d_e))                                           _[_I_S_O_]
    Read the next character code from _S_t_r_e_a_m.


ggeett__cchhaarr((_-_C_h_a_r))                                                    _[_I_S_O_]
    Read  the  current  input  stream  and  unify  _C_h_a_r  with  the  next
    character  as a  one-character atom.    See also  atom_chars/2.    On
    end-of-file, _C_h_a_r is unified to the atom end_of_file.


ggeett__cchhaarr((_+_S_t_r_e_a_m_, _-_C_h_a_r))                                           _[_I_S_O_]
    Unify  _C_h_a_r with the next  character from _S_t_r_e_a_m as a  one-character
    atom.  See also get_char/2, get_byte/2 and get_code/2.


ggeett00((_-_C_h_a_r))                                                _[_d_e_p_r_e_c_a_t_e_d_]
    Edinburgh  version  of the  ISO  get_code/1 predicate.    Note  that
    Edinburgh  Prolog  didn't  support  wide  characters  and  therefore
    technically  speaking get0/1 should have been  mapped to get_byte/1.
    The intention of get0/1, however, is to read character codes.


ggeett00((_+_S_t_r_e_a_m_, _-_C_h_a_r))                                       _[_d_e_p_r_e_c_a_t_e_d_]
    Edinburgh  version  of  the ISO  get_code/2  predicate.    See  also
    get0/1.


ggeett((_-_C_h_a_r))                                                 _[_d_e_p_r_e_c_a_t_e_d_]
    Read  the  current   input  stream  and  unify  the  next  non-blank
    character  with _C_h_a_r.  _C_h_a_r is unified with -1 on end of file.   The
    predicate get/1 operates on character _c_o_d_e_s.  See also get0/1.


ggeett((_+_S_t_r_e_a_m_, _-_C_h_a_r))                                        _[_d_e_p_r_e_c_a_t_e_d_]
    Read  the next  non-blank character from  _S_t_r_e_a_m.   See also  get/1,
    get0/1 and get0/2.


ppeeeekk__bbyyttee((_-_B_y_t_e))                                                   _[_I_S_O_]


ppeeeekk__bbyyttee((_+_S_t_r_e_a_m_, _-_B_y_t_e))                                          _[_I_S_O_]


ppeeeekk__ccooddee((_-_C_o_d_e))                                                   _[_I_S_O_]


ppeeeekk__ccooddee((_+_S_t_r_e_a_m_, _-_C_o_d_e))                                          _[_I_S_O_]


ppeeeekk__cchhaarr((_-_C_h_a_r))                                                   _[_I_S_O_]


ppeeeekk__cchhaarr((_+_S_t_r_e_a_m_, _-_C_h_a_r))                                          _[_I_S_O_]
    Read  the  next  byte/code/char  from  the  input  without  removing
    it.    These  predicates  do not  modify  the stream's  position  or
    end-of-file  status.   These  predicates require  a buffered  stream
    (see  set_stream/2)  and raise  a  permission  error if  the  stream
    is  unbuffered  or the  buffer  is too  small  to hold  the  longest
    multi-byte sequence that might need to be buffered.


ppeeeekk__ssttrriinngg((_+_S_t_r_e_a_m_, _+_L_e_n_, _-_S_t_r_i_n_g))
    Read  the next _L_e_n  characters (if the stream  is a text stream)  or
    bytes  (if the stream  is binary) from  Stream without removing  the
    data.   If  _L_e_n is larger  that the stream  buffer size, the  buffer
    size  is increased to _L_e_n.   _S_t_r_i_n_g can  be shorter than _L_e_n if  the
    stream contains less data.   This predicate is intended to guess the
    content type of data read from non-repositionable streams.


sskkiipp((_+_C_o_d_e))
    Read the input until  _C_o_d_e or the end of the file is encountered.  A
    subsequent  call to get_code/1 will  read the first character  after
    _C_o_d_e.


sskkiipp((_+_S_t_r_e_a_m_, _+_C_o_d_e))
    Skip input (as skip/1) on _S_t_r_e_a_m.


ggeett__ssiinnggllee__cchhaarr((_-_C_o_d_e))
    Get  a single character from input stream `user' (regardless  of the
    current  input stream).  Unlike get_code/1, this predicate  does not
    wait  for a  return.   The  character is  not echoed  to the  user's
    terminal.    This predicate  is meant for  keyboard menu  selection,
    etc.  If  SWI-Prolog was started with the -tty option this predicate
    reads  an  entire line  of  input and  returns the  first  non-blank
    character  on this line, or the  character code of the newline  (10)
    if the entire line consisted of blank characters.


aatt__eenndd__ooff__ssttrreeaamm                                                    _[_I_S_O_]
    Succeeds  after the last character  of the current input stream  has
    been  read.    Also succeeds  if  there is  no valid  current  input
    stream.


aatt__eenndd__ooff__ssttrreeaamm((_+_S_t_r_e_a_m))                                           _[_I_S_O_]
    Succeeds  after the last character of  the named stream is read,  or
    _S_t_r_e_a_m is not a  valid input stream.  The end-of-stream test is only
    available  on buffered input  streams (unbuffered input streams  are
    rarely used; see open/4).


sseett__eenndd__ooff__ssttrreeaamm((_+_S_t_r_e_a_m))
    Set  the size  of  the file  opened as  _S_t_r_e_a_m to  the current  file
    position.   This is typically used in combination with the open-mode
    update.


ccooppyy__ssttrreeaamm__ddaattaa((_+_S_t_r_e_a_m_I_n_, _+_S_t_r_e_a_m_O_u_t_, _+_L_e_n))
    Copy  _L_e_n codes from _S_t_r_e_a_m_I_n to _S_t_r_e_a_m_O_u_t.   Note that the  copy is
    done  using the semantics of get_code/2 and  put_code/2, taking  care
    of  possibly recoding  that  needs to  take place  between two  text
    files.  See section 2.18.1.


ccooppyy__ssttrreeaamm__ddaattaa((_+_S_t_r_e_a_m_I_n_, _+_S_t_r_e_a_m_O_u_t))
    Copy all (remaining) data from _S_t_r_e_a_m_I_n to _S_t_r_e_a_m_O_u_t.


rreeaadd__ppeennddiinngg__iinnppuutt((_+_S_t_r_e_a_m_I_n_, _-_C_o_d_e_s_, _?_T_a_i_l))
    Read input pending in  the input buffer of _S_t_r_e_a_m_I_n and return it in
    the  difference list _C_o_d_e_s-_T_a_i_l.  That is, the  available characters
    codes  are used to  create the list _C_o_d_e_s  ending in the tail  _T_a_i_l.
    This  predicate is  intended  for efficient  unbuffered copying  and
    filtering of input coming from network connections or devices.

    The following  code fragment realises efficient non-blocking copying
    of  data from an input to an  output stream.  The  at_end_of_stream/1
    call  checks for  end-of-stream and fills  the input  buffer.   Note
    that  the use of a  get_code/2 and put_code/2 based loop requires  a
    flush_output/1 call  after _e_a_c_h put_code/2.   The copy_stream_data/2
    does  not allow for inspection of  the copied data and suffers  from
    the same buffering issues.

    ____________________________________________________________________|                                                                    |
    | copy(In, Out) :-                                                   |

    |         repeat,                                                    |
    |             (   at_end_of_stream(In)                               |
    |             ->  !                                                  |
    |             ;   read_pending_input(In, Chars, []),                 |
    |                 format(Out, '~s', [Chars]),                        |
    |                 flush_output(Out),                                 |
    |                 fail                                               |
    ||____________).____________________________________________________ ||


44..1199 TTeerrmm rreeaaddiinngg aanndd wwrriittiinngg

This section  describes the basic term  reading and writing  predicates.
The  predicates  format/[1,2] and  writef/2  provide  formatted  output.
Writing  to  Prolog data  structures  such  as atoms  or  code-lists  is
supported by with_output_to/2and format/3.

Reading  is  sensitive  to  the  Prolog  flag  character_escapes,   which
controls  the interpretation  of the  \ character  in  quoted atoms  and
strings.


wwrriittee__tteerrmm((_+_T_e_r_m_, _+_O_p_t_i_o_n_s))                                        _[_I_S_O_]
    The  predicate  write_term/2  is  the generic  form  of  all  Prolog
    term-write predicates.  Valid options are:

    aattttrriibbuutteess((_A_t_o_m))
         Define how attributed variables (see section 7.1)  are written.
         The default is determined by  the Prolog flag write_attributes.
         Defined values are  ignore (ignore the attribute), dots  (write
         the attributes  as {...}),  write (simply  hand the  attributes
         recursively to write_term/2) and  portray (hand the  attributes
         to attr_portray_hook/2).

    bbaacckk__qquuootteess((_A_t_o_m))
         Fulfills  the  same  role  as   the  back_quotes  prolog  flag.
         Notably, the value  string causes string objects to be  printed
         between back quotes and symbol_char causes the backquote  to be
         printed unquoted.  In all other cases the  backquote is printed
         as a quoted atom.

    bbrraaccee__tteerrmmss((_B_o_o_l))
         If true (default), write {}(X)  as {X}.  See also  dotlists and
         ignore_ops.

    bblloobbss((_A_t_o_m))
         Define how  non-text blobs are  handled.   By default, this  is
         left to the write handler specified with the blob type.   Using
         portray, portray/1 is  called for each  blob encountered.   See
         section 10.4.7.

    cchhaarraacctteerr__eessccaappeess((_B_o_o_l))
         If  true and  quoted(_t_r_u_e)  is active,  special  characters  in
         quoted atoms and strings  are emitted as ISO escape  sequences.
         Default is taken from the reference module (see below).

    ccyycclleess((_B_o_o_l))
         If true  (default),  cyclic terms  are  written as  @(_T_e_m_p_l_a_t_e_,
         _S_u_b_s_t_i_t_u_t_i_o_n_s), where _S_u_b_s_t_i_t_u_t_i_o_n_s is a list _V_a_r = _V_a_l_u_e.   If
         cycles is false,  max_depth is not given,  and _T_e_r_m is  cyclic,
         write_term/2 raises a domain_error.   See also the cycles option
         in read_term/2.

    ddoottlliissttss((_B_o_o_l))
         If true  (default false),  write  lists using  the dotted  term
         notation  rather  than  the  list  notation.     Note  that  as
         of  version  7,   the  list  constructor  is  '[|]'.      Using
         dotlists(_t_r_u_e),  write_term/2 writes  a  list  using `.'     as
         constructor.  This is intended for  communication with programs
         such as other Prolog systems, that rely on this notation.

    ffuullllssttoopp((_B_o_o_l))
         If true (default  false), add a  fullstop token to the  output.
         The dot  is preceeded  by  a space  if needed  and followed  by
         a space  (default) or newline  if the  nl(_t_r_u_e) option is  also
         given.

    iiggnnoorree__ooppss((_B_o_o_l))
         If true, the generic term representation (<_f_u_n_c_t_o_r>(<_a_r_g_s> ...))
         will be  used for all  terms.   Otherwise (default),  operators
         will be used where appropriate..

    mmaaxx__ddeepptthh((_I_n_t_e_g_e_r))
         If the term is nested deeper than _I_n_t_e_g_e_r,  print the remainder
         as ellipses  (...).    A 0  (zero) value  (default) imposes  no
         depth limit.   This option also delimits the number  of printed
         items in a list.  Example:

         _______________________________________________________________|                                                               |

         |?- write_term(a(s(s(s(s(0)))), [a,b,c,d,e,f]),                 |
         |              [max_depth(3)]).                                 |
         |a(s(s(...)), [a, b|...])                                       |
         |true.|________________________________________________________ |     |

         Used  by   the  top   level  and  debugger   to  limit   screen
         output.   See  also the  Prolog flags  answer_write_options and
         debugger_write_options.

    mmoodduullee((_M_o_d_u_l_e))
         Define the reference module  (default user).  This  defines the
         default value for  the character_escapes option as well as  the
         operator definitions to use.  See also op/3.

    nnll((_B_o_o_l))
         Add a newline to the output.  See also the fullstop option.

    nnuummbbeerrvvaarrss((_B_o_o_l))
         If  true, terms  of  the  format $VAR(N),  where  _N is  a  non-
         negative integer, will be written as a variable name.   If _N is
         an atom it  is written without quotes.   This extension  allows
         for writing variables  with user-provided names.   The  default
         is false.  See also numbervars/3 and the option variable_names.

    ppaarrttiiaall((_B_o_o_l))
         If true (default  false), do not  reset the logic that  inserts
         extra  spaces that  separate  tokens where  needed.    This  is
         intended to solve  the problems with the  code below.   Calling
         write_value(.) writes  .., which  cannot be  read.   By  adding
         partial(_t_r_u_e)  to the  option  list,  it correctly  emits  . ..
         Similar problems appear when emitting operators  using multiple
         calls to write_term/3.

         _______________________________________________________________|                                                               |
         |write_value(Value) :-                                          |
         |        write_term(Value, [partial(true)]),                    |

         ||_______write('.'),_nl._______________________________________ ||

    ppoorrttrraayy((_B_o_o_l))
         Same as portrayed(_B_o_o_l).  Deprecated.

    ppoorrttrraayy__ggooaall((_:_G_o_a_l))
         Implies portray(_t_r_u_e),  but calls _G_o_a_l  rather than the  prede-
         fined hook  portray/1.   _G_o_a_l is called  through call/3,  where
         the first  argument  is _G_o_a_l,  the  second is  the term  to  be
         printed and the 3rd argument is the current  write option list.
         The  write option  list  is copied  from  the  write_term  call,
         but the  list is  guaranteed to  hold an  option priority  that
         reflects the current priority.

    ppoorrttrraayyeedd((_B_o_o_l))
         If true, the  hook portray/1 is  called before printing a  term
         that is not  a variable.   If portray/1  succeeds, the term  is
         considered printed.  See  also print/1.  The default  is false.
         This option is an extension to the ISO write_term options.

    pprriioorriittyy((_I_n_t_e_g_e_r))
         An  integer  between  0  and  1200  representing  the  `context
         priority'.   Default is  1200.   Can be  used to write  partial
         terms appearing as the argument to an operator.  For example:

         _______________________________________________________________|                                                               |
         |        format('~w = ', [VarName]),                            |
         ||_______write_term(Value,_[quoted(true),_priority(699)])______ ||

    qquuootteedd((_B_o_o_l))
         If true, atoms  and functors that  need quotes will be  quoted.
         The default is false.

    ssppaacciinngg((_+_S_p_a_c_i_n_g))
         Determines whether  and where  extra  white space  is added  to
         enhance readability.    The default  is  standard, adding  only
         space  where needed  for  proper  tokenization by  read_term/3.
         Currently,  the only  other value  is  next_argument,  adding  a
         space after  a comma used  to separate arguments  in a term  or
         list.

    vvaarriiaabbllee__nnaammeess((_+_L_i_s_t))
         Assign names to  variables in _T_e_r_m.   _L_i_s_t  is a list of  terms
         _N_a_m_e = _V_a_r,  where _N_a_m_e  is  an atom  that represents  a  valid
         Prolog  variable name.    Terms  where _V_a_r  is  bound or  is  a
         variable that does not appear  in _T_e_r_m are ignored.   Raises an
         error if _L_i_s_t is not  a list, one of the members is not  a term
         _N_a_m_e = _V_a_r, _N_a_m_e is  not an atom or  _N_a_m_e does not represent  a
         valid Prolog variable name.

         The implementation  binds the  variables  from _L_i_s_t  to a  term
         '$VAR'(_N_a_m_e).  Like write_canonical/1, terms that where already
         bound to  '$VAR'(_X) before  write_term/2 are printed  normally,
         unless the option  numbervars(_t_r_u_e) is also  provided.  If  the
         option numbervars(_t_r_u_e)  is used, the  user is responsible  for
         avoiding collisions between assigned names and  numbered names.
         See also the variable_names option of read_term/2.

         Possible variable attributes (see  section 7) are ignored.   In
         most cases  one should  use copy_term/3 to obtain  a copy  that
         is  free of  attributed  variables  and handle  the  associated
         constraints as appropriate for the use-case.


wwrriittee__tteerrmm((_+_S_t_r_e_a_m_, _+_T_e_r_m_, _+_O_p_t_i_o_n_s))                               _[_I_S_O_]
    As  write_term/2,  but output  is sent  to  _S_t_r_e_a_m rather  than  the
    current output.


wwrriittee__lleennggtthh((_+_T_e_r_m_, _-_L_e_n_g_t_h_, _+_O_p_t_i_o_n_s))                         _[_s_e_m_i_d_e_t_]
    True   when  _L_e_n_g_t_h  is  the   number  of  characters  emitted   for
    _w_r_i_t_e___t_e_r_mTerm,  Options.     In  addition  to   valid  options  for
    write_term/2, it processes the option:

    mmaaxx__lleennggtthh((_+_M_a_x_L_e_n_g_t_h))
         If provided,  fail if  _L_e_n_g_t_h would be  larger than  _M_a_x_L_e_n_g_t_h.
         The implementation  ensures that  the runtime  is limited  when
         computing the length of a huge term with a bounded maximum.


wwrriittee__ccaannoonniiccaall((_+_T_e_r_m))                                             _[_I_S_O_]
    Write  _T_e_r_m  on  the current  output  stream using  standard  paren-
    thesised  prefix notation  (i.e.,  ignoring operator  declarations).
    Atoms  that  need  quotes are  quoted.    Terms  written  with  this
    predicate  can always be read  back, regardless of current  operator
    declarations.      Equivalent  to  write_term/2  using  the  options
    ignore_ops,  quoted  and  numbervars after  numbervars/4  using  the
    singletons option.

    Note  that due to the use of numbervars/4, non-ground terms  must be
    written  using a  _s_i_n_g_l_e write_canonical/1 call.   This  used to  be
    the  case anyhow,  as garbage collection  between multiple calls  to
    one  of the write predicates can change the _G<NNN> identity  of the
    variables.


wwrriittee__ccaannoonniiccaall((_+_S_t_r_e_a_m_, _+_T_e_r_m))                                    _[_I_S_O_]
    Write _T_e_r_m in canonical form on _S_t_r_e_a_m.


wwrriittee((_+_T_e_r_m))                                                      _[_I_S_O_]
    Write  _T_e_r_m  to the  current output,  using  brackets and  operators
    where appropriate.


wwrriittee((_+_S_t_r_e_a_m_, _+_T_e_r_m))                                             _[_I_S_O_]
    Write _T_e_r_m to _S_t_r_e_a_m.


wwrriitteeqq((_+_T_e_r_m))                                                     _[_I_S_O_]
    Write  _T_e_r_m  to the  current output,  using  brackets and  operators
    where  appropriate.    Atoms that  need quotes  are quoted.    Terms
    written  with this predicate can  be read back with read/1  provided
    the currently active operator declarations are identical.


wwrriitteeqq((_+_S_t_r_e_a_m_, _+_T_e_r_m))                                            _[_I_S_O_]
    Write _T_e_r_m to _S_t_r_e_a_m, inserting quotes.


wwrriitteellnn((_+_T_e_r_m))
    Equivalent to write(Term), nl..   The output stream is locked, which
    implies  no output from  other threads can  appear between the  term
    and newline.


wwrriitteellnn((_+_S_t_r_e_a_m_, _+_T_e_r_m))
    Equivalent  to write(Stream, Term), nl(Stream)..  The  output stream
    is  locked, which implies  no output from  other threads can  appear
    between the term and newline.


pprriinntt((_+_T_e_r_m))
    Print a term for  debugging porposes.  The predicate print/1 acts as
    if defined as below.

    ____________________________________________________________________|                                                                    |
    | print(Term) :-                                                     |
    |     current_prolog_flag(print_write_options, Options), !,          |
    |     write_term(Term, Options).                                     |

    | print(Term) :-                                                     |
    |     write_term(Term, [ portray(true),                              |
    |                        numbervars(true),                           |
    |                        quoted(true)                                |
    ||_____________________]).__________________________________________ ||

    The  print/1  predicate  is used  primarily  through the  ~p  escape
    sequence  of format/2, which is  commonly used in the recipies  used
    by print_message/2 to emit messages.

    The  classical definition  of this  predicate is  equivalent to  the
    ISO  predicate  write_term/2  using the  options  portray(_t_r_u_e)  and
    numbervars(_t_r_u_e).    The portray(_t_r_u_e)  options allows  the user  to
    implement  application-specific  printing  of terms  printed  during
    debugging  to facilitate  easy  understanding of  the output.    See
    also  portray/1 and portray_text.   SWI-Prolog adds quoted(_t_r_u_e)  to
    facilitate copy/paste of  terms not affected by portray/1 and better
    distinguishing  of  e.g., 42,  '42'  and "42",  a number,  atom  and
    string.


pprriinntt((_+_S_t_r_e_a_m_, _+_T_e_r_m))
    Print _T_e_r_m to _S_t_r_e_a_m.


ppoorrttrraayy((_+_T_e_r_m))
    A dynamic predicate, which  can be defined by the user to change the
    behaviour  of print/1 on (sub)terms.   For each subterm  encountered
    that is not  a variable print/1 first calls portray/1 using the term
    as  argument.   For  lists, only  the list as  a whole  is given  to
    portray/1.   If portray/1 succeeds print/1 assumes the term has been
    written.


rreeaadd((_-_T_e_r_m))                                                       _[_I_S_O_]
    Read  the next Prolog term from  the current input stream and  unify
    it  with _T_e_r_m.  On a syntax error read/1 displays an  error message,
    attempts  to  skip  the erroneous  term  and  fails.    On  reaching
    end-of-file _T_e_r_m is unified with the atom end_of_file.


rreeaadd((_+_S_t_r_e_a_m_, _-_T_e_r_m))                                              _[_I_S_O_]
    Read _T_e_r_m from _S_t_r_e_a_m.


rreeaadd__ccllaauussee((_+_S_t_r_e_a_m_, _-_T_e_r_m_, _+_O_p_t_i_o_n_s))
    Equivalent  to  read_term/3,  but  sets  options  according  to  the
    current  compilation  context  and  optionally  processes  comments.
    Defined options:

    ssyynnttaaxx__eerrrroorrss((_+_A_t_o_m))
         See read_term/3, but the default is dec10 (report and restart).

    tteerrmm__ppoossiittiioonn((_-_T_e_r_m_P_o_s))
         Same as for read_term/3.

    ssuubbtteerrmm__ppoossiittiioonnss((_-_T_e_r_m_P_o_s))
         Same as for read_term/3.

    vvaarriiaabbllee__nnaammeess((_-_B_i_n_d_i_n_g_s))
         Same as for read_term/3.

    pprroocceessss__ccoommmmeenntt((_+_B_o_o_l_e_a_n))
         If true (default),  call prolog:comment_hook(_C_o_m_m_e_n_t_s_,  _T_e_r_m_P_o_s_,
         _T_e_r_m)   if  this   multifile   hook   is  defined   (see   pro-
         log:comment_hook/3).  This is used to drive PlDoc.

    ccoommmmeennttss((_-_C_o_m_m_e_n_t_s))
         If  provided,  unify _C_o_m_m_e_n_t_s  with  the  comments  encountered
         while   reading   _T_e_r_m.         This   option   implies    pro-
         cess_comment(_f_a_l_s_e).

    The singletons  option of read_term/3is  initialised from the active
    style-checking  mode.    The  module option  is initialised  to  the
    current compilation module (see prolog_load_context/2).


rreeaadd__tteerrmm((_-_T_e_r_m_, _+_O_p_t_i_o_n_s))                                         _[_I_S_O_]
    Read  a term from the current  input stream and unify the term  with
    _T_e_r_m.    The  reading is  controlled  by options  from the  list  of
    _O_p_t_i_o_n_s.   If this list is  empty, the behaviour is the same  as for
    read/1.    The options  are upward compatible  with Quintus  Prolog.
    The  argument  order is  according  to the  ISO  standard.    Syntax
    errors  are always reported using exception-handling  (see catch/3).
    Options:

    bbaacckkqquuootteedd__ssttrriinngg((_B_o_o_l))
         If true, read `...` to a string object (see section 5.2).   The
         default depends on the Prolog flag back_quotes.

    cchhaarraacctteerr__eessccaappeess((_B_o_o_l))
         Defines how to  read \ escape sequences  in quoted atoms.   See
         the  Prolog  flag  character_escapes in  current_prolog_flag/2.
         (SWI-Prolog).

    ccoommmmeennttss((_-_C_o_m_m_e_n_t_s))
         Unify _C_o_m_m_e_n_t_s with a list of _P_o_s_i_t_i_o_n-_C_o_m_m_e_n_t,  where _P_o_s_i_t_i_o_n
         is  a  stream   position  object  (see  stream_position_data/3)
         indicating the  start  of a  comment and  _C_o_m_m_e_n_t  is a  string
         object containing the  text including delimiters of a  comment.
         It returns all comments from where the read_term/2 call started
         up to the end of the term read.

    ccyycclleess((_B_o_o_l))
         If true (default  false), re-instantiate templates as  produced
         by  the corresponding  write_term/2  option.    Note  that  the
         default  is false  to  avoid misinterpretation  of  @(_T_e_m_p_l_a_t_e_,
         _S_u_b_s_t_u_t_i_o_n_s), while the default of write_term/2 is true because
         emitting  cyclic terms  without  using the  template  construct
         produces an infinitely large  term (read:  it will  generate an
         error after producing a huge amount of output).

    ddoottlliissttss((_B_o_o_l))
         If true (default false), read .(a,[]) as a list,  even if lists
         are internally nor constructed using the dot as functor.   This
         is primarily intended to read the output from write_canonical/1
         from other Prolog systems.  See section 5.1.

    ddoouubbllee__qquuootteess((_A_t_o_m))
         Defines  how to  read  "..." strings.     See the  Prolog  flag
         double_quotes.  (SWI-Prolog).

    mmoodduullee((_M_o_d_u_l_e))
         Specify  _M_o_d_u_l_e  for  operators,   character_escapes  flag  and
         double_quotes flag.  The  value of the latter two is  overruled
         if the  corresponding read_term/3 option  is provided.   If  no
         module  is specified,  the  current  `source module'  is  used.
         (SWI-Prolog).

    qquuaassii__qquuoottaattiioonnss((_-_L_i_s_t))
         If present,  unify  _L_i_s_t with  the quasi  quotations (see  sec-
         tion 12.26 instead of evaluating quasi quotations.   Each quasi
         quotation is a term  quasi_quotation(_+_S_y_n_t_a_x_, _+_Q_u_o_t_a_t_i_o_n_,  _+_V_a_r_-
         _D_i_c_t_, _-_R_e_s_u_l_t),  where _S_y_n_t_a_x  is the  term in  {|Syntax||..|},
         _Q_u_o_t_a_t_i_o_n  is a  list of  character  codes that  represent  the
         quotation, _V_a_r_D_i_c_t is a  list of _N_a_m_e=_V_a_r_i_a_b_l_e and _R_e_s_u_l_t  is a
         variable that shares  with the place  where the quotation  must
         be inserted.   This  option is intended  to support tools  that
         manipulate Prolog source text.

    ssiinngglleettoonnss((_V_a_r_s))
         As variable_names,  but only  reports  the variables  occurring
         only  once in  the  _T_e_r_m read.     Variables starting  with  an
         underscore (`_')  are not included  in this  list.   (ISO).  If
         _V_a_r_s is the constant warning, singleton variables  are reported
         using print_message/2.  The variables appear in the  order they
         have been read.

    ssyynnttaaxx__eerrrroorrss((_A_t_o_m))
         If error  (default),  throw  an exception  on a  syntax  error.
         Other values  are fail, which  causes a  message to be  printed
         using print_message/2, after which  the predicate fails,  quiet
         which causes the  predicate to fail  silently, and dec10  which
         causes syntax errors to be printed, after which read_term/[2,3]
         continues reading the next term.   Using dec10, read_term/[2,3]
         never fails.  (Quintus, SICStus).

    ssuubbtteerrmm__ppoossiittiioonnss((_T_e_r_m_P_o_s))
         Describes the  detailed layout of  the term.   The formats  for
         the various types of terms are given below.   All positions are
         character positions.    If  the input  is related  to a  normal
         stream,  these  positions are  relative  to the  start  of  the
         input; when  reading from  the terminal,  they are relative  to
         the start of the term.

         _F_r_o_m--_T_o
             Used for primitive types (atoms, numbers, variables).

         ssttrriinngg__ppoossiittiioonn((_F_r_o_m_, _T_o))
             Used  to indicate  the  position of  a string  enclosed  in
             double quotes (").

         bbrraaccee__tteerrmm__ppoossiittiioonn((_F_r_o_m_, _T_o_, _A_r_g))
             Term  of  the form  {...},  as used  in  DCG  rules.    _A_r_g
             describes the argument.

         lliisstt__ppoossiittiioonn((_F_r_o_m_, _T_o_, _E_l_m_s_, _T_a_i_l))
             A  list.   _E_l_m_s describes  the positions  of the  elements.
             If  the list  specifies the  tail as  |<TailTerm>, _T_a_i_l  is
             unified with the term position  of the tail, otherwise with
             the atom none.

         tteerrmm__ppoossiittiioonn((_F_r_o_m_, _T_o_, _F_F_r_o_m_, _F_T_o_, _S_u_b_P_o_s))
             Used  for a compound  term not matching  one of the  above.
             _F_F_r_o_m  and  _F_T_o  describe  the  position  of  the  functor.
             _S_u_b_P_o_s is a list, each element  of which describes the term
             position of the corresponding subterm.

         mmaapp__ppoossiittiioonn((_F_r_o_m_, _T_o_, _T_y_p_e_F_r_o_m_, _T_y_p_e_T_o_, _K_e_y_V_a_l_u_e_P_o_s_L_i_s_t))
             Used  for  a  map (see  section  5.4).    The  position  of
             the  key-value  pairs  is   described  by  _K_e_y_V_a_l_u_e_P_o_s_L_i_s_t,
             which  is  a  list  of  key_value_position/7 terms.     The
             key_value_position/7  terms appear  in  the  order  of  the
             input.   Because maps to not preserve ordering, the  key is
             provided in the position description.

         kkeeyy__vvaalluuee__ppoossiittiioonn((_F_r_o_m_, _T_o_, _S_e_p_F_r_o_m_, _S_e_p_T_o_, _K_e_y_, _K_e_y_P_o_s_, _V_a_l_u_e_P_o_s))
             Used for  key-value pairs in a map  (see section 5.4).   It
             is  similar to the  term_position/5 that would be  created,
             except  that the  key and value  positions do  not need  an
             intermediate list and the key is  provided in _K_e_y to enable
             synchronisation  of the  file position data  with the  data
             structure.

    tteerrmm__ppoossiittiioonn((_P_o_s))
         Unifies _P_o_s with the starting  position of the term read.   _P_o_s
         is of the same format as used by stream_property/2.

    vvaarriiaabblleess((_V_a_r_s))
         Unify  _V_a_r_s  with a  list  of  variables  in the  term.     The
         variables appear in  the order they have  been read.  See  also
         term_variables/2.  (ISO).

    vvaarriiaabbllee__nnaammeess((_V_a_r_s))
         Unify _V_a_r_s with a list  of `_N_a_m_e = _V_a_r', where _N_a_m_e is  an atom
         describing the variable name and _V_a_r is a  variable that shares
         with the corresponding variable in _T_e_r_m.   (ISO). The variables
         appear in the order they have been read.


rreeaadd__tteerrmm((_+_S_t_r_e_a_m_, _-_T_e_r_m_, _+_O_p_t_i_o_n_s))                                _[_I_S_O_]
    Read term with options from _S_t_r_e_a_m.  See read_term/2.


rreeaadd__tteerrmm__ffrroomm__aattoomm((_+_A_t_o_m_, _-_T_e_r_m_, _+_O_p_t_i_o_n_s))
    Use  read_term/3 to read the  next term from _A_t_o_m.   _A_t_o_m is  either
    an  atom or a string object (see  section 5.2).  It is  not required
    for  _A_t_o_m  to end  with  a full-stop.    This  predicate  supersedes
    atom_to_term/3.


rreeaadd__hhiissttoorryy((_+_S_h_o_w_, _+_H_e_l_p_, _+_S_p_e_c_i_a_l_, _+_P_r_o_m_p_t_, _-_T_e_r_m_, _-_B_i_n_d_i_n_g_s))
    Similar  to read_term/2 using the option variable_names, but  allows
    for history  substitutions.  read_history/6is used  by the top level
    to  read the user's actions.   _S_h_o_w is  the command the user  should
    type  to show  the saved  events.   _H_e_l_p is  the command  to get  an
    overview  of the capabilities.   _S_p_e_c_i_a_l is a list of commands  that
    are  not saved in the  history.  _P_r_o_m_p_t  is the first prompt  given.
    Continuation  prompts for  more  lines are  determined by  prompt/2.
    A  %w  in the  prompt  is substituted  by  the event  number.    See
    section 2.7 for available substitutions.

    SWI-Prolog calls read_history/6 as follows:

    ____________________________________________________________________|                                                                    |
    ||read_history(h,_'!h',_[trace],_'%w_?-_',_Goal,_Bindings)__________ ||


pprroommpptt((_-_O_l_d_, _+_N_e_w))
    Set  prompt associated  with read/1  and its  derivatives.   _O_l_d  is
    first  unified with the current prompt.  On success the  prompt will
    be  set to _N_e_w if  this is an atom.   Otherwise an error message  is
    displayed.   A prompt  is printed if one  of the read predicates  is
    called  and the cursor is  at the left margin.   It is also  printed
    whenever  a newline is given and  the term has not been  terminated.
    Prompts are only printed when the current input stream is _u_s_e_r.


pprroommpptt11((_+_P_r_o_m_p_t))
    Sets  the prompt for the next line  to be read.   Continuation lines
    will be read using the prompt defined by prompt/2.


44..2200 AAnnaallyyssiinngg aanndd CCoonnssttrruuccttiinngg TTeerrmmss


ffuunnccttoorr((_?_T_e_r_m_, _?_N_a_m_e_, _?_A_r_i_t_y))                                     _[_I_S_O_]
    True  when _T_e_r_m is  a term with  functor _N_a_m_e/_A_r_i_t_y.   If _T_e_r_m is  a
    variable  it is  unified with  a new  term whose  arguments are  all
    different variables (such a  term is called a skeleton).  If _T_e_r_m is
    atomic,  _A_r_i_t_y will be unified with the integer 0, and _N_a_m_e  will be
    unified  with _T_e_r_m.   Raises instantiation_error if _T_e_r_m is  unbound
    and _N_a_m_e/_A_r_i_t_y is insufficiently instantiated.

    SWI-Prolog   also  supports   terms  with   arity  0,   as  in   a()
    (see   section   5.       Such  terms   must  be   processed   using
    compound_name_arity/3.   The predicate functor/3  and =../2 raise  a
    domain_error when faced with these terms.   Without this precaution,
    the inconsistency demonstrated below could happen silently.

    ____________________________________________________________________|                                                                    |
    | ?- functor(a(), N, A).                                             |

    | N = a, A = 0.                                                      |
    | ?- functor(T, a, 0).                                               |
    ||T_=_a.____________________________________________________________ ||


aarrgg((_?_A_r_g_, _+_T_e_r_m_, _?_V_a_l_u_e))                                          _[_I_S_O_]
    _T_e_r_m  should be instantiated  to a term,  _A_r_g to an integer  between
    1  and  the  arity of  _T_e_r_m.    _V_a_l_u_e  is  unified with  the  _A_r_g-th
    argument  of _T_e_r_m.   _A_r_g may also  be unbound.   In this case  _V_a_l_u_e
    will  be unified  with the  successive arguments of  the term.    On
    successful  unification, _A_r_g  is unified  with the argument  number.
    Backtracking  yields alternative  solutions.    The predicate  arg/3
    fails  silently if  _A_r_g= 0 or _A_r_g > _a_r_i_t_y and raises  the exception
    domain_error(not_less_than_zero, _A_r_g)if _A_r_g <0.


_?_T_e_r_m =.. _?_L_i_s_t                                                   _[_I_S_O_]
    _L_i_s_t  is a list whose head is the functor of _T_e_r_m and  the remaining
    arguments  are  the arguments  of the  term.    Either side  of  the
    predicate  may be  a variable,  but  not both.    This predicate  is
    called `Univ'.

    ____________________________________________________________________|                                                                    |
    | ?- foo(hello, X) =.. List.                                         |
    | List = [foo, hello, X]                                             |
    |                                                                    |

    | ?- Term =.. [baz, foo(1)].                                         |
    ||Term_=_baz(foo(1))________________________________________________ ||

    SWI-Prolog   also  supports   terms  with   arity  0,   as  in   a()
    (see   section   5.       Such  terms   must  be   processed   using
    compound_name_arguments/3.  This predicate raises a  domain error as
    shown below.  See also functor/3.

    ____________________________________________________________________|                                                                    |
    | ?- a() =.. L.                                                      |
    ||ERROR:_Domain_error:_`compound_non_zero_arity'_expected,_found_`a()'||_


ccoommppoouunndd__nnaammee__aarriittyy((_?_C_o_m_p_o_u_n_d_, _?_N_a_m_e_, _?_A_r_i_t_y))
    Rationalized  version  of functor/3  that  only works  for  compound
    terms and can  examine and create compound terms with zero arguments
    (e.g, name().  See also compound_name_arguments/3.


ccoommppoouunndd__nnaammee__aarrgguummeennttss((_?_C_o_m_p_o_u_n_d_, _?_N_a_m_e_, _?_A_r_g_u_m_e_n_t_s))
    Rationalized  version of =../2 that  can compose and decompose  com-
    pound terms with zero arguments.  See also compound_name_arity/3.


nnuummbbeerrvvaarrss((_+_T_e_r_m_, _+_S_t_a_r_t_, _-_E_n_d))
    Unify  the free variables  in _T_e_r_m with a  term $VAR(_N), where _N  is
    the  number of  the variable.   Counting starts  at _S_t_a_r_t.   _E_n_d  is
    unified  with the number that should be given to the  next variable.
    The  example below illustrates this.  Note that the  toplevel prints
    '$VAR'(0)  as _A  due to  the numbervars(_t_r_u_e) option  used to  print
    answers.

    ____________________________________________________________________|                                                                    |
    | ?- Term = f(X,Y,X),                                                |
    |    numbervars(Term, 0, End),                                       |
    |    write_canonical(Term), nl.                                      |

    | f('$VAR'(0),'$VAR'(1),'$VAR'(0))                                   |
    | Term = f(A, B, A),                                                 |
    | X = A,                                                             |
    | Y = B,                                                             |
    ||End_=_2.__________________________________________________________ ||

    See also the numbervars option to write_term/3 and numbervars/4.


nnuummbbeerrvvaarrss((_+_T_e_r_m_, _+_S_t_a_r_t_, _-_E_n_d_, _+_O_p_t_i_o_n_s))
    As numbervars/3, providing the following options:

    ffuunnccttoorr__nnaammee((_+_A_t_o_m))
         Name of the functor to use instead of $VAR.

    aattttvvaarr((_+_A_c_t_i_o_n))
         What to do if  an attributed variable is encountered.   Options
         are skip,  which causes numbervars/3  to ignore the  attributed
         variable,  bind  which causes  it  to  thread it  as  a  normal
         variable  and  assign  the  next  '$VAR'(N)  term  to  it,   or
         (default) error which raises a type_error exception.

    ssiinngglleettoonnss((_+_B_o_o_l))
         If true  (default false),  numbervars/4  does singleton  detec-
         tion.    Singleton  variables  are  unified  with  '$VAR'('_'),
         causing  them  to  be  printed  as   _  by  write_term/2  using
         the  numbervars  option.      This   option  is  exploited   by
         portray_clause/2 and write_canonical/2.


vvaarr__nnuummbbeerr((_@_T_e_r_m_, _-_V_a_r_N_u_m_b_e_r))
    True  if  _T_e_r_m is  numbered  by numbervars/3  and _V_a_r_N_u_m_b_e_r  is  the
    number  given to this variable.  This predicate avoids the  need for
    unification  with '$VAR'(X)  and opens the  path for replacing  this
    valid Prolog term  by an internal representation that has no textual
    equivalent.


tteerrmm__vvaarriiaabblleess((_+_T_e_r_m_, _-_L_i_s_t))                                       _[_I_S_O_]
    Unify  _L_i_s_t with  a list of  variables, each  sharing with a  unique
    variable  of _T_e_r_m.   The variables in _L_i_s_t  are ordered in order  of
    appearance traversing _T_e_r_m  depth-first and left-to-right.  See also
    term_variables/3.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- term_variables(a(X, b(Y, X), Z), L).                            |

    ||L_=_[X,_Y,_Z].____________________________________________________ ||


tteerrmm__vvaarriiaabblleess((_+_T_e_r_m_, _-_L_i_s_t_, _?_T_a_i_l))
    Difference  list version of term_variables/2.  That is, _T_a_i_l  is the
    tail of the variable list _L_i_s_t.


ccooppyy__tteerrmm((_+_I_n_, _-_O_u_t))                                               _[_I_S_O_]
    Create  a version  of _I_n  with renamed (fresh)  variables and  unify
    it  to  _O_u_t.   Attributed  variables (see  section  7.1) have  their
    attributes  copied.    The  implementation of  copy_term/2 can  deal
    with  infinite  trees  (cyclic  terms).     As  pure  Prolog  cannot
    distinguish a ground  term from another ground term with exactly the
    same  structure, ground  sub-terms are  _s_h_a_r_e_d between  _I_n and  _O_u_t.
    Sharing  ground terms  does affect  setarg/3.   SWI-Prolog  provides
    duplicate_term/2 to create a true copy of a term.


44..2200..11 NNoonn--llooggiiccaall ooppeerraattiioonnss oonn tteerrmmss

Prolog is  not able to  _m_o_d_i_f_y instantiated  parts of a  term.   Lacking
that capability makes  the language much safer, but  unfortunately there
are problems that suffer severely in terms of time  and/or memory usage.
Always try hard to avoid the use of these primitives, but  they can be a
good alternative  to using dynamic  predicates.   See also section  7.3,
discussing the use of global variables.


sseettaarrgg((_+_A_r_g_, _+_T_e_r_m_, _+_V_a_l_u_e))
    Extra-logical  predicate.     Assigns the  _A_r_g-th  argument  of  the
    compound  term _T_e_r_m with the given _V_a_l_u_e.  The assignment  is undone
    if  backtracking brings the  state back into  a position before  the
    setarg/3 call.  See also nb_setarg/3.

    This  predicate may  be used  for destructive  assignment to  terms,
    using  them as an  extra-logical storage  bin.   Always try hard  to
    avoid  the use of  setarg/3 as  it is not  supported by many  Prolog
    systems  and one  has to  be very careful  about unexpected  copying
    as  well as  unexpected noncopying  of terms.   A  good practice  to
    improve somewhat on  this situation is to make sure that terms whose
    arguments  are  subject to  setarg/3 have  one  unused and  unshared
    variable  in addition to the used  arguments.  This variable  avoids
    unwanted  sharing in, e.g., copy_term/2,  and causes the term to  be
    considered as non-ground.


nnbb__sseettaarrgg((_+_A_r_g_, _+_T_e_r_m_, _+_V_a_l_u_e))
    Assigns  the _A_r_g-th  argument  of the  compound term  _T_e_r_m with  the
    given  _V_a_l_u_e  as  setarg/3,   but  on  backtracking  the  assignment
    is  _n_o_t  reversed.    If  _V_a_l_u_e  is not  atomic,  it  is  duplicated
    using  duplicate_term/2.   This  predicate uses  the same  technique
    as  nb_setval/2.     We  therefore  refer   to  the  description  of
    nb_setval/2  for details on  non-backtrackable assignment of  terms.
    This  predicate is  compatible with GNU-Prolog  setarg(_A_,_T_,_V_,_f_a_l_s_e),
    removing  the type  restriction on  _V_a_l_u_e.   See  also nb_linkarg/3.
    Below  is  an example  for counting  the number  of  solutions of  a
    goal.    Note  that this  implementation is  thread-safe,  reentrant
    and  capable of handling exceptions.  Realising these  features with
    a  traditional implementation based  on assert/retract or flag/3  is
    much more complicated.

    ____________________________________________________________________|                                                                    |
    | :- meta_predicate                                                  |

    |         succeeds_n_times(0, -).                                    |
    |                                                                    |
    | succeeds_n_times(Goal, Times) :-                                   |
    |         Counter = counter(0),                                      |
    |         (   Goal,                                                  |
    |             arg(1, Counter, N0),                                   |
    |             N is N0 + 1,                                           |
    |             nb_setarg(1, Counter, N),                              |

    |             fail                                                   |
    |         ;   arg(1, Counter, Times)                                 |
    ||________).________________________________________________________ ||


nnbb__lliinnkkaarrgg((_+_A_r_g_, _+_T_e_r_m_, _+_V_a_l_u_e))
    As  nb_setarg/3,  but like nb_linkval/2 it does _n_o_t duplicate  _V_a_l_u_e.
    Use with  extreme care and consult the documentation of nb_linkval/2
    before use.


dduupplliiccaattee__tteerrmm((_+_I_n_, _-_O_u_t))
    Version  of copy_term/2 that also copies ground terms  and therefore
    ensures  that  destructive  modification  using  setarg/3  does  not
    affect  the copy.   See also  nb_setval/2,  nb_linkval/2, nb_setarg/3
    and nb_linkarg/3.


ssaammee__tteerrmm((_@_T_1_, _@_T_2))                                            _[_s_e_m_i_d_e_t_]
    True  if _T_1 and _T_2 are  equivalent and will remain equivalent,  even
    if  setarg/3 is  used  on either  of them.    This means  _T_1 and  _T_2
    are  the same variable,  equivalent atomic data  or a compound  term
    allocated at the same address.


44..2211 AAnnaallyyssiinngg aanndd CCoonnssttrruuccttiinngg AAttoommss

These  predicates  convert   between  Prolog  constants  and  lists   of
character codes.  The predicates atom_codes/2, number_codes/2 and name/2
behave the same when  converting from a constant to a list  of character
codes.     When converting  the  other  way  around,  atom_codes/2  will
generate an  atom, number_codes/2  will generate a  number or  exception
and name/2 will return a number if possible and an atom otherwise.

The ISO standard  defines atom_chars/2 to describe the `broken-up'  atom
as  a list  of one-character  atoms instead  of a  list of  codes.    Up
to  version 3.2.x,  SWI-Prolog's  atom_chars/2 behaved  like atom_codes,
compatible with  Quintus and SICStus  Prolog.   As of 3.3.x,  SWI-Prolog
atom_codes/2 and atom_chars/2are compliant to the ISO standard.

To  ease  the pain  of  all  variations in  the  Prolog  community,  all
SWI-Prolog predicates  behave as  flexible as  possible.   This  implies
the  `list-side' accepts  either  a code-list  or  a char-list  and  the
`atom-side' accepts all atomic types (atom, number and string).


aattoomm__ccooddeess((_?_A_t_o_m_, _?_S_t_r_i_n_g))                                         _[_I_S_O_]
    Convert  between an atom and a list of character codes.   If _A_t_o_m is
    instantiated,  it will be translated into a list of  character codes
    and  the result  is unified with  _S_t_r_i_n_g.   If _A_t_o_m  is unbound  and
    _S_t_r_i_n_g  is a list of character  codes, _A_t_o_m will be unified  with an
    atom constructed from this list.


aattoomm__cchhaarrss((_?_A_t_o_m_, _?_C_h_a_r_L_i_s_t))                                       _[_I_S_O_]
    As  atom_codes/2, but  _C_h_a_r_L_i_s_t  is a  list of  one-character  atoms
    rather than a list of character codes.

    ____________________________________________________________________|                                                                    |
    | ?- atom_chars(hello, X).                                           |
    |                                                                    |
    ||X_=_[h,_e,_l,_l,_o]_______________________________________________ ||


cchhaarr__ccooddee((_?_A_t_o_m_, _?_C_o_d_e))                                            _[_I_S_O_]
    Convert  between character and character  code for a single  charac-
    ter.


nnuummbbeerr__cchhaarrss((_?_N_u_m_b_e_r_, _?_C_h_a_r_L_i_s_t))                                   _[_I_S_O_]
    Similar  to  atom_chars/2,  but  converts between  a number  and  its
    representation  as a  list of  one-character atoms.    Fails with  a
    syntax_error if  _N_u_m_b_e_r is unbound or  _C_h_a_r_L_i_s_t does not describe  a
    number.   Following  the ISO standard,  it allows for _l_e_a_d_i_n_g  white
    space  (including newlines)  and does not  allow for _t_r_a_i_l_i_n_g  white
    space.


nnuummbbeerr__ccooddeess((_?_N_u_m_b_e_r_, _?_C_o_d_e_L_i_s_t))                                   _[_I_S_O_]
    As number_chars/2, but converts to a list  of character codes rather
    than  one-character atoms.    In the  mode (-,  +), both  predicates
    behave identically to improve handling of non-ISO source.


aattoomm__nnuummbbeerr((_?_A_t_o_m_, _?_N_u_m_b_e_r))
    Realises  the popular combination of atom_codes/2 and number_codes/2
    to   convert  between  atom  and   number  (integer  or  float)   in
    one  predicate,   avoiding  the  intermediate  list.     Unlike  the
    ISO  number_codes/2  predicates,  atom_number/2  fails  silently  in
    mode  (+,-)  if  _A_t_o_m  does  not  represent a  number.     See  also
    atomic_list_concat/2 for assembling an atom from atoms and numbers.


nnaammee((_?_A_t_o_m_i_c_, _?_C_o_d_e_L_i_s_t))
    _C_o_d_e_L_i_s_t  is a list  of character codes  representing the same  text
    as  _A_t_o_m_i_c.    Each of  the arguments  may be  a variable,  but  not
    both.   When _C_o_d_e_L_i_s_t describes an integer or floating  point number
    and  _A_t_o_m_i_c is a variable, _A_t_o_m_i_c  will be unified with the  numeric
    value  described by  _C_o_d_e_L_i_s_t (e.g.,  name(N, "300"), 400 is N + 100
    succeeds).  If  _C_o_d_e_L_i_s_t is not a representation of a number, _A_t_o_m_i_c
    will  be unified with the atom with the name given by  the character
    code  list.  When  _A_t_o_m_i_c is an atom  or number, the unquoted  print
    representation  of it as a character code list will be  unified with
    _C_o_d_e_L_i_s_t.

    Note   that  it  is   not  possible  to   produce  the  atom   '300'
    using  name/2,  and that  name(300, CodeList), name('300', CodeList)
    succeeds.     For these  reasons,  new  code should  consider  using
    the  ISO  predicates  atom_codes/2  or number_codes/2.     See  also
    atom_number/2.


tteerrmm__ttoo__aattoomm((_?_T_e_r_m_, _?_A_t_o_m))
    True  if  _A_t_o_m describes  a  term  that unifies  with  _T_e_r_m.    When
    _A_t_o_m  is instantiated, _A_t_o_m  is parsed and  the result unified  with
    _T_e_r_m.    If _A_t_o_m has  no valid syntax,  a syntax_error exception  is
    raised.   Otherwise _T_e_r_m  is ``written'' on _A_t_o_m  using write_term/2
    with  the option quoted(_t_r_u_e).   See also format/3, with_output_to/2
    and term_string/2.


aattoomm__ttoo__tteerrmm((_+_A_t_o_m_, _-_T_e_r_m_, _-_B_i_n_d_i_n_g_s))                       _[_d_e_p_r_e_c_a_t_e_d_]
    Use  _A_t_o_m as  input to  read_term/2 using the  option variable_names
    and  return  the read  term in  _T_e_r_m and  the  variable bindings  in
    _B_i_n_d_i_n_g_s.   _B_i_n_d_i_n_g_s is a list of _N_a_m_e =_V_a_r couples, thus providing
    access  to the actual  variable names.   See  also read_term/2.   If
    _A_t_o_m  has no valid syntax, a syntax_error exception is raised.   New
    code should use read_term_from_atom/3.


aattoomm__ccoonnccaatt((_?_A_t_o_m_1_, _?_A_t_o_m_2_, _?_A_t_o_m_3))                                _[_I_S_O_]
    _A_t_o_m_3  forms the concatenation  of _A_t_o_m_1  and _A_t_o_m_2.   At least  two
    of  the arguments  must be instantiated  to atoms.   This  predicate
    also  allows for the  mode (-,-,+), non-deterministically  splitting
    the  3rd  argument into  two  parts (as  append/3 does  for  lists).
    SWI-Prolog  allows for  atomic arguments.   Portable  code must  use
    atomic_concat/3 if non-atom arguments are involved.


aattoommiicc__ccoonnccaatt((_+_A_t_o_m_i_c_1_, _+_A_t_o_m_i_c_2_, _-_A_t_o_m))
    _A_t_o_m  represents the  text after converting  _A_t_o_m_i_c_1 and _A_t_o_m_i_c_2  to
    text and concatenating the result:

    ____________________________________________________________________|                                                                    |
    | ?- atomic_concat(name, 42, X).                                     |

    ||X_=_name42._______________________________________________________ ||


aattoommiicc__lliisstt__ccoonnccaatt((_+_L_i_s_t_, _-_A_t_o_m))                               _[_c_o_m_m_o_n_s_]
    _L_i_s_t  is  a  list of  strings,  atoms,  integers or  floating  point
    numbers.    Succeeds if _A_t_o_m  can be  unified with the  concatenated
    elements  of  _L_i_s_t.     Equivalent to  atomic_list_concat(_L_i_s_t_,  _'_'_,
    _A_t_o_m).


aattoommiicc__lliisstt__ccoonnccaatt((_+_L_i_s_t_, _+_S_e_p_a_r_a_t_o_r_, _-_A_t_o_m))                   _[_c_o_m_m_o_n_s_]
    Creates  an atom just like atomic_list_concat/2, but  inserts _S_e_p_a_r_a_-
    _t_o_r between each pair of inputs.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- atomic_list_concat([gnu, gnat], ', ', A).                       |
    |                                                                    |
    ||A_=_'gnu,_gnat'___________________________________________________ ||

    The  SWI-Prolog version of this predicate can also be used  to split
    atoms  by  instantiating _S_e_p_a_r_a_t_o_r  and _A_t_o_m  as shown  below.    We
    kept  this functionality  to  simplify porting  old SWI-Prolog  code
    where  this  predicate  was called  concat_atom/3.    When  used  in
    mode  (-,+,+),  _S_e_p_a_r_a_t_o_r  must  be a  non-empty  atom.    See  also
    split_string/4.

    ____________________________________________________________________|                                                                    |

    | ?- atomic_list_concat(L, -, 'gnu-gnat').                           |
    |                                                                    |
    ||L_=_[gnu,_gnat]___________________________________________________ ||


aattoomm__lleennggtthh((_+_A_t_o_m_, _-_L_e_n_g_t_h))                                        _[_I_S_O_]
    True  if _A_t_o_m  is  an atom  of _L_e_n_g_t_h  characters.   The  SWI-Prolog
    version  accepts  all  atomic  types,  as  well  as  code-lists  and
    character-lists.     New code  should  avoid  this feature  and  use
    write_length/3  to  get  the  number of  characters  that  would  be
    written if the argument was handed to write_term/3.


aattoomm__pprreeffiixx((_+_A_t_o_m_, _+_P_r_e_f_i_x))                                 _[_d_e_p_r_e_c_a_t_e_d_]
    True if _A_t_o_m starts  with the characters from _P_r_e_f_i_x.  Its behaviour
    is equivalent to ?- sub_atom(_A_t_o_m, 0, _, _, _P_r_e_f_i_x).  Deprecated.


ssuubb__aattoomm((_+_A_t_o_m_, _?_B_e_f_o_r_e_, _?_L_e_n_, _?_A_f_t_e_r_, _?_S_u_b))                       _[_I_S_O_]
    ISO  predicate  for breaking  atoms.    It maintains  the  following
    relation:  _S_u_b is  a sub-atom of _A_t_o_m that starts at _B_e_f_o_r_e, has _L_e_n
    characters, and _A_t_o_m contains _A_f_t_e_r characters after the match.

    ____________________________________________________________________|                                                                    |
    | ?- sub_atom(abc, 1, 1, A, S).                                      |
    |                                                                    |

    ||A_=_1,_S_=_b______________________________________________________ ||

    The implementation  minimises non-determinism and creation of atoms.
    This  is  a  flexible predicate  that  can do  search,  prefix-  and
    suffix-matching, etc.


ssuubb__aattoomm__iiccaasseecchhkk((_+_H_a_y_s_t_a_c_k_, _?_S_t_a_r_t_, _+_N_e_e_d_l_e))                  _[_s_e_m_i_d_e_t_]
    True  when _N_e_e_d_l_e is a sub atom of _H_a_y_s_t_a_c_k starting at _S_t_a_r_t.   The
    match is `half  case insensitive', i.e., uppercase letters in _N_e_e_d_l_e
    only match themselves,  while lowercase letters in _N_e_e_d_l_e match case
    insensitively.   _S_t_a_r_t is  the first 0-based offset inside  _H_a_y_s_t_a_c_k
    where _N_e_e_d_l_e matches.


44..2222 LLooccaalliizzaattiioonn ((llooccaallee)) ssuuppppoorrtt

SWI-Prolog   provides   (currently  limited)   support   for   localized
applications.

  o The  predicates char_type/2 and code_type/2 query character  classes
    depending on the locale.

  o The  predicates collation_key/2  and locale_sort/2 can  be used  for
    locale dependent sorting of atoms.

  o The  predicate format_time/3  can be used  to format  time and  date
    representations, where some of the specifiers are locale dependent.

  o The   predicate  format/2  provides  locale-specific  formating   of
    numbers.     This functionality  is  based  on a  more  fine-grained
    localization model that is the subject of this section.

A  locale  is  a  (optionally  named)  read-only  object  that  provides
information to locale specific functions.  The system  creates a default
locale object  named default  from the system  locale.   This locale  is
used as  the initial locale  for the three standard  streams as well  as
the main thread.   Locale sensitive  output predicates such as  format/3
get their  locale from the  stream to which  they deliver their  output.
New streams get  their locale from the  thread that created the  stream.
Threads get their locale from the thread that created them.


llooccaallee__ccrreeaattee((_-_L_o_c_a_l_e_, _+_D_e_f_a_u_l_t_, _+_O_p_t_i_o_n_s))
    Create  a new locale object.   _D_e_f_a_u_l_t is either an existing  locale
    or  a string  that  denotes the  name of  a locale  provided by  the
    system,  such as "en_EN.UTF-8".   The  values read from the  default
    locale can be modified using _O_p_t_i_o_n_s.  _O_p_t_i_o_n_s provided are:

    aalliiaass((_+_A_t_o_m))
         Give the locale a name.

    ddeecciimmaall__ppooiinntt((_+_A_t_o_m))
         Specify the decimal point to use.

    tthhoouussaannddss__sseepp((_+_A_t_o_m))
         Specify the string that delimits digit groups.   Only effective
         is grouping is also specified.

    ggrroouuppiinngg((_+_L_i_s_t))
         Specify the grouping  of digits.   Groups are created from  the
         right (least  significant) digits, left  of the decimal  point.
         _L_i_s_t is a list of integers, specifying the number  of digits in
         each group, counting  from the right.   If the last element  is
         repeat(_C_o_u_n_t), the  remaining digits are  grouped in groups  of
         size _C_o_u_n_t.   If the last element  is a normal integer,  digits
         further to the left are not grouped.

    For example, the English locale uses

    ____________________________________________________________________|                                                                    |

    ||[_decimal_point('.'),_thousands_sep(','),_grouping([repeat(3)])_]_ ||

    Named    locales   exists   until    they   are   destroyed    using
    locale_destroy/1  and   they  are  no   longer  referenced.      Un-
    named locales are subject to (atom) garbage collection.


llooccaallee__ddeessttrrooyy((_+_L_o_c_a_l_e))
    Destroy  a locale.   If the locale is  named, this removes the  name
    association  from the locale, after which  the locale is left to  be
    reclaimed by garbage collection.


llooccaallee__pprrooppeerrttyy((_?_L_o_c_a_l_e_, _?_P_r_o_p_e_r_t_y))
    True  when _L_o_c_a_l_e  has _P_r_o_p_e_r_t_y.   Properties  are the  same as  the
    _O_p_t_i_o_n_s described with locale_create/3.


sseett__llooccaallee((_+_L_o_c_a_l_e))
    Set  the  default  locale  for  the  current  thread,   as  well  as
    the  locale  for  the  standard  streams  (user_input,  user_output,
    user_error, current_output and  current_input.   This locale is  used
    for  new streams, unless  overruled using the locale(_L_o_c_a_l_e)  option
    of open/4 or set_stream/2.


ccuurrrreenntt__llooccaallee((_-_L_o_c_a_l_e))
    True when _L_o_c_a_l_e is the locale of the calling thread.


44..2233 CChhaarraacctteerr pprrooppeerrttiieess

SWI-Prolog   offers  two   comprehensive  predicates   for   classifying
characters  and  character   codes.     These  predicates  are   defined
as  built-in  predicates to  exploit  the  C-character  classification's
handling  of  _l_o_c_a_l_e  (handling  of  local  character  sets).      These
predicates are fast, logical and deterministic if applicable.

In addition,  there is  the library ctype  providing compatibility  with
some other Prolog systems.   The predicates of this library  are defined
in terms of code_type/2.


cchhaarr__ttyyppee((_?_C_h_a_r_, _?_T_y_p_e))
    Tests or generates  alternative _T_y_p_es or _C_h_a_rs.  The character types
    are inspired by the standard C <ctype.h>  primitives.

    aallnnuumm
         _C_h_a_r is a letter (upper- or lowercase) or digit.

    aallpphhaa
         _C_h_a_r is a letter (upper- or lowercase).

    ccssyymm
         _C_h_a_r  is a  letter  (upper- or  lowercase),  digit or  the  un-
         derscore  (_).      These  are   valid  C  and  Prolog   symbol
         characters.

    ccssyymmff
         _C_h_a_r is a letter  (upper- or lowercase) or the  underscore (_).
         These are valid first characters for C and Prolog symbols.

    aasscciiii
         _C_h_a_r is a 7-bit ASCII character (0..127).

    wwhhiittee
         _C_h_a_r is a space or tab, i.e. white space inside a line.

    ccnnttrrll
         _C_h_a_r is an ASCII control character (0..31).

    ddiiggiitt
         _C_h_a_r is a digit.

    ddiiggiitt((_W_e_i_g_h_t))
         _C_h_a_r is a digit with value  _W_e_i_g_h_t.  I.e. char_type(X, digit(6)
         yields _X = '6'.  Useful for parsing numbers.

    xxddiiggiitt((_W_e_i_g_h_t))
         _C_h_a_r  is  a  hexadecimal  digit  with  value  _W_e_i_g_h_t.      I.e.
         char_type(a, xdigit(X) yields _X  = '10'.    Useful for  parsing
         numbers.

    ggrraapphh
         _C_h_a_r produces  a visible mark  on a  page when printed.    Note
         that the space is not included!

    lloowweerr
         _C_h_a_r is a lowercase letter.

    lloowweerr((_U_p_p_e_r))
         _C_h_a_r is a  lowercase version of  _U_p_p_e_r.   Only true if _C_h_a_r  is
         lowercase and _U_p_p_e_r uppercase.

    ttoo__lloowweerr((_U_p_p_e_r))
         _C_h_a_r is  a lowercase  version of _U_p_p_e_r.    For non-letters,  or
         letter without case,  _C_h_a_r and  _L_o_w_e_r are the same.   See  also
         upcase_atom/2 and downcase_atom/2.

    uuppppeerr
         _C_h_a_r is an uppercase letter.

    uuppppeerr((_L_o_w_e_r))
         _C_h_a_r is an  uppercase version of _L_o_w_e_r.   Only true if _C_h_a_r  is
         uppercase and _L_o_w_e_r lowercase.

    ttoo__uuppppeerr((_L_o_w_e_r))
         _C_h_a_r is  an uppercase version  of _L_o_w_e_r.   For non-letters,  or
         letter without case,  _C_h_a_r and  _L_o_w_e_r are the same.   See  also
         upcase_atom/2 and downcase_atom/2.

    ppuunncctt
         _C_h_a_r is  a punctuation character.   This  is a graph  character
         that is not a letter or digit.

    ssppaaccee
         _C_h_a_r is  some  form of  layout  character (tab,  vertical  tab,
         newline, etc.).

    eenndd__ooff__ffiillee
         _C_h_a_r is -1.

    eenndd__ooff__lliinnee
         _C_h_a_r ends a line (ASCII: 10..13).

    nneewwlliinnee
         _C_h_a_r is a newline character (10).

    ppeerriioodd
         _C_h_a_r counts as the end of a sentence (.,!,?).

    qquuoottee
         _C_h_a_r is a quote character (", ', `).

    ppaarreenn((_C_l_o_s_e))
         _C_h_a_r is  an open  parenthesis  and _C_l_o_s_e  is the  corresponding
         close parenthesis.

    pprroolloogg__vvaarr__ssttaarrtt
         _C_h_a_r can start a Prolog variable name.

    pprroolloogg__aattoomm__ssttaarrtt
         _C_h_a_r can start a unquoted Prolog atom that is not a symbol.

    pprroolloogg__iiddeennttiiffiieerr__ccoonnttiinnuuee
         _C_h_a_r can continue a Prolog variable name or atom.

    pprroolloogg__pprroolloogg__ssyymmbbooll
         _C_h_a_r is a Prolog symbol character.  Sequences  of Prolog symbol
         characters glue together  to form an  unquoted atom.   Examples
         are =.., \=, etc.


ccooddee__ttyyppee((_?_C_o_d_e_, _?_T_y_p_e))
    As  char_type/2,  but uses character codes rather than  one-character
    atoms.     Please note  that  both  predicates are  as  flexible  as
    possible.    They handle  either representation if  the argument  is
    instantiated  and will instantiate  only with an  integer code or  a
    one-character  atom, depending of  the version used.   See also  the
    Prolog flag double_quotes, atom_chars/2 and atom_codes/2.


44..2233..11 CCaassee ccoonnvveerrssiioonn

There is nothing in  the Prolog standard for converting case  in textual
data.    The SWI-Prolog  predicates code_type/2 and  char_type/2 can  be
used to test  and convert individual characters.   We have started  some
additional support:


ddoowwnnccaassee__aattoomm((_+_A_n_y_C_a_s_e_, _-_L_o_w_e_r_C_a_s_e))
    Converts  the characters  of _A_n_y_C_a_s_e  into lowercase  as char_type/2
    does  (i.e. based on  the defined _l_o_c_a_l_e  if Prolog provides  locale
    support  on the  hosting platform)  and unifies  the lowercase  atom
    with _L_o_w_e_r_C_a_s_e.


uuppccaassee__aattoomm((_+_A_n_y_C_a_s_e_, _-_U_p_p_e_r_C_a_s_e))
    Converts, similar to downcase_atom/2, an atom to uppercase.


44..2233..22 WWhhiittee ssppaaccee nnoorrmmaalliizzaattiioonn


nnoorrmmaalliizzee__ssppaaccee((_-_O_u_t_, _+_I_n))
    Normalize  white  space in  _I_n.    All  leading and  trailing  white
    space  is removed.  All non-empty sequences for Unicode  white space
    characters  are replaced by a single space (\u0020) character.   _O_u_t
    uses the same conventions as with_output_to/2 and format/3.


44..2233..33 LLaanngguuaaggee--ssppeecciiffiicc ccoommppaarriissoonn

This  section  deals   with  predicates  for  language-specific   string
comparison operations.


ccoollllaattiioonn__kkeeyy((_+_A_t_o_m_, _-_K_e_y))
    Create  a _K_e_y from _A_t_o_m for locale-specific comparison.  The  key is
    defined  such that if the key of atom A precedes the  key of atom B
    in the  standard order of terms, A is alphabetically smaller than B
    using the sort order of the current locale.

    The   predicate  collation_key/2  is  used  by   locale_sort/2  from
    library(sort).   Please examine the  implementation of locale_sort/2
    as an example of using this call.

    The  _K_e_y  is  an  implementation-defined  and  generally  unreadable
    string.   On  systems that  do not support  locale handling, _K_e_y  is
    simply unified with _A_t_o_m.


llooccaallee__ssoorrtt((_+_L_i_s_t_, _-_S_o_r_t_e_d))
    Sort  a list of atoms using the current  locale.  _L_i_s_t is a  list of
    atoms  or string objects (see section 5.2).  _S_o_r_t_e_d is  unified with
    a  list containing all  atoms of  _L_i_s_t, sorted to  the rules of  the
    current locale.  See also collation_key/2 and setlocale/3.


44..2244 OOppeerraattoorrss

Operators  are  defined  to improve  the  readability  of  source  code.
For  example, without  operators, to  write  2*3+4*5 one  would have  to
write +(*(2,3),*(4,5)).    In Prolog,  a number of  operators have  been
predefined.   All operators, except for  the comma (,) can be  redefined
by the user.

Some care  has to  be taken  before defining  new operators.    Defining
too many  operators might  make your  source `natural'  looking, but  at
the same  time make  it hard to  understand the  limits of your  syntax.
To ease  the pain, as  of SWI-Prolog 3.3.0,  operators are local to  the
module  in which  they are  defined.   Operators  can  be exported  from
modules  using a  term op(_P_r_e_c_e_d_e_n_c_e_,  _T_y_p_e_,  _N_a_m_e) in  the export  list
as  specified by  module/2.    Many modern  Prolog systems  have  module
specific operators.   Unfortunately,  there is no established  interface
for  exporting and  importing operators.    SWI-Prolog's convention  has
been addopted by YAP.

The  module table  of the  module user  acts as  default  table for  all
modules  and  can  be  modified  explicitly  from  inside  a  module  to
achieve compatibility  with other Prolog that  do not have  module-local
operators:

________________________________________________________________________|                                                                        |
|:- module(prove,                                                        |

|          [ prove/1                                                     |
|          ]).                                                           |
|                                                                        |
|:-|op(900,_xfx,_user:(=>)).____________________________________________ |  |

In SWI-Prolog, a _q_u_o_t_e_d  _a_t_o_m never acts as an operator.  Note  that the
portable way to stop an  atom acting as an operator is to enclose  it in
parentheses like this:  (myop).  See also section 5.3.1.


oopp((_+_P_r_e_c_e_d_e_n_c_e_, _+_T_y_p_e_, _:_N_a_m_e))                                     _[_I_S_O_]
    Declare  _N_a_m_e  to  be  an  operator of  type  _T_y_p_e  with  precedence
    _P_r_e_c_e_d_e_n_c_e.    _N_a_m_e  can also  be a  list of  names,  in which  case
    all  elements of the  list are declared  to be identical  operators.
    _P_r_e_c_e_d_e_n_c_e  is an integer between 0 and 1200.  Precedence  0 removes
    the  declaration.  _T_y_p_e  is one of:   xf, yf, xfx,  xfy, yfx, fy  or
    fx.   The `f' indicates the  position of the functor, while x  and y
    indicate  the position of the arguments.  `y' should  be interpreted
    as  ``on this position a term with precedence lower or equal  to the
    precedence  of the functor should occur''.   For `x' the  precedence
    of  the argument must be strictly lower.   The precedence of  a term
    is  0, unless its  principal functor is an  operator, in which  case
    the precedence is the  precedence of this operator.  A term enclosed
    in parentheses (...) has precedence 0.

    The  predefined operators  are shown in  table 4.2.   Operators  can
    be  redefined, unless  prohibited by one  of the limitations  below.
    Applications  must be careful  with (re-)defining operators  because
    changing  operators  may  cause  (other)  files  to  be  interpreted
    ddiiffffeerreennttllyy.   Often  this will lead  to a syntax error.   In  other
    cases,  text is read silently into  a different term which may  lead
    to subtle and difficult to track errors.

      o  It is not allowed to redefine the comma (',').

      o  The bar  (|) can only  be (re-)defined  as infix operator  with
         priority not less than 1001.

      o  It  is not  allowed  to  define  the empty  list  ([])  or  the
         curly-bracket pair ({}) as operators.

    In   SWI-Prolog,  operators  are   _l_o_c_a_l  to  a  module  (see   also
    section  6.8).   Keeping operators in  modules and using  controlled
    import/export of operators  as described with the module/2 directive
    keep  the  issues  manageable.    The  module  system  provides  the
    operators  from table  4.2 and these  operators cannot be  modified.
    Files  that  are  loaded  from the  SWI-Prolog  directories  resolve
    operators  and predicates from this system module rather  than user,
    which  makes the  semantics of  the library  and development  system
    modules independent of operator changes to the user module.
     ______________________________________________________________
     | 1200 |xfx  |-->, :-                                        |

     | 1200 | fx  |:-, ?-                                         |
     | 1150 | fx  |dynamic,    discontiguous,     initialization, |
     |      |     |meta_predicate,  module_transparent, multifile,|
     |      |     |public,  thread_local,   thread_initialization,|
     |      |     |volatile                                       |
     | 1100 |xfy  |;, |                                           |
     | 1050 |xfy  |->, *->                                        |
     | 1000 |xfy  |,                                              |

     |  990 |xfx  |:=                                             |
     |  900 | fy  |\+                                             |
     |  700 |xfx  |<, =, =.., =@=, \=@=, =:=, =<, ==, =\=, >, >=, |
     |      |     |@<, @=<, @>, @>=, \=, \==, as, is, >:<, :<     |
     |  600 |xfy  |:                                              |
     |  500 | yfx |+, -, /\, \/, xor                              |
     |  500 | fx  |?                                              |

     |  400 | yfx |*, /, //, div, rdiv, <<, >>, mod, rem          |
     |  200 |xfx  |**                                             |
     |  200 |xfy  |^                                              |
     |  200 | fy  |+, -, \                                        |
     |  100 | yfx |.                                              |
     |____1_|_fx__|$______________________________________________|_

                      Table 4.2:  System operators


ccuurrrreenntt__oopp((_?_P_r_e_c_e_d_e_n_c_e_, _?_T_y_p_e_, _?_:_N_a_m_e))                             _[_I_S_O_]
    True  if _N_a_m_e is currently defined as an operator of type  _T_y_p_e with
    precedence _P_r_e_c_e_d_e_n_c_e.  See also op/3.


44..2255 CChhaarraacctteerr CCoonnvveerrssiioonn

Although  I  wouldn't really  know  why  you  would like  to  use  these
features, they are provided for ISO compliance.


cchhaarr__ccoonnvveerrssiioonn((_+_C_h_a_r_I_n_, _+_C_h_a_r_O_u_t))                                 _[_I_S_O_]
    Define  that term input  (see read_term/3) maps each character  read
    as  _C_h_a_r_I_n to the character _C_h_a_r_O_u_t.   Character conversion is  only
    executed  if  the Prolog  flag char_conversion is  set  to true  and
    not  inside quoted atoms  or strings.   The initial table maps  each
    character onto itself.  See also current_char_conversion/2.


ccuurrrreenntt__cchhaarr__ccoonnvveerrssiioonn((_?_C_h_a_r_I_n_, _?_C_h_a_r_O_u_t))                         _[_I_S_O_]
    Queries   the   current   character   conversion   table.        See
    char_conversion/2 for details.


44..2266 AArriitthhmmeettiicc

Arithmetic can be  divided into some special purpose integer  predicates
and  a series  of general  predicates for  integer,  floating point  and
rational arithmetic as  appropriate.  The general arithmetic  predicates
all handle _e_x_p_r_e_s_s_i_o_n_s.   An expression is  either a simple number or  a
_f_u_n_c_t_i_o_n.  The  arguments of a function are expressions.   The functions
are described in section 4.26.2.3.


44..2266..11 SSppeecciiaall ppuurrppoossee iinntteeggeerr aarriitthhmmeettiicc

The predicates in  this section provide more logical operations  between
integers.  They  are not covered by the ISO standard, although  they are
`part of the community' and found as either library  or built-in in many
other Prolog systems.


bbeettwweeeenn((_+_L_o_w_, _+_H_i_g_h_, _?_V_a_l_u_e))
    _L_o_w  and _H_i_g_h are  integers, _H_i_g_h >=_L_o_w.   If  _V_a_l_u_e is an  integer,
    _L_o_w=< _V_a_l_u_e=< _H_i_g_h.   When _V_a_l_u_e  is a  variable it is  successively
    bound  to  all integers  between  _L_o_w and  _H_i_g_h.    If _H_i_g_h  is  inf
    or  infinite between/3 is  true iff _V_a_l_u_e>= _L_o_w,  a feature that  is
    particularly  interesting  for generating  integers from  a  certain
    value.


ssuucccc((_?_I_n_t_1_, _?_I_n_t_2))
    True  if _I_n_t_2= _I_n_t_1+1  and _I_n_t_1>=0.   At least one of the arguments
    must  be instantiated to  a natural number.   This predicate  raises
    the  domain  error  not_less_than_zero  if  called  with  a  negative
    integer.   E.g. succ(_X_, _0)  fails silently and succ(_X_, _-_1) raises  a
    domain error.


pplluuss((_?_I_n_t_1_, _?_I_n_t_2_, _?_I_n_t_3))
    True  if _I_n_t_3 =_I_n_t_1 +_I_n_t_2.    At least two  of the  three arguments
    must be instantiated to integers.


ddiivvmmoodd((_+_D_i_v_i_d_e_n_d_, _+_D_i_v_i_s_o_r_, _-_Q_u_o_t_i_e_n_t_, _-_R_e_m_a_i_n_d_e_r))
    This  predicate is a shorthand  for computing both the _Q_u_o_t_i_e_n_t  and
    _R_e_m_a_i_n_d_e_r  of two integers in a  single operation.  This allows  for
    exploiting the fact  that the low level implementation for computing
    the  quotient also  produces the  remainder.   Timing confirms  that
    this  predicate is  almost  twice as  fast as  performing the  steps
    independently.  Semantically, divmod/4 is defined as below.

    ____________________________________________________________________|                                                                    |
    | divmod(Dividend, Divisor, Quotient, Remainder) :-                  |

    |         Quotient  is Dividend div Divisor,                         |
    ||________Remainder_is_Dividend_mod_Divisor.________________________ ||

    Note  that  this  predicate  is  only  available  if  SWI-Prolog  is
    compiled  with unbounded integer support.  This is the case  for all
    packaged versions.


nntthh__iinntteeggeerr__rroooott__aanndd__rreemmaaiinnddeerr((_+_N_, _+_I_, _-_R_o_o_t_, _-_R_e_m_a_i_n_d_e_r))
    True  when  Root to the power N+ Remainder= I.    _N and  _I must  be
    integers.   _N must be one or more.   If _I is negative and _N  is _o_d_d,
    _R_o_o_t  and  _R_e_m_a_i_n_d_e_r are  negative, i.e.,  the  following holds  for
    _I <0:

    ____________________________________________________________________|                                                                    |
    | %   I < 0,                                                         |
    | %   N mod 2 =\= 0,                                                 |
    |     nth_integer_root_and_remainder(                                |

    |         N, I, Root, Remainder),                                    |
    |     IPos is -I,                                                    |
    |     nth_integer_root_and_remainder(                                |
    |         N, IPos, RootPos, RemainderPos),                           |
    |     Root =:= -RootPos,                                             |
    ||____Remainder_=:=_-RemainderPos.__________________________________ ||


44..2266..22 GGeenneerraall ppuurrppoossee aarriitthhmmeettiicc

The  general   arithmetic  predicates   are  optionally  compiled   (see
set_prolog_flag/2  and  the   -O  command  line   option).      Compiled
arithmetic reduces global  stack requirements and improves  performance.
Unfortunately compiled arithmetic cannot  be traced, which is why  it is
optional.


_+_E_x_p_r_1 > _+_E_x_p_r_2                                                   _[_I_S_O_]
    True if expression _E_x_p_r_1 evaluates to a larger number than _E_x_p_r_2.


_+_E_x_p_r_1 < _+_E_x_p_r_2                                                   _[_I_S_O_]
    True if expression _E_x_p_r_1 evaluates to a smaller number than _E_x_p_r_2.


_+_E_x_p_r_1 =< _+_E_x_p_r_2                                                  _[_I_S_O_]
    True  if expression _E_x_p_r_1 evaluates to a smaller or equal  number to
    _E_x_p_r_2.


_+_E_x_p_r_1 >= _+_E_x_p_r_2                                                  _[_I_S_O_]
    True  if expression _E_x_p_r_1 evaluates to  a larger or equal number  to
    _E_x_p_r_2.


_+_E_x_p_r_1 =\= _+_E_x_p_r_2                                                 _[_I_S_O_]
    True if expression _E_x_p_r_1 evaluates to a number non-equal to _E_x_p_r_2.


_+_E_x_p_r_1 =:= _+_E_x_p_r_2                                                 _[_I_S_O_]
    True if expression _E_x_p_r_1 evaluates to a number equal to  _E_x_p_r_2.


_-_N_u_m_b_e_r iiss _+_E_x_p_r                                                  _[_I_S_O_]
    True  when _N_u_m_b_e_r is the value to which _E_x_p_r evaluates.   Typically,
    is/2  should be used with unbound left  operand.  If equality  is to
    be tested, =:=/2 should be used.  For example:

             ?- 1 is sin(pi/2).   Fails!    sin(pi/2) evaluates
                                  to the float  1.0, which does
                                  not unify with the integer 1.
             ?- 1 =:= sin(pi/2).  Succeeds as expected.


44..2266..22..11 AArriitthhmmeettiicc ttyyppeess

SWI-Prolog defines the following numeric types:

  o _i_n_t_e_g_e_r
    If  SWI-Prolog is built using the _G_N_U _m_u_l_t_i_p_l_e  _p_r_e_c_i_s_i_o_n _a_r_i_t_h_m_e_t_i_c
    _l_i_b_r_a_r_y  (GMP), integer  arithmetic is _u_n_b_o_u_n_d_e_d,  which means  that
    the  size of integers is limited by available memory only.   Without
    GMP,  SWI-Prolog  integers are  64-bits,  regardless of  the  native
    integer  size  of  the  platform.    The  type  of  integer  support
    can  be detected  using the  Prolog flags  bounded, min_integer  and
    max_integer.   As the use of GMP  is default, most of the  following
    descriptions assume unbounded integer arithmetic.

    Internally,  SWI-Prolog has  three integer  representations.   Small
    integers   (defined  by  the  Prolog  flag  max_tagged_integer)  are
    encoded directly.   Larger integers are represented as 64-bit values
    on  the global  stack.   Integers  that do not  fit in  64 bits  are
    represented as serialised GNU MPZ structures on the global stack.

  o _r_a_t_i_o_n_a_l _n_u_m_b_e_r
    Rational  numbers  (Q) are  quotients of  two  integers.   Rational
    arithmetic  is only provided if GMP  is used (see above).   Rational
    numbers  are currently not  supported by  a Prolog type.   They  are
    represented  by the compound  term rdiv(_N_,_M). Rational numbers  that
    are  returned from is/2  are _c_a_n_o_n_i_c_a_l, which  means M  is positive
    and  N  and  M have  no  common divisors.    Rational  numbers  are
    introduced  in the computation  using the rational/1,  rationalize/1
    or the rdiv/2  (rational division) function.  Using the same functor
    for  rational division and for representing rational  numbers allows
    for  passing rational  numbers between computations  as well as  for
    using format/3 for printing.

    In  the long term,  it is likely  that rational numbers will  become
    _a_t_o_m_i_c  as well  as a subtype  of _n_u_m_b_e_r.   User  code that  creates
    or  inspects the  rdiv(_M_,_N)  terms will  not be  portable to  future
    versions.     Rationals  are  created using  one  of  the  functions
    mentioned above and inspected using rational/3.

  o _f_l_o_a_t
    Floating  point numbers  are represented  using the  C type  double.
    On  most of today's platforms  these are 64-bit IEEE floating  point
    numbers.

Arithmetic functions that require integer arguments accept,  in addition
to integers,  rational numbers  with (canonical)  denominator `1'.    If
the required  argument is a  float the argument  is converted to  float.
Note that conversion of integers to floating point numbers  may raise an
overflow exception.  In all other cases, arguments  are converted to the
same type using the order below.

    integer ! rational number ! floating point number


44..2266..22..22 RRaattiioonnaall nnuummbbeerr eexxaammpplleess

The  use  of  rational  numbers  with  unbounded   integers  allows  for
exact integer  or _f_i_x_e_d  _p_o_i_n_t arithmetic  under addition,  subtraction,
multiplication  and division.    To exploit  rational arithmetic  rdiv/2
should  be used  instead  of `/'  and  floating  point numbers  must  be
converted to  rational using  rational/1.   Omitting  the rational/1  on
floats  will  convert a  rational  operand  to float  and  continue  the
arithmetic using floating point numbers.  Here are some examples.

              A is 2 rdiv 6                  A = 1 rdiv 3
              A is 4 rdiv 3 + 1              A = 7 rdiv 3
              A is 4 rdiv 3 + 1.5            A = 2.83333
              A is 4 rdiv 3 + rational(1.5)  A = 17 rdiv 6

Note that  floats cannot  represent all  decimal numbers exactly.    The
function  rational/1 creates  an _e_x_a_c_t  equivalent of  the float,  while
rationalize/1  creates  a  rational number  that  is  within  the  float
rounding error from the original float.  Please  check the documentation
of these functions for details and examples.

Rational  numbers can  be  printed  as decimal  numbers  with  arbitrary
precision using the format/3 floating point conversion:

________________________________________________________________________|                                                                        |
|?- A is 4 rdiv 3 + rational(1.5),                                       |

|   format('~50f~n', [A]).                                               |
|2.83333333333333333333333333333333333333333333333333                    |
|                                                                        |
|A|=_17_rdiv_6__________________________________________________________ | |


44..2266..22..33 AArriitthhmmeettiicc FFuunnccttiioonnss

Arithmetic functions  are terms  which are evaluated  by the  arithmetic
predicates  described in  section  4.26.2.    There  are four  types  of
arguments to functions:

       _E_x_p_r       Arbitrary   expression,   returning  either   a
                  floating point value or an integer.
       _I_n_t_E_x_p_r    Arbitrary expression  that must evaluate to  an
                  integer.
       _R_a_t_E_x_p_r    Arbitrary expression  that must  evaluate to  a

                  rational number.
       _F_l_o_a_t_E_x_p_r  Arbitrary expression  that must  evaluate to  a
                  floating point.

For  systems using  bounded integer  arithmetic  (default is  unbounded,
see section 4.26.2.1  for details), integer operations that  would cause
overflow automatically convert to floating point arithmetic.

SWI-Prolog  provides  many  extensions to  the  set  of  floating  point
functions  defined by  the  ISO standard.    The  current policy  is  to
provide such  functions on `as-needed' basis  if the function is  widely
supported elsewhere and  notably if it is  part of the C99  mathematical
library.  In addition, we try to maintain compatibility with YAP.


- _+_E_x_p_r                                                           _[_I_S_O_]
    _R_e_s_u_l_t =-_E_x_p_r


+ _+_E_x_p_r                                                           _[_I_S_O_]
    _R_e_s_u_l_t =_E_x_p_r.   Note that if + is  followed by a number, the parser
    discards the +.  I.e. ?- integer(+1) succeeds.


_+_E_x_p_r_1 + _+_E_x_p_r_2                                                   _[_I_S_O_]
    _R_e_s_u_l_t =_E_x_p_r_1 +_E_x_p_r_2


_+_E_x_p_r_1 - _+_E_x_p_r_2                                                   _[_I_S_O_]
    _R_e_s_u_l_t =_E_x_p_r_1 -_E_x_p_r_2


_+_E_x_p_r_1 * _+_E_x_p_r_2                                                   _[_I_S_O_]
    _R_e_s_u_l_t =_E_x_p_r_1_*Expr2


_+_E_x_p_r_1 / _+_E_x_p_r_2                                                   _[_I_S_O_]
    _R_e_s_u_l_t = _E_x_p_r_1=_E_x_p_r_2.  If the flag  iso is true, both arguments are
    converted  to float  and the  return value is  a float.    Otherwise
    (default),  if both arguments are integers the operation  returns an
    integer if the division  is exact.  If at least one of the arguments
    is  rational  and  the  other argument  is  integer,  the  operation
    returns  a rational number.  In all other cases the return  value is
    a float.  See also ///2 and rdiv/2.


_+_I_n_t_E_x_p_r_1 mmoodd _+_I_n_t_E_x_p_r_2                                           _[_I_S_O_]
    Modulo, defined as _R_e_s_u_l_t = _I_n_t_E_x_p_r_1 - (_I_n_t_E_x_p_r_1 div _I_n_t_E_x_p_r_2)  * _I_n_t_E_x_p_r_2,
    where div is _f_l_o_o_r_e_d division.


_+_I_n_t_E_x_p_r_1 rreemm _+_I_n_t_E_x_p_r_2                                           _[_I_S_O_]
    Remainder   of  integer  division.     Behaves  as  if   defined  by
    _R_e_s_u_l_t is _I_n_t_E_x_p_r_1 - (_I_n_t_E_x_p_r_1 // _I_n_t_E_x_p_r_2)  * _I_n_t_E_x_p_r_2


_+_I_n_t_E_x_p_r_1 // _+_I_n_t_E_x_p_r_2                                            _[_I_S_O_]
    Integer  division,  defined  as  _R_e_s_u_l_t is rndI(_E_x_p_r_1/_E_x_p_r_2).     The
    function  rndI is the  default rounding used  by the C  compiler and
    available  through the  Prolog flag  integer_rounding_function.    In
    the C99 standard, C-rounding is defined as towards_zero.


ddiivv((_+_I_n_t_E_x_p_r_1_, _+_I_n_t_E_x_p_r_2))                                         _[_I_S_O_]
    Integer              division,                defined             as
    _R_e_s_u_l_t is (_I_n_t_E_x_p_r_1 - _I_n_t_E_x_p_r_1 mod _I_n_t_E_x_p_r_2) // _I_n_t_E_x_p_r_2 .        In
    other   words,  this  is   integer  division  that  rounds   towards
    -infinity.   This function  guarantees behaviour that is  consistent
    with  mod/2, i.e.,  the following holds for  every pair of  integers
    X; Y where Y =\= 0.

    ____________________________________________________________________|                                                                    |
    |         Q is div(X, Y),                                            |
    |         M is mod(X, Y),                                            |

    ||________X_=:=_Y*Q+M.______________________________________________ ||


_+_R_a_t_E_x_p_r rrddiivv _+_R_a_t_E_x_p_r
    Rational  number  division.    This function  is only  available  if
    SWI-Prolog  has been  compiled with  rational number support.    See
    section 4.26.2.2 for details.


_+_I_n_t_E_x_p_r_1 ggccdd _+_I_n_t_E_x_p_r_2
    Result is the greatest common divisor of _I_n_t_E_x_p_r_1, _I_n_t_E_x_p_r_2.


aabbss((_+_E_x_p_r))                                                        _[_I_S_O_]
    Evaluate _E_x_p_r and return the absolute value of it.


ssiiggnn((_+_E_x_p_r))                                                       _[_I_S_O_]
    Evaluate to -1  if _E_x_p_r< 0, 1 if _E_x_p_r> 0 and 0 if _E_x_p_r= 0.  If _E_x_p_r
    evaluates  to a float, the return value is a float (e.g.,  -1.0, 0.0
    or  1.0).   In particular,  note that  sign(-0.0) evaluates to  0.0.
    See also copysign/1


ccooppyyssiiggnn((_+_E_x_p_r_1_, _+_E_x_p_r_2))                                          _[_I_S_O_]
    Evaluate  to _X, where  the absolute value  of _X equals the  absolute
    value  of  _E_x_p_r_1 and  the  sign  of _X  matches  the sign  of  _E_x_p_r_2.
    This  function  is based  on copysign()  from  C99, which  works  on
    double precision floats  and deals with handling the sign of special
    floating point values  such as -0.0.  Our implementation follows C99
    if  both arguments are floats.   Otherwise, copysign/1 evaluates  to
    _E_x_p_r_1  if the  sign of  both expressions  matches or  -_E_x_p_r_1 if  the
    signs  do not match.  Here, we use the extended notion  of signs for
    floating  point numbers, where  the sign of  -0.0 and other  special
    floats is negative.


mmaaxx((_+_E_x_p_r_1_, _+_E_x_p_r_2))                                               _[_I_S_O_]
    Evaluate  to the  larger of  _E_x_p_r_1 and _E_x_p_r_2.    Both arguments  are
    compared after converting  to the same type, but the return value is
    in  the original type.   For example,  max(2.5, 3) compares the  two
    values after converting to float, but returns the integer 3.


mmiinn((_+_E_x_p_r_1_, _+_E_x_p_r_2))                                               _[_I_S_O_]
    Evaluate  to  the smaller  of _E_x_p_r_1  and _E_x_p_r_2.    See  max/2 for  a
    description of type handling.


.((_+_I_n_t_, _[_]))
    A  list of one element evaluates to  the element.  This  implies "a"
    evaluates  to the character  code of the  letter `a' (97) using  the
    traditional  mapping of double quoted string to a list  of character
    codes.   Arithmetic evaluation also translates a string  object (see
    section  5.2) of one  character length into  the character code  for
    that character.   This implies that expression "a" also works of the
    Prolog flag  double_quotesis set to string.   The recommended way to
    specify the character code of the letter `a' is 0'a.


rraannddoomm((_+_I_n_t_E_x_p_r))
    Evaluate  to  a random  integer _i  for which  0=< i< _I_n_t_E_x_p_r.    The
    system  has two  implementations.   If it  is compiled with  support
    for  unbounded arithmetic (default) it  uses the GMP library  random
    functions.   In this case,  each thread keeps its own  random state.
    The  default algorithm is the _M_e_r_s_e_n_n_e _T_w_i_s_t_e_r algorithm.   The seed
    is  set when the first random number  in a thread is generated.   If
    available,  it is set  from /dev/random.   Otherwise it is set  from
    the system clock.   If unbounded arithmetic is not supported, random
    numbers are shared  between threads and the seed is initialised from
    the  clock when SWI-Prolog was started.   The predicate set_random/1
    can be used to control the random number generator.


rraannddoomm__ffllooaatt
    Evaluate  to a random float I  for which 0:0 <i <1:0.   This function
    shares  the  random state  with  random/1.    All remarks  with  the
    function  random/1 also apply  for random_float/0.   Note that  both
    sides  of the domain  are _o_p_e_n.   This avoids evaluation errors  on,
    e.g., log/1 or //2 while no practical application can expect 0.0.


rroouunndd((_+_E_x_p_r))                                                      _[_I_S_O_]
    Evaluate  _E_x_p_r  and   round  the  result  to  the  nearest  integer.
    According  to  ISO, round/1  is  defined as  floor(_E_x_p_r_+_1_/_2),  i.e.,
    rounding  _d_o_w_n.     This  is  an  unconventional  choice  and  under
    which  the  relation  round(Expr) == -round(-Expr)  does  not  hold.
    SWI-Prolog   rounds  _o_u_t_w_a_r_d,   e.g.,  round(1.5) =:= 2  and   round
    round(-1.5) =:= -2.


iinntteeggeerr((_+_E_x_p_r))
    Same as round/1 (backward compatibility).


ffllooaatt((_+_E_x_p_r))                                                      _[_I_S_O_]
    Translate  the result to a floating point number.   Normally, Prolog
    will  use integers  whenever possible.    When used  around the  2nd
    argument  of is/2, the result will  be returned as a floating  point
    number.  In other contexts, the operation has no effect.


rraattiioonnaall((_+_E_x_p_r))
    Convert  the _E_x_p_r to  a rational  number or integer.   The  function
    returns  the input on integers and  rational numbers.  For  floating
    point  numbers, the returned rational number _e_x_a_c_t_l_y  represents the
    float.    As  floats cannot  exactly represent  all decimal  numbers
    the  results may  be surprising.    In the  examples below,  doubles
    can  represent 0.25 and  the result is as  expected, in contrast  to
    the  result of rational(_0_._1).   The function rationalize/1  remedies
    this.   See section 4.26.2.2 for more information on rational number
    support.

    ____________________________________________________________________|                                                                    |
    | ?- A is rational(0.25).                                            |

    |                                                                    |
    | A is 1 rdiv 4                                                      |
    | ?- A is rational(0.1).                                             |
    ||A_=_3602879701896397_rdiv_36028797018963968_______________________ ||


rraattiioonnaalliizzee((_+_E_x_p_r))
    Convert  the _E_x_p_r to  a rational  number or integer.   The  function
    is  similar to rational/1,  but the result  is only accurate  within
    the rounding error  of floating point numbers, generally producing a
    much smaller denominator.

    ____________________________________________________________________|                                                                    |
    | ?- A is rationalize(0.25).                                         |
    |                                                                    |
    | A = 1 rdiv 4                                                       |

    | ?- A is rationalize(0.1).                                          |
    |                                                                    |
    ||A_=_1_rdiv_10_____________________________________________________ ||


ffllooaatt__ffrraaccttiioonnaall__ppaarrtt((_+_E_x_p_r))                                       _[_I_S_O_]
    Fractional   part  of  a  floating  point  number.      Negative  if
    _E_x_p_r   is  negative,  rational   if  _E_x_p_r  is  rational  and  0   if
    _E_x_p_r   is  integer.     The  following  relation  is   always  true:
    Xisfloatfractionalpart(X)+ floatintegerpart(X).


ffllooaatt__iinntteeggeerr__ppaarrtt((_+_E_x_p_r))                                          _[_I_S_O_]
    Integer  part  of  floating point  number.    Negative  if  _E_x_p_r  is
    negative, _E_x_p_r if _E_x_p_r is integer.


ttrruunnccaattee((_+_E_x_p_r))                                                   _[_I_S_O_]
    Truncate  _E_x_p_r to  an integer.    If _E_x_p_r>= 0  this is  the same  as
    floor(_E_x_p_r).  For _E_x_p_r <0 this is the same as ceil(_E_x_p_r).  That is,
    truncate/1 rounds towards zero.


fflloooorr((_+_E_x_p_r))                                                      _[_I_S_O_]
    Evaluate  _E_x_p_r and return  the largest integer  smaller or equal  to
    the result of the evaluation.


cceeiilliinngg((_+_E_x_p_r))                                                    _[_I_S_O_]
    Evaluate  _E_x_p_r and return  the smallest integer  larger or equal  to
    the result of the evaluation.


cceeiill((_+_E_x_p_r))
    Same as ceiling/1 (backward compatibility).


_+_I_n_t_E_x_p_r_1 >> _+_I_n_t_E_x_p_r_2                                            _[_I_S_O_]
    Bitwise  shift  _I_n_t_E_x_p_r_1  by  _I_n_t_E_x_p_r_2  bits to  the  right.     The
    operation   performs  _a_r_i_t_h_m_e_t_i_c  _s_h_i_f_t,  which  implies   that  the
    inserted  most  significant bits  are copies  of  the original  most
    significant bits.


_+_I_n_t_E_x_p_r_1 << _+_I_n_t_E_x_p_r_2                                            _[_I_S_O_]
    Bitwise shift _I_n_t_E_x_p_r_1 by _I_n_t_E_x_p_r_2 bits to the left.


_+_I_n_t_E_x_p_r_1 \/ _+_I_n_t_E_x_p_r_2                                            _[_I_S_O_]
    Bitwise `or' _I_n_t_E_x_p_r_1 and _I_n_t_E_x_p_r_2.


_+_I_n_t_E_x_p_r_1 /\ _+_I_n_t_E_x_p_r_2                                            _[_I_S_O_]
    Bitwise `and' _I_n_t_E_x_p_r_1 and _I_n_t_E_x_p_r_2.


_+_I_n_t_E_x_p_r_1 xxoorr _+_I_n_t_E_x_p_r_2                                           _[_I_S_O_]
    Bitwise `exclusive or' _I_n_t_E_x_p_r_1 and _I_n_t_E_x_p_r_2.


\ _+_I_n_t_E_x_p_r                                                        _[_I_S_O_]
    Bitwise  negation.   The returned value  is the one's complement  of
    _I_n_t_E_x_p_r.


ssqqrrtt((_+_E_x_p_r))                                                       _[_I_S_O_]
    _R_e_s_u_l_t =square root of _E_x_p_r


ssiinn((_+_E_x_p_r))                                                        _[_I_S_O_]
    _R_e_s_u_l_t =sine of _E_x_p_r.  _E_x_p_r is the angle in radians.


ccooss((_+_E_x_p_r))                                                        _[_I_S_O_]
    _R_e_s_u_l_t =cosine of _E_x_p_r.  _E_x_p_r is the angle in radians.


ttaann((_+_E_x_p_r))                                                        _[_I_S_O_]
    _R_e_s_u_l_t =tangus of _E_x_p_r.  _E_x_p_r is the angle in radians.


aassiinn((_+_E_x_p_r))                                                       _[_I_S_O_]
    _R_e_s_u_l_t =inverse sine of _E_x_p_r.  _R_e_s_u_l_t is the angle in radians.


aaccooss((_+_E_x_p_r))                                                       _[_I_S_O_]
    _R_e_s_u_l_t =inverse cosine of _E_x_p_r.  _R_e_s_u_l_t is the angle in radians.


aattaann((_+_E_x_p_r))                                                       _[_I_S_O_]
    _R_e_s_u_l_t =inverse tangus of _E_x_p_r.  _R_e_s_u_l_t is the angle in radians.


aattaann22((_+_Y_E_x_p_r_, _+_X_E_x_p_r))                                             _[_I_S_O_]
    _R_e_s_u_l_t = inverse tangus of _Y_E_x_p_r / _X_E_x_p_r.   _R_e_s_u_l_t is  the angle in
    radians.    The return  value is  in the  range [-pi:::pi].   Used  to
    convert between rectangular and polar coordinate system.

    Note  that the ISO Prolog  standard demands atan2(_0_._0_,_0_._0) to  raise
    an  evaluation error,  whereas the  C99 and  POSIX standards  demand
    this to evaluate to 0.0.  SWI-Prolog follows C99 and POSIX.


aattaann((_+_Y_E_x_p_r_, _+_X_E_x_p_r))
    Same as atan2/2 (backward compatibility).


ssiinnhh((_+_E_x_p_r))
    _R_e_s_u_l_t = sinh_E_x_p_r.     The  hyperbolic  sine  of  X  is  defined  as
    e to the power X -e to the power -X=2.


ccoosshh((_+_E_x_p_r))
    _R_e_s_u_l_t = cosh_E_x_p_r.     The hyperbolic  cosine  of  X is  defined  as
    e to the power X +e to the power -X=2.


ttaannhh((_+_E_x_p_r))
    _R_e_s_u_l_t = tanh_E_x_p_r.   The  hyperbolic  tangent of  X  is defined  as
    sinhX=coshX.


aassiinnhh((_+_E_x_p_r))
    _R_e_s_u_l_t =arcsinh(_E_x_p_r) (inverse hyperbolic sine).


aaccoosshh((_+_E_x_p_r))
    _R_e_s_u_l_t =arccosh(_E_x_p_r) (inverse hyperbolic cosine).


aattaannhh((_+_E_x_p_r))
    _R_e_s_u_l_t =arctanh(_E_x_p_r).  (inverse hyperbolic tangent).


lloogg((_+_E_x_p_r))                                                        _[_I_S_O_]
    Natural logarithm.  _R_e_s_u_l_t =natural logarithm of _E_x_p_r


lloogg1100((_+_E_x_p_r))
    Base-10 logarithm.  _R_e_s_u_l_t =10 base logarithm of _E_x_p_r


eexxpp((_+_E_x_p_r))                                                        _[_I_S_O_]
    _R_e_s_u_l_t =e to the power _E_x_p_r


_+_E_x_p_r_1 ** _+_E_x_p_r_2                                                  _[_I_S_O_]
    _R_e_s_u_l_t = _E_x_p_r_1 to the power _E_x_p_r_2.   The result is  a float, unless
    SWI-Prolog  is  compiled  with  unbounded integer  support  and  the
    inputs are integers and  produce an integer result.  The integer ex-
    pressions  0 to the power I, 1 to the power I and  -1 to the power I
    are  guaranteed to  work  for any  integer I.    Other integer  base
    values  generate a  resource error  if the  result does  not fit  in
    memory.

    The  ISO  standard  demands  a  float  result  for  all  inputs  and
    introduces  ^/2 for  integer exponentiation.   The function  float/1
    can  be used  on one  or both arguments  to force  a floating  point
    result.     Note  that  casting  the  _i_n_p_u_t  result  in  a  floating
    point  computation,   while  casting  the  _o_u_t_p_u_t  performs  integer
    exponentiation followed by a conversion to float.


_+_E_x_p_r_1 ^ _+_E_x_p_r_2                                                   _[_I_S_O_]
    In  SWI-Prolog,  ^/2 is  equivalent to  **/2.   The  ISO version  is
    similar,  except that it produces  a evaluation error if both  _E_x_p_r_1
    and _E_x_p_r_2 are integers  and the result is not an integer.  The table
    below  illustrates the behaviour of the exponentiation  functions in
    ISO and SWI.

            _____________________________________________________
            |__E_x_p_r_1__E_x_p_r_2__|Function_|SWI__________|ISO__________|_
            | Int   Int   |**/2     |Int or Float |Float        |
            | Int   Float |**/2     |Float        |Float        |
            | Float Int   |**/2     |Float        |Float        |

            |_Float_Float_|**/2_____|Float________|Float________|_
            | Int   Int   |^/2      |Int or Float |Int or error |
            | Int   Float |^/2      |Float        |Float        |
            | Float Int   |^/2      |Float        |Float        |
            |_Float_Float_|^/2______|Float________|Float________|_


ppoowwmm((_+_I_n_t_E_x_p_r_B_a_s_e_, _+_I_n_t_E_x_p_r_E_x_p_, _+_I_n_t_E_x_p_r_M_o_d))
    _R_e_s_u_l_t   =  (_I_n_t_E_x_p_r_B_a_s_e to the power _I_n_t_E_x_p_r_E_x_p) modulo _I_n_t_E_x_p_r_M_o_d.
    Only  available when compiled with unbounded integer support.   This
    formula  is required  for Diffie-Hellman  key-exchange, a  technique
    where two parties can establish a secret key over a public network.


llggaammmmaa((_+_E_x_p_r))
    Return  the natural  logarithm of  the absolute value  of the  Gamma
    function.


eerrff((_+_E_x_p_r))
    WikipediA:  ``In mathematics,  the error  function (also called  the
    Gauss  error function)  is  a special  function (non-elementary)  of
    sigmoid  shape which occurs  in probability, statistics and  partial
    differential equations.''


eerrffcc((_+_E_x_p_r))
    WikipediA: ``The complementary error function.''


ppii                                                                _[_I_S_O_]
    Evaluate to the mathematical constant pi (3.14159...).


ee
    Evaluate to the mathematical constant e (2.71828...).


eeppssiilloonn
    Evaluate  to the  difference  between the  float 1.0  and the  first
    larger floating point number.


ccppuuttiimmee
    Evaluate  to a  floating point  number expressing the  cpu time  (in
    seconds)  used by Prolog  up till  now.   See also statistics/2  and
    time/1.


eevvaall((_+_E_x_p_r))
    Evaluate  _E_x_p_r.  Although  ISO standard dictates that `A=1+2,  B is
    A'  works and unifies B to  3, it is widely felt  that source level
    variables  in arithmetic  expressions  should have  been limited  to
    numbers.   In this  view the eval function  can be used to  evaluate
    arbitrary expressions.

BBiittvveeccttoorr ffuunnccttiioonnss

The  functions   below  are  not   covered  by  the   standard.      The
msb/1  function  also appears  in  hProlog  and  SICStus Prolog.     The
getbit/2  function  also   appears  in  ECLiPSe,  which   also  provides
setbit(_V_e_c_t_o_r_,_I_n_d_e_x)  and   clrbit(_V_e_c_t_o_r_,_I_n_d_e_x).      The  others   are
SWI-Prolog extensions that improve handling of  ---unbounded--- integers
as bit-vectors.


mmssbb((_+_I_n_t_E_x_p_r))
    Return  the largest integer N  such that (IntExpr >> N) /\ 1 =:= 1.
    This  is the (zero-origin)  index of the  most significant 1 bit  in
    the  value of _I_n_t_E_x_p_r,  which must evaluate  to a positive  integer.
    Errors for 0, negative integers, and non-integers.


llssbb((_+_I_n_t_E_x_p_r))
    Return  the smallest integer N such that (IntExpr >> N) /\ 1 =:= 1.
    This  is the (zero-origin) index of  the least significant 1 bit  in
    the  value of _I_n_t_E_x_p_r,  which must evaluate  to a positive  integer.
    Errors for 0, negative integers, and non-integers.


ppooppccoouunntt((_+_I_n_t_E_x_p_r))
    Return  the  number  of  1s  in the  binary  representation  of  the
    non-negative integer _I_n_t_E_x_p_r.


ggeettbbiitt((_+_I_n_t_E_x_p_r_V_, _+_I_n_t_E_x_p_r_I))
    Evaluates  to the  bit  value (0  or 1)  of the  _I_n_t_E_x_p_r_I-th bit  of
    _I_n_t_E_x_p_r_V.  Both arguments  must evaluate  to non-negative  integers.
    The  result  is equivalent  to (IntExprV >> IntExprI)/\1,  but  more
    efficient  because materialization of the shifted value  is avoided.
    Future  versions will optimise  (IntExprV >> IntExprI)/\1 to a  call
    to getbit/2, providing both portability and performance.


44..2277 MMiisscc aarriitthhmmeettiicc ssuuppppoorrtt pprreeddiiccaatteess


sseett__rraannddoomm((_+_O_p_t_i_o_n))
    Controls   the  random  number  generator  accessible   through  the
    _f_u_n_c_t_i_o_n_s  random/1  and  random_float/0.     Note that  the  library
    random provides an alternative API to the same random primitives.

    sseeeedd((_+_S_e_e_d))
         Set the  seed of the random  generator for this  thread.   _S_e_e_d
         is an  integer  or the  atom random.    If random,  repeat  the
         initialization procedure described with the  function random/1.
         Here is an example:

         _______________________________________________________________|                                                               |

         |?- set_random(seed(111)), A is random(6).                      |
         |A = 5.                                                         |
         |?- set_random(seed(111)), A is random(6).                      |
         |A|=_5.________________________________________________________ | |

    ssttaattee((_+_S_t_a_t_e))
         Set the generator to  a state fetched using the  state property
         of random_property/1.  Using other values may lead to undefined
         behaviour.


rraannddoomm__pprrooppeerrttyy((_?_O_p_t_i_o_n))
    True  when _O_p_t_i_o_n  is a  current property of  the random  generator.
    Currently,  this  predicate provides  access  to the  state.    This
    predicate   is  not   present  on   systems  where   the  state   is
    inaccessible.

    ssttaattee((_-_S_t_a_t_e))
         Describes the  current state of  the random  generator.   State
         is a normal  Prolog term that can  be asserted or written to  a
         file.  Applications should make no other  assumptions about its
         representation.   The only  meaningful operation  is to use  as
         argument to set_random/1 using the state(_S_t_a_t_e) option.


ccuurrrreenntt__aarriitthhmmeettiicc__ffuunnccttiioonn((_?_H_e_a_d))
    True when _H_e_a_d is an evaluable function.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- current_arithmetic_function(sin(_)).                            |

    ||true._____________________________________________________________ ||


44..2288 BBuuiilltt--iinn lliisstt ooppeerraattiioonnss

Most  list  operations  are  defined  in  the  library  lists  described
in  section 12.14.    Some  that  are  implemented with  more  low-level
primitives are built-in and described here.


iiss__lliisstt((_+_T_e_r_m))
    True if _T_e_r_m is  bound to the empty list ([]) or a term with functor
    `'[|]''  and  arity 2  and the  second argument  is a  list.    This
    predicate  acts as  if defined  by the definition  below on  _a_c_y_c_l_i_c
    terms.   The implementation _f_a_i_l_s safely if _T_e_r_m represents a cyclic
    list.

    ____________________________________________________________________|                                                                    |
    | is_list(X) :-                                                      |
    |         var(X), !,                                                 |
    |         fail.                                                      |

    | is_list([]).                                                       |
    | is_list([_|T]) :-                                                  |
    ||________is_list(T)._______________________________________________ ||


mmeemmbbeerrcchhkk((_?_E_l_e_m_, _+_L_i_s_t))                                       _[_s_e_m_i_d_e_t_]
    True  when  _E_l_e_m  is  an  element  of _L_i_s_t.     This  `chk'  variant
    of  member/2  is  semi  deterministic and  typically  used  to  test
    membership  of  a list.     Raises a  type  error if  scanning  _L_i_s_t
    encounters  a non-list.   Note that  memberchk/2 does _n_o_t perform  a
    full  list typecheck.    For  example, memberchk(a, [a|b])  succeeds
    without error and memberchk/2  loops on a cyclic list if _E_l_e_m is not
    a member of _L_i_s_t.


lleennggtthh((_?_L_i_s_t_, _?_I_n_t))                                               _[_I_S_O_]
    True  if  _I_n_t represents  the number  of  elements in  _L_i_s_t.    This
    predicate  is a true  relation and  can be used  to find the  length
    of  a list  or produce  a list  (holding variables)  of length  _I_n_t.
    The  predicate is non-deterministic,  producing lists of  increasing
    length  if _L_i_s_t is  a _p_a_r_t_i_a_l _l_i_s_t  and _I_n_t is unbound.   It  raises
    errors if

      o  _I_n_t is bound to a non-integer.

      o  _I_n_t is a negative integer.

      o  _L_i_s_t  is neither  a  list  nor a  partial  list.    This  error
         condition includes cyclic lists.

    This  predicate  fails if  the tail  of _L_i_s_t  is  equivalent to  _I_n_t
    (e.g., length(L,L)).


ssoorrtt((_+_L_i_s_t_, _-_S_o_r_t_e_d))                                              _[_I_S_O_]
    True  if _S_o_r_t_e_d can be unified  with a list holding the elements  of
    _L_i_s_t,  sorted  to the  standard order  of terms  (see section  4.7).
    Duplicates  are removed.  The implementation is in C,  using _n_a_t_u_r_a_l
    _m_e_r_g_e _s_o_r_t.   The sort/2 predicate can sort a cyclic list, returning
    a non-cyclic version with the same elements.


ssoorrtt((_+_K_e_y_, _+_O_r_d_e_r_, _+_L_i_s_t_, _-_S_o_r_t_e_d))
    True  when _S_o_r_t_e_d can be unified with a list holding the  element of
    _L_i_s_t.   _K_e_y determines  which part of each  element in _L_i_s_t is  used
    for  comparing two  term and  _O_r_d_e_r describes  the relation  between
    each set of consecutive elements in _S_o_r_t_e_d.

    If  _K_e_y is the integer zero (0), the entire term is used  to compare
    two  elements.   Using _K_e_y=0  can be used  to sort arbitrary  Prolog
    terms.   Other values for _K_e_y  can only be used with  compound terms
    or  dicts (see section  5.4).   An integer  key extracts the  _K_e_y-th
    argument  from a compound  term.   An integer  or atom key  extracts
    the  value from a  dict that is  associated with the given  key.   A
    type_error is  raised  if the  list  element is  of the  wrong  type
    and  an existence_error is  raised if  the compound  has not  enough
    argument or the dict does not contain the requested key.

    Deeper  nested elements  of structures  can be selected  by using  a
    list of keys for the _K_e_y argument.

    The _O_r_d_e_r argument is described in the table below

                   _Order__Ordering____Duplicate_handling__
                    @<     ascending   remove
                    @=<    ascending   keep
                    @>     descending  remove
                    @>=    descending  keep

    The sort is _s_t_a_b_l_e,  which implies that, if duplicates are kept, the
    order  of duplicates  is not changed.    If duplicates are  removed,
    only  the  first element  of  a sequence  of duplicates  appears  in
    _S_o_r_t_e_d.

    This predicate supersedes  most of the other sorting primitives, for
    example:

    ____________________________________________________________________|                                                                    |

    | sort(List, Sorted)     :- sort(0,  @<, List,  Sorted).             |
    | msort(List, Sorted)    :- sort(0, @=<, List,  Sorted).             |
    ||keysort(Pairs,_Sorted)_:-_sort(1,_@=<,_Pairs,_Sorted).____________ ||

    The  following example sorts a  list of rows, for example  resulting
    from  csv_read_file/2) ascending on the 3th column  and descending on
    the 4th column:

    ____________________________________________________________________|                                                                    |
    |     sort(4, @>=, Rows0, Rows1),                                    |
    ||____sort(3,_@=<,_Rows1,_Sorted).__________________________________ ||

    See   also  sort/2   (ISO),  msort/2,   keysort/2,  predsort/3   and
    order_by/2.


mmssoorrtt((_+_L_i_s_t_, _-_S_o_r_t_e_d))
    Equivalent  to sort/2,  but does not  remove duplicates.   Raises  a
    type_error if _L_i_s_t is a cyclic list or not a list.


kkeeyyssoorrtt((_+_L_i_s_t_, _-_S_o_r_t_e_d))                                           _[_I_S_O_]
    Sort  a list  of _p_a_i_r_s.   _L_i_s_t must  be a  list of _K_e_y-_V_a_l_u_e  pairs,
    terms  whose principal  functor is  (-)/2.   _L_i_s_t is  sorted on  _K_e_y
    according  to  the  standard order  of  terms (see  section  4.7.1).
    Duplicates  are _n_o_t removed.   Sorting is _s_t_a_b_l_e with regard to  the
    order of the _V_a_l_u_e_s,  i.e., the order of multiple elements that have
    the same _K_e_y is not changed.

    The  keysort/2 predicate is often used together with  library pairs.
    It  can be  used to sort  lists on  different or multiple  criteria.
    For  example,  the  following  predicates  sorts  a  list  of  atoms
    according  to their length, maintaining the initial order  for atoms
    that have the same length.

    ____________________________________________________________________|                                                                    |
    | :- use_module(library(pairs)).                                     |

    |                                                                    |
    | sort_atoms_by_length(Atoms, ByLength) :-                           |
    |         map_list_to_pairs(atom_length, Atoms, Pairs),              |
    |         keysort(Pairs, Sorted),                                    |
    ||________pairs_values(Sorted,_ByLength).___________________________ ||


pprreeddssoorrtt((_+_P_r_e_d_, _+_L_i_s_t_, _-_S_o_r_t_e_d))
    Sorts  similar to sort/2, but determines  the order of two terms  by
    calling  _P_r_e_d(-_D_e_l_t_a, +_E_1, +_E_2).   This call  must unify _D_e_l_t_a  with
    one of <, >  or =.  If the built-in predicate compare/3 is used, the
    result is the same as sort/2.  See also keysort/2.


44..2299 FFiinnddiinngg aallll SSoolluuttiioonnss ttoo aa GGooaall


ffiinnddaallll((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_B_a_g))                                   _[_I_S_O_]
    Create  a list of the  instantiations _T_e_m_p_l_a_t_e gets successively  on
    backtracking  over _G_o_a_l  and unify the  result with  _B_a_g.   Succeeds
    with  an  empty  list  if _G_o_a_l  has  no  solutions.    findall/3  is
    equivalent  to  bagof/3  with  all free  variables  bound  with  the
    existential  operator (^), except that  bagof/3 fails when _G_o_a_l  has
    no solutions.


ffiinnddaallll((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_B_a_g_, _+_T_a_i_l))
    As  findall/3,  but  returns  the  result  as  the  difference  list
    _B_a_g-_T_a_i_l.  The 3-argument version is defined as

    ____________________________________________________________________|                                                                    |
    | findall(Templ, Goal, Bag) :-                                       |

    ||________findall(Templ,_Goal,_Bag,_[])_____________________________ ||


ffiinnddnnssoollss((_+_N_, _@_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_L_i_s_t))                         _[_n_o_n_d_e_t_]


ffiinnddnnssoollss((_+_N_, _@_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_L_i_s_t_, _?_T_a_i_l))                  _[_n_o_n_d_e_t_]
    As  findall/3 and findall/4, but generates at most _N solutions.   If
    _N  solutions are  returned, this  predicate succeeds  with a  choice
    point  if _G_o_a_l has  a choice point.   Backtracking returns the  next
    chunk  of (at most)  _N solutions.   In addition  to passing a  plain
    integer  for _N,  a term of  the form  count(_N) is accepted.    Using
    count(_N),  the  size  of the  next  chunk  can be  controlled  using
    nb_setarg/3.  The non-deterministic behaviour  used to implement the
    _c_h_u_n_k  option in  pengines.   Based on  Ciao, but  the Ciao  version
    is  deterministic.    Portability can  be achieved  by wrapping  the
    goal  in once/1.  Below are  three examples.  The  first illustrates
    standard  chunking of  answers.    The second  illustrates that  the
    chunk  size can  be adjusted  dynamically and  the last  illustrates
    that  no choice point is left  if _G_o_a_l leaves no choice-point  after
    the last solution.

    ____________________________________________________________________|                                                                    |
    | ?- findnsols(5, I, between(1, 12, I), L).                          |
    | L = [1, 2, 3, 4, 5] ;                                              |
    | L = [6, 7, 8, 9, 10] ;                                             |

    | L = [11, 12].                                                      |
    |                                                                    |
    | ?- State = count(2),                                               |
    |    findnsols(State, I, between(1, 12, I), L),                      |
    |    nb_setarg(1, State, 5).                                         |
    | State = count(5), L = [1, 2] ;                                     |
    | State = count(5), L = [3, 4, 5, 6, 7] ;                            |
    | State = count(5), L = [8, 9, 10, 11, 12].                          |

    |                                                                    |
    | ?- findnsols(4, I, between(1, 4, I), L).                           |
    ||L_=_[1,_2,_3,_4]._________________________________________________ ||


bbaaggooff((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_B_a_g))                                     _[_I_S_O_]
    Unify  _B_a_g with  the alternatives  of _T_e_m_p_l_a_t_e.   If  _G_o_a_l has  free
    variables  besides  the  one sharing  with  _T_e_m_p_l_a_t_e,  bagof/3  will
    backtrack  over the alternatives  of these free variables,  unifying
    _B_a_g with the  corresponding alternatives of _T_e_m_p_l_a_t_e.  The construct
    +_V_a_r^_G_o_a_l  tells bagof/3 not to bind _V_a_r in _G_o_a_l.  bagof/3  fails if
    _G_o_a_l has no solutions.

    The  example below  illustrates bagof/3  and the  ^ operator.    The
    variable bindings are printed together on one line to save paper.

    ____________________________________________________________________|                                                                    |
    | 2 ?- listing(foo).                                                 |
    | foo(a, b, c).                                                      |
    | foo(a, b, d).                                                      |

    | foo(b, c, e).                                                      |
    | foo(b, c, f).                                                      |
    | foo(c, c, g).                                                      |
    | true.                                                              |
    |                                                                    |
    | 3 ?- bagof(C, foo(A, B, C), Cs).                                   |
    | A = a, B = b, C = G308, Cs = [c, d] ;                              |
    | A = b, B = c, C = G308, Cs = [e, f] ;                              |

    | A = c, B = c, C = G308, Cs = [g].                                  |
    |                                                                    |
    | 4 ?- bagof(C, A^foo(A, B, C), Cs).                                 |
    | A = G324, B = b, C = G326, Cs = [c, d] ;                           |
    | A = G324, B = c, C = G326, Cs = [e, f, g].                         |
    |                                                                    |
    ||5_?-______________________________________________________________ ||


sseettooff((_+_T_e_m_p_l_a_t_e_, _+_G_o_a_l_, _-_S_e_t))                                     _[_I_S_O_]
    Equivalent  to bagof/3, but sorts the  result using sort/2 to get  a
    sorted list of alternatives without duplicates.


44..3300 FFoorraallll


ffoorraallll((_:_C_o_n_d_, _:_A_c_t_i_o_n))                                        _[_s_e_m_i_d_e_t_]
    For  all alternative bindings of  _C_o_n_d, _A_c_t_i_o_n can  be proven.   The
    example  verifies that all arithmetic  statements in the given  list
    are correct.  It does not say which is wrong if one proves wrong.

    ____________________________________________________________________|                                                                    |
    | ?- forall(member(Result = Formula, [2 = 1 + 1, 4 = 2 * 2]),        |

    ||_________________Result_=:=_Formula)._____________________________ ||

    The  predicate  forall/2  is implemented  as  \+ ( Cond, \+ Action),
    i.e., _T_h_e_r_e _i_s  _n_o _i_n_s_t_a_n_t_i_a_t_i_o_n _o_f _C_o_n_d _f_o_r _w_h_i_c_h _A_c_t_i_o_n _i_s _f_a_l_s_e_..
    The  use of double  negation implies that  forall/2 _d_o_e_s _n_o_t  _c_h_a_n_g_e
    _a_n_y _v_a_r_i_a_b_l_e _b_i_n_d_i_n_g_s.   It proves a relation.  The forall/2 control
    structure  can be used  for its side-effects.   E.g., the  following
    asserts relations in a list into the dynamic database:

    ____________________________________________________________________|                                                                    |
    | ?- forall(member(Child-Parent, ChildPairs),                        |
    ||__________assertz(child_of(Child,_Parent))).______________________ ||

    Using  forall/2 as forall(_G_e_n_e_r_a_t_o_r_,  _S_i_d_e_E_f_f_e_c_t) is preferred  over
    the  classical _f_a_i_l_u_r_e _d_r_i_v_e_n _l_o_o_p  as shown below because it  makes
    it  explicit which part of the construct is the generator  and which
    part  creates the  side effects.   Also,  unexpected failure of  the
    side effect causes the  construct to fail.  Failure makes it evident
    that  there is an issue with  the code, while a failure  driven loop
    would succeed with an erroneous result.

    ____________________________________________________________________|                                                                    |
    |         ...,                                                       |
    |         (   Generator,                                             |
    |             SideEffect,                                            |

    |             fail                                                   |
    |         ;   true                                                   |
    ||________)_________________________________________________________ ||

    If your intent  is to create variable bindings, the forall/2 control
    structure  is inadequate.   Possibly you are looking for  maplist/2,
    findall/3 or foreach/2.


44..3311 FFoorrmmaatttteedd WWrriittee

The  current  version   of  SWI-Prolog  provides  two  formatted   write
predicates.   The  `writef' family (writef/1,  writef/2, swritef/3),  is
compatible with Edinburgh C-Prolog and should  be considered _d_e_p_r_e_c_a_t_e_d.
The  `format' family  (format/1,  format/2,  format/3), was  defined  by
Quintus Prolog and currently available in many  Prolog systems, although
the details vary.


44..3311..11 WWrriitteeff


wwrriitteeff((_+_A_t_o_m))                                              _[_d_e_p_r_e_c_a_t_e_d_]
    Equivalent to writef(Atom, []). See writef/2 for details.


wwrriitteeff((_+_F_o_r_m_a_t_, _+_A_r_g_u_m_e_n_t_s))                                _[_d_e_p_r_e_c_a_t_e_d_]
    Formatted  write.    _F_o_r_m_a_t  is an  atom  whose characters  will  be
    printed.    _F_o_r_m_a_t may contain  certain special character  sequences
    which   specify   certain  formatting   and  substitution   actions.
    _A_r_g_u_m_e_n_t_s provides all the terms required to be output.

    Escape sequences to generate a single special character:

             __________________________________________________
             | \n   |Output  a  newline  character  (see  also |
             |      |nl/[0,1])                                 |
             | \l   |Output a line separator (same as \n)      |

             | \r   |Output  a   carriage   return   character |
             |      |(ASCII 13)                                |
             | \t   |Output the ASCII character TAB (9)        |
             | \\   |The character \ is output                 |
             | \%   |The character % is output                 |
             | \nnn |where <_n_n_n> is  an integer  (1-3 digits); |
             |      |the character with  code <_n_n_n>  is output |

             |______|(NB_:_<_n_n_n>_is_read_as_ddeecciimmaall)___________|

    Note  that  \l,   \nnn  and  \\  are  interpreted  differently  when
    character escapes are in effect.  See section 2.15.2.1.

    Escape  sequences to include  arguments from _A_r_g_u_m_e_n_t_s.   Each  time
    a  %  escape sequence  is found  in _F_o_r_m_a_t  the  next argument  from
    _A_r_g_u_m_e_n_t_s is formatted according to the specification.

              _________________________________________________%t

              | %w  print/1 the next item (mnemonic:  term)   |    |

              | %q  |write/1the next item                     |

              |     |writeq/1the next item                    |
              | %d  |Write the term,  ignoring operators.  See|
              |     |also  write_term/2.      Mnemonic:    old|
              | %p  |Edinburgh display/1                      |

              |     |print/1the next item (identical to %t)   |
              | %n  |Put the  next item as  a character (i.e.,|

              |     |it is a character code)                  |
              | %r  |Write the  next item  N times where  N is|
              |     |the second item (an integer)             |
              | %s  |Write the  next item  as a String  (so it|
              |     |must be a list of characters)            |
              | %f  |Perform a ttyflush/0 (no items used)     |
              | %Nc |Write  the   next  item  Centered  in  N |

              |     |columns                                  |
              | %Nl |Write the next  item Left justified in N |
              |     |columns                                  |
              | %Nr |Write the next item Right justified in N |
              |     |columns.   N is a decimal number with  at|
              |     |least  one digit.   The  item must  be an|
              |_____|atom,_integer,_float_or_string.__________|_


sswwrriitteeff((_-_S_t_r_i_n_g_, _+_F_o_r_m_a_t_, _+_A_r_g_u_m_e_n_t_s))                      _[_d_e_p_r_e_c_a_t_e_d_]
    Equivalent to writef/2,  but ``writes'' the result on _S_t_r_i_n_g instead
    of the current output stream.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- swritef(S, '%15L%w', ['Hello', 'World']).                       |
    |                                                                    |
    ||S_=_"Hello__________World"________________________________________ ||


sswwrriitteeff((_-_S_t_r_i_n_g_, _+_F_o_r_m_a_t))                                  _[_d_e_p_r_e_c_a_t_e_d_]
    Equivalent to swritef(String, Format, []).


44..3311..22 FFoorrmmaatt

The format family of  predicates is the most versatile and  portable way
to produce textual output.


ffoorrmmaatt((_+_F_o_r_m_a_t))
    Defined  as `format(Format) :- format(Format, []).'.   See  format/2
    for details.


ffoorrmmaatt((_+_F_o_r_m_a_t_, _:_A_r_g_u_m_e_n_t_s))
    _F_o_r_m_a_t  is an  atom, list of  character codes,  or a Prolog  string.
    _A_r_g_u_m_e_n_t_s   provides   the   arguments  required   by   the   format
    specification.   If  only one argument  is required and this  single
    argument  is not a  list, the argument  need not be  put in a  list.
    Otherwise the arguments are put in a list.

    Special sequences start  with the tilde (~), followed by an optional
    numeric  argument,  optionally  followed by  a colon  modifier  (:),
    followed  by a character describing the action to be undertaken.   A
    numeric  argument is  either a  sequence of  digits, representing  a
    positive  decimal number, a sequence  `<_c_h_a_r_a_c_t_e_r>, representing  the
    character  code value  of the character  (only useful  for ~t) or  a
    asterisk  (*), in which case the numeric argument is taken  from the
    next  argument of  the argument  list,  which should  be a  positive
    integer.  E.g., the following three examples all pass 46 (.) to ~t:

    ____________________________________________________________________|                                                                    |
    | ?- format('~w ~46t ~w~72|~n', ['Title', 'Page']).                  |

    | ?- format('~w ~`.t ~w~72|~n', ['Title', 'Page']).                  |
    ||?-_format('~w_~*t_~w~72|~n',_['Title',_46,_'Page']).______________ ||

    Numeric  conversion (d, D,  e, E, f, g  and G) accept an  arithmetic
    expression  as argument.    This  is introduced  to handle  rational
    numbers  transparently (see section 4.26.2.2).   The floating  point
    conversions  allow  for unlimited  precision for  printing  rational
    numbers  in decimal form.   E.g., the  following will write as  many
    3's as you want by changing the `70'.

    ____________________________________________________________________|                                                                    |
    | ?- format('~50f', [10 rdiv 3]).                                    |
    ||3.33333333333333333333333333333333333333333333333333______________ ||

      ~  Output the tilde itself.

      a  Output the next argument, which  must be an atom.   This option
         is equivalent to ww, except that it requires the  argument to be
         an atom.

      c  Interpret the next argument  as a character code and add  it to
         the output.   This argument must  be a valid Unicode  character
         code.  Note that the actually emitted bytes are  defined by the
         character encoding of  the output stream  and an exception  may
         be raised if the  output stream is not capable  of representing
         the  requested Unicode  character.    See  section  2.18.1  for
         details.

      d  Output  next argument  as  a decimal  number.    It  should  be
         an integer.    If a  numeric argument  is specified,  a dot  is
         inserted _a_r_g_u_m_e_n_t  positions from the  right (useful for  doing
         fixed point arithmetic with integers, such as  handling amounts
         of money).

         The  colon  modifier  (e.g.,  ~:d)  causes  the  number  to  be
         printed according  to the  locale of the  output stream.    See
         section 4.22.

      D  Same as dd, but  makes large values easier to read  by inserting
         a comma every three digits  left or right of the dot.   This is
         the same as ~:d, but using the fixed English locale.

      e  Output next argument as a floating point  number in exponential
         notation.    The  numeric  argument  specifies  the  precision.
         Default is  6 digits.   Exact representation  depends on the  C
         library function printf().   This function is invoked  with the
         format %.<_p_r_e_c_i_s_i_o_n>e.

      E  Equivalent  to ee,  but  outputs a  capital  E to  indicate  the
         exponent.

      f  Floating  point  in non-exponential  notation.     The  numeric
         argument defines  the number  of  digits right  of the  decimal
         point.   If  the colon  modifier (:)   is  used,  the float  is
         formatted using conventions from the current locale,  which may
         define the decimal point as well as grouping of  digits left of
         the decimal point.

      g  Floating point in ee or ff notation, whichever is shorter.

      G  Floating point in EE or ff notation, whichever is shorter.

      i  Ignore  next argument  of  the  argument  list.    Produces  no
         output.

      I  Emit  a  decimal  number  using  Prolog  digit   grouping  (the
         underscore, _).  The argument describes the size  of each digit
         group.   The default is  3.   See also section  2.15.2.3.   For
         example:

         _______________________________________________________________|                                                               |

         |?- A is 1<<100, format('~10I', [A]).                           |
         |1_2676506002_2822940149_6703205376|___________________________ |                                  |

      k  Give the next argument to write_canonical/1.

      n  Output a newline character.

      N  Only output  a newline  if the  last character  output on  this
         stream was not a newline.  Not properly implemented yet.

      p  Give the next argument to print/1.

      q  Give the next argument to writeq/1.

      r  Print integer in  radix numeric argument  notation.  Thus  ~16r
         prints its  argument hexadecimal.   The  argument should be  in
         the range [2;:::;36].   Lowercase letters are used for digits above
         9.   The  colon modifier may  be used  to form  locale-specific
         digit groups.

      R  Same as rr, but uses uppercase letters for digits above 9.

      s  Output text  from a list  of character codes  or a string  (see
         string/1 and section 5.2) from the next argument.

      @  Interpret the next argument as  a goal and execute it.   Output
         written to the current_output stream is inserted at this place.
         Goal is  called in the  module calling format/3.   This  option
         is not  present  in the  original  definition by  Quintus,  but
         supported by some other Prolog systems.

      t  All remaining space between 2 tab stops  is distributed equally
         over ~t  statements  between the  tab  stops.   This  space  is
         padded with spaces by default.  If an argument  is supplied, it
         is taken  to be the  character code of  the character used  for
         padding.   This  can be  used to  do left  or right  alignment,
         centering, distributing, etc.   See also  ~| and ~+ to set  tab
         stops.  A tab stop is assumed at the start of each line.

      |  Set a  tab stop on  the current position.    If an argument  is
         supplied set  a  tab stop  on the  position  of that  argument.
         This  will  cause  all  ~t's  to  be  distributed  between  the
         previous and this tab stop.

      +  Set  a tab  stop (as  ~|)  relative to  the  last tab  stop  or
         the beginning  of  the line  if  no tab  stops are  set  before
         the ~+.    This constructs can  be used  to fill fields.    The
         partial format sequence  below prints an integer  right-aligned
         and padded with zeros in 6 columns.  The ...   sequences in the
         example illustrate  that the  integer is aligned  in 6  columns
         regardless of the remainder of the format specification.

         _______________________________________________________________|                                                               |
         ||_______format('...~|~`0t~d~6+...',_[...,_Integer,_...])______ ||

      w  Give the next argument to write/1.

      W  Give the  next two  arguments to  write_term/2.   For  example,
         format('~W', [Term, [numbervars(true)]]).     This   option  is
         SWI-Prolog specific.

    Example:

    ____________________________________________________________________|                                                                    |
    | simple_statistics :-                                               |

    |     <obtain statistics>         % left to the user                 |
    |     format('~tStatistics~t~72|~n~n'),                              |
    |     format('Runtime: ~`.t ~2f~34|  Inferences: ~`.t ~D~72|~n',     |
    |                                             [RunT, Inf]),          |
    ||____....__________________________________________________________ ||

    will output

    ____________________________________________________________________|                                                                    |

    |                              Statistics                            |
    |                                                                    |
    ||Runtime:_.................._3.45__Inferences:_.........._60,345___ ||


ffoorrmmaatt((_+_O_u_t_p_u_t_, _+_F_o_r_m_a_t_, _:_A_r_g_u_m_e_n_t_s))
    As  format/2, but write  the output on  the given _O_u_t_p_u_t.   The  de-
    facto  standard only allows _O_u_t_p_u_t to  be a stream.  The  SWI-Prolog
    implementation  allows  all  valid  arguments for  with_output_to/2.
    For example:

    ____________________________________________________________________|                                                                    |
    | ?- format(atom(A), '~D', [1000000]).                               |

    ||A_=_'1,000,000'___________________________________________________ ||


44..3311..33 PPrrooggrraammmmiinngg FFoorrmmaatt


ffoorrmmaatt__pprreeddiiccaattee((_+_C_h_a_r_, _+_H_e_a_d))
    If  a sequence ~c (tilde, followed by some character) is  found, the
    format/3  and friends  first check  whether the user  has defined  a
    predicate  to handle the  format.  If  not, the built-in  formatting
    rules  described above are  used.  _C_h_a_r  is either a character  code
    or  a one-character atom, specifying  the letter to be  (re)defined.
    _H_e_a_d  is a  term, whose  name and  arity are used  to determine  the
    predicate  to call  for  the redefined  formatting character.    The
    first  argument to  the  predicate is  the numeric  argument of  the
    format  command, or the  atom default if  no argument is  specified.
    The  remaining arguments  are filled from  the argument  list.   The
    example  below defines  ~T to  print a timestamp  in ISO8601  format
    (see  format_time/3).   The  subsequent block illustrates a  possible
    call.

    ____________________________________________________________________|                                                                    |
    | :- format_predicate('T', format_time(_Arg,_Time)).                 |
    |                                                                    |
    | format_time(_Arg, Stamp) :-                                        |

    |         must_be(number, Stamp),                                    |
    ||________format_time(current_output,_'%FT%T%z',_Stamp).____________ ||

    ____________________________________________________________________|                                                                    |

    | ?- get_time(Now),                                                  |
    |    format('Now, it is ~T~n', [Now]).                               |
    | Now, it is 2012-06-04T19:02:01+0200                                |
    ||Now_=_1338829321.6620328._________________________________________ ||


ccuurrrreenntt__ffoorrmmaatt__pprreeddiiccaattee((_?_C_o_d_e_, _?_:_H_e_a_d))
    True  when ~_C_o_d_e is handled by the user-defined  predicate specified
    by _H_e_a_d.


44..3322 TTeerrmmiinnaall CCoonnttrrooll

The  following  predicates  form  a  simple  access   mechanism  to  the
Unix  termcap library  to provide  terminal-independent  I/O for  screen
terminals.  These  predicates are only available on Unix machines.   The
SWI-Prolog Windows console accepts the ANSI escape sequences.


ttttyy__ggeett__ccaappaabbiilliittyy((_+_N_a_m_e_, _+_T_y_p_e_, _-_R_e_s_u_l_t))
    Get  the  capability named  _N_a_m_e  from the  termcap  library.    See
    termcap(5)  for the capability  names.   _T_y_p_e specifies the type  of
    the  expected result, and is one of string, number or bool.   String
    results  are returned as an atom, number results as an  integer, and
    bool  results as the atom on or off.  If an option  cannot be found,
    this predicate fails  silently.  The results are only computed once.
    Successive queries on the same capability are fast.


ttttyy__ggoottoo((_+_X_, _+_Y))
    Goto  position  (_X, _Y) on  the screen.    Note  that the  predicates
    line_count/2  and  line_position/2  will  not  have  a  well-defined
    behaviour while using this predicate.


ttttyy__ppuutt((_+_A_t_o_m_, _+_L_i_n_e_s))
    Put  an  atom  via the  termcap  library  function tputs().     This
    function  decodes padding  information  in the  strings returned  by
    tty_get_capability/3 and  should be  used to  output these  strings.
    _L_i_n_e_s is the number  of lines affected by the operation, or 1 if not
    applicable (as in almost all cases).


ttttyy__ssiizzee((_-_R_o_w_s_, _-_C_o_l_u_m_n_s))
    Determine the size of the terminal.  Platforms:

    UUnniixx  If  the  system  provides _i_o_c_t_l  calls  for  this,  these  are
         used and tty_size/2 properly  reflects the actual size after  a
         user resize  of the window.    As a fallback,  the system  uses
         tty_get_capability/3 using li  and co  capabilities.   In  this
         case the reported size reflects the size at the  first call and
         is not updated after a user-initiated resize of the terminal.

    WWiinnddoowwss  Getting  the   size  of  the   terminal  is  provided   for
         swipl-win.exe.  The requested value reflects  the current size.
         For the  multithreaded version the  console that is  associated
         with the user_input stream is used.


44..3333 OOppeerraattiinngg SSyysstteemm IInntteerraaccttiioonn


sshheellll((_+_C_o_m_m_a_n_d_, _-_S_t_a_t_u_s))
    Execute  _C_o_m_m_a_n_d on the operating system.   _C_o_m_m_a_n_d is given to  the
    Bourne  shell (/bin/sh).  _S_t_a_t_u_s is unified with the exit  status of
    the command.

    On   Windows,    shell/[1,2]  executes   the   command   using   the
    CreateProcess() API and waits  for the command to terminate.  If the
    command  ends with a & sign, the command is handed to  the WinExec()
    API,  which does not wait for the  new task to terminate.   See also
    win_exec/2 and  win_shell/2.   Please  note that the  CreateProcess()
    API  does nnoott  imply the  Windows command  interpreter (cmd.exe  and
    therefore  commands that  are built in  the command interpreter  can
    only  be activated using  the command interpreter.   For example,  a
    file can be compied using the command below.

    ____________________________________________________________________|                                                                    |
    ||?-_shell('cmd.exe_/C_copy_file1.txt_file2.txt').__________________ ||

    Note  that  many  of  the  operations that  can  be  achieved  using
    the  shell built-in  commands can  easily be  achieved using  Prolog
    primitives.    See  make_directory/1, delete_file/1,  rename_file/2,
    etc.   The clib package provides filesex, implementing  various high
    level file  operations such as copy_file/2.   Using Prolog primitives
    instead of shell commands improves the portability of your program.

    The  library process  provides process_create/3 and several  related
    primitives   that   support  more   fine-grained  interaction   with
    processes, including  I/O redirection and management of asynchronous
    processes.


sshheellll((_+_C_o_m_m_a_n_d))
    Equivalent to `shell(Command, 0)'.


sshheellll
    Start  an  interactive  Unix  shell.     Default  is  /bin/sh;   the
    environment  variable SHELL overrides this  default.  Not  available
    for Win32 platforms.


ggeetteennvv((_+_N_a_m_e_, _-_V_a_l_u_e))
    Get  environment variable.    Fails  silently if  the variable  does
    not  exist.     Please  note that  environment  variable  names  are
    case-sensitive on Unix systems and case-insensitive on Windows.


sseetteennvv((_+_N_a_m_e_, _+_V_a_l_u_e))
    Set  an environment variable.   _N_a_m_e and _V_a_l_u_e must be  instantiated
    to  atoms or  integers.   The  environment variable  will be  passed
    to  shell/[0-2] and  can be  requested using  getenv/2.   They  also
    influence  expand_file_name/2.    Environment variables  are  shared
    between  threads.  Depending  on the underlying C library,  setenv/2
    and  unsetenv/1 may not be  thread-safe and may cause memory  leaks.
    Only  changing the environment once  and before starting threads  is
    safe in all versions of SWI-Prolog.


uunnsseetteennvv((_+_N_a_m_e))
    Remove  an environment variable from the environment.   Some systems
    lack  the underlying unsetenv() library function.  On  these systems
    unsetenv/1 sets the variable to the empty string.


sseettllooccaallee((_+_C_a_t_e_g_o_r_y_, _-_O_l_d_, _+_N_e_w))
    Set/Query  the  _l_o_c_a_l_e setting  which  tells the  C library  how  to
    interpret  text  files, write  numbers,  dates, etc.    Category  is
    one  of all, collate,  ctype, messages,  monetary, numeric or  time.
    For  details,  please consult  the C  library locale  documentation.
    See  also section 2.18.1.    Please note that  the locale is  shared
    between  all  threads and  thread-safe usage  of  setlocale/3 is  in
    general  not  possible.     Do  locale  operations  before  starting
    threads  or thoroughly  study  threading aspects  of locale  support
    in  your  environment before  using in  multithreaded  environments.
    Locale  settings  are  used  by format_time/3,  collation_key/2  and
    locale_sort/2.


uunniixx((_+_C_o_m_m_a_n_d))
    This  predicate comes  from  the Quintus  compatibility library  and
    provides  a partial implementation thereof.   It provides access  to
    some operating system  features and unlike the name suggests, is not
    operating system specific.  Defined _C_o_m_m_a_n_d's are below.

    ssyysstteemm((_+_C_o_m_m_a_n_d))
         Equivalent to calling shell/1.  Use for compatibility only.

    sshheellll((_+_C_o_m_m_a_n_d))
         Equivalent to calling shell/1.  Use for compatibility only.

    sshheellll
         Equivalent to calling shell/0.  Use for compatibility only.

    ccdd
         Equivalent to calling working_directory/2 to the expansion (see
         expand_file_name/2) of ~.  For compatibility only.

    ccdd((_+_D_i_r_e_c_t_o_r_y))
         Equivalent to calling working_directory/2.  Use for compatibil-
         ity only.

    aarrggvv((_-_A_r_g_v))
         Unify _A_r_g_v with the list of command line  arguments provided to
         this Prolog run.  Please note that Prolog  system arguments and
         application arguments are separated  by --.  Integer  arguments
         are  passed as  Prolog  integers,  float arguments  and  Prolog
         floating  point  numbers and  all  other  arguments  as  Prolog
         atoms.  New applications should use the Prolog flag argv.   See
         also the Prolog flag argv.

         A  stand-alone program  could  use  the following  skeleton  to
         handle command line arguments.  See also section 2.10.2.4.

         _______________________________________________________________|                                                               |

         |main :-                                                        |
         |        current_prolog_flag(argv, Argv),                       |
         |        append(_PrologArgs, [--|AppArgs], Argv), !,            |
         ||_______main(AppArgs).________________________________________ ||


44..3333..11 WWiinnddoowwss--ssppeecciiffiicc OOppeerraattiinngg SSyysstteemm IInntteerraaccttiioonn

The  predicates  in this  section  are  only available  on  the  Windows
version  of  SWI-Prolog.     Their  use  is  discouraged  if  there  are
portably  alternatives.   For  example,  win_exec/2 and win_shell/2  can
often be  replaced by  the more  portable shell/2 or  the more  powerful
process_create/3.


wwiinn__eexxeecc((_+_C_o_m_m_a_n_d_, _+_S_h_o_w))
    Windows  only.    Spawns  a Windows  task  without waiting  for  its
    completion.    _S_h_o_w  is  one  of the  Win32  SW_*  constants  written
    in  lowercase  without the  SW_*:   hide maximize  minimize  restore
    show showdefault  showmaximized showminimized showminnoactive showna
    shownoactive  shownormal.   In  addition,  iconic is  a synonym  for
    minimize and normal for shownormal.


wwiinn__sshheellll((_+_O_p_e_r_a_t_i_o_n_, _+_F_i_l_e_, _+_S_h_o_w))
    Windows  only.   Opens  the document  _F_i_l_e using  the Windows  shell
    rules  for doing so.  _O_p_e_r_a_t_i_o_n is one of open, print  or explore or
    another  operation registered with the shell for the  given document
    type.  On  modern systems it is also possible to pass a URL as _F_i_l_e,
    opening  the URL in Windows default  browser.  This call  interfaces
    to  the Win32 API ShellExecute().  The _S_h_o_w argument  determines the
    initial  state of the  opened window (if any).   See  win_exec/2 for
    defined values.


wwiinn__sshheellll((_+_O_p_e_r_a_t_i_o_n_, _+_F_i_l_e))
    Same as win_shell(_O_p_e_r_a_t_i_o_n_, _F_i_l_e_, _n_o_r_m_a_l)


wwiinn__rreeggiissttrryy__ggeett__vvaalluuee((_+_K_e_y_, _+_N_a_m_e_, _-_V_a_l_u_e))
    Windows  only.  Fetches  the value of a  Windows registry key.   _K_e_y
    is  an atom formed  as a path  name describing the desired  registry
    key.   _N_a_m_e  is the  desired attribute name  of the key.   _V_a_l_u_e  is
    unified  with  the value.    If  the  value is  of type  DWORD,  the
    value  is returned  as an integer.   If  the value is  a string,  it
    is  returned  as a  Prolog atom.    Other  types are  currently  not
    supported.    The default  `root' is HKEY_CURRENT_USER. Other  roots
    can be  specified explicitly as HKEY_CLASSES_ROOT, HKEY_CURRENT_USER,
    HKEY_LOCAL_MACHINE  or HKEY_USERS.  The  example below  fetches  the
    extension  to use for  Prolog files (see  README.TXT on the  Windows
    version):

    ____________________________________________________________________|                                                                    |
    | ?- win_registry_get_value(                                         |
    |        'HKEY_LOCAL_MACHINE/Software/SWI/Prolog',                   |
    |        fileExtension,                                              |

    |        Ext).                                                       |
    |                                                                    |
    ||Ext_=_pl__________________________________________________________ ||


wwiinn__ffoollddeerr((_?_N_a_m_e_, _-_D_i_r_e_c_t_o_r_y))
    True  if _N_a_m_e  is the  Windows `CSIDL'  of _D_i_r_e_c_t_o_r_y.    If _N_a_m_e  is
    unbound,  all  known Windows  special  paths are  generated.    _N_a_m_e
    is  the  CSIDL after  deleting the  leading CSIDL_  and mapping  the
    constant  to lowercase.    Check the Windows  documentation for  the
    function  SHGetSpecialFolderPath() for a description of  the defined
    constants.  This example extracts the `My Documents' folder:

    ____________________________________________________________________|                                                                    |
    | ?- win_folder(personal, MyDocuments).                              |

    |                                                                    |
    ||MyDocuments_=_'C:/Documents_and_Settings/jan/My_Documents'________ ||


wwiinn__aadddd__ddllll__ddiirreeccttoorryy((_+_A_b_s_D_i_r))
    This  predicate  adds  a  directory  to  the  search  path  for  de-
    pendent   DLL  files.      If  possible,   this  is  achieved   with
    win_add_dll_directory/2.   Otherwise,  %PATH% is  extended with  the
    provided  directory.     _A_b_s_D_i_r  may  be  specified  in  the  Prolog
    canonical   syntax.     See  prolog_to_os_filename/2.      Note  that
    use_foreign_library/1 passes  an absolute  path  to the  DLL if  the
    destination  DLL  can   be  located  from  the  specification  using
    absolute_file_name/3.


wwiinn__aadddd__ddllll__ddiirreeccttoorryy((_+_A_b_s_D_i_r_, _-_C_o_o_k_i_e))
    This  predicate adds a  directory to the  search path for  dependent
    DLL  files.   If the  call is  successful it unifies  _C_o_o_k_i_e with  a
    handle  that must be passed  to win_remove_dll_directory/1to  remove
    the directory from the search path.  Error conditions:

      o  This predicate is available  in the Windows port of  SWI-Prolog
         starting from 6.3.8/6.2.6.

      o  This  predicate _f_a_i_l_s  if  Windows  does not  yet  support  the
         underlying  primitives.     These  are  available  in  recently
         patched Windows 7 systems and later.

      o  This predicate  throws an  acception  if the  provided path  is
         invalid or the underlying Windows API returns an error.

    If    open_shared_object/2  is   passed   an   _a_b_s_o_l_u_t_e    path   to
    a    DLL   on   a    Windows   installation   that   supports    Ad-
    dDllDirectory()    and    friends,     SWI-Prolog    uses    LoadLi-
    braryEx()   with  the   flags   LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR   and
    LOAD_LIBRARY_SEARCH_DEFAULT_DIRS. In this  scenario, directories from
    %PATH% and _n_o_t  searched.  Additional directories can be added using
    win_add_dll_directory/2.


wwiinn__rreemmoovvee__ddllll__ddiirreeccttoorryy((_-_C_o_o_k_i_e))
    Remove     a     DLL     search    directory     installed     using
    win_add_dll_directory/2.


44..3333..22 DDeeaalliinngg wwiitthh ttiimmee aanndd ddaattee

Representing  time in  a computer  system  is surprisingly  complicated.
There  are a  large  number of  time  representations in  use,  and  the
correct choice  depends on factors such  as compactness, resolution  and
desired operations.   Humans  tend to think about  time in hours,  days,
months, years  or centuries.   Physicists think  about time in  seconds.
But, a  month does not  have a defined  number of seconds.   Even a  day
does not  have a defined  number of seconds  as sometimes a  leap-second
is introduced  to synchronise properly  with our earth's  rotation.   At
the same time, resolution demands a range from  better than pico-seconds
to millions  of years.    Finally, civilizations  have a  wide range  of
calendars.   Although there  exist libraries dealing  with most if  this
complexity,  our desire  to keep  Prolog clean  and lean  stops us  from
fully supporting these.

For human-oriented tasks,  time can be broken into years, months,  days,
hours,  minutes, seconds  and a  timezone.   Physicists  prefer to  have
time in an arithmetic type representing seconds or  fraction thereof, so
basic arithmetic  deals with comparison  and durations.   An  additional
advantage of  the physicist's  approach is  that it  requires much  less
space.   For these  reasons, SWI-Prolog uses an  arithmetic type as  its
prime time representation.

Many C  libraries deal with time  using fixed-point arithmetic,  dealing
with a large  but finite time interval at  constant resolution.  In  our
opinion, using a  floating point number is  a more natural choice as  we
can use a natural unit and the interface does not need  to be changed if
a higher resolution  is required in the future.   Our unit of choice  is
the second as it is  the scientific unit.  We have placed our  origin at
1970-1-1T0:0:0Z for compatibility with the POSIX notion of  time as well
as with older time support provided by SWI-Prolog.

Where  older versions  of  SWI-Prolog  relied on  the  POSIX  conversion
functions, the current implementation uses libtai  to realise conversion
between  time-stamps and  calendar  dates for  a  period of  10  million
years.


44..3333..22..11 TTiimmee aanndd ddaattee ddaattaa ssttrruuccttuurreess

We use the following time representations

TTiimmeeSSttaammpp
    A  TimeStamp  is a  floating  point number  expressing the  time  in
    seconds since the Epoch at 1970-1-1.

ddaattee((_Y_,_M_,_D_,_H_,_M_n_,_S_,_O_f_f_,_T_Z_,_D_S_T))
    We  call this term a  _d_a_t_e_-_t_i_m_e structure.   The first 5 fields  are
    integers  expressing  the year,  month  (1..12), day  (1..31),  hour
    (0..23)  and minute (0..59).   The  _S field holds  the seconds as  a
    floating  point number  between 0.0  and 60.0.   _O_f_f  is an  integer
    representing  the offset relative to UTC in seconds,  where positive
    values  are west of  Greenwich.  If  converted from local time  (see
    stamp_date_time/3), _T_Z  holds the name  of the local  timezone.   If
    the  timezone is  not known,  _T_Z is  the atom  -.   _D_S_T  is true  if
    daylight saving time  applies to the current time, false if daylight
    saving  time is relevant but not effective, and - if unknown  or the
    timezone has no daylight saving time.

ddaattee((_Y_,_M_,_D))
    Date  using the  same values as  described above.   Extracted  using
    date_time_value/3.

ttiimmee((_H_,_M_n_,_S))
    Time  using the  same values as  described above.   Extracted  using
    date_time_value/3.


44..3333..22..22 TTiimmee aanndd ddaattee pprreeddiiccaatteess


ggeett__ttiimmee((_-_T_i_m_e_S_t_a_m_p))
    Return  the  current  time as  a  _T_i_m_e_S_t_a_m_p.    The  granularity  is
    system-dependent.  See section 4.33.2.1.


ssttaammpp__ddaattee__ttiimmee((_+_T_i_m_e_S_t_a_m_p_, _-_D_a_t_e_T_i_m_e_, _+_T_i_m_e_Z_o_n_e))
    Convert  a _T_i_m_e_S_t_a_m_p  to  a _D_a_t_e_T_i_m_e  in the  given timezone.    See
    section 4.33.2.1 for  details on the data types.  _T_i_m_e_Z_o_n_e describes
    the timezone for the  conversion.  It is one of local to extract the
    local  time, 'UTC' to  extract a UTC  time or an integer  describing
    the seconds west of Greenwich.


ddaattee__ttiimmee__ssttaammpp((_+_D_a_t_e_T_i_m_e_, _-_T_i_m_e_S_t_a_m_p))
    Compute  the timestamp from a date/9  term.  Values for month,  day,
    hour,  minute or second  need not be  normalized.  This  flexibility
    allows  for easy  computation of  the time  at any  given number  of
    these  units from a given timestamp.  Normalization can  be achieved
    following  this call with stamp_date_time/3.  This example  computes
    the date 200 days after 2006-7-14:

    ____________________________________________________________________|                                                                    |
    | ?- date_time_stamp(date(2006,7,214,0,0,0,0,-,-), Stamp),           |

    |    stamp_date_time(Stamp, D, 0),                                   |
    |    date_time_value(date, D, Date).                                 |
    ||Date_=_date(2007,_1,_30)__________________________________________ ||

    When  computing a time  stamp from a  local time specification,  the
    UTC offset (arg 7),  TZ (arg 8) and DST (arg 9) argument may be left
    unbound  and are unified with the  proper information.  The  example
    below,  executed in Amsterdam, illustrates  this behaviour.  On  the
    25th of March at 01:00,  DST does not apply.  At 02.00, the clock is
    advanced  by one hour  and thus both  02:00 and 03:00 represent  the
    same time stamp.

    ____________________________________________________________________|                                                                    |
    | 1 ?- date_time_stamp(date(2012,3,25,1,0,0,UTCOff,TZ,DST),          |
    |                      Stamp).                                       |
    | UTCOff = -3600,                                                    |

    | TZ = 'CET',                                                        |
    | DST = false,                                                       |
    | Stamp = 1332633600.0.                                              |
    |                                                                    |
    | 2 ?- date_time_stamp(date(2012,3,25,2,0,0,UTCOff,TZ,DST),          |
    |                      Stamp).                                       |
    | UTCOff = -7200,                                                    |
    | TZ = 'CEST',                                                       |

    | DST = true,                                                        |
    | Stamp = 1332637200.0.                                              |
    |                                                                    |
    | 3 ?- date_time_stamp(date(2012,3,25,3,0,0,UTCOff,TZ,DST),          |
    |                      Stamp).                                       |
    | UTCOff = -7200,                                                    |
    | TZ = 'CEST',                                                       |

    | DST = true,                                                        |
    ||Stamp_=_1332637200.0._____________________________________________ ||

    Note   that   DST  and   offset  calculation   are   based  on   the
    POSIX  function  mktime().     If  mktime()  returns  an  error,   a
    representation_error dst is generated.


ddaattee__ttiimmee__vvaalluuee((_?_K_e_y_, _+_D_a_t_e_T_i_m_e_, _?_V_a_l_u_e))
    Extract values from a date/9 term.  Provided keys are:

       ______________________________________________________________kkeeyyvvaalluuee
       ____________________________________________________________________________________________________________________________yearCalendar year as an integer

        month            Calendar month as an integer 1..12
        day              Calendar day as an integer 1..31
        hour             Clock hour as an integer 0..23

        minute           Clock minute as an integer 0..59
        second           Clock second as a float 0.0..60.0
        utc_offset       Offset to UTC in seconds (positive is west)
        time_zone        Name of timezone; fails if unknown
        daylight_saving  Bool (true) if dst is in effect
        date             Term date(_Y_,_M_,_D)
       _time_____________Term_time(_H_,_M_,_S)____________________________


ffoorrmmaatt__ttiimmee((_+_O_u_t_, _+_F_o_r_m_a_t_, _+_S_t_a_m_p_O_r_D_a_t_e_T_i_m_e))
    Modelled  after POSIX  strftime(),  using GNU  extensions.   _O_u_t  is
    a  destination  as  specified  with  with_output_to/2.     _F_o_r_m_a_t  is
    an  atom or  string  with the  following conversions.    Conversions
    start  with a  tilde (%)  character.   _S_t_a_m_p_O_r_D_a_t_e_T_i_m_e  is either  a
    numeric  time-stamp,  a term  date(_Y_,_M_,_D_,_H_,_M_,_S_,_O_,_T_Z_,_D_S_T)  or a  term
    date(_Y_,_M_,_D).

      a  The abbreviated weekday  name according to the current  locale.
         Use format_time/4 for POSIX locale.

      A  The full  weekday name according  to the current  locale.   Use
         format_time/4 for POSIX locale.

      b  The abbreviated  month name  according to  the current  locale.
         Use format_time/4 for POSIX locale.

      B  The full  month name  according  to the  current locale.    Use
         format_time/4 for POSIX locale.

      c  The preferred  date  and time  representation for  the  current
         locale.

      C  The century number (year/100) as a 2-digit integer.

      d  The day of the month as a decimal number (range 01 to 31).

      D  Equivalent  to %m/%d/%y.    (For  Americans  only.    Americans
         should note that in other countries %d/%m/%y  is rather common.
         This means  that in  an  international context  this format  is
         ambiguous and should not be used.)

      e  Like %d,  the  day of  the month  as a  decimal number,  but  a
         leading zero is replaced by a space.

      E  Modifier.  Not implemented.

      f  Number of microseconds.   The f  can be prefixed by an  integer
         to print  the  desired number  of  digits.   E.g.,  %3f  prints
         milliseconds.   This  format is  not covered  by any  standard,
         but  available  with different  format  specifiers  in  various
         incarnations of the strftime() function.

      F  Equivalent to %Y-%m-%d (the ISO 8601 date format).

      g  Like  %G,  but without  century,  i.e.,  with  a  2-digit  year
         (00-99).

      G  The ISO  8601  year with  century as  a decimal  number.    The
         4-digit year  corresponding to  the ISO week  number (see  %V).
         This has the  same format and value as  %y, except that if  the
         ISO week  number belongs  to the  previous or  next year,  that
         year is used instead.

      V  The ISO 8601:1988 week number of the current year  as a decimal
         number, range  01 to 53,  where week 1 is  the first week  that
         has at least  4 days in  the current year,  and with Monday  as
         the first day of the week.  See also %U and %W.

      h  Equivalent to %b.

      H  The hour as  a decimal number using  a 24-hour clock (range  00
         to 23).

      I  The hour as  a decimal number using  a 12-hour clock (range  01
         to 12).

      j  The day of the year as a decimal number (range 001 to 366).

      k  The hour (24-hour clock)  as a decimal number (range 0  to 23);
         single digits are preceded by a blank.  (See also %H.)

      l  The hour (12-hour clock)  as a decimal number (range 1  to 12);
         single digits are preceded by a blank.  (See also %I.)

      m  The month as a decimal number (range 01 to 12).

      M  The minute as a decimal number (range 00 to 59).

      n  A newline character.

      O  Modifier to select locale-specific output.  Not implemented.

      p  Either `AM' or `PM'  according to the given time value,  or the
         corresponding strings for the current locale.   Noon is treated
         as `pm' and midnight as `am'.

      P  Like %p  but in  lowercase:  `am'  or `pm'  or a  corresponding
         string for the current locale.

      r  The time in  a.m. or p.m. notation.   In the POSIX locale  this
         is equivalent to `%I:%M:%S %p'.

      R  The time in 24-hour  notation (%H:%M). For a version  including
         the seconds, see %T below.

      s  The number of seconds  since the Epoch, i.e., since  1970-01-01
         00:00:00 UTC.

      S  The second as  a decimal number (range 00  to 60).  (The  range
         is up to 60 to allow for occasional leap seconds.)

      t  A tab character.

      T  The time in 24-hour notation (%H:%M:%S).

      u  The day of the  week as a decimal,  range 1 to 7, Monday  being
         1.  See also %w.

      U  The week number of the current year as a  decimal number, range
         00 to 53,  starting with the first  Sunday as the first day  of
         week 01.  See also %V and %W.

      w  The day of the  week as a decimal,  range 0 to 6, Sunday  being
         0.  See also %u.

      W  The week number of the current year as a  decimal number, range
         00 to 53,  starting with the first  Monday as the first day  of
         week 01.

      x  The  preferred  date  representation  for  the  current  locale
         without the time.

      X  The  preferred  time  representation  for  the  current  locale
         without the date.

      y  The year  as a decimal  number without a  century (range 00  to
         99).

      Y  The year as a decimal number including the century.

      z  The  timezone  as  hour  offset  from  GMT   using  the  format
         HHmm.     Required  to  emit  RFC822-conforming   dates  (using
         '%a, %d %b %Y %T %z').  Our implementation supports  %:z, which
         modifies the output to  HH:mm as required by XML-Schema.   Note
         that both notations  are valid in ISO  8601.  The sequence  %:z
         is compatible to the GNU date(1) command.

      Z  The timezone or name or abbreviation.

      +  The date and time in date(1) format.

      %  A literal `%' character.

    The  table  below   gives  some  format  strings  for  popular  time
    representations.   RFC1123 is used by HTTP. The  full implementation
    of http_timestamp/2 as available from http/http_header is here.

    ____________________________________________________________________|                                                                    |

    | http_timestamp(Time, Atom) :-                                      |
    |         stamp_date_time(Time, Date, 'UTC'),                        |
    |         format_time(atom(Atom),                                    |
    |                     '%a, %d %b %Y %T GMT',                         |
    ||____________________Date,_posix)._________________________________ ||

                      __________________________________SSttaannddaarrddFFoorrmmaatt ssttrriinngg
                      ____________________________________________________________________xxssdd'%FT%T%:z'

                       IISSOO88660011   '%FT%T%z'
                       RRFFCC882222    '%a, %d %b %Y %T %z'
                      _RRFFCC11112233___'%a,_%d_%b_%Y_%T_GMT'__


ffoorrmmaatt__ttiimmee((_+_O_u_t_, _+_F_o_r_m_a_t_, _+_S_t_a_m_p_O_r_D_a_t_e_T_i_m_e_, _+_L_o_c_a_l_e))
    Format  time  given  a  specified  _L_o_c_a_l_e.    This  predicate  is  a
    work-around  for   lacking  proper  portable  and  thread-safe  time
    and  locale  handling  in current  C  libraries.    In  its  current
    implementation  the only value  allowed for  _L_o_c_a_l_e is posix,  which
    currently  only modifies the behaviour of  the a, A, b and  B format
    specifiers.   The predicate is used to be able to emit  POSIX locale
    week  and month names for emitting standardised time-stamps  such as
    RFC1123.


ppaarrssee__ttiimmee((_+_T_e_x_t_, _-_S_t_a_m_p))
    Same as parse_time(_T_e_x_t_, ___F_o_r_m_a_t_, _S_t_a_m_p).  See parse_time/3.


ppaarrssee__ttiimmee((_+_T_e_x_t_, _?_F_o_r_m_a_t_, _-_S_t_a_m_p))
    Parse  a  textual  time  representation,   producing  a  time-stamp.
    Supported  formats  for  _T_e_x_t  are in  the  table  below.    If  the
    format  is  known,  it  may  be  given  to  reduce  parse  time  and
    avoid  ambiguities.   Otherwise, _F_o_r_m_a_t is  unified with the  format
    encountered.

                 ___________________________________________
                 |__NNaammee________||EExxaammppllee__________________________________________________||
                 || rfc_1123F|ri, 08 Dec 2006 15:29:44 GMT   |
                 |_________|Fri,_08_Dec_2006_15:29:44_+0000_|
                 | iso_86012|006-12-08T17:29:44+02:00       |

                 |         |20061208T172944+0200            |
                 |         |2006-12-08T15:29Z               |
                 |         |2006-12-08                      |
                 |         |20061208                        |
                 |         |2006-12                         |
                 |         |2006-W49-5                      |
                 |_________|2006-342________________________|


ddaayy__ooff__tthhee__wweeeekk((_+_D_a_t_e_,_-_D_a_y_O_f_T_h_e_W_e_e_k))
    Computes    the   day    of   the   week    for   a   given    date.
    _D_a_t_e = date(_Y_e_a_r,_M_o_n_t_h,_D_a_y).       Days   of  the   week  are   num-
    bered  from one to seven:   Monday = 1, Tuesday  = 2, ..., Sunday  =
    7.


44..3333..33 CCoonnttrroolllliinngg tthhee swipl-win.exe ccoonnssoollee wwiinnddooww

The Windows executable swipl-win.exe console has a  number of predicates
to control the appearance  of the console.  Being  totally non-portable,
we do  not advise using  it for your  own application,  but use XPCE  or
another  portable GUI  platform instead.    We give  the predicates  for
reference here.


wwiinnddooww__ttiittllee((_-_O_l_d_, _+_N_e_w))
    Unify  _O_l_d with the  title displayed in  the console and change  the
    title to _N_e_w.


wwiinn__wwiinnddooww__ppooss((_+_L_i_s_t_O_f_O_p_t_i_o_n_s))
    Interface  to the  MS-Windows  SetWindowPos() function,  controlling
    size,  position and stacking order of the window.   _L_i_s_t_O_f_O_p_t_i_o_n_s is
    a list that may hold any number of the terms below:

    ssiizzee((_W_, _H))
         Change the  size of  the window.    _W  and _H  are expressed  in
         character units.

    ppoossiittiioonn((_X_, _Y))
         Change the  top-left corner  of  the window.    The values  are
         expressed in pixel units.

    zzoorrddeerr((_Z_O_r_d_e_r))
         Change the  location  in the  window stacking  order.    Values
         are bottom, top,  topmost and notopmost.   _T_o_p_m_o_s_t windows  are
         displayed above all other windows.

    sshhooww((_B_o_o_l))
         If true, show the window, if false hide the window.

    aaccttiivvaattee
         If present, activate the window.


wwiinn__hhaass__mmeennuu
    True if win_insert_menu/2 and win_insert_menu_item/4are present.


wwiinn__iinnsseerrtt__mmeennuu((_+_L_a_b_e_l_, _+_B_e_f_o_r_e))
    Insert  a new entry  (pulldown) in the  menu.   If the menu  already
    contains  this entry,  nothing  is done.    The _L_a_b_e_l  is the  label
    and,  using  the Windows  convention, a  letter prefixed  with &  is
    underlined  and defines the associated  accelerator key.  _B_e_f_o_r_e  is
    the label before which this one  must be inserted.  Using - adds the
    new  entry at the end (right).  For example, the call  below adds an
    Application entry just before the Help menu.

    ____________________________________________________________________|                                                                    |
    ||win_insert_menu('&Application',_'&Help')__________________________ ||


wwiinn__iinnsseerrtt__mmeennuu__iitteemm((_+_P_u_l_l_d_o_w_n_, _+_L_a_b_e_l_, _+_B_e_f_o_r_e_, _:_G_o_a_l))
    Add  an  item  to  the  named  _P_u_l_l_d_o_w_n menu.     _L_a_b_e_l  and  _B_e_f_o_r_e
    are  handled  as in  win_insert_menu/2,  but the  label -  inserts  a
    _s_e_p_a_r_a_t_o_r.  _G_o_a_l is called if the user selects the item.


44..3344 FFiillee SSyysstteemm IInntteerraaccttiioonn


aacccceessss__ffiillee((_+_F_i_l_e_, _+_M_o_d_e))
    True  if _F_i_l_e  exists and  can be  accessed by  this Prolog  process
    under  mode _M_o_d_e.   _M_o_d_e is  one of the  atoms read, write,  append,
    exist,  none or execute.  _F_i_l_e may also be the name  of a directory.
    Fails  silently otherwise.   access_file(File, none)simply  succeeds
    without testing anything.

    If  _M_o_d_e is  write or append,  this predicate  also succeeds if  the
    file  does not exist and the user has write access to  the directory
    of the specified location.


eexxiissttss__ffiillee((_+_F_i_l_e))
    True if _F_i_l_e exists  and is a regular file.  This does not imply the
    user has read and/or write permission for the file.


ffiillee__ddiirreeccttoorryy__nnaammee((_+_F_i_l_e_, _-_D_i_r_e_c_t_o_r_y))
    Extracts  the directory part of _F_i_l_e.   The returned _D_i_r_e_c_t_o_r_y  name
    does  not end in  /.  There  are two special  cases.  The  directory
    name  of / is  / itself, and  the directory name is  . if _F_i_l_e  does
    not  contain any / characters.  If the _F_i_l_e argument ends  with a /,
    e.g.,  '/hello/', it is  not a valid  file name.   In this case  the
    final / is removed from _F_i_l_e, e.g., '/hello'.

    See   also  directory_file_path/3  from   filesex.      The   system
    ensures  that  for   every  valid  _P_a_t_h  using  the  Prolog  (POSIX)
    directory  separators, following  is true  on systems  with a  sound
    implementation of same_file/2.  See also prolog_to_os_filename/2.

    ____________________________________________________________________|                                                                    |
    |         ...,                                                       |

    |         file_directory_name(Path, Dir),                            |
    |         file_base_name(Path, File),                                |
    |         directory_file_path(Dir, File, Path2),                     |
    ||________same_file(Path,_Path2).___________________________________ ||


ffiillee__bbaassee__nnaammee((_+_F_i_l_e_, _-_B_a_s_e_N_a_m_e))
    Extracts the filename part  from a path specification.  If _F_i_l_e does
    not contain any  directory separators, _F_i_l_e is returned in _B_a_s_e_N_a_m_e.
    See  also file_directory_name/2.   If the _F_i_l_e arguments ends  with a
    /, e.g., '/hello/', _B_a_s_e_N_a_m_e is unified with the empty atom ('').


ssaammee__ffiillee((_+_F_i_l_e_1_, _+_F_i_l_e_2))
    True  if both  filenames  refer to  the same  physical file.    That
    is,  if _F_i_l_e_1  and _F_i_l_e_2  are the  same string or  both names  exist
    and  point  to  the  same  file  (due  to  hard  or  symbolic  links
    and/or  relative  vs. absolute  paths).    On systems  that  provide
    stat()  with meaningful values for  st_dev  and st_inode, same_file/2
    is  implemented  by  comparing  the device  and  inode  identifiers.
    On  Windows,  same_file/2  compares  the  strings  returned  by  the
    GetFullPathName() system call.


eexxiissttss__ddiirreeccttoorryy((_+_D_i_r_e_c_t_o_r_y))
    True  if _D_i_r_e_c_t_o_r_y exists and is a  directory.  This does  not imply
    the user has read, search or write permission for the directory.


ddeelleettee__ffiillee((_+_F_i_l_e))
    Remove _F_i_l_e from the file system.


rreennaammee__ffiillee((_+_F_i_l_e_1_, _+_F_i_l_e_2))
    Rename  _F_i_l_e_1 as _F_i_l_e_2.   The semantics  is compatible to the  POSIX
    semantics  of  the rename()  system  call as  far as  the  operating
    system  allows.   Notably, if _F_i_l_e_2  exists, the operation  succeeds
    (except  for  possible permission  errors)  and is  _a_t_o_m_i_c  (meaning
    there is no window where _F_i_l_e_2 does not exist).


ssiizzee__ffiillee((_+_F_i_l_e_, _-_S_i_z_e))
    Unify _S_i_z_e with the size of _F_i_l_e in bytes.


ttiimmee__ffiillee((_+_F_i_l_e_, _-_T_i_m_e))
    Unify  the last  modification time of  _F_i_l_e with  _T_i_m_e.   _T_i_m_e is  a
    floating  point number expressing the  seconds elapsed since Jan  1,
    1970.  See also convert_time/[2,8] and get_time/1.


aabbssoolluuttee__ffiillee__nnaammee((_+_F_i_l_e_, _-_A_b_s_o_l_u_t_e))
    Expand  a  local filename  into  an absolute  path.    The  absolute
    path  is  canonicalised:    references  to .  and  ..  are  deleted.
    This  predicate ensures that expanding  a filename returns the  same
    absolute  path regardless of how the file is addressed.   SWI-Prolog
    uses absolute filenames  to register source files independent of the
    current  working directory.    See also  absolute_file_name/3.    See
    also absolute_file_name/3 and expand_file_name/2.


aabbssoolluuttee__ffiillee__nnaammee((_+_S_p_e_c_, _-_A_b_s_o_l_u_t_e_, _+_O_p_t_i_o_n_s))
    Convert  the given file specification into  an absolute path.   _S_p_e_c
    is  a  term  Alias(Relative)  (e.g.,  (library(lists)),  a  relative
    filename  or an absolute  filename.   The primary intention of  this
    predicate is to  resolve files specified as Alias(Relative).  _O_p_t_i_o_n
    is a list of options to guide the conversion:

    eexxtteennssiioonnss((_L_i_s_t_O_f_E_x_t_e_n_s_i_o_n_s))
         List of  file extensions  to try.   Default  is ''.   For  each
         extension,  absolute_file_name/3 will first  add the  extension
         and then verify  the conditions imposed  by the other  options.
         If the  condition  fails, the  next extension  on  the list  is
         tried.  Extensions may be specified both as .ext or plain ext.

    rreellaattiivvee__ttoo((_+_F_i_l_e_O_r_D_i_r))
         Resolve  the  path relative  to  the  given  directory  or  the
         directory  holding  the given  file.     Without  this  option,
         paths  are   resolved   relative  to   the  working   directory
         (see   working_directory/2)   or,   if   _S_p_e_c  is   atomic   and
         absolute_file_name/[2,3] is executed  in a  directive, it  uses
         the current source file as reference.

    aacccceessss((_M_o_d_e))
         Imposes the  condition access_file(_F_i_l_e, _M_o_d_e).    _M_o_d_e is  one
         of read,  write,  append, execute,  exist or  none.   See  also
         access_file/2.

    ffiillee__ttyyppee((_T_y_p_e))
         Defines  extensions.    Current  mapping:   txt  implies  [''],
         prolog  implies ['.pl', ''],  executable  implies  ['.so', ''],
         qlf implies  ['.qlf', '']  and  directory implies  [''].    The
         file  type source  is an  alias  for prolog  for  compatibility
         with  SICStus Prolog.     See also  prolog_file_type/2.     This
         predicate  only  returns  non-directories,  unless  the  option
         file_type(_d_i_r_e_c_t_o_r_y) is specified.

    ffiillee__eerrrroorrss((_f_a_i_l_/_e_r_r_o_r))
         If error (default),  throw an existence_error exception if  the
         file cannot be found.  If fail, stay silent.

    ssoolluuttiioonnss((_f_i_r_s_t_/_a_l_l))
         If  first (default),  the  predicate  leaves no  choice  point.
         Otherwise a  choice point  will  be left  and backtracking  may
         yield more solutions.

    eexxppaanndd((_t_r_u_e_/_f_a_l_s_e))
         If  true  (default   is  false)  and   _S_p_e_c  is  atomic,   call
         expand_file_name/2  followed  by   member/2   on  _S_p_e_c   before
         proceeding.  This is a SWI-Prolog extension.

    The  Prolog  flag verbose_file_search can  be set  to  true to  help
    debugging Prolog's search for files.

    This  predicate is derived from Quintus Prolog.  In  Quintus Prolog,
    the  argument order was  absolute_file_name(_+_S_p_e_c_, _+_O_p_t_i_o_n_s_,  _-_P_a_t_h).
    The  argument order has been changed for compatibility with  ISO and
    SICStus.  The Quintus argument order is still accepted.


iiss__aabbssoolluuttee__ffiillee__nnaammee((_+_F_i_l_e))
    True  if _F_i_l_e specifies  an absolute  path name.   On Unix  systems,
    this  implies the path starts with a `/'.  For  Microsoft-based sys-
    tems  this implies the path  starts with <_l_e_t_t_e_r>:.  This  predicate
    is  intended to provide  platform-independent checking for  absolute
    paths.  See also absolute_file_name/2 and prolog_to_os_filename/2.


ffiillee__nnaammee__eexxtteennssiioonn((_?_B_a_s_e_, _?_E_x_t_e_n_s_i_o_n_, _?_N_a_m_e))
    This  predicate is used to add, remove or test  filename extensions.
    The  main reason  for  its introduction  is to  deal with  different
    filename  properties  in a  portable manner.    If  the file  system
    is  case-insensitive, testing  for an  extension will  also be  done
    case-insensitive.    _E_x_t_e_n_s_i_o_n may  be specified with  or without  a
    leading  dot (.).  If an _E_x_t_e_n_s_i_o_n is generated, it will  not have a
    leading dot.


ddiirreeccttoorryy__ffiilleess((_+_D_i_r_e_c_t_o_r_y_, _-_E_n_t_r_i_e_s))
    Unify  _E_n_t_r_i_e_s with a  list of  entries in _D_i_r_e_c_t_o_r_y.   Each  member
    of  _E_n_t_r_i_e_s is  an  atom denoting  an entry  relative to  _D_i_r_e_c_t_o_r_y.
    _E_n_t_r_i_e_s  contains  all  entries,  including  hidden  files  and,  if
    supplied  by  the OS,  the  special entries  .  and ...    See  also
    expand_file_name/2.


eexxppaanndd__ffiillee__nnaammee((_+_W_i_l_d_C_a_r_d_, _-_L_i_s_t))
    Unify  _L_i_s_t with  a  sorted list  of files  or directories  matching
    _W_i_l_d_C_a_r_d.   The  normal Unix wildcard  constructs `?', `*',  `[...]'
    and  `{...}'  are recognised.    The  interpretation  of `{...}'  is
    slightly  different from the C shell (csh(1)).   The comma-separated
    argument  can  be arbitrary  patterns,  including `{...}'  patterns.
    The  empty pattern  is  legal as  well:   `\{.pl,\}' matches  either
    `.pl' or the empty string.

    If  the pattern  contains wildcard characters,  only existing  files
    and  directories  are  returned.    Expanding  a  `pattern'  without
    wildcard  characters returns the argument, regardless of  whether or
    not it exists.

    Before  expanding wildcards, the construct  $_v_a_r is expanded to  the
    value  of the  environment variable  _v_a_r, and a  possible leading  ~
    character is expanded to the user's home directory.


pprroolloogg__ttoo__ooss__ffiilleennaammee((_?_P_r_o_l_o_g_P_a_t_h_, _?_O_s_P_a_t_h))
    Convert  between the internal Prolog  path name conventions and  the
    operating  system path name conventions.   The internal  conventions
    follow  the POSIX  standard, which  implies that  this predicate  is
    equivalent  to  =/2 (unify)  on  POSIX (e.g.,  Unix)  systems.    On
    Windows systems it changes the directory separator from \ into /.


rreeaadd__lliinnkk((_+_F_i_l_e_, _-_L_i_n_k_, _-_T_a_r_g_e_t))
    If _F_i_l_e points to  a symbolic link, unify _L_i_n_k with the value of the
    link and _T_a_r_g_e_t to  the file the link is pointing to.  _T_a_r_g_e_t points
    to  a file, directory or non-existing entry in the file  system, but
    never  to a link.   Fails if _F_i_l_e  is not a link.   Fails always  on
    systems that do not support symbolic links.


ttmmpp__ffiillee((_+_B_a_s_e_, _-_T_m_p_N_a_m_e))                                   _[_d_e_p_r_e_c_a_t_e_d_]
    Create  a name for a temporary file.  _B_a_s_e is an  identifier for the
    category  of file.  The _T_m_p_N_a_m_e is guaranteed to be unique.   If the
    system  halts, it  will automatically  remove all created  temporary
    files.    _B_a_s_e is  used as  part of the  final filename.    Portable
    applications should limit themselves to alphanumeric characters.

    Because  it is possible to  guess the generated filename,  attackers
    may  create the  filesystem entry as  a link  and possibly create  a
    security issue.  New code should use tmp_file_stream/3.


ttmmpp__ffiillee__ssttrreeaamm((_+_E_n_c_o_d_i_n_g_, _-_F_i_l_e_N_a_m_e_, _-_S_t_r_e_a_m))
    Create  a  temporary  filename  _F_i_l_e_N_a_m_e and  open  it  for  writing
    in  the  given  _E_n_c_o_d_i_n_g.    _E_n_c_o_d_i_n_g  is a  text-encoding  name  or
    binary.    _S_t_r_e_a_m is  the output  stream.   If the  OS supports  it,
    the  created file is only  accessible to the current  user.  If  the
    OS  supports it, the file  is created using the  open()-flag O_EXCL,
    which  guarantees that  the  file did  not exist  before this  call.
    This  predicate is a safe replacement  of tmp_file/2.  Note that  in
    those cases where  the temporary file is needed to store output from
    an  external command,  the file  must be closed  first.   E.g.,  the
    following downloads a file  from a URL to a temporary file and opens
    the  file for reading (on Unix  systems you can delete the file  for
    cleanup after opening it for reading):

    ____________________________________________________________________|                                                                    |
    | open_url(URL, In) :-                                               |

    |         tmp_file_stream(text, File, Stream),                       |
    |         close(Stream),                                             |
    |         process_create(curl, ['-o', File, URL], []),               |
    |         open(File, read, In),                                      |
    ||________delete_file(File).______________%_Unix-only_______________ ||

    Temporary  files  created   using  this  call  are  removed  if  the
    Prolog   process  terminates  _g_r_a_c_e_f_u_l_l_y.     Calling  delete_file/1
    using  _F_i_l_e_N_a_m_e removes  the  file and  removes the  entry from  the
    administration of files-to-be-deleted.


mmaakkee__ddiirreeccttoorryy((_+_D_i_r_e_c_t_o_r_y))
    Create  a  new directory  (folder) on  the filesystem.    Raises  an
    exception  on failure.   On Unix systems,  the directory is  created
    with default permissions (defined by the process _u_m_a_s_k setting).


ddeelleettee__ddiirreeccttoorryy((_+_D_i_r_e_c_t_o_r_y))
    Delete directory (folder)  from the filesystem.  Raises an exception
    on failure.   Please note that in general it will not be possible to
    delete a non-empty directory.


wwoorrkkiinngg__ddiirreeccttoorryy((_-_O_l_d_, _+_N_e_w))
    Unify  _O_l_d with an  absolute path to  the current working  directory
    and   change  working   directory  to   _N_e_w.      Use  the   pattern
    working_directory(_C_W_D_, _C_W_D) to get the current directory.   See also
    absolute_file_name/2 and chdir/1.   Note that the working  directory
    is shared between all threads.


cchhddiirr((_+_P_a_t_h))
    Compatibility predicate.  New code should use working_directory/2.


44..3355 UUsseerr TToopp--lleevveell MMaanniippuullaattiioonn


bbrreeaakk
    Recursively  start a new  Prolog top level.   This Prolog top  level
    has its own  stacks, but shares the heap with all break environments
    and  the top level.  Debugging  is switched off on entering  a break
    and  restored on leaving one.   The break environment is  terminated
    by  typing the  system's end-of-file character  (control-D). If  the
    -t toplevel  command  line option  is given,  this  goal is  started
    instead of entering the default interactive top level (prolog/0).


aabboorrtt
    Abort  the Prolog  execution  and restart  the top  level.   If  the
    -t toplevel  command  line option  is given,  this  goal is  started
    instead of entering the default interactive top level.

    Aborting   is  implemented  by   throwing  the  reserved   exception
    '$aborted'.   This  exception can be caught  using catch/3, but  the
    recovery  goal is wrapped  with a predicate  that prunes the  choice
    points  of the  recovery goal  (i.e., as once/1)  and re-throws  the
    exception.    This is  illustrated in  the example  below, where  we
    press control-C and `a'.

    ____________________________________________________________________|                                                                    |
    | ?- catch((repeat,fail), E, true).                                  |

    | ^CAction (h for help) ? abort                                      |
    ||%_Execution_Aborted_______________________________________________ ||


hhaalltt                                                              _[_I_S_O_]
    Terminate  Prolog execution.   This  is the  same as halt(_0).    See
    halt/1 for details.


hhaalltt((_+_S_t_a_t_u_s))                                                     _[_I_S_O_]
    Terminate  Prolog  execution  with _S_t_a_t_u_s.    This  predicate  calls
    PL_halt() which preforms the following steps:

     1.  Set the Prolog flag exit_status to _S_t_a_t_u_s.

     2.  Call all hooks registered using at_halt/1.  If _S_t_a_t_u_s  equals 0
         (zero), any of these hooks  calls cancel_halt/1,  termination is
         cancelled.

     3.  Call all hooks  registered using PL_at_halt().   In the  future,
         if any  of these  hooks returns non-zero,  termination will  be
         cancelled.  Currently, this only prints a warning.

     4.  Perform the following system cleanup actions:

           o Cancel  all  threads,  calling thread_at_exit/1  registered
             termination hooks.  Threads  not responding within 1 second
             are cancelled forcefully.

           o Flush I/O and close all streams except for standard I/O.

           o Reset the terminal if its properties were changed.

           o Remove temporary files and incomplete compilation output.

           o Reclaim memory.

     5.  Call exit(Status) to terminate the process


pprroolloogg
    This  goal starts the  default interactive top  level.  Queries  are
    read from  the stream user_input.  See  also the Prolog flag history.
    The  prolog/0  predicate  is  terminated (succeeds)  by  typing  the
    end-of-file character (typically control-D).

The following  two hooks allow  for expanding  queries and handling  the
result of  a query.   These  hooks are  used by the  top level  variable
expansion mechanism described in section 2.8.


eexxppaanndd__qquueerryy((_+_Q_u_e_r_y_, _-_E_x_p_a_n_d_e_d_, _+_B_i_n_d_i_n_g_s_, _-_E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s))
    Hook  in module  user, normally  not defined.    _Q_u_e_r_y and  _B_i_n_d_i_n_g_s
    represents  the  query read  from  the user  and  the names  of  the
    free  variables as obtained  using read_term/3.   If this  predicate
    succeeds, it should  bind _E_x_p_a_n_d_e_d and _E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s to the query
    and  bindings to be executed  by the top level.   This predicate  is
    used  by the  top level (prolog/0).    See also  expand_answer/2 and
    term_expansion/2.


eexxppaanndd__aannsswweerr((_+_B_i_n_d_i_n_g_s_, _-_E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s))
    Hook  in module user,  normally not defined.   Expand the result  of
    a  successfully executed  top-level query.   _B_i_n_d_i_n_g_s  is the  query
    < Name >=<_V_a_l_u_e> binding list  from the query.    _E_x_p_a_n_d_e_d_B_i_n_d_i_n_g_s
    must be unified with the bindings the top level should print.


44..3366 CCrreeaattiinngg aa PPrroottooccooll ooff tthhee UUsseerr IInntteerraaccttiioonn

SWI-Prolog offers the  possibility to log the interaction with  the user
on  a file.    All  Prolog interaction,  including warnings  and  tracer
output, are written to the protocol file.


pprroottooccooll((_+_F_i_l_e))
    Start  protocolling on file  _F_i_l_e.  If  there is already a  protocol
    file open, then close it first.  If _F_i_l_e exists it is truncated.


pprroottooccoollaa((_+_F_i_l_e))
    Equivalent  to protocol/1,  but  does not  truncate the  _F_i_l_e if  it
    exists.


nnoopprroottooccooll
    Stop  making a protocol of the user interaction.  Pending  output is
    flushed on the file.


pprroottooccoolllliinngg((_-_F_i_l_e))
    True  if a protocol was  started with protocol/1 or protocola/1  and
    unifies _F_i_l_e with the current protocol output file.


44..3377 DDeebbuuggggiinngg aanndd TTrraacciinngg PPrrooggrraammss

This section is a  reference to the debugger interaction predicates.   A
more use-oriented overview of the debugger is in section 2.9.

If you have installed  XPCE, you can use the graphical front-end  of the
tracer.  This front-end is installed using the predicate guitracer/0.


ttrraaccee
    Start  the tracer.   trace/0  itself cannot be  seen in the  tracer.
    Note  that the  Prolog top level  treats trace/0  special; it  means
    `trace the next goal'.


ttrraacciinngg
    True  if the  tracer is  currently switched  on.   tracing/0  itself
    cannot be seen in the tracer.


nnoottrraaccee
    Stop the tracer.  notrace/0 itself cannot be seen in the tracer.


gguuiittrraacceerr
    Installs  hooks  (see prolog_trace_interception/4) into  the  system
    that  redirect  tracing information  to  a GUI  front-end  providing
    structured  access to variable  bindings, graphical overview of  the
    stack and highlighting of relevant source code.


nnoogguuiittrraacceerr
    Revert back to the textual tracer.


ttrraaccee((_+_P_r_e_d))
    Equivalent to trace(_P_r_e_d, +all).


ttrraaccee((_+_P_r_e_d_, _+_P_o_r_t_s))
    Put  a  trace  point  on all  predicates  satisfying  the  predicate
    specification  _P_r_e_d.   _P_o_r_t_s is  a list of  port names (call,  redo,
    exit,  fail).   The atom all refers  to all ports.   If the port  is
    preceded  by a - sign, the trace point is cleared for the port.   If
    it is preceded by a +, the trace point is set.

    The  predicate trace/2  activates debug  mode (see debug/0).    Each
    time  a port (of the 4-port model) is passed that has a  trace point
    set, the goal is  printed as with trace/0.  Unlike trace/0, however,
    the  execution is continued without asking for  further information.
    Examples:

        ?- trace(hello).         Trace all  ports of hello  with any
                                 arity in any module.
        ?- trace(foo/2, +fail).  Trace  failures  of  foo/2  in  any
                                 module.
        ?- trace(bar/1, -all).   Stop tracing bar/1.

    The predicate debugging/0 shows all currently defined trace points.


nnoottrraaccee((_:_G_o_a_l))
    Call  _G_o_a_l,  but  suspend  the  debugger while  _G_o_a_l  is  executing.
    The  current implementation  cuts the  choice points  of _G_o_a_l  after
    successful completion.   See once/1.  Later implementations may have
    the same semantics as call/1.


ddeebbuugg
    Start  debugger.   In  debug mode,  Prolog  stops at  spy and  trace
    points,  disables last-call optimisation and aggressive  destruction
    of   choice  points  to   make  debugging  information   accessible.
    Implemented by the Prolog flag debug.

    Note  that the min_free parameter of all  stacks is enlarged to 8  K
    cells  if debugging is switched off in order to avoid  excessive GC.
    GC  complicates tracing because it renames the __G_<_N_N_N_>  variables and
    replaces  unreachable variables  with the atom  <garbage_collected>.
    Calling  nodebug/0 does  _n_o_t reset the  initial free-margin  because
    several  parts of the  top level and  debugger disable debugging  of
    system code regions.  See also set_prolog_stack/2.


nnooddeebbuugg
    Stop  debugger.   Implemented by the  Prolog flag debug.   See  also
    debug/0.


ddeebbuuggggiinngg
    Print  debug status and  spy points on current  output stream.   See
    also the Prolog flag debug.


ssppyy((_+_P_r_e_d))
    Put  a spy point on all predicates meeting the  predicate specifica-
    tion _P_r_e_d.  See section 4.5.


nnoossppyy((_+_P_r_e_d))
    Remove   spy  point  from  all  predicates  meeting   the  predicate
    specification _P_r_e_d.


nnoossppyyaallll
    Remove all spy points from the entire program.


lleeaasshh((_?_P_o_r_t_s))
    Set/query leashing (ports  which allow for user interaction).  _P_o_r_t_s
    is  one of _+_N_a_m_e, _-_N_a_m_e,  _?_N_a_m_e or a list  of these.  _+_N_a_m_e  enables
    leashing  on that  port,  _-_N_a_m_e disables  it and  _?_N_a_m_e succeeds  or
    fails according to  the current setting.  Recognised ports are call,
    redo,  exit, fail and  unify.  The  special shorthand all refers  to
    all  ports,  full refers  to all  ports except  for  the unify  port
    (default).  half refers to the call, redo and fail port.


vviissiibbllee((_+_P_o_r_t_s))
    Set the ports shown  by the debugger.  See leash/1 for a description
    of the _P_o_r_t_s specification.  Default is full.


uunnkknnoowwnn((_-_O_l_d_, _+_N_e_w))
    Edinburgh-Prolog  compatibility predicate,  interfacing  to the  ISO
    Prolog  flag unknown.   Values are  trace (meaning error) and  fail.
    If  the unknown flag is set to warning, unknown/2 reports  the value
    as trace.


ssttyyllee__cchheecckk((_+_S_p_e_c))
    Modify/query  style checking  options.   _S_p_e_c  is one  of the  terms
    below or a list of these.

      o  +_S_t_y_l_e enables a style check

      o  -_S_t_y_l_e disables a style check

      o  ?(_S_t_y_l_e) queries a style  check (note the brackets).   If _S_t_y_l_e
         is unbound,  all  active style  check options  are returned  on
         backtracking.

    Loading  a file using load_files/2 or one of its  derived predicates
    reset  the style checking options to their value before  loading the
    file, scoping the option  to the remainder of the file and all files
    loaded _a_f_t_e_r changing the style checking.

    ssiinngglleettoonn((_t_r_u_e))
         The  predicate read_clause/3  (used  by the  compiler  to  read
         source code) warns on  variables appearing only once in  a term
         (clause) which  have a  name not starting  with an  underscore.
         See  section 2.15.2.5  for  details  on variable  handling  and
         warnings.

    nnoo__eeffffeecctt((_t_r_u_e))
         This warning is  generated by the  compiler for BIPs  (built-in
         predicates) that  are inlined  by  the compiler  and for  which
         the  compiler  can  prove  that  they  are  meaningless.     An
         example is  using ==/2 against  a not-yet-initialised  variable
         as  illustrated in  the  example below.    This  comparison  is
         always false.

         _______________________________________________________________|                                                               |
         |always_false(X) :-                                             |
         |        X == Y,                                                |
         ||_______write(Y)._____________________________________________ ||

    vvaarr__bbrraanncchheess((_f_a_l_s_e))
         Verifies that if a variable is introduced in a  branch and used
         _a_f_t_e_r the branch, it is introduced in all branches.   This code
         aims at bugs  following the skeleton  below, where p(_N_e_x_t)  may
         be called with _N_e_x_t unbound.

         _______________________________________________________________|                                                               |

         |p(Arg) :-                                                      |
         |        (  Cond                                                |
         |        -> Next = value1                                       |
         |        ;  true                                                |
         |        ),                                                     |
         ||_______p(Next).______________________________________________ ||

         If a variable  _V is intended  to be left  unbound, one can  use
         V=_.  This construct is removed by the compiler and thus has no
         implications for the performance of your program.

         This  check  was suggested  together  with  _s_e_m_a_n_t_i_c  singleton
         checking.   The  SWI-Prolog libraries contain  about a  hundred
         clauses  that are  triggered  by  this  style check.     Unlike
         semantic singleton  analysis,  only a  tiny  fraction of  these
         clauses proofed faulty.   In  most cases, the branches  failing
         to bind the variable  fail or raise an exception or  the caller
         handles the  case where the  variable is unbound.   The  status
         of this style  check is unclear.   It  might be removed in  the
         future or  it might be  enhanced with a  deeper analysis to  be
         more precise.

    aattoomm((_t_r_u_e))
         The predicate  read/1 and derived  predicates produce an  error
         message on quoted atoms  or strings with more than  6 _u_n_e_s_c_a_p_e_d
         newlines.    Newlines  may be  escaped  with \  or  \c.    This
         flag  also enables  warnings  on \<_n_e_w_l_i_n_e>  followed  by blank
         space in native  mode.   See section 2.15.2.1.   Note that  the
         ISO standard does  not allow for  unescaped newlines in  quoted
         atoms.

    ddiissccoonnttiigguuoouuss((_t_r_u_e))
         Warn if  the clauses for  a predicate are  not together in  the
         same source  file.  It  is advised to  disable the warning  for
         discontiguous predicates using the discontiguous/1 directive.

    cchhaarrsseett((_f_a_l_s_e))
         Warn on atoms  and variable names holding non-ASCII  characters
         that are not quoted.  See also section 2.15.1.1.


44..3388 OObbttaaiinniinngg RRuunnttiimmee SSttaattiissttiiccss


ssttaattiissttiiccss((_+_K_e_y_, _-_V_a_l_u_e))
    Unify  system  statistics  determined  by  _K_e_y  with  _V_a_l_u_e.     The
    possible  keys  are  given  in  the  table  4.3.     This  predicate
    supports additional keys  for compatibility reasons.  These keys are
    described in table 4.4.
___________________________________________________________________________
|_________________Native_keys_(times_as_float_in_seconds)__________________|
| agc            |Number of atom garbage collections performed            |
| agc_gained     N|umber of atoms removed                                 |
| agc_time       T|ime spent in atom garbage collections                  |
| epoch          |Time stamp when thread was started                      |
| process_epoch  T|ime stamp when Prolog was started                      |

| cputime        |(User) cpu time since thread was started in seconds     |
| process_cputime(|User) cpu time since Prolog was started in seconds     |
| inferences     |Total  number  of passes  via  the call  and redo  ports|
|                |since Prolog was started                                |
| heapused       |Bytes of heap in use by Prolog (0 if not maintained)    |
| heap_gc        N|umber  of  heap garbage  collections performed.    Only|
|                p|rovided  if SWI-Prolog is configured with Boehm-GC. See|

|                a|lso garbage_collect_heap/0.                            |
| c_stack        S|ystem (C-) stack limit.  0 if not known.               |
| stack          |Total memory in use for stacks in all threads           |
| local          |Allocated size of the local stack in bytes              |
| localused      |Number of bytes in use on the local stack               |
| locallimit     |Size to which the local stack is allowed to grow        |
| local_shifts   N|umber of local stack expansions                        |
| global         |Allocated size of the global stack in bytes             |

| globalused     |Number of bytes in use on the global stack              |
| globallimit    |Size to which the global stack is allowed to grow       |
| global_shifts  N|umber of global stack expansions                       |
| trail          |Allocated size of the trail stack in bytes              |
| trailused      |Number of bytes in use on the trail stack               |
| traillimit     |Size to which the trail stack is allowed to grow        |
| trail_shifts   N|umber of trail stack expansions                        |

| shift_time     T|ime spent in stack-shifts                              |
| atoms          |Total number of defined atoms                           |
| functors       |Total number of defined name/arity pairs                |
| clauses        |Total number of clauses in the program                  |
| modules        |Total number of defined modules                         |
| codes          |Total size of (virtual) executable code in words        |
| threads        |MT-version:  number of active threads                   |
| threads_createdM|T-version:  number of created threads                  |

| thread_cputime M|T-version:   seconds CPU time used by finished threads.|
|                S|upported  on Windows-NT  and later, Linux  and possibly|
|                a| few more.   Verify it gives  plausible results before |
|________________u|sing.__________________________________________________|_

Table 4.3:  Keys for  statistics/2.  Space is expressed in bytes.   Time
is expressed in seconds, represented as a floating point number.
__________________________________________________________________________________
|____________________Compatibility_keys_(times_in_milliseconds)___________________|

| runtime                |[  CPU  time,  CPU  time  since  last ]  (milliseconds,|
|                        |excluding time spent in garbage collection)            |
| system_time            [| System  CPU  time,  System  CPU  time  since last  ] |
|                        (|milliseconds)                                         |
| real_time              [|Wall time,  Wall time since  last ] (integer seconds. |
|                        S|ee get_time/1)                                        |
| walltime               |[  Wall  time  since  start,   Wall  time  since  last]|

|                        |(milliseconds, SICStus compatibility)                  |
| memory                 |[ Total unshared data,  free memory ] (Uses getrusage()|
|                        |if available, otherwise incomplete own statistics.)    |
| stacks                 |[ global use, local use ]                              |
| program                |[ heap, 0 ]                                            |
| global_stack           [|global use, global free ]                             |
| local_stack            [|local use, local free ]                               |

| trail                  |[ trail use, trail free ]                              |
| garbage_collection     [|number of GC, bytes  gained, time spent, bytes left ] |
|                        T|he last column is a SWI-Prolog extension.  It contains|
|                        t|he  sum of  the  memory  left  after  each collection,|
|                        w|hich can be  divided by the count  to find the average|
|                        w|orking set size  after GC. Use  [Count, Gained, Time|_]|
|                        f|or compatiblity.                                      |
| stack_shifts           [|global shifts, local shifts, time spent ]             |

| atoms                  |[ number, memory use, 0 ]                              |
| atom_garbage_collection[|number of AGC, bytes gained, time spent ]             |
|_core___________________|Same_as_memory_________________________________________|_

Table 4.4:  Compatibility  keys for statistics/2.  Time is  expressed in
milliseconds.


ssttaattiissttiiccss
    Display a table of system statistics on the stream user_error.


ttiimmee((_:_G_o_a_l))
    Execute  _G_o_a_l  just  like call/1  and  print time  used,  number  of
    logical   inferences  and  the  average  number  of   _l_i_p_s  (logical
    inferences  per second).    Note that SWI-Prolog  counts the  actual
    executed  number  of inferences  rather than  the  number of  passes
    through  the call and  redo ports of  the theoretical 4-port  model.
    If  _G_o_a_l is non-deterministic,  print statistics for each  solution,
    where the reported values are relative to the previous answer.


44..3399 EExxeeccuuttiioonn pprrooffiilliinngg

This section describes  the hierarchical execution profiler.   This pro-
filer is based  on ideas from gprof described in  [Graham _e_t _a_l_., 1982].
The  profiler  consists   of  two  parts:    the   information-gathering
component built into the  kernel, and a presentation component  which is
defined in  the statistics  library.   The latter can  be hooked,  which
is used  by the  XPCE module swi/pce_profile to  provide an  interactive
graphical frontend for the results.


44..3399..11 PPrrooffiilliinngg pprreeddiiccaatteess

The following predicates are defined to interact with the profiler.


pprrooffiillee((_:_G_o_a_l))
    Execute _G_o_a_l just  like once/1, collecting profiling statistics, and
    call  show_profile(_[_]).   With XPCE installed this opens  a graphical
    interface to examine the collected profiling data.


pprrooffiillee((_:_G_o_a_l_, _+_O_p_t_i_o_n_s))
    Execute  _G_o_a_l  just  like  once/1.    Collect  profiling  statistics
    according  to _O_p_t_i_o_n_s  and call  show_profile/1 with _O_p_t_i_o_n_s.    The
    default collects CPU  profiling and opens a graphical interface when
    provided,  printing the `plain' time usage of the top  25 predicates
    as a ballback.   Options are described below.  Remaining options are
    passed to show_profile/1.

    ttiimmee((_+_W_h_i_c_h))
         If _W_h_i_c_h is cpu  (default), collect CPU timing statistics.   If
         wall, collect  wall time  statistics based on  a 5  millisecond
         sampling rate.    Wall time statistics  can be  useful if  _G_o_a_l
         calls blocking system calls.


sshhooww__pprrooffiillee((_+_O_p_t_i_o_n_s))
    This  predicate first calls  prolog:show_profile_hook/1.   If XPCE  is
    loaded,  this hook is used to activate a GUI interface  to visualise
    the  profile results.  If not,  a report is printed to  the terminal
    according to _O_p_t_i_o_n_s:

    ttoopp((_+_N))
         Show the only top _N predicates.  Default is 25.

    ccuummmmuullaattiivvee((_+_B_o_o_l))
         If true (default false), include the time spent  in children in
         the time reported for a predicate.


pprrooffiilleerr((_-_O_l_d_, _+_N_e_w))
    Query or change the status of the profiler.  The status is one of

    ffaallssee
         The profiler is not activated.

    ccppuuttiimmee
         The profiler collects CPU statistics.

    wwaallllttiimmee
         The profiler collects wall time statistics.

    The   value  true  is  accepted   as  a  synonym  for  cputime   for
    compatibility reasons.


rreesseett__pprrooffiilleerr
    Switches the profiler to false and clears all collected statistics.


nnoopprrooffiillee((_+_N_a_m_e_/_+_A_r_i_t_y_, _._._.))
    Declares  the predicate _N_a_m_e/_A_r_i_t_y to be invisible to  the profiler.
    The  time  spent in  the named  predicate is  added  to the  caller,
    and  the  callees are  linked  directly  to the  caller.    This  is
    particularly  useful  for  simple meta-predicates  such  as  call/1,
    ignore/1, catch/3, etc.


44..3399..22 VViissuuaalliizziinngg pprrooffiilliinngg ddaattaa

Browsing  the  annotated  call-tree  as  described   in  section  4.39.3
itself is  not very  attractive.   Therefore, the  results are  combined
per  predicate,  collecting all  _c_a_l_l_e_r_s  and  _c_a_l_l_e_e_s as  well  as  the
propagation  of time  and activations  in both  directions.   Figure  ????
illustrates  this.     The  central  yellowish  line  is  the  `current'
predicate with  counts for time  spent in  the predicate (`Self'),  time
spent in  its children  (`Siblings'), activations through  the call  and
redo ports.   Above  that are the _c_a_l_l_e_r_s.   Here,  the two time  fields
indicate  how much  time is  spent serving  each of  the callers.    The
columns sum to the time in the yellowish  line.  The caller <_r_e_c_u_r_s_i_v_e>
is the  number of recursive calls.   Below  the yellowish lines are  the
callees,  with the  time  spent in  the callee  itself for  serving  the
current  predicate and  the time  spent  in the  callees of  the  callee
('Siblings'), so  the whole time-block adds  up to the `Siblings'  field
of the current predicate.   The `Access' fields show how many  times the
current predicate accesses each of the callees.

The predicates have a  menu that allows changing the view of  the detail
window to the given  caller or callee, showing the documentation  (if it
is a built-in) and/or jumping to the source.

The  statistics  shown  in  the report  field  of  figure  ????  show  the
following information:

  o _s_a_m_p_l_e_s
    Number  of  times  the call-tree  was  sampled for  collecting  time
    statistics.   On most hardware,  the resolution of SIGPROF is  1/100
    second.    This number must  be sufficiently  large to get  reliable
    timing  figures.   The  Time menu  allows viewing  time as  samples,
    relative time or absolute time.

  o _s_e_c
    Total user CPU time with the profiler active.

  o _p_r_e_d_i_c_a_t_e_s
    Total  count of predicates that have  been called at least one  time
    during the profile.

  o _n_o_d_e_s
    Number of nodes in the call-tree.

  o _d_i_s_t_o_r_t_i_o_n
    How  much  of  the  time  is  spent  building  the  call-tree  as  a
    percentage  of the total execution time.   Timing samples while  the
    profiler is building the call-tree are not added to the call-tree.


44..3399..33 IInnffoorrmmaattiioonn ggaatthheerriinngg

While  the program  executes under  the profiler,  the  system builds  a
_d_y_n_a_m_i_c call-tree.    It does this  using three  hooks from the  kernel:
one  that starts  a  new goal  (_p_r_o_f_C_a_l_l),  one  that tells  the  system
which goal is  resumed after an _e_x_i_t  (_p_r_o_f_E_x_i_t) and one that tells  the
system which  goal is  resumed after a  _f_a_i_l (i.e.,  which goal is  used
to _r_e_t_r_y  (_p_r_o_f_R_e_d_o)).   The  profCall() function finds  or creates  the
subnode for  the argument predicate below  the current node,  increments
the call-count of this  link and returns the sub-node which  is recorded
in the Prolog  stack-frame.  Choice-points  are marked with the  current
profiling  node.   profExit()  and profRedo()  pass  the profiling  node
where execution resumes.

Just using the above  algorithm would create a much too big tree  due to
recursion.  For this reason the system performs  detection of recursion.
In the  simplest case,  recursive procedures  increment the  `recursive'
count on  the current node.   Mutual recursion,  however, is not  easily
detected.   For example,  call/1 can call a  predicate that uses  call/1
itself.   This  can be  viewed as a  recursive invocation,  but this  is
generally not  desirable.   Recursion is currently  assumed if the  same
predicate _w_i_t_h _t_h_e _s_a_m_e _p_a_r_e_n_t appears higher in the  call-graph.  Early
experience with some non-trivial programs are promising.

The  last part  of the  profiler  collects statistics  on the  CPU  time
used in each  node.  On  systems providing setitimer() with SIGPROF,  it
`ticks' the  current node of  the call-tree each  time the timer  fires.
On Windows, a MM-timer in a separate thread checks  100 times per second
how much  time is  spent in  the profiled thread  and adds  this to  the
current node.  See section 4.39.3.1 for details.


44..3399..33..11 PPrrooffiilliinngg iinn tthhee WWiinnddoowwss IImmpplleemmeennttaattiioonn

Profiling  in the  Windows version  is similar,  but as  profiling is  a
statistical process  it is good  to be aware  of the implementation  for
proper interpretation of the results.

Windows does not  provide timers that fire asynchronously,  frequent and
proportional to the CPU time used by the process.   Windows does provide
multi-media  timers that  can  run at  high  frequency.    Such  timers,
however, run  in a separate  thread of execution and  they are fired  on
the wall clock  rather than the amount of  CPU time used.  The  profiler
installs such a timer running, for saving CPU  time, rather inaccurately
at about 100 Hz.   Each time it is fired, it determines the CPU  time in
milliseconds used by Prolog since  the last time it was fired.   If this
value is non-zero, active predicates are incremented with this value.


44..4400 MMeemmoorryy MMaannaaggeemmeenntt


ggaarrbbaaggee__ccoolllleecctt
    Invoke  the global  and  trail stack  garbage collector.    Normally
    the  garbage   collector  is  invoked  automatically  if  necessary.
    Explicit  invocation  might   be  useful  to  reduce  the  need  for
    garbage  collections in time-critical segments  of the code.   After
    the  garbage  collection  trim_stacks/0 is  invoked to  release  the
    collected memory resources.


ggaarrbbaaggee__ccoolllleecctt__aattoommss
    Reclaim  unused atoms.  Normally invoked  after agc_margin (a Prolog
    flag)  atoms  have been  created.    On multithreaded  versions  the
    actual  collection is delayed until there are no  threads performing
    normal  garbage collection.    In this  case garbage_collect_atoms/0
    returns  immediately.    Note that  there is  no  guarantee it  will
    _e_v_e_r  happen,  as there  may always  be  threads performing  garbage
    collection.


ttrriimm__ssttaacckkss
    Release  stack memory resources that are not in use at  this moment,
    returning  them to the operating system.  It can be used  to release
    memory  resources  in  a backtracking  loop,  where  the  iterations
    require  typically seconds  of  execution time  and very  different,
    potentially  large, amounts  of stack  space.   Such a  loop can  be
    written as follows:

    ____________________________________________________________________|                                                                    |
    | loop :-                                                            |
    |         generator,                                                 |
    |             trim_stacks,                                           |

    |             potentially_expensive_operation,                       |
    ||________stop_condition,_!.________________________________________ ||

    The  Prolog top-level loop  is written  this way, reclaiming  memory
    resources after every user query.


sseett__pprroolloogg__ssttaacckk((_+_S_t_a_c_k_, _+_K_e_y_V_a_l_u_e))
    Set a parameter for  one of the Prolog runtime stacks.  _S_t_a_c_k is one
    of local, global,  trail or argument.  The table below describes the
    _K_e_y(_V_a_l_u_e)  pairs.  _V_a_l_u_e  can be an arithmetic integer  expression.
    For  example, to specify a 2 GB limit for the global stack,  one can
    use:

    ____________________________________________________________________|                                                                    |
    ||?-_set_prolog_stack(global,_limit(2*10**9)).______________________ ||

    Current settings can be retrieved with prolog_stack_property/2.

    lliimmiitt((_+_B_y_t_e_s))
         Set the  limit to  which the  stack  is allowed  to grow.    If
         the  specified  value  is  lower  than  the   current  usage  a
         permission_error is  raised.    If  the  limit is  larger  than
         supported, the system  silently reduces the requested limit  to
         the system limit.

    mmiinn__ffrreeee((_+_C_e_l_l_s))
         Minimum amount  of free  space after trimming  or shifting  the
         stack.   Setting  this value higher  can reduce  the number  of
         garbage collections  and  stack-shifts at  the cost  of  higher
         memory  usage.     The  spare  stack  amount  is  reported  and
         specified in `cells'.  A cell is 4 bytes in  the 32-bit version
         and 8 bytes on the 64-bit version.  See address_bits.  See also
         trim_stacks/0 and debug/0.

    ssppaarree((_+_C_e_l_l_s))
         All  stacks  trigger  overflow  before  actually  reaching  the
         limit,  so  the  resulting error  can  be  handled  gracefully.
         The spare  stack is used  for print_message/2 from the  garbage
         collector and for handling  exceptions.  The default  suffices,
         unless  the user  redefines  related hooks.    Do  nnoott  specify
         large values for this  because it reduces the amount  of memory
         available for your real task.

         Related  hooks  are message_hook/3  (redefining  GC  messages),
         prolog_trace_interception/4and prolog_exception_hook/4.


pprroolloogg__ssttaacckk__pprrooppeerrttyy((_?_S_t_a_c_k_, _?_K_e_y_V_a_l_u_e))
    True   if  _K_e_y_V_a_l_u_e  is   a  current  property   of  _S_t_a_c_k.      See
    set_prolog_stack/2 for defined properties.


44..4411 WWiinnddoowwss DDDDEE iinntteerrffaaccee

The  predicates in  this  section  deal with  MS-Windows  `Dynamic  Data
Exchange'  or DDE  protocol.    A Windows  DDE  conversation is  a  form
of interprocess  communication based on  sending reserved window  events
between the communicating processes.

Failing DDE  operations raise  an error  of the  structure below,  where
_O_p_e_r_a_t_i_o_n  is  the name  of  the  (partial) operation  that  failed  and
_M_e_s_s_a_g_e is a translation  of the operator error code.  For  some errors,
_C_o_n_t_e_x_t provides additional comments.

________________________________________________________________________|                                                                        |
||_______error(dde_error(Operation,_Message),_Context)__________________ ||


44..4411..11 DDDDEE cclliieenntt iinntteerrffaaccee

The DDE client interface  allows Prolog to talk to DDE  server programs.
We  will demonstrate  the use  of the  DDE interface  using the  Windows
PROGMAN (Program Manager) application:

________________________________________________________________________|                                                                        |
|1 ?- open_dde_conversation(progman, progman, C).                        |

|                                                                        |
|C = 0                                                                   |
|2 ?- dde_request(0, groups, X)                                          |
|                                                                        |
|--> Unifies X with description of groups                                |
|                                                                        |
|3 ?- dde_execute(0, '[CreateGroup("DDE Demo")]').                       |
|true.                                                                   |

|                                                                        |
|4 ?- close_dde_conversation(0).                                         |
|true.|_________________________________________________________________ |     |

For  details   on  interacting  with   progman,   use  the  SDK   online
manual  section on  the  Shell  DDE interface.     See also  the  Prolog
library(progman),  which  may be  used  to  write simple  Windows  setup
scripts in Prolog.


ooppeenn__ddddee__ccoonnvveerrssaattiioonn((_+_S_e_r_v_i_c_e_, _+_T_o_p_i_c_, _-_H_a_n_d_l_e))
    Open a conversation  with a server supporting the given service name
    and  topic (atoms).    If successful,  _H_a_n_d_l_e  may be  used to  send
    transactions  to the server.    If no willing  server is found  this
    predicate fails silently.


cclloossee__ddddee__ccoonnvveerrssaattiioonn((_+_H_a_n_d_l_e))
    Close  the  conversation   associated  with  _H_a_n_d_l_e.     All  opened
    conversations  should  be  closed  when they're  no  longer  needed,
    although  the system  will  close any  that remain  open on  process
    termination.


ddddee__rreeqquueesstt((_+_H_a_n_d_l_e_, _+_I_t_e_m_, _-_V_a_l_u_e))
    Request  a value from the server.   _I_t_e_m is an atom  that identifies
    the requested  data, and _V_a_l_u_e will be a string (CF_TEXT data in DDE
    parlance) representing that data, if the request is successful.


ddddee__eexxeeccuuttee((_+_H_a_n_d_l_e_, _+_C_o_m_m_a_n_d))
    Request  the  DDE  server  to  execute  the  given  command  string.
    Succeeds  if the command could be  executed and fails with an  error
    message otherwise.


ddddee__ppookkee((_+_H_a_n_d_l_e_, _+_I_t_e_m_, _+_C_o_m_m_a_n_d))
    Issue  a POKE command to the server on the specified _I_t_e_m.   _c_o_m_m_a_n_d
    is passed as data of type CF_TEXT.


44..4411..22 DDDDEE sseerrvveerr mmooddee

The  library(dde)  defines  primitives  to  realise  simple  DDE  server
applications in SWI-Prolog.   These features are provided as  of version
2.0.6 and  should be  regarded as prototypes.    The C part  of the  DDE
server can  handle some  more primitives,  so if you  need features  not
provided by this interface, please study library(dde).


ddddee__rreeggiisstteerr__sseerrvviiccee((_+_T_e_m_p_l_a_t_e_, _+_G_o_a_l))
    Register  a server  to handle  DDE request or  DDE execute  requests
    from  other applications.  To register a service for a  DDE request,
    _T_e_m_p_l_a_t_e is of the form:

         +Service(+Topic, +Item, +Value)

    _S_e_r_v_i_c_e  is the name  of the DDE  service provided (like progman  in
    the  client example  above).   _T_o_p_i_c is either  an atom,  indicating
    _G_o_a_l  only handles requests on this  topic, or a variable that  also
    appears  in _G_o_a_l.  _I_t_e_m and _V_a_l_u_e are variables that also  appear in
    _G_o_a_l.  _I_t_e_m represents the request data as a Prolog atom.

    The   example  below  registers   the  Prolog  current_prolog_flag/2
    predicate  to be accessible  from other applications.   The  request
    may  be  given  from  the  same  Prolog  as  well  as  from  another
    application.

    ____________________________________________________________________|                                                                    |
    | ?- dde_register_service(prolog(current_prolog_flag, F, V),         |

    |                         current_prolog_flag(F, V)).                |
    |                                                                    |
    | ?- open_dde_conversation(prolog, current_prolog_flag, Handle),     |
    |    dde_request(Handle, home, Home),                                |
    |    close_dde_conversation(Handle).                                 |
    |                                                                    |
    ||Home_=_'/usr/local/lib/pl-2.0.6/'_________________________________ ||

    Handling  DDE execute requests  is very similar.   In this case  the
    template is of the form:

         +Service(+Topic, +Item)

    Passing  a _V_a_l_u_e argument is  not needed as execute requests  either
    succeed  or fail.  If _G_o_a_l  fails, a `not processed' is  passed back
    to the caller of the DDE request.


ddddee__uunnrreeggiisstteerr__sseerrvviiccee((_+_S_e_r_v_i_c_e))
    Stop  responding  to  _S_e_r_v_i_c_e.     If  Prolog  is  halted,  it  will
    automatically call this on all open services.


ddddee__ccuurrrreenntt__sseerrvviiccee((_-_S_e_r_v_i_c_e_, _-_T_o_p_i_c))
    Find currently registered services and the topics served on them.


ddddee__ccuurrrreenntt__ccoonnnneeccttiioonn((_-_S_e_r_v_i_c_e_, _-_T_o_p_i_c))
    Find currently open conversations.


44..4422 MMiisscceellllaanneeoouuss


ddwwiimm__mmaattcchh((_+_A_t_o_m_1_, _+_A_t_o_m_2))
    True  if _A_t_o_m_1 matches _A_t_o_m_2  in the `Do What  I Mean' sense.   Both
    _A_t_o_m_1  and _A_t_o_m_2  may also be  integers or  floats.   The two  atoms
    match if:

      o  They are identical

      o  They differ by one character (spy  spu)

      o  One character is inserted/deleted (debug  deug)

      o  Two characters are transposed (trace  tarce)

      o  `Sub-words' are glued  differently (existsfile   existsFile
         exists_file)

      o  Two   adjacent   sub-words   are  transposed   (existsFile
         fileExists)


ddwwiimm__mmaattcchh((_+_A_t_o_m_1_, _+_A_t_o_m_2_, _-_D_i_f_f_e_r_e_n_c_e))
    Equivalent  to  dwim_match/2,  but unifies  _D_i_f_f_e_r_e_n_c_e  with an  atom
    identifying  the difference  between _A_t_o_m_1  and _A_t_o_m_2.   The  return
    values  are (in the same  order as above):   equal, mismatched_char,
    inserted_char, transposed_char, separated and transposed_word.


wwiillddccaarrdd__mmaattcchh((_+_P_a_t_t_e_r_n_, _+_S_t_r_i_n_g))
    True  if _S_t_r_i_n_g matches  the wildcard pattern  _P_a_t_t_e_r_n.  _P_a_t_t_e_r_n  is
    very  similar to the  Unix csh  pattern matcher.   The patterns  are
    given below:

     ?      Matches one arbitrary character.
     *      Matches any number of arbitrary characters.
     [...]  Matches one of the characters specified between the brackets.
            <_c_h_a_r_1>-<_c_h_a_r_2>indicates a range.
     {...}  Matches any of the patterns of the comma-separated list between the braces.

    Example:

    ____________________________________________________________________|                                                                    |
    | ?- wildcard_match('[a-z]*.{pro,pl}[%~]', 'a_hello.pl%').           |
    ||true._____________________________________________________________ ||


sslleeeepp((_+_T_i_m_e))
    Suspend  execution _T_i_m_e seconds.   _T_i_m_e  is either a floating  point
    number  or an  integer.   Granularity is  dependent on the  system's
    timer  granularity.   A  negative time  causes the  timer to  return
    immediately.   On  most non-realtime operating  systems we can  only
    ensure execution is suspended for aatt lleeaasstt _T_i_m_e seconds.

    On  Unix systems the  sleep/1 predicate is  realised ---in order  of
    preference---  by nanosleep(),  usleep(),  select() if  the time  is
    below 1 minute, or sleep().  On Windows systems Sleep() is used.


CChhaapptteerr 55..  SSWWII--PPRROOLLOOGG EEXXTTEENNSSIIOONNSS

This  chapter describes  extensions to  the  Prolog language  introduced
with SWI-Prolog version  7.  The  changes bring more modern  syntactical
conventions to  Prolog such as key-value  maps, called _d_i_c_t_s as  primary
citizens  and a  restricted form  of  _f_u_n_c_t_i_o_n_a_l _n_o_t_a_t_i_o_n.    They  also
extend Prolog basic types with strings, providing a  natural notation to
textual material as opposed to identifiers (atoms) and lists.

These extensions make the  syntax more intuitive to new users,  simplify
the integration  of domain  specific languages (DSLs)  and facilitate  a
more natural Prolog  representation for popular exchange languages  such
as XML and JSON.

While many programs  run unmodified in SWI-Prolog version 7,  especially
those  that  pass   double  quoted  strings  to  general  purpose   list
processing  predicates  require  modifications.     We  provide  a  tool
(list_strings/0) that we used to port a huge code base in half a day.


55..11 LLiissttss aarree ssppeecciiaall

As of version 7, SWI-Prolog lists can be  distinguished unambiguously at
runtime from ./2  terms and the atom '[]'.   The constant [] is  special
constant that is not an atom.  It has the following properties:

________________________________________________________________________|                                                                        |
|?- atom([]).                                                            |

|false.                                                                  |
|?- atomic([]).                                                          |
|true.                                                                   |
|?- [] == '[]'.                                                          |
|false.                                                                  |
|?- [] == [].                                                            |
|true.|_________________________________________________________________ |     |

The `cons' operator for creating list cells has changed  from the pretty
atom  '.' to  the ugly  atom '[|]',  so we  can  use the  '.' for  other
purposes.  See section 5.4.1.

This modification has  minimal impact on typical  Prolog code.  It  does
affect  foreign code  (see section  10) that  uses the  normal atom  and
compound term interface for manipulation lists.  In  most cases this can
be avoided by using the dedicated list functions.   For convenience, the
macros ATOM_nil and ATOM_dot are provided by SWI-Prolog.h.

Another  place  that  is  affected is  write_canonical/1.     Impact  is
minimized  by  using  the  list  syntax  for  lists.     The  predicates
read_term/2 and  write_term/2 support the  option dotlists(_t_r_u_e),  which
causes read_term/2 to read .(a,[]) as [a]  and write_term/2to  write [a]
as .(a,[]).


55..11..11 MMoottiivvaattiinngg ''[|]'' aanndd [[]] ffoorr lliissttss

Representing lists the conventional way using ./2 as  cons-cell and '[]'
as list  terminator both  (independently) poses  conflicts, while  these
conflicts are easily avoided.

  o Using  ./2 prevents using this  commonly used symbol as an  operator
    because  a.B  cannot   be  distinguished  from  [a|B].  Freeing  ./2
    provides  us  with a  unique term  that we  can  use for  functional
    notation on dicts as described in section 5.4.1.

  o Using  '[]' as list terminator prevents dynamic  distinction between
    atoms  and lists.    As a result,  we cannot  use type  polymorphism
    that  involve both  atoms and  lists.   For example,  we cannot  use
    _m_u_l_t_i  _l_i_s_t_s (arbitrary deeply nested lists) of atoms.   Multi lists
    of  atoms  are a  in  some situations  a  good representation  of  a
    flat  list that is assembled from  sub sequences.  The  alternative,
    using  difference lists or DCGs is often less natural  and sometimes
    demands  for `opening' proper  lists (i.e.,  copying the list  while
    replacing  the terminating  empty list  with a  variable) that  have
    to  be  added to  the sequence.    The ambiguity  of  atom and  list
    is  particularly painful when mapping external  data representations
    that do not suffer from this ambiguity.

    At  the same  time, avoiding  '[]' as  a list  terminator makes  the
    various  text representations unambiguous, which allows us  to write
    predicates  that require  a textual argument  to accept both  atoms,
    strings,  and  lists  of  character codes  or  one-character  atoms.
    Traditionally, the empty  list can be interpreted both as the string
    "[]" and "".


55..22 TThhee ssttrriinngg ttyyppee aanndd iittss ddoouubbllee qquuootteedd ssyynnttaaxx

As  of SWI-Prolog  version  7, text  encloses  in double  quotes  (e.g.,
"Hello world")  is read  as  objects  of the  type  _s_t_r_i_n_g.    A  string
is  a compact  representation  of a  character  sequence that  lives  on
the  global  (term) stack.     Strings represent  sequences  of  Unicode
characters including the  character code 0 (zero).   The length  strings
is  limited by  the available  space  on the  global (term)  stack  (see
set_prolog_stack/2).   Strings  are distinct from  lists, which makes  it
possible  to detect  them at  runtime and  print them  using the  string
syntax, as illustrated below:

________________________________________________________________________|                                                                        |
|?- write("Hello world!").                                               |

|Hello world!                                                            |
|                                                                        |
|?- writeq("Hello world!").                                              |
|"Hello|world!"_________________________________________________________ |      |

_B_a_c_k _q_u_o_t_e_d text (as  in `text`) is mapped to a list of  character codes
in version 7.   The settings for  the flags that control how double  and
back quoted  text is read  is summarised  in table 5.1.   Programs  that
aim for compatibility should realise that the ISO  standard defines back
quoted text,  but does not define  the back_quotes Prolog flag and  does
not define the term that is produced by back quoted text.

             _______________________________________________MMooddeedouble_quotesback_quotes
             _______________________________________________Versions7tdefaultringcodes

             _--traditional_________codes_______symbol_char_

  Table 5.1:  Mapping of double and back quoted text in the two modes.

Section 5.2.4 motivates  the introduction of strings and mapping  double
quoted text to this type.


55..22..11 PPrreeddiiccaatteess tthhaatt ooppeerraattee oonn ssttrriinnggss

Strings may  be manipulated by  a set of predicates  that is similar  to
the manipulation  of atoms.   In  addition to the  list below,  string/1
performs the type check for this type and is described in section 4.6.

SWI-Prolog's  string primitives  are  being synchronized  with  ECLiPSe.
We  expect the  set  of predicates  documented  in  this section  to  be
stable, although  it might be expanded.   In general, SWI-Prolog's  text
manipulation  predicates accept  any  form  of text  as  input  argument
and  produce  the  type indicated  by  the  predicate  name  as  output.
This  policy simplifies  migration  and writing  programs that  can  run
unmodified or  with minor modifications on  systems that do not  support
strings.  Code should avoid relying on this feature  as much as possible
for clarity  as well  as to facilitate  a more  strict mode and/or  type
checking in future releases.


aattoomm__ssttrriinngg((_?_A_t_o_m_, _?_S_t_r_i_n_g))
    Bi-directional  conversion between an atom and  a string.  At  least
    one of the two  arguments must be instantiated.  _A_t_o_m can also be an
    integer or floating point number.


nnuummbbeerr__ssttrriinngg((_?_N_u_m_b_e_r_, _?_S_t_r_i_n_g))
    Bi-directional  conversion between a number and a string.   At least
    one  of the two  arguments must be instantiated.   Besides the  type
    used  to represent the text, this predicate differs in  several ways
    from its ISO cousin:

      o  If _S_t_r_i_n_g  does not  represent a  number,  the predicate  _f_a_i_l_s
         rather than throwing a syntax error exception.

      o  Leading white space and Prolog comments are _n_o_t allowed.

      o  Numbers may start with '+' or '-'.

      o  It is _n_o_t allowed to have white space between a  leading '+' or
         '-' and the number.

      o  Floating point numbers  in exponential notation do not  require
         a dot before exponent, i.e., "1e10" is a valid number.


tteerrmm__ssttrriinngg((_?_T_e_r_m_, _?_S_t_r_i_n_g))
    Bi-directional  conversion between a term and  a string.  If  _S_t_r_i_n_g
    is  instantiated, it is parsed and the result is unified  with _T_e_r_m.
    Otherwise  _T_e_r_m is `written' using  the option quoted(_t_r_u_e) and  the
    result is converted to _S_t_r_i_n_g.


tteerrmm__ssttrriinngg((_?_T_e_r_m_, _?_S_t_r_i_n_g_, _+_O_p_t_i_o_n_s))
    As   term_string/2,  passing   _O_p_t_i_o_n_s  to  either   read_term/2  or
    write_term/2.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- term_string(Term, 'a(A)', [variable_names(VNames)]).            |

    | Term = a(_G1466),                                                  |
    ||VNames_=_['A'=_G1466].____________________________________________ ||


ssttrriinngg__cchhaarrss((_?_S_t_r_i_n_g_, _?_C_h_a_r_s))
    Bi-directional conversion between  a string and a list of characters
    (one-character  atoms).  At least  one of the two arguments must  be
    instantiated.


ssttrriinngg__ccooddeess((_?_S_t_r_i_n_g_, _?_C_o_d_e_s))
    Bi-directional  conversion between a string and a list  of character
    codes.  At least one of the two arguments must be instantiated.


tteexxtt__ttoo__ssttrriinngg((_+_T_e_x_t_, _-_S_t_r_i_n_g))                                     _[_d_e_t_]
    Converts  _T_e_x_t to  a string.   _T_e_x_t is  an atom,  string or list  of
    characters  (codes or chars).   When running in --traditional  mode,
    '[]' is ambiguous and interpreted as an empty string.


ssttrriinngg__lleennggtthh((_+_S_t_r_i_n_g_, _-_L_e_n_g_t_h))
    Unify  _L_e_n_g_t_h  with  the number  of  characters  in _S_t_r_i_n_g.     This
    predicate  is  functionally  equivalent  to atom_length/2  and  also
    accepts atoms, integers and floats as its first argument.


ssttrriinngg__ccooddee((_?_I_n_d_e_x_, _+_S_t_r_i_n_g_, _?_C_o_d_e))
    True  when  _C_o_d_e  represents  the character  at  the  1-based  _I_n_d_e_x
    position in _S_t_r_i_n_g.   If _I_n_d_e_x is unbound the string is scanned from
    index  1.    Raises a  domain error  if _I_n_d_e_x  is negative.    Fails
    silently  if _I_n_d_e_x  is zero or  greater than  the length of  _S_t_r_i_n_g.
    The  mode string_code(_-_,_+_,_+)  is deterministic  if the  searched-for
    _C_o_d_e appears only once in _S_t_r_i_n_g.  See also sub_string/5.


ggeett__ssttrriinngg__ccooddee((_+_I_n_d_e_x_, _+_S_t_r_i_n_g_, _-_C_o_d_e))
    Semi-deterministic  version  of string_code/3.   In  addition,  this
    version  provides strict range checking, throwing a domain  error if
    _I_n_d_e_x is less than  1 or greater than the length of _S_t_r_i_n_g.  ECLiPSe
    provides this to support String[Index] notation.


ssttrriinngg__ccoonnccaatt((_?_S_t_r_i_n_g_1_, _?_S_t_r_i_n_g_2_, _?_S_t_r_i_n_g_3))
    Similar  to atom_concat/3,  but the unbound argument will  be unified
    with  a string object rather  than an atom.   Also, if both  _S_t_r_i_n_g_1
    and  _S_t_r_i_n_g_2 are  unbound and _S_t_r_i_n_g_3  is bound to  text, it  breaks
    _S_t_r_i_n_g_3,  unifying the start with  _S_t_r_i_n_g_1 and the end with  _S_t_r_i_n_g_2
    as  append does  with lists.   Note  that this  is not  particularly
    fast  on long strings,  as for  each redo the  system has to  create
    two  entirely new strings, while the list equivalent only  creates a
    single new list-cell and moves some pointers around.


sspplliitt__ssttrriinngg((_+_S_t_r_i_n_g_, _+_S_e_p_C_h_a_r_s_, _+_P_a_d_C_h_a_r_s_, _-_S_u_b_S_t_r_i_n_g_s))           _[_d_e_t_]
    Break  _S_t_r_i_n_g into _S_u_b_S_t_r_i_n_g_s.   The _S_e_p_C_h_a_r_s argument provides  the
    characters that act  as separators and thus the length of _S_u_b_S_t_r_i_n_g_s
    is  one more  than the number  of separators  found if _S_e_p_C_h_a_r_s  and
    _P_a_d_C_h_a_r_s  do not have common characters.   If _S_e_p_C_h_a_r_s and  _P_a_d_C_h_a_r_s
    are  equal,  sequences  of  adjacent  separators  act  as  a  single
    separator.    Leading  and trailing  characters  for each  substring
    that  appear  in _P_a_d_C_h_a_r_s  are  removed from  the  substring.    The
    input  arguments can be  either atoms,  strings or char/code  lists.
    Compatible with ECLiPSe.  Below are some examples:

    ____________________________________________________________________|                                                                    |
    | % a simple split                                                   |

    | ?- split_string("a.b.c.d", ".", "", L).                            |
    | L = ["a", "b", "c", "d"].                                          |
    | % Consider sequences of separators as a single one                 |
    | ?- split_string("/home//jan///nice/path", "/", "/", L).            |
    | L = ["home", "jan", "nice", "path"].                               |
    | % split and remove white space                                     |
    | ?- split_string("SWI-Prolog, 7.0", ",", " ", L).                   |
    | L = ["SWI-Prolog", "7.0"].                                         |

    | % only remove leading and trailing white space                     |
    | ?- split_string("  SWI-Prolog  ", "", "\s\t\n", L).                |
    ||L_=_["SWI-Prolog"]._______________________________________________ ||

    In the typical  use cases, _S_e_p_C_h_a_r_s either does not overlap _P_a_d_C_h_a_r_s
    or is equivalent  to handle multiple adjacent separators as a single
    (often white space).   The behaviour with partially overlapping sets
    of padding and  separators should be considered undefined.  See also
    read_string/5.


ssuubb__ssttrriinngg((_+_S_t_r_i_n_g_, _?_B_e_f_o_r_e_, _?_L_e_n_g_t_h_, _?_A_f_t_e_r_, _?_S_u_b_S_t_r_i_n_g))
    _S_u_b_S_t_r_i_n_g is a substring  of _S_t_r_i_n_g.  There are _B_e_f_o_r_e characters in
    _S_t_r_i_n_g before _S_u_b_S_t_r_i_n_g,  _S_u_b_S_t_r_i_n_g contains _L_e_n_g_t_h character and is
    followed  by _A_f_t_e_r characters in _S_t_r_i_n_g.  If not  enough information
    is  provided to compute  the start of the  match, _S_t_r_i_n_g is  scanned
    left-to-right.     This  predicate  is  functionally  equivalent  to
    sub_atom/5, but operates  on strings.  The following  example splits
    a string  of the form <_n_a_m_e>=<_v_a_l_u_e> into the name part (an atom) and
    the value (a string).

    ____________________________________________________________________|                                                                    |
    | name_value(String, Name, Value) :-                                 |

    |         sub_string(String, Before, _, After, "="), !,              |
    |         sub_string(String, 0, Before, _, NameString),              |
    |         atom_string(Name, NameString),                             |
    ||________sub_string(String,__,_After,_0,_Value).___________________ ||


aattoommiiccss__ttoo__ssttrriinngg((_+_L_i_s_t_, _-_S_t_r_i_n_g))
    _L_i_s_t  is  a  list of  strings,  atoms,  integers or  floating  point
    numbers.   Succeeds if _S_t_r_i_n_g  can be unified with the  concatenated
    elements  of  _L_i_s_t.     Equivalent  to  atomics_to_string(_L_i_s_t_,  _'_'_,
    _S_t_r_i_n_g).


aattoommiiccss__ttoo__ssttrriinngg((_+_L_i_s_t_, _+_S_e_p_a_r_a_t_o_r_, _-_S_t_r_i_n_g))
    Creates  a string just like atomics_to_string/2, but  inserts _S_e_p_a_r_a_-
    _t_o_r between each pair of inputs.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- atomics_to_string([gnu, "gnat", 1], ', ', A).                   |

    |                                                                    |
    ||A_=_"gnu,_gnat,_1"________________________________________________ ||


ssttrriinngg__uuppppeerr((_+_S_t_r_i_n_g_, _-_U_p_p_e_r_C_a_s_e))
    Convert _S_t_r_i_n_g to upper case and unify the result with _U_p_p_e_r_C_a_s_e.


ssttrriinngg__lloowweerr((_+_S_t_r_i_n_g_, _L_o_w_e_r_C_a_s_e))
    Convert _S_t_r_i_n_g to lower case and unify the result with _U_p_p_e_r_C_a_s_e.


rreeaadd__ssttrriinngg((_+_S_t_r_e_a_m_, _?_L_e_n_g_t_h_, _-_S_t_r_i_n_g))
    Read  at most _L_e_n_g_t_h characters from  _S_t_r_e_a_m and return them in  the
    string _S_t_r_i_n_g.   If _L_e_n_g_t_h is unbound, _S_t_r_e_a_m is read to the end and
    _L_e_n_g_t_h is unified with the number of characters read.


rreeaadd__ssttrriinngg((_+_S_t_r_e_a_m_, _+_S_e_p_C_h_a_r_s_, _+_P_a_d_C_h_a_r_s_, _-_S_e_p_, _-_S_t_r_i_n_g))
    Read  a  string  from _S_t_r_e_a_m,  providing  functionality  similar  to
    split_string/4.  The predicate performs the following steps:

     1.  Skip all characters that match _P_a_d_C_h_a_r_s

     2.  Read up to a character that matches _S_e_p_C_h_a_r_s or end of file

     3.  Discard  trailing  characters  that  match  _P_a_d_C_h_a_r_s  from  the
         collected input

     4.  Unify _S_t_r_i_n_g with a string created from the input  and _S_e_p with
         the separator character read.   If input was terminated  by the
         end of the input, _S_e_p is unified with -1.

    The predicate  read_string/5called repeatedly on  an input until _S_e_p
    is  -1 (end of file) is  equivalent to reading the entire file  into
    a  string  and calling  split_string/4,  provided  that _S_e_p_C_h_a_r_s  and
    _P_a_d_C_h_a_r_s are not _p_a_r_t_i_a_l_l_y _o_v_e_r_l_a_p_p_i_n_g.  Below are some examples:

    ____________________________________________________________________|                                                                    |

    | % Read a line                                                      |
    | read_string(Input, "\n", "\r", End, String)                        |
    | % Read a line, stripping leading and trailing white space          |
    | read_string(Input, "\n", "\r\t ", End, String)                     |
    | % Read upto , or ), unifying End with 0', or 0')                   |

    ||read_string(Input,_",)",_"\t_",_End,_String)______________________ ||


ooppeenn__ssttrriinngg((_+_S_t_r_i_n_g_, _-_S_t_r_e_a_m))
    True  when _S_t_r_e_a_m is  an input stream  that accesses the content  of
    _S_t_r_i_n_g.  _S_t_r_i_n_g  can be any text representation, i.e., string, atom,
    list of codes or list of characters.


55..22..22 RReepprreesseennttiinngg tteexxtt::  ssttrriinnggss,, aattoommss aanndd ccooddee lliissttss

With  the introduction  of strings  as  a Prolog  data type,  there  are
three  main ways  to  represent text:    using strings,  atoms  or  code
lists.   This section explains  what to choose for  what purpose.   Both
strings and  atoms are _a_t_o_m_i_c  objects:  you can  only look inside  them
using  dedicated predicates.    Lists of  character  codes are  compound
datastructures.

LLiissttss ooff cchhaarraacctteerr ccooddeess  is what  you need if  you want  to _p_a_r_s_e  text
    using  Prolog grammar rules (DCGs, see phrase/3).  Most of  the text
    reading  predicates  (e.g., read_line_to_codes/2)  return  a list  of
    character codes because  most applications need to parse these lines
    before the data can be processed.

AAttoommss  are  _i_d_e_n_t_i_f_i_e_r_s.    They  are  typically  used  in  cases  where
    identity  comparison is  the main operation  and that are  typically
    not  composed nor  taken apart.   Examples  are RDF resources  (URIs
    that  identify something), system identifiers (e.g.,  'Boeing 747'),
    but  also individual words in a natural language  processing system.
    They  are  also  used where  other  languages would  use  _e_n_u_m_e_r_a_t_e_d
    _t_y_p_e_s,  such as the names  of days in the  week.  Unlike  enumerated
    types,  Prolog atoms do not form not  a fixed set and the  same atom
    can represent different things in different contexts.

SSttrriinnggss  typically represents text that is  processed as a unit most  of
    the  time, but  which is not  an identifier for  something.   Format
    specifications  for format/3  is a  good example.   Another  example
    is  a  descriptive  text  provided  in  an  application.     Strings
    may  be  composed and  decomposed  using e.g.,  string_concat/3  and
    sub_string/5  or  converted  for  parsing  using  string_codes/2  or
    created  from codes  generated by  a generative  grammar rule,  also
    using string_codes/2.


55..22..33 AAddaappttiinngg ccooddee ffoorr ddoouubbllee qquuootteedd ssttrriinnggss

The predicates  in this section  can help adapting  your program to  the
new convention for  handling double quoted strings.   We have adapted  a
huge code base with which we were not familiar in about half a day.


lliisstt__ssttrriinnggss
    This  predicate may be  used to assess  compatibility issues due  to
    the  representation of double  quoted text as  string objects.   See
    section  5.2  and section  5.2.4.    To use  it,  load your  program
    into  Prolog and  run list_strings/0.   The  predicate lists  source
    locations of string  objects encountered in the program that are not
    considered  safe.  Such string  need to be examined manually,  after
    which one of the actions below may be appropriate:

      o  Rewrite the code.  For example, change [X] = "a" into X = 0'a.

      o  If a particular  module relies heavily on representing  strings
         as  lists of  character  code,  consider adding  the  following
         directive to the module.   Note that this flag only  applies to
         the module in which it appears.

         _______________________________________________________________|                                                               |

         ||_________:-_set_prolog_flag(double_quotes,_codes).___________ ||

      o  Use a  back  quoted string  (e.g.,  `text`).   Note  that  this
         will not  make your  code run regardless  of the  --traditional
         command line option  and code exploiting  this mapping is  also
         not portable to ISO compliant systems.

      o  If the strings appear in facts and usage is safe,  add a clause
         to the multifile  predicate check:string_predicate/1 to  silence
         list_strings/0 on all clauses of that predicate.

      o  If the strings  appear as an argument  to a predicate that  can
         handle string objects, add a clause to  the multifile predicate
         check:valid_string_goal/1 to silence list_strings/0.


cchheecckk::ssttrriinngg__pprreeddiiccaattee((_:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r))
    Declare  that _P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r has  clauses that contain  strings,
    but  that  this is  safe.   For  example, if  there  is a  predicate
    help_info/2,  where the  second argument  contains  a double  quoted
    string   that  is  handled  properly   by  the  predicates  of   the
    applications'  help system,  add the  following declaration to  stop
    list_strings/0 from complaining:

    ____________________________________________________________________|                                                                    |
    | :- multifile check:string_predicate/1.                             |

    |                                                                    |
    ||string_predicate(user:help_info/2)._______________________________ ||


cchheecckk::vvaalliidd__ssttrriinngg__ggooaall((_:_G_o_a_l))
    Declare  that calls to _G_o_a_l are  safe.  The module qualification  is
    the  actual module in which  _G_o_a_l is defined.   For example, a  call
    to  format/3 is  resolved  by the  predicate system:format/3.    and
    the  code below specifies that the  second argument may be a  string
    (system predicates that accept strings are defined in the library).

    ____________________________________________________________________|                                                                    |
    | :- multifile check:valid_string_goal/1.                            |

    |                                                                    |
    ||check:valid_string_goal(system:format(_,S,_))_:-_string(S)._______ ||


55..22..44 WWhhyy hhaass tthhee rreepprreesseennttaattiioonn ooff ddoouubbllee qquuootteedd tteexxtt cchhaannggeedd??

Prolog defines two forms  of quoted text.  Traditionally,  single quoted
text is  mapped to atoms while  double quoted text  is mapped to a  list
of _c_h_a_r_a_c_t_e_r _c_o_d_e_s  (integers) or characters represented as  1-character
atoms.   Representing text  using atoms  is often considered  inadequate
for several reasons:

  o It  hides  the   conceptual  difference  between  text  and  program
    symbols.   Where  content of text often  matters because it is  used
    in  I/O, program symbols are merely identifiers that match  with the
    same  symbol elsewhere.   Program symbols can often be  consistently
    replaced, for example to obfuscate or compact a program.

  o Atoms are globally unique  identifiers.  They are stored in a shared
    table.   Volatile strings represented as atoms come at a significant
    price  due to the required cooperation between threads  for creating
    atoms.   Reclaiming temporary atoms using _A_t_o_m _g_a_r_b_a_g_e _c_o_l_l_e_c_t_i_o_n is
    a costly process that requires significant synchronisation.

  o Many Prolog systems  (not SWI-Prolog) put severe restrictions on the
    length of atoms or the maximum number of atoms.

Representing text  as a  list of  character codes  or 1-character  atoms
also comes at a price:

  o It  is not possible to distinguish  (at runtime) a list of  integers
    or  atoms from a string.  Sometimes this information can  be derived
    from  (implicit) typing.  In  other cases the list must be  embedded
    in  a compound  term to  distinguish the two  types.   For  example,
    s("hello world") could be  used to indicate that we are dealing with
    a string.

    Lacking  runtime information,  debuggers and  the toplevel can  only
    use  heuristics to  decide whether to  print a  list of integers  as
    such or as a string (see portray_text/1).

    While  experienced  Prolog programmers  have  learned to  cope  with
    this, we still consider this an unfortunate situation.

  o Lists are expensive  structures, taking 2 cells per character (3 for
    SWI-Prolog  in its current form).  This stresses  memory consumption
    on the stacks while  pushing them on the stack and dealing with them
    during garbage collection is unnecessarilly expensive.

We observe  that in many  programs, most strings are  only handled as  a
single unit during  their lifetime.   Examining real code tells us  that
double quoted strings typically appear in one of the following roles:

 AA DDCCGG lliitteerraall   Although represented as a list of codes is  the correct
    representation  for  handling  in  DCGs,   the  DCG  translator  can
    recognise  the literal and convert it to the  proper representation.
    Such code need not be modified.

 AA ffoorrmmaatt ssttrriinngg   This  is   a  typical   example  of   text  that   is
    conceptually  not a program identifier.  Format is designed  to deal
    with  alternative representations of the  format string.  Such  code
    need not be modified.

 GGeettttiinngg aa cchhaarraacctteerr ccooddee   The construct [X] = "a"  is a commonly  used
    template  for getting the  character code  of the letter  'a'.   ISO
    Prolog  defines the syntax  0'a for this purpose.   Code using  this
    must  be modified.  The modified code will run on any  ISO compliant
    processor.

 AAss aarrgguummeenntt ttoo lliisstt pprreeddiiccaatteess ttoo ooppeerraattee oonn ssttrriinnggss   Here,   we   see
    code  such as append("name:", Rest, Codes).   Such code needs to  be
    modified.    In this  particular example,  the following  is a  good
    portable alternative:  phrase("name:", Codes, Rest)

 CChheecckkss ffoorr aa cchhaarraacctteerr ttoo bbee iinn aa sseett   Such tests are often  performed
    with  code  such  as  this:   memberchk(C, "~!@#$").     This  is  a
    rather  inefficient check in a traditional Prolog system  because it
    pushes  a list of character codes cell-by-cell the Prolog  stack and
    then  traverses this  list cell-by-cell  to see whether  one of  the
    cells  unifies with _C.  If the test is  successful, the string  will
    eventually  be subject  to garbage collection.    The best code  for
    this  is to write a predicate  as below, which pushes noting  on the
    stack  and performs an indexed  lookup to see whether the  character
    code is in `my_class'.

    ____________________________________________________________________|                                                                    |

    | my_class(0'~).                                                     |
    | my_class(0'!).                                                     |
    ||..._______________________________________________________________ ||

    An alternative to reach  the same effect is to use term expansion to
    create the clauses:

    ____________________________________________________________________|                                                                    |
    | term_expansion(my_class(_), Clauses) :-                            |
    |         findall(my_class(C),                                       |
    |                 string_code(_, "~!@#$", C),                        |
    |                 Clauses).                                          |

    |                                                                    |
    ||my_class(_).______________________________________________________ ||

    Finally,  the predicate string_code/3can be  exploited directly as a
    replacement  for the memberchk/2 on a  list of codes.  Although  the
    string  is still pushed onto the stack, it is more compact  and only
    a single entity.

We offer the predicate list_strings/0 to help porting your program.


55..33 SSyynnttaaxx cchhaannggeess


55..33..11 OOppeerraattoorrss aanndd qquuootteedd aattoommss

As of SWI-Prolog version 7, quoted atoms loose  their operator property.
This means  that expressions such as  A = 'dynamic'/1 are valid  syntax,
regardless  of  the  operator  definitions.     From  questions  on  the
mailinglist  this  is what  people  expect.    To  accomodate  for  real
quoted operators, a  quoted atom that _n_e_e_d_s  quotes can still act as  an
operator.  A good use-case for this is a unit  library, which allows for
expressions such as below.

________________________________________________________________________|                                                                        |
|?- Y isu 600kcal - 1h*200'W'.                                           |

|Y|=_1790400.0'J'.______________________________________________________ | |


55..33..22 CCoommppoouunndd tteerrmmss wwiitthh zzeerroo aarrgguummeennttss

As of  SWI-Prolog version  7, the  system supports  compound terms  that
have no  arguments.   This implies  that e.g.,  name() is valid  syntax.
This extension  aims at  functions on  dicts (see section  5.4) as  well
as  the  implementation  of  domain  specific  languages  (DSLs).     To
minimise the  consequences, the classic  predicates functor/3 and  =../2
have  not  been modified.     The  predicates compound_name_arity/3  and
compound_name_arguments/3 have  been added.    These predicates  operate
only on compound  terms and behave consistently for compounds  with zero
arguments.    Code that  _g_e_n_e_r_a_l_i_s_e_s  a term  using the  sequence  below
should generally be changed to use compound_name_arity/3.

________________________________________________________________________|                                                                        |
|    ...,                                                                |

|    functor(Specific, Name, Arity),                                     |
|    functor(General, Name, Arity),                                      |
||___...,_______________________________________________________________ ||

Replacement of =../2 by compound_name_arguments/3 is typically needed to
deal with code that follow the skeleton below.

________________________________________________________________________|                                                                        |
|    ...,                                                                |
|    Term0 =.. [Name|Args0],                                             |
|    maplist(convert, Args0, Args),                                      |
|    Term =.. [Name|Args],                                               |
||___...,_______________________________________________________________ ||

For predicates, goals and arithmetic functions (evaluable terms), <_n_a_m_e>
and <_n_a_m_e>()  are _e_q_u_i_v_a_l_e_n_t.   Below are some  examples that illustrate
this behaviour.

________________________________________________________________________|                                                                        |

|go() :- format('Hello world~n').                                        |
|                                                                        |
|?- go().                                                                |
|Hello world                                                             |
|                                                                        |
|?- go.                                                                  |
|Hello world                                                             |

|                                                                        |
|?- Pi is pi().                                                          |
|Pi = 3.141592653589793.                                                 |
|                                                                        |
|?- Pi is pi.                                                            |
|Pi|=_3.141592653589793.________________________________________________ |  |

Note  that  the   _c_a_n_n_o_n_i_c_a_l  representation  of  predicate  heads   and
functions  without arguments  is  an atom.    Thus,  clause(_g_o_(_)_,  _B_o_d_y)
returns the  clauses for  go/0, but clause(_-_H_e_a_d_,  _-_B_o_d_y_, _+_R_e_f)  unifies
_H_e_a_d with an atom if the clause specified by _R_e_f is  part of a predicate
with zero arguments.


55..33..33 BBlloocckk ooppeerraattoorrss

Introducing curly bracket  and array subscripting.   The symbols []  and
{} may be declared as an operator, which has the following effect:

[[ ]]
    This  operator is  typically declared as  a low-priority yf  postfix
    operator,  which  allows for  array[index] notation.    This  syntax
    produces a term []([index],array).

{ }
    This  operator is  typically declared as  a low-priority xf  postfix
    operator,  which  allows  for  head(arg) { body } notation.     This
    syntax produces a term {}({body},head(arg)).

Below is  an example that  illustrates the  representation of a  typical
`curly bracket language' in Prolog.

________________________________________________________________________|                                                                        |

|?- op(100, xf, {}).                                                     |
|?- op(100, yf, []).                                                     |
|?- op(1100, yf, ;).                                                     |
|                                                                        |
|?- displayq(func(arg)                                                   |

|            { a[10] = 5;                                                |
|              update();                                                 |
|            }).                                                         |
|{}({;(=([]([10],a),5),;(update()))},func(arg))|________________________ |                                              |


55..44 DDiiccttss::  ssttrruuccttuurreess wwiitthh nnaammeedd aarrgguummeennttss

SWI-Prolog  version 7  introduces dicts  as an  abstract  object with  a
concrete modern  syntax and  functional notation  for accessing  members
and as  well as access functions  defined by the user.   The syntax  for
a dict  is illustrated  below.   _T_a_g is  either a variable  or an  atom.
As  with compound  terms, there  is nnoo  space  between the  tag and  the
opening brace.    The keys  are either atoms  or small  integers (up  to
max_tagged_integer).   The  values are arbitrary  Prolog terms which  are
parsed using the same rules as used for arguments in compound terms.

    Tag{Key1:Value1, Key2:Value2, ...}

A  dict can  _n_o_t hold  duplicate keys.    The dict  is transformed  into
an opaque  internal representation that  does _n_o_t  respect the order  in
which the  key-value pairs  appear in  the input  text.   If  a dict  is
written, the keys are  written according to the standard order  of terms
(see section 4.7.1).   Here are some examples, where the  second example
illustrates that the  order is not maintained and the  third illustrates
an anonymous dict.

________________________________________________________________________|                                                                        |

|?- A = point{x:1, y:2}.                                                 |
|A = point{x:1, y:2}.                                                    |
|                                                                        |
|?- A = point{y:2, x:1}.                                                 |
|A = point{x:1, y:2}.                                                    |

|                                                                        |
|?- A = _{first_name:"Mel", last_name:"Smith"}.                          |
|A|=__G1476{first_name:"Mel",_last_name:"Smith"}._______________________ | |

Dicts  can   be  unified   following  the   standard  symmetric   Prolog
unification  rules.    As dicts  use  an internal  canonical  form,  the
order in  which the named keys  are represented is  not relevant.   This
behaviour is illustrated by the following example.

________________________________________________________________________|                                                                        |
|?- point{x:1, y:2} = Tag{y:2, x:X}.                                     |
|Tag = point,                                                            |
|X|=_1._________________________________________________________________ | |

NNoottee In the  current implementation, two dicts  unify only if they  have
the same set  of keys and the tags  and values associated with the  keys
unify.   In  future versions,  the notion of  unification between  dicts
could  be modified  such that  two dicts  unify if  their  tags and  the
values associated with _c_o_m_m_o_n keys unify, turning both  dicts into a new
dict that has the union of the keys of the two original dicts.


55..44..11 FFuunnccttiioonnss oonn ddiiccttss

The infix operator dot (op(_1_0_0_,  _y_f_x_, _.)  is used to extract  values and
evaluate functions on  dicts.  Functions  are recognised if they  appear
in the  argument of  a _g_o_a_l  in the source  text, possibly  nested in  a
term.   The keys  act as field  selector, which  is illustrated in  this
example.

________________________________________________________________________|                                                                        |
|?- X = point{x:1,y:2}.x.                                                |

|X = 1.                                                                  |
|                                                                        |
|?- Pt = point{x:1,y:2}, write(Pt.y).                                    |
|2                                                                       |
|Pt = point{x:1,y:2}.                                                    |
|                                                                        |
|?- X = point{x:1,y:2}.C.                                                |
|X = 1,                                                                  |

|C = x ;                                                                 |
|X = 2,                                                                  |
|C|=_y._________________________________________________________________ | |

The compiler translates a goal that contains ./2 terms  in its arguments
into a conjunction of calls to ./3 defined in the system  module.  Terms
funcref.2 that  appears in  the head  are replaced with  a variable  and
calls to  ./3 are  inserted at the  start of the  body.   Below are  two
examples, where the first extracts the x key from a  dict and the second
extends  a dict  containing an  address with  the postal  code, given  a
find_postal_code/4predicate.

________________________________________________________________________|                                                                        |
|dict_x(X, X.x).                                                         |
|                                                                        |
|add_postal_code(Dict, Dict.put(postal_code, Code)) :-                   |

|        find_postal_code(Dict.city,                                     |
|                         Dict.street,                                   |
|                         Dict.house_number,                             |
||________________________Code).________________________________________ ||

Note  that expansion  of ./2  terms implies  that such  terms cannot  be
created by  writing them  explicitly in your  source code.   Such  terms
can still  be created  with functor/3, =../2,  compound_name_arity/3 and
compound_name_arguments/3.


.((_+_D_i_c_t_, _+_F_u_n_c_t_i_o_n_, _-_R_e_s_u_l_t))
    This  predicate  is  called  to  evaluate ./2  terms  found  in  the
    arguments of a  goal.  This predicate evaluates the field extraction
    described  above, which is mapped to get_dict_ex/3.  If  _F_u_n_c_t_i_o_n is
    a  compound term, it  checks for the  predefined functions on  dicts
    described in section  5.4.1.2 or executes a user defined function as
    described in section 5.4.1.1.


55..44..11..11 UUsseerr ddeeffiinneedd ffuunnccttiioonnss oonn ddiiccttss

The tag of a dict associates the dict to a module.   If the dot notation
uses a compound term, this calls the goal below.

    <_m_o_d_u_l_e>:<_n_a_m_e>(Arg1, ..., +Dict, -Value)

Functions  are  normal  Prolog predicates.     The  dict  infrastructure
provides a  more convenient  syntax for  representing the  head of  such
predicates  without worrying  about  the argument  calling  conventions.
The  code below  defines  a function  multiply(_T_i_m_e_s)  on a  point  that
creates  a new  point  by multiplying  both coordinates.    and  len  to
compute the length  from the origin.  The  .  and := operators  are used
to abstract the location  of the predicate arguments.  It is  allowed to
define multiple a function with multiple clauses,  providing overloading
and non-determinism.

________________________________________________________________________|                                                                        |

|:- module(point, []).                                                   |
|                                                                        |
|M.multiply(F) := point{x:X, y:Y} :-                                     |
|        X is M.x*F,                                                     |
|        Y is M.y*F.                                                     |
|                                                                        |
|M.len() := Len :-                                                       |

||_______Len_is_sqrt(M.x**2_+_M.y**2).__________________________________ ||

After these definitions, we can evaluate the following functions:

________________________________________________________________________|                                                                        |
|?- X = point{x:1, y:2}.multiply(2).                                     |
|X = point{x:2, y:4}.                                                    |
|                                                                        |
|?- X = point{x:1, y:2}.multiply(2).len().                               |

|X|=_4.47213595499958.__________________________________________________ | |


55..44..11..22 PPrreeddeeffiinneedd ffuunnccttiioonnss oonn ddiiccttss

Dicts currently define the following reserved functions:


ggeett((_?_K_e_y))
    Same  as _D_i_c_t._K_e_y, but maps  to get_dict/3 instead of get_dict_ex/3.
    This  implies that  the function  evaluation fails  silently if  _K_e_y
    does  not appear in _D_i_c_t.  See also :</2, which can be  used to test
    for  existence and  unify  multiple key  values from  a dict.    For
    example:

    ____________________________________________________________________|                                                                    |
    | ?- write(t{a:x}.get(a)).                                           |

    | x                                                                  |
    | ?- write(t{a:x}.get(b)).                                           |
    ||false.____________________________________________________________ ||


ppuutt((_+_N_e_w))
    Evaluates  to a  new dict  where the  key-values in  _N_e_w replace  or
    extend the key-values in the original dict.  See put_dict/3.


ppuutt((_+_K_e_y_P_a_t_h_, _+_V_a_l_u_e))
    Evaluates to a  new dict where the _K_e_y_P_a_t_h-_V_a_l_u_e replaces or extends
    the  key-values in  the  original dict.    _K_e_y_P_a_t_h is  either a  key
    or  a  term _K_e_y_P_a_t_h/_K_e_y,  replacing the  value  associated with  _K_e_y
    in  a sub-dict  of the dict  on which  the function operates.    See
    put_dict/4.  Below are some examples:

    ____________________________________________________________________|                                                                    |
    | ?- A = _{}.put(a, 1).                                              |

    | A = _G7359{a:1}.                                                   |
    |                                                                    |
    | ?- A = _{a:1}.put(a, 2).                                           |
    | A = _G7377{a:2}.                                                   |
    |                                                                    |
    | ?- A = _{a:1}.put(b/c, 2).                                         |
    | A = _G1395{a:1, b:_G1584{c:2}}.                                    |
    |                                                                    |

    | ?- A = _{a:_{b:1}}.put(a/b, 2).                                    |
    | A = _G1429{a:_G1425{b:2}}.                                         |
    |                                                                    |
    | ?- A = _{a:1}.put(a/b, 2).                                         |
    ||A_=__G1395{a:_G1578{b:2}}.________________________________________ ||


55..44..22 PPrreeddiiccaatteess ffoorr mmaannaaggiinngg ddiiccttss

This section  documents the predicates  that are defined on  dicts.   We
use the naming and argument conventions of the traditional assoc.


iiss__ddiicctt((_@_T_e_r_m))
    True if _T_e_r_m is a dict.  This is the same as is_dict(Term,_).


iiss__ddiicctt((_@_T_e_r_m_, _-_T_a_g))
    True if _T_e_r_m is a dict of _T_a_g.


ggeett__ddiicctt((_?_K_e_y_, _+_D_i_c_t_, _-_V_a_l_u_e))
    Unify  the value associated  with _K_e_y in  dict with _V_a_l_u_e.   If  _K_e_y
    is  unbound, all associations in _D_i_c_t are returned  on backtracking.
    The  order  in which  the associations  are  returned is  undefined.
    This  predicate is normally  accessed using the functional  notation
    Dict.Key.  See section 5.4.1.


ggeett__ddiicctt((_+_K_e_y_, _+_D_i_c_t_, _-_V_a_l_u_e_, _-_N_e_w_D_i_c_t_, _+_N_e_w_V_a_l_u_e))             _[_s_e_m_i_d_e_t_]
    Create a new dict  after updating the value for _K_e_y.  Fails if _V_a_l_u_e
    does  not unify with  the current value associated  with _K_e_y.   Acts
    according  to the following below.  _D_i_c_t is either a dict  or a list
    the can be converted into a dict.

    ____________________________________________________________________|                                                                    |
    | get_dict(Key, Dict, Value, NewDict, NewDict) :-                    |
    |         get_dict(Key, Dict, Value),                                |
    ||________put_dict(Key,_Dict,_NewDict,_NewDict).____________________ ||


ddiicctt__ccrreeaattee((_-_D_i_c_t_, _+_T_a_g_, _+_D_a_t_a))
    Create  a dict in _T_a_g from _D_a_t_a.  _D_a_t_a is a  list of attribute-value
    pairs   using  the   syntax  Key:Value,   Key=Value,  Key-Value   or
    Key(Value).   An exception is raised  if _D_a_t_a is not a  proper list,
    one  of the elements is not of the shape above, a key  is neither an
    atom nor a small integer or there is a duplicate key.


ddiicctt__ppaaiirrss((_?_D_i_c_t_, _?_T_a_g_, _?_P_a_i_r_s))
    Bi-directional  mapping between a dict and an ordered list  of pairs
    (see section 12.20).


ppuutt__ddiicctt((_+_N_e_w_, _+_D_i_c_t_I_n_, _-_D_i_c_t_O_u_t))
    _D_i_c_t_O_u_t  is a  new  dict created  by replacing  or adding  key-value
    pairs  from _N_e_w to  _D_i_c_t.   _N_e_w is  either a dict  or a valid  input
    for  dict_create/3.   This predicate  is normally accessed using  the
    functional notation.  Below are some examples:

    ____________________________________________________________________|                                                                    |
    | ?- A = point{x:1, y:2}.put(_{x:3}).                                |

    | A = point{x:3, y:2}.                                               |
    |                                                                    |
    | ?- A = point{x:1, y:2}.put([x=3]).                                 |
    | A = point{x:3, y:2}.                                               |
    |                                                                    |
    | ?- A = point{x:1, y:2}.put([x=3,z=0]).                             |
    ||A_=_point{x:3,_y:2,_z:0}._________________________________________ ||


ppuutt__ddiicctt((_+_K_e_y_, _+_D_i_c_t_I_n_, _+_V_a_l_u_e_, _-_D_i_c_t_O_u_t))
    _D_i_c_t_O_u_t  is a new dict created  by replacing or adding _K_e_y-_V_a_l_u_e  to
    _D_i_c_t_I_n.   This predicate  is normally accessed using the  functional
    notation.  Below is an example:

    ____________________________________________________________________|                                                                    |
    | ?- A = point{x:1, y:2}.put(x, 3).                                  |

    ||A_=_point{x:3,_y:2}.______________________________________________ ||


ddeell__ddiicctt((_+_K_e_y_, _+_D_i_c_t_I_n_, _?_V_a_l_u_e_, _-_D_i_c_t_O_u_t))
    True   when  _K_e_y-_V_a_l_u_e  is  in  _D_i_c_t_I_n  and  _D_i_c_t_O_u_t   contains  all
    associations of _D_i_c_t_I_n except for _K_e_y.


_+_S_e_l_e_c_t :< _+_F_r_o_m                                              _[_s_e_m_i_d_e_t_]
    True  when _S_e_l_e_c_t is  a `sub dict'  of _F_r_o_m:   the tages must  unify
    and  all keys in  _S_e_l_e_c_t must appear  with unifying values in  _F_r_o_m.
    _F_r_o_m  may contain  keys  that are  not in  _S_e_l_e_c_t.   This  operation
    is  frequently used to  _m_a_t_c_h a  dict and at  the same time  extract
    relevant values from it.  For example:

    ____________________________________________________________________|                                                                    |
    | plot(Dict, On) :-                                                  |

    |         _{x:X, y:Y, z:Z} :< Dict, !,                               |
    |         plot_xyz(X, Y, Z, On).                                     |
    | plot(Dict, On) :-                                                  |
    |         _{x:X, y:Y} :< Dict, !,                                    |
    ||________plot_xy(X,_Y,_On).________________________________________ ||

    The  goal Select :< From is equivalent to  select_dict(_S_e_l_e_c_t_,  _F_r_o_m_,
    __).


sseelleecctt__ddiicctt((_+_S_e_l_e_c_t_, _+_F_r_o_m_, _-_R_e_s_t))                             _[_s_e_m_i_d_e_t_]
    True  when the tags of _S_e_l_e_c_t  and _F_r_o_m have been unified,  all keys
    in  _S_e_l_e_c_t appear  in _F_r_o_m  and the corresponding  values have  been
    unified.   The key-value pairs of _F_r_o_m that do not appear  in _S_e_l_e_c_t
    are  used to  form an anonymous  dict, which  us unified with  _R_e_s_t.
    For example:

    ____________________________________________________________________|                                                                    |
    | ?- select_dict(P{x:0, y:Y}, point{x:0, y:1, z:2}, R).              |

    | P = point,                                                         |
    | Y = 1,                                                             |
    ||R_=__G1705{z:2}.__________________________________________________ ||

    See  also select_dict/2 to  ignore _R_e_s_t  and >:</2  for a  symmetric
    partial unification of two dicts.


_+_D_i_c_t_1 >:< _+_D_i_c_t_2
    This  operator specifies  a  _p_a_r_t_i_a_l _u_n_i_f_i_c_a_t_i_o_n  between _D_i_c_t_1  and
    _D_i_c_t_2.  It  is true when the tags and the values associated with all
    _c_o_m_m_o_n  keys have been unified.  The values associated to  keys that
    do  not appear in the other  dict are ignored.  Partial  unification
    is  symmetric.  For example, given a list of dicts, find  dicts that
    represent a point with X equal to zero:

    ____________________________________________________________________|                                                                    |
    |     member(Dict, List),                                            |

    ||____Dict_>:<_point{x:0,_y:Y}._____________________________________ ||

    See also :</2  and select_dict/3.


55..44..22..11 DDeessttrruuccttiivvee aassssiiggnnmmeenntt iinn ddiiccttss

This  section describes  the destructive  update  operations defined  on
dicts.    These actions  can  only _u_p_d_a_t_e  keys and  not  add or  remove
keys.    If  the  requested key  does  not  exist the  predicate  raises
existence_error(_k_e_y_, _K_e_y_, _D_i_c_t).  Note the additional argument.

Destructive assignment  is a  non-logical operation and  should be  used
with care  because identical Prolog  terms may be  copied or shared  add
will of the system.  Some of this behaviour can  be avoided by adding an
additional unbound value  to the dict.   This prevents unwanted  sharing
and ensures that copy_term/2 actually copies the dict.   This pitfall is
demonstrated in the example below:

________________________________________________________________________|                                                                        |
|?- A = a{a:1}, copy_term(A,B), b_set_dict(a, A, 2).                     |

|A = B, B = a{a:2}.                                                      |
|                                                                        |
|?- A = a{a:1,dummy:_}, copy_term(A,B), b_set_dict(a, A, 2).             |
|A = a{a:2, dummy:_G3195},                                               |
|B|=_a{a:1,_dummy:_G3391}.______________________________________________ | |


bb__sseett__ddiicctt((_+_K_e_y_, _!_D_i_c_t_, _+_V_a_l_u_e))                                    _[_d_e_t_]
    Destructively  update  the  value associated  with  _K_e_y in  _D_i_c_t  to
    _V_a_l_u_e.   The  update is trailed  and undone on  backtracking.   This
    predicate raises an  existence error if _K_e_y does not appear in _D_i_c_t.
    The update semantics are equivalent to setarg/3 and b_setval/2.


nnbb__sseett__ddiicctt((_+_K_e_y_, _!_D_i_c_t_, _+_V_a_l_u_e))                                   _[_d_e_t_]
    Destructively  update the  value associated  with _K_e_y in  _D_i_c_t to  a
    copy  of _V_a_l_u_e.   The update  is _n_o_t undone on  backtracking.   This
    predicate raises an  existence error if _K_e_y does not appear in _D_i_c_t.
    The update semantics are equivalent to nb_setarg/3 and nb_setval/2.


nnbb__lliinnkk__ddiicctt((_+_K_e_y_, _!_D_i_c_t_, _+_V_a_l_u_e))                                  _[_d_e_t_]
    Destructively  update  the  value associated  with  _K_e_y in  _D_i_c_t  to
    _V_a_l_u_e.   The update is _n_o_t  undone on backtracking.   This predicate
    raises  an existence  error if _K_e_y  does not  appear in _D_i_c_t.    The
    update  semantics  are equivalent  to b_linkarg/3 and  nb_linkval/2.
    Use with  extreme care and consult the documentation of nb_linkval/2
    before use.


55..44..33 WWhheenn ttoo uussee ddiiccttss??

Dicts are  a new type in  the Prolog world.   They compete with  several
other types  and libraries.   In the  list below we  have a closer  look
at these  relations.   We will see that  dicts are first  of all a  good
replacement for compound terms  with a high or not clearly  fixed arity,
library record and option processing.

CCoommppoouunndd tteerrmmss  Compound  terms  with  positional  arguments   form  the
    traditional  way to package data in Prolog.  This  representation is
    well  understood, fast  and compound  terms are stored  efficiently.
    Compound  terms are  still the  representation  of choice,  provided
    that  the number  of arguments is  low and  fixed or compactness  or
    performance are of utmost importance.

    A  good example  of a  compound term  is the  representation of  RDF
    triples  using  the  term rdf(_S_u_b_j_e_c_t_,  _P_r_e_d_i_c_a_t_e_,  _O_b_j_e_c_t)  because
    RDF  triples are  defined to  have precisely  these three  arguments
    and  they are  always referred  to in this  order.   An  application
    processing  information  about  persons should  probably  use  dicts
    because  the  information that  is related  to a  person  is not  so
    fixed.    Typically  we see  first and  last name.    But there  may
    also  be  title, middle  name,  gender, date  of birth,  etc.    The
    number of arguments  becomes unmanagable when using a compound term,
    while  adding or removing an argument  leads to many changes in  the
    program.

LLiibbrraarryy record  Using library  record  relieves the  maintenance  issues
    associated  with using  compound terms significantly.   The  library
    generates  access and  modification predicates for  each field in  a
    compound  term  from a  declaration.    The library  provides  sound
    access  to compound terms with many arguments.  One of  its problems
    is  the  verbose syntax  needed  to access  or modify  fields  which
    results  from  long  names  for the  generated  predicates  and  the
    restriction  that each field needs  to be extracted with a  separate
    goal.    Consider the example  below, where  the first uses  library
    record and the second uses dicts.

    ____________________________________________________________________|                                                                    |
    |     ...,                                                           |

    |     person_first_name(P, FirstName),                               |
    |     person_last_name(P, LastName),                                 |
    |     format('Dear ~w ~w,~n~n', [FirstName, LastName]).              |
    |                                                                    |
    |     ...,                                                           |
    ||____format('Dear_~w_~w,~n~n',_[Dict.first_name,_Dict.last_name])._ ||

    Records  have a  fixed number  of arguments  and (non-)existence  of
    an  argument must be represented using  a value that is outside  the
    normal  domain.  This lead to unnatural code.  For  example, suppose
    our person also has a  title.  If we know the first name we use this
    and else we use the title.  The code samples below illustrate this.

    ____________________________________________________________________|                                                                    |

    | salutation(P) :-                                                   |
    |     person_first_name(P, FirstName), nonvar(FirstName), !,         |
    |     person_last_name(P, LastName),                                 |
    |     format('Dear ~w ~w,~n~n', [FirstName, LastName]).              |
    | salutation(P) :-                                                   |
    |     person_title(P, Title), nonvar(Title), !,                      |
    |     person_last_name(P, LastName),                                 |

    |     format('Dear ~w ~w,~n~n', [Title, LastName]).                  |
    |                                                                    |
    | salutation(P) :-                                                   |
    |     _{first_name:FirstName, last_name:LastName} :< P, !,           |
    |     format('Dear ~w ~w,~n~n', [FirstName, LastName]).              |
    | salutation(P) :-                                                   |
    |     _{title:Title, last_name:LastName} :< P, !,                    |
    ||____format('Dear_~w_~w,~n~n',_[Title,_LastName])._________________ ||

LLiibbrraarryy assoc  This library implements  a balanced binary  tree.   Dicts
    can  replace the use  of this library  if the association is  fairly
    static  (i.e.,  there  are  few update  operations),  all  keys  are
    atoms  or (small)  integers and the  code does  not rely on  ordered
    operations.

LLiibbrraarryy option  Option lists are introduced  by ISO Prolog, for  example
    for  read_term/3,  open/4,   etc.     The  option  library  provides
    operations to extract options,  merge options lists, etc.  Dicts are
    well  suited to replace option  lists because they are cheaper,  can
    be processed faster and have a more natural syntax.

LLiibbrraarryy pairs  This library  is  commonly used  to process  large  name-
    value  associations.     In many  cases  this  concerns  short-lived
    datastructures  that result  from findall/3,  maplist/3 and  similar
    list  processing predicates.    Dicts may  play a  role if  frequent
    random  key lookups are  needed on the  resulting association.   For
    example,  the skeleton  `create a pairs  list', `use list_to_assoc/2
    to  create an assoc', followed  by frequent usage of  get_assoc/2 to
    extract  key values can be replaced using  dict_pairs/2and  the dict
    access  functions.  Using dicts  in this scenario is more  efficient
    and provides a more pleasant access syntax.


55..44..44 AA mmoottiivvaattiioonn ffoorr ddiiccttss aass pprriimmaarryy cciittiizzeennss

Dicts, or key-value associations,  are a common data structure.   A good
old example  are _p_r_o_p_e_r_t_y _l_i_s_t_s  as found in Lisp,  while a good  recent
example is formed  by JavaScript _o_b_j_e_c_t_s.   Traditional Prolog does  not
offer native  property lists.    As a result,  people are  using a  wide
range of data structures for key-value associations:

  o Using compound terms and positional arguments, e.g., point(1,2).

  o Using   compound  terms   with  library   record,  which   generates
    access  predicates  for a  term using  positional  arguments from  a
    description.

  o Using   lists  of  terms  Name=Value,   Name-Value,  Name:Value   or
    Name(Value).

  o Using library assoc  which represents the associations as a balanced
    binary tree.

This situation  is unfortunate.    Each of these  have their  advantages
and disadvantages.    E.g.,  compound terms  are compact  and fast,  but
inflexible and using positional arguments quickly breaks down.   Library
record fixes this, but the syntax is considered hard to use.   Lists are
flexible, but  expensive and  the alternative key-value  representations
that  are  used  complicate  the  matter  even  more.     Library  assoc
allows  for efficient  manipulation of  changing associations,  but  the
syntactical  representation of  an assoc  is complex,  which makes  them
unsuitable  for e.g.,  _o_p_t_i_o_n_s  _l_i_s_t_s  as  seen in  predicates  such  as
open/4.


55..44..55 IImmpplleemmeennttaattiioonn nnootteess aabboouutt ddiiccttss

Although  dicts   are  designed  as  an   abstract  data  type  and   we
deliberately reserve  the possibility to  change the representation  and
even use  multiple representations, this  section describes the  current
implementation.

Dicts are  currently represented as  a compound  term using the  functor
`dict`.  The first argument is the tag.   The remaining arguments create
an array of sorted key-value pairs.  This  representation is compact and
guarantees good locality.  Lookup is order log(N),  while adding values,
deleting values  and merging with  other dicts has  order N.   The main
disadvantage is that changing  values in large dicts is costly,  both in
terms of memory and time.

Future versions may share  keys in a separate structure or use  a binary
trees to  allow for  cheaper updates.   One  of the issues  is that  the
representation must  either be  kept cannonical or  unification must  be
extended to compensate for alternate representations.


55..55 IInntteeggrraattiioonn ooff ssttrriinnggss aanndd ddiiccttss iinn tthhee lliibbrraarriieess

While  lacking proper  string  support  and dicts  when  designed,  many
predicates  and libraries  use  interfaces that  must be  classified  as
suboptimal.   Changing  these interfaces  is likely to  break much  more
code  than  the  changes  described in  this  chapter.     This  section
discusses  some  of  these issues.     Roughly,  there  are  two  cases.
There where  key-value associations  or text  is required  as _i_n_p_u_t,  we
can  facilitate the  new  features by  overloading the  accepted  types.
Interfaces that produce  text or key-value associations as their  _o_u_t_p_u_t
however  must make  a choice.    We plan  to resolve  that using  either
options  that specify  the  desired  output or  provide  an  alternative
library.


55..55..11 DDiiccttss aanndd ooppttiioonn pprroocceessssiinngg

System predicates and predicates based on library  options process dicts
as an alternative to traditional option lists.


55..55..22 DDiiccttss iinn ccoorree ddaattaa ssttrruuccttuurreess

Some predicates  now produce  structured data using  compound terms  and
access predicates.   We consider migrating these  to dicts.  Below is  a
tentative list  of candidates.   Portable code  should use the  provided
access predicates and not rely on the term representation.

  o Stream position terms

  o Date and time records


55..55..33 DDiiccttss,, ssttrriinnggss aanndd XXMMLL

The  XML  representation  could  benefit  significantly   from  the  new
features.    In  due time  we  plan to  provide  an set  of  alternative
predicates  and options  to  existing predicates  that  can be  used  to
exploit the  new types.   We propose the  following changes to the  data
representation:

  o The  attribute list of the  element(_N_a_m_e_, _A_t_t_r_i_b_u_t_e_s_, _C_o_n_t_e_n_t)  will
    become a dict.

  o Attribute values will remain atoms

  o CDATA in element content will be represented as strings


55..55..44 DDiiccttss,, ssttrriinnggss aanndd JJSSOONN

The  JSON  representation  could  benefit  significantly  from  the  new
features.    In  due time  we  plan to  provide  an set  of  alternative
predicates  and options  to  existing predicates  that  can be  used  to
exploit the  new types.   We propose the  following changes to the  data
representation:

  o Instead   of  using  json(_K_e_y_V_a_l_u_e_L_i_s_t),  the  new   interface  will
    translate  JSON objects to a  dict.  The  type of this dict will  be
    json.

  o String values in JSON will be mapped to strings.

  o The values true, false and null will be represented as atoms.


55..55..55 DDiiccttss,, ssttrriinnggss aanndd HHTTTTPP

The  HTTP  library  and  related  data  structures   would  profit  from
exploiting dicts.   Below  is a  list of data  structures that might  be
affected by future changes.   Code can be made more robust by  using the
option library functions for extracting values from these structures.

  o The HTTP request structure

  o The HTTP parameter interface

  o URI components

  o Attributes to HTML elements


55..66 RReemmaaiinniinngg iissssuueess

The changes  and extensions  described in  this chapter  resolve a  many
limitations of the  Prolog language we have  encountered.  Still,  there
are remaining issues for which we seek solutions in the future.

TTeexxtt  rreepprreesseennttaattiioonn Although  strings  resolve  this  issue   for  many
applications,  we are still  faced with  the representation  of text  as
lists  of  characters which  we  need  for  parsing using  DCGs.     The
ISO standard  provides two  representations, a list  of _c_h_a_r_a_c_t_e_r  _c_o_d_e_s
(`codes'  for short)  and a  list of  _o_n_e_-_c_h_a_r_a_c_t_e_r  _a_t_o_m_s (`chars'  for
short).     There  are  two  sets of  predicates,  named  *_code(s)  and
*_char(s)  that provide  the same  functionality (e.g.,  atom_codes/2 and
atom_chars/2) using  their  own representation  of  characters.    Codes
can be  used in arithmetic expressions,  while chars are more  readable.
Neither can  unambiguously be interpreted as  a representation for  text
because codes can  be interpreted as a list  of integers and chars as  a
list of atoms.

We have  not found  a convincing  way out.    One of  the options  could
be the  introduction of  a `char' type.    This type can  be allowed  in
arithmetic and with  the 0'<char> syntax we  have a concrete syntax  for
it.

AArrrraayyss Although  lists are  generally  a  much cleaner  alternative  for
Prolog, real  arrays with direct  access to elements  can be useful  for
particular tasks.  The problem of integrating arrays is  twofold.  First
of  all, there  is  no good  one-size-fits-all data  representation  for
arrays.   Many tasks that involve  arrays require _m_u_t_a_b_l_e arrays,  while
Prolog data  is immutable  by design.   Second,  standard Prolog has  no
good  syntax support  for  arrays.    SWI-Prolog  version 7  has  `block
operators' (see section  5.3.3) which can resolve the syntactic  issues.
Block operators have been adopted by YAP.

LLaammbbddaa  eexxpprreessssiioonnss Although many  alternatives have  been proposed,  we
still feel uneasy with them.

LLooooppss Many people have  explored routes to avoid the need  for recursion
in  Prolog for  simple iterations  over  data.   ECLiPSe  have  proposed
_l_o_g_i_c_a_l  _l_o_o_p_s [Schimpf, 2002],  while  B-Prolog introduced  _d_e_c_l_a_r_a_t_i_v_e
_l_o_o_p_s and _l_i_s_t  _c_o_m_p_r_e_h_e_n_s_i_o_n.  The above mentioned  lambda expressions,
combined with maplist/2 can achieve similar results.


CChhaapptteerr 66..  MMOODDUULLEESS

A Prolog  module is a  collection of predicates  which defines a  public
interface  by means  of  a set  of  provided predicates  and  operators.
Prolog  modules are  defined by  an ISO  standard.   Unfortunately,  the
standard  is considered  a failure  and, as  far as  we are  aware,  not
implemented  by any  concrete  Prolog implementation.    The  SWI-Prolog
module system syntax  is derived from the Quintus Prolog  module system.
The Quintus  module system has  been the starting  point for the  module
systems  of a  number of  mainstream Prolog  systems,  such as  SICStus,
Ciao and YAP. The underlying primitives of the  SWI-Prolog module system
differ from the mentioned systems.  These primitives  allow for multiple
modules in  a file,  hierarchical  modules, emulation  of other  modules
interfaces, etc.

This  chapter motivates  and  describes  the SWI-Prolog  module  system.
Novices can  start using  the module  system after  reading section  6.2
and section 6.3.   The primitives defined in these sections  suffice for
basic usage  until one needs  to export predicates  that call or  manage
other predicates dynamically (e.g.,  use call/1, assert/1, etc.).   Such
predicates are called _m_e_t_a _p_r_e_d_i_c_a_t_e_s and are discussed  in section 6.4.
Section 6.5  to section  6.8 describe  more advanced issues.    Starting
with section  6.9, we discuss more  low-level aspects of the  SWI-Prolog
module system that are used to implement the visible  module system, and
can be used to build other code reuse mechanisms.


66..11 WWhhyy UUssee MMoodduulleess??

In classic  Prolog systems,  all predicates  are organised  in a  single
namespace  and any  predicate can  call  any predicate.    Because  each
predicate  in  a file  can  be  called  from anywhere  in  the  program,
it  becomes  very  hard  to  find  the  dependencies   and  enhance  the
implementation  of a  predicate  without risking  to break  the  overall
application.  This  is true for any language, but even worse  for Prolog
due to its frequent need for `helper predicates'.

A  Prolog  module  encapsulates a  set  of  predicates  and  defines  an
_i_n_t_e_r_f_a_c_e.     Modules  can  import  other  modules,   which  makes  the
dependencies explicit.   Given explicit dependencies and a  well-defined
interface, it  becomes much easier  to change the internal  organisation
of a module without breaking the overall application.

Explicit dependencies can  also be used by the development  environment.
The SWI-Prolog library  prolog_xref  can be used to analyse  completeness
and  consistency of  modules.   This  library is  used  by the  built-in
editor PceEmacs for syntax highlighting, jump-to-definition, etc.


66..22 DDeeffiinniinngg aa MMoodduullee

Modules are normally  created by loading a _m_o_d_u_l_e  _f_i_l_e.  A module  file
is a file holding a module/2 directive as its first term.   The module/2
directive declares  the name and the  public (i.e., externally  visible)
predicates of  the module.   The  rest of  the file is  loaded into  the
module.   Below is an example of  a module file, defining reverse/2  and
hiding  the helper  predicate rev/3.    A module  can  use all  built-in
predicates and, by default, cannot redefine system predicates.

________________________________________________________________________|                                                                        |
|:- module(reverse, [reverse/2]).                                        |

|                                                                        |
|reverse(List1, List2) :-                                                |
|        rev(List1, [], List2).                                          |
|                                                                        |
|rev([], List, List).                                                    |
|rev([Head|List1], List2, List3) :-                                      |
||_______rev(List1,_[Head|List2],_List3)._______________________________ ||

The  module is  named reverse.    Typically,  the name  of  a module  is
the same  as the name  of the file  by which it  is defined without  the
filename  extension, but  this  naming is  not enforced.    Modules  are
organised in  a single  and flat  namespace and  therefore module  names
must be  chosen with  some care to  avoid conflicts.   As  we will  see,
typical  applications of  the module  system rarely  use the  name of  a
module explicitly in the source text.


::-- mmoodduullee((_+_M_o_d_u_l_e_, _+_P_u_b_l_i_c_L_i_s_t))
    This  directive can  only  be used  as the  first term  of a  source
    file.    It  declares  the file  to be  a  _m_o_d_u_l_e _f_i_l_e,  defining  a
    module  named _M_o_d_u_l_e.   Note  that a module  name is an  atom.   The
    module  exports  the predicates  of  _P_u_b_l_i_c_L_i_s_t.   _P_u_b_l_i_c_L_i_s_t  is  a
    list  of predicate indicators  (name/arity or name//arity pairs)  or
    operator  declarations using the format op(_P_r_e_c_e_d_e_n_c_e_, _T_y_p_e_,  _N_a_m_e).
    Operators  defined  in  the export  list  are available  inside  the
    module  as well  as  to modules  importing this  module.   See  also
    section 4.24.

    Compatible to Ciao Prolog,  if _M_o_d_u_l_e is unbound, it is unified with
    the basename without extension of the file being loaded.


::-- mmoodduullee((_+_M_o_d_u_l_e_, _+_P_u_b_l_i_c_L_i_s_t_, _+_D_i_a_l_e_c_t))
    Same  as module/2.  The additional _D_i_a_l_e_c_t argument provides  a list
    of  _l_a_n_g_u_a_g_e _o_p_t_i_o_n_s.  Each atom in the list _D_i_a_l_e_c_t is  mapped to a
    use_module/1 goal as given  below.  See also section 14.   The third
    argument  is supported  for  compatibility with  the Prolog  Commons
    project.

    ____________________________________________________________________|                                                                    |
    ||:-_use_module(library(dialect/LangOption))._______________________ ||


66..33 IImmppoorrttiinngg PPrreeddiiccaatteess iinnttoo aa MMoodduullee

Predicates  can be  added to  a module  by _i_m_p_o_r_t_i_n_g  them from  another
module.   Importing adds predicates  to the namespace of  a module.   An
imported predicate can be  called exactly the same as a  locally defined
predicate, although  its implementation  remains part of  the module  in
which it has been defined.

Importing  the predicates  from  another module  is achieved  using  the
directives use_module/1 or use_module/2.  Note that both directives take
_f_i_l_e_n_a_m_e_(_s_) as arguments.  That is, modules are  imported based on their
filename rather than their module name.


uussee__mmoodduullee((_+_F_i_l_e_s))
    Load  the file(s)  specified with  _F_i_l_e_s just  like ensure_loaded/1.
    The  files  must all  be  module files.    All  exported  predicates
    from  the  loaded files  are  imported into  the module  from  which
    this  predicate  is  called.     This  predicate  is  equivalent  to
    ensure_loaded/1,  except that it  raises an error  if _F_i_l_e_s are  not
    module files.

    The  imported predicates  act  as _w_e_a_k  _s_y_m_b_o_l_s in  the module  into
    which  they are imported.   This implies that a local definition  of
    a  predicate overrides (clobbers) the  imported definition.  If  the
    flag  warn_override_implicit_importis true  (default), a warning  is
    printed.  Below  is an example of a module that uses library(lists),
    but redefines flatten/2, giving it a totally different meaning:

    ____________________________________________________________________|                                                                    |
    | :- module(shapes, []).                                             |

    | :- use_module(library(lists)).                                     |
    |                                                                    |
    | flatten(cube, square).                                             |
    ||flatten(ball,_circle).____________________________________________ ||

    Loading the above file prints the following message:

    ____________________________________________________________________|                                                                    |
    | Warning: /home/janw/Bugs/Import/t.pl:5:                            |
    |         Local definition of shapes:flatten/2                       |

    ||________overrides_weak_import_from_lists__________________________ ||

    This  warning  can be  avoided  by (1)  using  use_module/2 to  only
    import the predicates  from the lists library that are actually used
    in  the `shapes'  module, (2)  using the except([flatten/2])  option
    of  use_module/2, (3)  use :- abolish(flatten/2).  before the  local
    definition  or (4)  setting warn_override_implicit_import to  false.
    Globally  disabling this warning  is only recommended if  overriding
    imported  predicates is common as a result of design choices  or the
    program  is ported  from a system  that silently overrides  imported
    predicates.

    Note  that  it  is  always  an error  to  import  two  modules  with
    use_module/1 that  export the same predicate.   Such conflicts  must
    be resolved with use_module/2 as described above.


uussee__mmoodduullee((_+_F_i_l_e_, _+_I_m_p_o_r_t_L_i_s_t))
    Load  _F_i_l_e, which must be a  module file, and import the  predicates
    as  specified by  _I_m_p_o_r_t_L_i_s_t.   _I_m_p_o_r_t_L_i_s_t  is a  list of  predicate
    indicators   specifying  the  predicates   that  will  be   imported
    from  the  loaded  module.    _I_m_p_o_r_t_L_i_s_t  also allows  for  renaming
    or  import-everything-except.     See  also  the  import  option  of
    load_files/2.    The first  example below  loads  member/2 from  the
    lists  library and  append/2 under  the name  list_concat, which  is
    how  this predicate is  named in YAP.  The second example loads  all
    exports  from  library  option except  for  meta_options/3.    These
    renaming  facilities are  generally  used to  deal with  portability
    issues  with as few  changes as possible  to the actual  code.   See
    also section 14 and section 6.7.

    ____________________________________________________________________|                                                                    |
    | :- use_module(library(lists), [ member/2,                          |
    |                                 append/2 as list_concat            |
    |                               ]).                                  |

    ||:-_use_module(library(option),_except([meta_options/3]))._________ ||

The module/2,  use_module/1 and  use_module/2 directives are  sufficient
to  partition a  simple Prolog  program into  modules.   The  SWI-Prolog
graphical  cross-referencing tool  gxref/0 can  be used  to analyse  the
dependencies between  non-module files  and propose module  declarations
for each file.


66..44 DDeeffiinniinngg aa mmeettaa--pprreeddiiccaattee

A   meta-predicate  is   a  predicate   that   calls  other   predicates
dynamically,  modifies  a  predicate,  or reasons  about  properties  of
a  predicate.     Such predicates  use  either  a  compound  term  or  a
_p_r_e_d_i_c_a_t_e  _i_n_d_i_c_a_t_o_r  to describe  the  predicate  they  address,  e.g.,
assert(name(jan))  or  abolish(name/1).     With  modules,  this  simple
schema  no longer  works as  each module  defines its  own mapping  from
name+arity to  predicate.   This  is resolved by  wrapping the  original
description in a term <_m_o_d_u_l_e>:<_t_e_r_m>,  e.g., assert(person:name(jan)) or
abolish(person:name/1).

Of course,  when calling  assert/1 from  inside a module,  we expect  to
assert to  a predicate  local to this  module.   In other  words, we  do
not wish  to provide  this :/2 wrapper  by hand.    The meta_predicate/1
directive tells the compiler that certain arguments are  terms that will
be used to look  up a predicate and thus need to be  wrapped (qualified)
with <_m_o_d_u_l_e>:<_t_e_r_m>, unless they are already wrapped.

In  the  example  below,  we  use this  to  define  maplist/3  inside  a
module.   The argument `2' in the  meta_predicate declaration means  that
the  argument is  module-sensitive and  refers to  a  predicate with  an
arity that is  two more than the term that  is passed in.   The compiler
only distinguishes the values 0..9 and :,  which denote module-sensitive
arguments,  from +,  -  and ?,  which denote  _m_o_d_e_s.    The values  0..9
are used  by the _c_r_o_s_s_-_r_e_f_e_r_e_n_c_e_r  and syntax highlighting.   Note  that
the  helper predicate  maplist_/3 does  not  need to  be declared  as  a
meta-predicate because the  maplist/3 wrapper already ensures that  _G_o_a_l
is qualified as <_m_o_d_u_l_e>:_G_o_a_l.   See the description of  meta_predicate/1
for details.

________________________________________________________________________|                                                                        |
|:- module(maplist, [maplist/3]).                                        |
|:- meta_predicate maplist(2, ?, ?).                                     |
|                                                                        |

|%%      maplist(:Goal, +List1, ?List2)                                  |
|%                                                                       |
|%       True if Goal can successfully be applied to all                 |
|%       successive pairs of elements from List1 and List2.              |
|                                                                        |
|maplist(Goal, L1, L2) :-                                                |
|        maplist_(L1, L2, Goal).                                         |
|                                                                        |

|maplist_([], [], _).                                                    |
|maplist_([H0|T0], [H|T], Goal) :-                                       |
|        call(Goal, H0, H),                                              |
||_______maplist_(T0,_T,_Goal)._________________________________________ ||


mmeettaa__pprreeddiiccaattee _+_H_e_a_d_, _._._.
    Define  the predicates referenced  by the comma-separated list  _H_e_a_d
    as  _m_e_t_a_-_p_r_e_d_i_c_a_t_e_s.  Each argument of each head is a  _m_e_t_a _a_r_g_u_m_e_n_t
    _s_p_e_c_i_f_i_e_r.  Defined  specifiers are given below.  Only 0..9, : and ^
    are interpreted; the mode declarations +, -  and ? are ignored.

    00....99
         The argument is  a term that is  used to reference a  predicate
         with N  more  arguments than  the given  argument  term.   For
         example:  call(0) or maplist(1, +).

    :
         The argument is  module-sensitive, but does not directly  refer
         to a predicate.  For example:  consult(:).

    -
         The argument is not module-sensitive and unbound on entry.

    ?
         The argument is not  module-sensitive and the mode is  unspeci-
         fied.

    *
         The argument is not  module-sensitive and the mode is  unspeci-
         fied.  The specification * is equivalent to ?.   It is accepted
         for compatibility reasons.   The predicate predicate_property/2
         reports arguments declared using * with ?.

    +
         The argument is  not module-sensitive and bound (i.e.,  nonvar)
         on entry.

    ^
         This extension is used to denote the  possibly ^-annotated goal
         of  setof/3, bagof/3,  aggregate/3  and  aggregate/4.    It  is
         processed similar to `0', but leaving the ^/2 intact.

    //
         The argument is a DCG body.  See phrase/3.

    Each  argument that is module-sensitive (i.e., marked 0..9, :  or ^)
    is  qualified with the  context module  of the caller  if it is  not
    already qualified.   The implementation ensures that the argument is
    passed  as <_m_o_d_u_l_e>:<_t_e_r_m>,  where <_m_o_d_u_l_e>  is an  atom denoting  the
    name  of a  module and  <_t_e_r_m> itself  is not a  :/2 term  where the
    first  argument is an  atom.   Below is a  simple declaration and  a
    number of queries.

    ____________________________________________________________________|                                                                    |

    | :- meta_predicate                                                  |
    |         meta(0, +).                                                |
    |                                                                    |
    | meta(Module:Term, _Arg) :-                                         |
    ||________format('Module=~w,_Term_=_~q~n',_[Module,_Term])._________ ||

    ____________________________________________________________________|                                                                    |
    | ?- meta(test, x).                                                  |
    | Module=user, Term = test                                           |

    | ?- meta(m1:test, x).                                               |
    | Module=m1, Term = test                                             |
    | ?- m2:meta(test, x).                                               |
    | Module=m2, Term = test                                             |
    | ?- m1:meta(m2:test, x).                                            |
    | Module=m2, Term = test                                             |
    | ?- meta(m1:m2:test, x).                                            |

    | Module=m2, Term = test                                             |
    | ?- meta(m1:42:test, x).                                            |
    ||Module=42,_Term_=_test____________________________________________ ||

    The   meta_predicate/1  declaration   is   the  portable   mechanism
    for  defining   meta-predicates  and  replaces  the  old  SWI-Prolog
    specific   mechanism   provided   by   the   deprecated   predicates
    module_transparent/1, context_module/1 and strip_module/3.  See also
    section 6.15.


66..55 OOvveerrrruulliinngg MMoodduullee BBoouunnddaarriieess

The module system described so far is sufficient  to distribute programs
over multiple  modules.   There are,  however, cases  in which we  would
like to be able to overrule this schema and  explicitly call a predicate
in  some module  or assert  explicitly into  some module.    Calling  in
a  particular  module  is useful  for  debugging  from  the  user's  top
level  or to  access  multiple  implementations of  the  same  interface
that reside  in multiple  modules.   Accessing the  same interface  from
multiple modules cannot be achieved using importing  because importing a
predicate with  the same name  and arity from two  modules results in  a
name conflict.   Asserting in a different  module can be used to  create
models dynamically in a new module.  See section 6.12.

Direct addressing  of modules is  achieved using a  :/2 explicitly in  a
program and  relies on the module  qualification mechanism described  in
section 6.4.  Here are a few examples:

________________________________________________________________________|                                                                        |
|?- assert(world:done).   % asserts done/0 into module world             |

|?- world:asserta(done).  % the same                                     |
|?-|world:done.___________%_calls_done/0_in_module_world________________ |  |

Note  that the  second  example  is the  same  due  to the  Prolog  flag
colon_sets_calling_context.   The  system predicate  asserta/1 is  called
in the  module world,  which is possible  because system predicates  are
_v_i_s_i_b_l_e  in all  modules.   At  the same  time, the  _c_a_l_l_i_n_g _c_o_n_t_e_x_t  is
set to  world.   Because meta arguments are  qualified with the  calling
context, the resulting call is the same as the first example.


66..55..11 EExxpplliicciitt mmaanniippuullaattiioonn ooff tthhee ccaalllliinngg ccoonntteexxtt

Quintus'  derived  module   systems  have  no  means  to  separate   the
lookup module  (for finding  predicates) from the  calling context  (for
qualifying meta  arguments).  Some  other Prolog implementations  (e.g.,
ECLiPSe  and IF/Proloog)  distinguish these  operations,  using @/2  for
setting the calling context of a goal.  This  is provided by SWI-Prolog,
currently mainly to support compatibility layers.


@@((_:_G_o_a_l_, _+_M_o_d_u_l_e))
    Execute  _G_o_a_l,  setting the  calling  context to  _M_o_d_u_l_e.    Setting
    the   calling  context  affects  meta-predicates,  for   which  meta
    arguments  are  qualified  with _M_o_d_u_l_e  and  transparent  predicates
    (see  module_transparent/1).    It  has  no implications  for  other
    predicates.

    For   example,   the  code  asserta(done)@world   is  the  same   as
    asserta(world:done).   Unlike  in world:asserta(done), asserta/1  is
    resolved  in the current module rather than the module world.   This
    makes  no difference for system predicates, but usually does  make a
    difference for user predicates.

    Not that SWI-Prolog does  not define @ as an operator.  Some systems
    define this construct using op(900, xfx, @).


66..66 IInntteerraaccttiinngg wwiitthh mmoodduulleess ffrroomm tthhee ttoopp lleevveell

Debugging  often requires  interaction with  predicates  that reside  in
modules:   running them,  setting spy  points on them,  etc.   This  can
be achieved using  the <_m_o_d_u_l_e>:<_t_e_r_m> construct explicitly  as described
above.     In  SWI-Prolog,  you  may   also  wish  to  omit  the  module
qualification.   Setting a spy point  (spy/1) on a plain predicate  sets
a spy  point on any  predicate with that  name in any  module.   Editing
(edit/1)  or calling  an  unqualified  predicate invokes  the  DWIM  (Do
What I Mean)  mechanism, which generally suggests the  correct qualified
query.

Mainly for compatibility, we provide module/1 to switch  the module with
which the interactive top level interacts:


mmoodduullee((_+_M_o_d_u_l_e))
    The  call module(_M_o_d_u_l_e) may be  used to switch the default  working
    module  for the interactive top level  (see prolog/0).  This may  be
    used  when debugging a module.  The example below lists  the clauses
    of file_of_label/2 in the module tex.

    ____________________________________________________________________|                                                                    |
    | 1 ?- module(tex).                                                  |
    | true.                                                              |
    | tex: 2 ?- listing(file_of_label/2).                                |

    ||..._______________________________________________________________ ||


66..77 CCoommppoossiinngg mmoodduulleess ffrroomm ootthheerr mmoodduulleess

The  predicates in  this  section are  intended  to create  new  modules
from  the content  of other  modules.   Below  is an  example to  define
a  _c_o_m_p_o_s_i_t_e module.    The  example exports  all public  predicates  of
module_1, module_2 and  module_3, pred/1  from module_4, all  predicates
from module_5 except do_not_use/1 and all predicates from module_6 while
renaming pred/1 into mypred/1.

________________________________________________________________________|                                                                        |
|:- module(my_composite, []).                                            |

|:- reexport([ module_1,                                                 |
|              module_2,                                                 |
|              module_3                                                  |
|            ]).                                                         |
|:- reexport(module_4, [ pred/1 ]).                                      |
|:- reexport(module_5, except([do_not_use/1])).                          |
|:-|reexport(module_6,_except([pred/1_as_mypred]))._____________________ |  |


rreeeexxppoorrtt((_+_F_i_l_e_s))
    Load  and  import  predicates  as  use_module/1  and  re-export  all
    imported  predicates.   The reexport  declarations must  immediately
    follow the module declaration.


rreeeexxppoorrtt((_+_F_i_l_e_, _+_I_m_p_o_r_t))
    Import  from   _F_i_l_e  as  use_module/2 and   re-export  the  imported
    predicates.   The reexport declarations must immediately  follow the
    module declaration.


66..88 OOppeerraattoorrss aanndd mmoodduulleess

Operators  (section  4.24) are  local  to  modules,  where  the  initial
table  behaves  as   if  it  is  copied   from  the  module  user   (see
section 6.10).    A specific operator  can be  disabled inside a  module
using :- op(0, Type, Name).   Inheritance from  the public table can  be
restored using :- op(-1, Type, Name).

In addition to  using the op/3 directive,  operators can be declared  in
the  module/2 directive  as shown  below.    Such operator  declarations
are  visible inside  the  module,  and  importing such  a  module  makes
the operators  visible in  the target  module.   Exporting operators  is
typically used by modules that implement sub-languages such  as chr (see
chapter 8).  The example below is copied from the library clpfd.

________________________________________________________________________|                                                                        |
|:- module(clpfd,                                                        |

|          [ op(760, yfx, #<==>),                                        |
|            op(750, xfy, #==>),                                         |
|            op(750, yfx, #<==),                                         |
|            op(740, yfx, #\/),                                          |
|            ...                                                         |
|            (#<==>)/2,                                                  |
|            (#==>)/2,                                                   |
|            (#<==)/2,                                                   |

|            (#\/)/2,                                                    |
|            ...                                                         |
||_________]).__________________________________________________________ ||


66..99 DDyynnaammiicc iimmppoorrttiinngg uussiinngg iimmppoorrtt mmoodduulleess

Until now  we discussed the  public module interface  that is, at  least
to some  extent, portable between  Prolog implementations with a  module
system that  is derived  from Quintus  Prolog.   The  remainder of  this
chapter describes the underlying mechanisms that can be  used to emulate
other module systems or implement other code-reuse mechanisms.

In  addition to  built-in predicates,  imported  predicates and  locally
defined predicates,  SWI-Prolog modules  can also  call predicates  from
its _i_m_p_o_r_t _m_o_d_u_l_e_s.   Each module has a (possibly empty) list  of import
modules.   In the  default setup,  each new module  has a single  import
module, which  is user for  all normal user modules  and system for  all
system  library modules.    Module user  imports from  system where  all
built-in predicates  reside.   These  special modules  are described  in
more detail in section 6.10.

The list  of import  modules can  be manipulated and  queried using  the
following predicates, as well as using set_module/1.


iimmppoorrtt__mmoodduullee((_+_M_o_d_u_l_e_, _-_I_m_p_o_r_t))                                 _[_n_o_n_d_e_t_]
    True  if  _M_o_d_u_l_e   inherits  directly  from  _I_m_p_o_r_t.     All  normal
    modules  only import  from user,  which imports  from system.    The
    predicates  add_import_module/3  and delete_import_module/2  can  be
    used to manipulate the import list.  See also default_module/2.


ddeeffaauulltt__mmoodduullee((_+_M_o_d_u_l_e_, _-_D_e_f_a_u_l_t))                                _[_m_u_l_t_i_]
    True  if predicates and operators in _D_e_f_a_u_l_t are visible  in _M_o_d_u_l_e.
    Modules  are returned in the  same search order used for  predicates
    and  operators.   That  is, _D_e_f_a_u_l_t  is first  unified with  _M_o_d_u_l_e,
    followed by the depth-first transitive closure of import_module/2.


aadddd__iimmppoorrtt__mmoodduullee((_+_M_o_d_u_l_e_, _+_I_m_p_o_r_t_, _+_S_t_a_r_t_O_r_E_n_d))
    If  _I_m_p_o_r_t is not  already an  import module for  _M_o_d_u_l_e, add it  to
    this  list at the start  or end depending on  _S_t_a_r_t_O_r_E_n_d.  See  also
    import_module/2 and delete_import_module/2.


ddeelleettee__iimmppoorrtt__mmoodduullee((_+_M_o_d_u_l_e_, _+_I_m_p_o_r_t))
    Delete  _I_m_p_o_r_t from the  list of import modules  for _M_o_d_u_l_e.   Fails
    silently if _I_m_p_o_r_t is not in the list.

One usage  scenario of import modules  is to define  a module that is  a
copy of another,  but where one or  more predicates have an  alternative
definition.


66..1100 RReesseerrvveedd MMoodduulleess aanndd uussiinngg tthhee ``uusseerr'' mmoodduullee

As  mentioned above,  SWI-Prolog  contains two  special  modules.    The
first one  is the  module system.    This module  contains all  built-in
predicates.   Module system has  no import module.   The second  special
module is the module user.  This module forms  the initial working space
of the user.   Initially it is empty.  The import module of  module user
is system, making all built-in predicates available.

All  other modules  import from  the module  user.    This implies  they
can use all  predicates imported into user without explicitly  importing
them.   If an application loads all  modules from the user module  using
use_module/1, one achieves a  scoping system similar to the  C-language,
where  every module  can  access  all exported  predicates  without  any
special precautions.


66..1111 AAnn aalltteerrnnaattiivvee iimmppoorrtt//eexxppoorrtt iinntteerrffaaccee

The use_module/1 predicate  from section 6.3  defines import and  export
relations based  on the  filename from  which a module  is loaded.    If
modules are created differently, such as by asserting  predicates into a
new module as described in section 6.12, this  interface cannot be used.
The interface  below provides  for import/export from  modules that  are
not created using a module file.


eexxppoorrtt((_+_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_, _._._.))
    Add  predicates to  the public  list of the  context module.    This
    implies  the predicate will be imported into another module  if this
    module is  imported with use_module/[1,2].   Note that predicates are
    normally  exported using the directive module/2.  export/1  is meant
    to handle export from dynamically created modules.


iimmppoorrtt((_+_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_, _._._.))
    Import  predicates   _P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r  into  the  current  context
    module.    _P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r must specify  the source module  using
    the  <_m_o_d_u_l_e>:<_p_i>construct.    Note  that predicates  are  normally
    imported  using  one  of  the  directives  use_module/[1,2].     The
    import/1 alternative is  meant for handling imports into dynamically
    created modules.  See also export/1 and export_list/2.


66..1122 DDyynnaammiicc MMoodduulleess

So  far, we  discussed modules  that were  created by  loading a  module
file.  These modules have been introduced to  facilitate the development
of large applications.   The modules  are fully defined at load-time  of
the application and normally  will not change during execution.   Having
the  notion  of a  set  of  predicates  as a  self-contained  world  can
be  attractive for  other purposes  as well.    For example,  assume  an
application that  can reason about  multiple worlds.   It is  attractive
to store  the data  of a  particular world in  a module,  so we  extract
information from a world simply by invoking goals in this world.

Dynamic modules  can easily  be created.   Any  built-in predicate  that
tries  to locate  a predicate  in  a specific  module will  create  this
module as a side-effect if it did not yet exist.  For example:

________________________________________________________________________|                                                                        |
|?- assert(world_a:consistent),                                          |

||__set_prolog_flag(world_a:unknown,_fail)._____________________________ ||

These  calls  create  a  module  called  `world_a'  and  make  the  call
`world_a:consistent'  succeed.   Undefined predicates  will not raise  an
exception for this module (see unknown).

Import  and export  from a  dynamically created  world  can be  achieved
using  import/1 and  export/1  or by  specifying  the import  module  as
described in section 6.9.

________________________________________________________________________|                                                                        |

|?- world_b:export(solve/2).          % exports solve/2 from world_b     |
|?-|world_c:import(world_b:solve/2).__%_and_import_it_to_world_c________ |  |


66..1133 TTrraannssppaarreenntt pprreeddiiccaatteess::  ddeeffiinniittiioonn aanndd ccoonntteexxtt mmoodduullee

_T_h_e  _`_m_o_d_u_l_e_-_t_r_a_n_s_p_a_r_e_n_t_'  _m_e_c_h_a_n_i_s_m  _i_s  _s_t_i_l_l  _u_n_d_e_r_l_y_i_n_g  _t_h_e  _a_c_t_u_a_l
_i_m_p_l_e_m_e_n_t_a_t_i_o_n_.  _D_i_r_e_c_t _u_s_a_g_e _b_y _p_r_o_g_r_a_m_m_e_r_s _i_s _d_e_p_r_e_c_a_t_e_d_.   _P_l_e_a_s_e _u_s_e
meta_predicate/1 _t_o _d_e_a_l _w_i_t_h _m_e_t_a_-_p_r_e_d_i_c_a_t_e_s_.

The   qualification   of   module-sensitive   arguments   described   in
section  6.4 is  realised  using _t_r_a_n_s_p_a_r_e_n_t  predicates.    It  is  now
deprecated  to use  this  mechanism directly.    However,  studying  the
underlying mechanism helps to understand SWI-Prolog's modules.   In some
respect, the transparent mechanism is more  powerful than meta-predicate
declarations.

Each  predicate  of  the  program  is  assigned  a  module,  called  its
_d_e_f_i_n_i_t_i_o_n _m_o_d_u_l_e.   The definition module of a predicate is  always the
module in which the predicate was originally defined.   Each active goal
in the Prolog system has a _c_o_n_t_e_x_t _m_o_d_u_l_e assigned to it.

The context  module is used to  find predicates for a  Prolog term.   By
default, the  context module is the  definition module of the  predicate
running the  goal.   For transparent  predicates, however,  this is  the
context module  of the  goal inherited  from the  parent goal.    Below,
we implement  maplist/3 using the  transparent mechanism.   The code  of
maplist/3 and maplist_/3 is the same as in section 6.4, but  now we must
declare both the main  predicate and the helper as transparent  to avoid
changing the context module when calling the helper.

________________________________________________________________________|                                                                        |
|:- module(maplist, maplist/3).                                          |

|                                                                        |
|:- module_transparent                                                   |
|        maplist/3,                                                      |
|        maplist_/3.                                                     |
|                                                                        |
|maplist(Goal, L1, L2) :-                                                |
|        maplist_(L1, L2, G).                                            |
|                                                                        |

|maplist_([], [], _).                                                    |
|maplist_([H0|T0], [H|T], Goal) :-                                       |
|        call(Goal, H0, H),                                              |
||_______maplist_(T0,_T,_Goal)._________________________________________ ||

Note  that   _a_n_y  call   that  translates  terms   into  predicates   is
subject  to  the  transparent  mechanism,  not  just  the  terms  passed
to  module-sensitive  arguments.      For  example,  the   module  below
counts  the  number   of  unique  atoms  returned  as  bindings   for  a
variable.     It   works  as  expected.     If  we  use   the  directive
:- module_transparent count_atom_results/3. instead,   atom_result/2  is
called wrongly  in the  module _c_a_l_l_i_n_g  count_atom_results/3.   This  can
be  solved  using  strip_module/3 to  create  a  qualified  goal  and  a
non-transparent helper predicate that is defined in the same module.

________________________________________________________________________|                                                                        |
|:- module(count_atom_results,                                           |
|          [ count_atom_results/3                                        |

|          ]).                                                           |
|:- meta_predicate count_atom_results(-,0,-).                            |
|                                                                        |
|count_atom_results(A, Goal, Count) :-                                   |
|        setof(A, atom_result(A, Goal), As), !,                          |
|        length(As, Count).                                              |
|count_atom_results(_, _, 0).                                            |

|                                                                        |
|atom_result(Var, Goal) :-                                               |
|        call(Goal),                                                     |
||_______atom(Var)._____________________________________________________ ||

The following predicates support the module-transparent interface:


::-- mmoodduullee__ttrraannssppaarreenntt((_+_P_r_e_d_s))
    _P_r_e_d_s   is  a  comma-separated   list  of  name/arity  pairs   (like
    dynamic/1).     Each  goal associated  with  a  transparent-declared
    predicate will inherit the _c_o_n_t_e_x_t _m_o_d_u_l_e from its parent goal.


ccoonntteexxtt__mmoodduullee((_-_M_o_d_u_l_e))
    Unify   _M_o_d_u_l_e  with  the  context  module  of  the   current  goal.
    context_module/1 itself is, of course, transparent.


ssttrriipp__mmoodduullee((_+_T_e_r_m_, _-_M_o_d_u_l_e_, _-_P_l_a_i_n))
    Used in  module-transparent predicates or meta-predicates to extract
    the   referenced  module   and  plain   term.      If   _T_e_r_m  is   a
    module-qualified  term, i.e. of the format _M_o_d_u_l_e:_P_l_a_i_n,  _M_o_d_u_l_e and
    _P_l_a_i_n  are unified to these values.  Otherwise, _P_l_a_i_n is  unified to
    _T_e_r_m and _M_o_d_u_l_e to the context module.


66..1144 MMoodduullee pprrooppeerrttiieess

The following  predicates can  be used  to query the  module system  for
reflexive programming:


ccuurrrreenntt__mmoodduullee((_?_M_o_d_u_l_e))                                         _[_n_o_n_d_e_t_]
    True  if  _M_o_d_u_l_e is  a currently  defined module.    This  predicate
    enumerates  all  modules,  whether loaded  from  a file  or  created
    dynamically.   Note that modules cannot be destroyed in  the current
    version of SWI-Prolog.


mmoodduullee__pprrooppeerrttyy((_?_M_o_d_u_l_e_, _?_P_r_o_p_e_r_t_y))
    True if _P_r_o_p_e_r_t_y is a property of _M_o_d_u_l_e.  Defined properties are:

    ccllaassss((_-_C_l_a_s_s))
         True when _C_l_a_s_s  is the class of  the module.  Defined  classes
         are

         uusseerr
             Default for user-defined modules.

         ssyysstteemm
             Module system and modules from <_h_o_m_e>/boot.

         lliibbrraarryy
             Other modules from the system directories.

         tteemmppoorraarryy
             Module is temporary.

         tteesstt
             Modules that create tests.

         ddeevveellooppmmeenntt
             Modules that only support the development environment.

    ffiillee((_?_F_i_l_e))
         True if _M_o_d_u_l_e was loaded from _F_i_l_e.

    lliinnee__ccoouunntt((_-_L_i_n_e))
         True if _M_o_d_u_l_e was loaded from the N-th line of file.

    eexxppoorrttss((_-_L_i_s_t_O_f_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r_s))
         True  if  _M_o_d_u_l_e exports  the  given  predicates.     Predicate
         indicators  are   in  canonical   form  (i.e.,   always   using
         name/arity  and  never the  DCG  form  name//arity).     Future
         versions  may  also  use  the  DCG  form   and  include  public
         operators.  See also predicate_property/2.

    eexxppoorrtteedd__ooppeerraattoorrss((_-_L_i_s_t_O_f_O_p_e_r_a_t_o_r_s))
         True if  _M_o_d_u_l_e exports  the given  operators.   Each  exported
         operator is represented as a term op(_P_r_i_,_A_s_s_o_c_,_N_a_m_e).

    pprrooggrraamm__ssiizzee((_-_B_y_t_e_s))
         Memory  (in bytes)  used  for  string the  predicates  of  this
         module.     This  figure  includes  the  predicate  header  and
         clauses.   Future versions  might give  a more precise  number,
         including e.g., the clause index tables.

    pprrooggrraamm__ssppaaccee((_-_B_y_t_e_s))
         If  present,  this  number   limits  the  program_size.      See
         set_module/1.


sseett__mmoodduullee((_:_P_r_o_p_e_r_t_y))
    Modify  properties  of  the  module.     Currently,   the  following
    properties may be modified:

    bbaassee((_+_B_a_s_e))
         Set the default import module of the current  module to _M_o_d_u_l_e.
         Typically, _M_o_d_u_l_e is one of user or system.  See section 6.9.

    ccllaassss((_+_C_l_a_s_s))
         Set the class of the module.  See module_property/2.

    pprrooggrraamm__ssppaaccee((_+_B_y_t_e_s))
         Maximum amount of memory  used to store the predicates  defined
         inside  the  module.     Raises  a  permission   error  if  the
         current  usage is  above  the requested  limit.    Setting  the
         limit  to  0  (zero)  removes  the  limit.      An  attempt  to
         assert clauses  that causes  the  limit to  be exceeded  causes
         a resource_error(_p_r_o_g_r_a_m___s_p_a_c_e)  exception.   See assertz/1  and
         module_property/2.


66..1155 CCoommppaattiibbiilliittyy ooff tthhee MMoodduullee SSyysstteemm

The  SWI-Prolog  module  system is  largely  derived  from  the  Quintus
Prolog module system,  which is also adopted  by SICStus, Ciao and  YAP.
Originally,  the mechanism  for defining  meta-predicates in  SWI-Prolog
was  based on  the  module_transparent/1 directive  and  strip_module/3.
Since  5.7.4   it  supports   the  de-facto   standard  meta_predicate/1
directive  for  implementing  meta-predicates,   providing  much  better
compatibility.

The   support  for   the   meta_predicate/1  mechanism,    however,   is
considerably  different.       On  most   systems,  the   _c_a_l_l_e_r  of   a
meta-predicate  is   compiled  differently   to  provide  the   required
<_m_o_d_u_l_e>:<_t_e_r_m> qualification.   This  implies that  the meta-declaration
must  be available  to the  compiler when  compiling code  that calls  a
meta-predicate.  In  practice, this implies that other systems  pose the
following restrictions on meta-predicates:

  o Modules  that provide  meta-predicates for a  module to be  compiled
    must be loaded explicitly by that module.

  o The  meta-predicate directives  of exported  predicates must  follow
    the module/2 directive immediately.

  o After  changing  a  meta-declaration,  all  modules  that  _c_a_l_l  the
    modified predicates need to be recompiled.

In  SWI-Prolog,   meta-predicates  are   also  _m_o_d_u_l_e_-_t_r_a_n_s_p_a_r_e_n_t,   and
qualifying  the module-sensitive  arguments  is  done inside  the  meta-
predicate.    As a  result, the  caller need  not  be aware  that it  is
calling a  meta-predicate and none  of the  above restrictions hold  for
SWI-Prolog.  However, code that aims at portability  must obey the above
rules.

Other differences are listed below.

  o If  a module does not define a predicate, it is searched for  in the
    _i_m_p_o_r_t  _m_o_d_u_l_e_s.  By default, the import module of  any user-defined
    module  is the user module.   In turn, the user module  imports from
    the  module  system that  provides  all built-in  predicates.    The
    auto-import  hierarchy can be changed  using add_import_module/3 and
    delete_import_module/2.

    This  mechanism  can be  used to  realise  a simple  object-oriented
    system or a hierarchical module system.

  o Operator  declarations are local  to a module  and may be  exported.
    In  Quintus and  SICStus all  operators are global.    YAP and  Ciao
    also  use  local operators.    SWI-Prolog  provides global  operator
    declarations  from  within a  module  by explicitly  qualifying  the
    operator  name with the user module.  I.e., operators  are inherited
    from the _i_m_p_o_r_t _m_o_d_u_l_e_s (see above).

    ____________________________________________________________________|                                                                    |
    ||:-_op(precedence,_type,_user:(operatorname))._____________________ ||


CChhaapptteerr 77..  SSPPEECCIIAALL VVAARRIIAABBLLEESS AANNDD CCOORROOUUTTIINNIINNGG

This  chapter  deals  with  extensions  primarily  designed  to  support
constraint logic  programming (CLP).  The low-level attributed  variable
interface defined in section 7.1 is not intended for  the typical Prolog
programmer.    Instead, the  typical Prolog  programmer  should use  the
coroutining predicates and  the various constraint solvers built on  top
of attributed  variables.   CHR (chapter 8)  provides a general  purpose
constraint handling language.

As a  rule of  thumb, constraint  programming reduces  the search  space
by reordering  goals and  joining goals based  on domain  knowledge.   A
typical example  is constraint reasoning  over integer  domains.   Plain
Prolog has no  efficient means to deal  with (integer) X >0  and X <3.
At best  it could translate  X >0 with  uninstantiated X  to between(_1_,
_i_n_f_i_n_i_t_e_,  _X) and  a  similar primitive  for  X< 3.    If  the two  are
combined it has  no choice but to  generate and test over this  infinite
two-dimensional  space.   Instead,  a constraint  system  will _d_e_l_a_y  an
uninstantiated  goal to  X> 0.    If, later,  it  finds a  value for  _X
it will  execute the  test.   If  it finds  X< 3  it will combine  this
knowledge to infer that X  is in 1..2 (see below).  If it never  finds a
concrete value for _X it  can be asked to _l_a_b_e_l _X and produce 1 and  2 on
backtracking.  See section 12.8.

________________________________________________________________________|                                                                        |
|1 ?- [library(clpfd)].                                                  |

|...                                                                     |
|true.                                                                   |
|                                                                        |
|2 ?- X #> 0, X #< 3.                                                    |
|X|in_1..2._____________________________________________________________ | |

Using constraints generally makes your program more _d_e_c_l_a_r_a_t_i_v_e.   There
are some caveats though:

  o Constraints and cuts do  not merge well.  A cut after a goal that is
    delayed prunes the search space before the condition is true.

  o Term-copying    operations   (assert/1,     retract/2,    findall/3,
    copy_term/2,  etc.)      generally  also  copy  constraints.     The
    effect  varies from ok, silent  copying of huge constraint  networks
    to  violations of the  internal consistency of constraint  networks.
    As  a  rule  of thumb,  copying  terms  holding attributes  must  be
    deprecated.


77..11 AAttttrriibbuutteedd vvaarriiaabblleess

_A_t_t_r_i_b_u_t_e_d  _v_a_r_i_a_b_l_e_s  provide  a technique  for  extending  the  Prolog
unification  algorithm  [Holzbaur, 1992]  by  hooking  the   binding  of
attributed variables.   There  is no consensus  in the Prolog  community
on the  exact definition  and interface  to attributed variables.    The
SWI-Prolog interface  is identical to  the one  realised by Bart  Demoen
for hProlog [Demoen, 2002].   This interface is simple and  available on
all Prolog  systems that can  run the Leuven CHR  system (see chapter  8
and the Leuven CHR page).

Binding  an attributed  variable  schedules a  goal  to be  executed  at
the  first possible  opportunity.   In  the  current implementation  the
hooks are  executed immediately  after a successful  unification of  the
clause-head or  successful completion of  a foreign language  (built-in)
predicate.   Each  attribute is  associated to  a module,  and the  hook
(attr_unify_hook/2)  is  executed in  this  module.   The  example  below
realises a very simple and incomplete finite domain reasoner:

________________________________________________________________________|                                                                        |
|:- module(domain,                                                       |

|          [ domain/2                    % Var, ?Domain                  |
|          ]).                                                           |
|:- use_module(library(ordsets)).                                        |
|                                                                        |
|domain(X, Dom) :-                                                       |
|        var(Dom), !,                                                    |
|        get_attr(X, domain, Dom).                                       |
|domain(X, List) :-                                                      |

|        list_to_ord_set(List, Domain),                                  |
|        put_attr(Y, domain, Domain),                                    |
|        X = Y.                                                          |
|                                                                        |
|%       An attributed variable with attribute value Domain has been     |
|%       assigned the value Y                                            |
|                                                                        |

|attr_unify_hook(Domain, Y) :-                                           |
|        (   get_attr(Y, domain, Dom2)                                   |
|        ->  ord_intersection(Domain, Dom2, NewDomain),                  |
|            (   NewDomain == []                                         |
|            ->  fail                                                    |
|            ;   NewDomain = [Value]                                     |
|            ->  Y = Value                                               |
|            ;   put_attr(Y, domain, NewDomain)                          |

|            )                                                           |
|        ;   var(Y)                                                      |
|        ->  put_attr( Y, domain, Domain )                               |
|        ;   ord_memberchk(Y, Domain)                                    |
|        ).                                                              |
|                                                                        |
|%       Translate attributes from this module to residual goals         |

|                                                                        |
|attribute_goals(X) -->                                                  |
|        { get_attr(X, domain, List) },                                  |
||_______[domain(X,_List)]._____________________________________________ ||

Before explaining the code we give some example queries:

     ?- domain(X, [a,b]), X = c                fail
     ?- domain(X, [a,b]), domain(X, [a,c]).    X = a
     ?- domain(X, [a,b,c]), domain(X, [a,c]).  domain(X, [a, c])

The  predicate  domain/2  fetches  (first  clause)  or  assigns  (second
clause)  the  variable a  _d_o_m_a_i_n,  a  set  of values  the  variable  can
be  unified with.    In  the second  clause, domain/2  first  associates
the  domain with  a  fresh  variable (Y)  and  then  unifies X  to  this
variable  to deal  with the  possibility that  X already  has a  domain.
The predicate  attr_unify_hook/2 (see below)  is a hook  called after  a
variable with a  domain is assigned a value.   In the simple case  where
the variable is bound to a concrete value, we  simply check whether this
value is  in the  domain.   Otherwise we  take the  intersection of  the
domains and  either fail if the  intersection is empty (first  example),
assign  the  value if  there  is  only  one value  in  the  intersection
(second example),  or assign the intersection as  the new domain of  the
variable (third  example).   The  nonterminal attribute_goals/3 is  used
to  translate remaining  attributes to  user-readable goals  that,  when
executed, reinstate these attributes.


77..11..11 AAttttrriibbuuttee mmaanniippuullaattiioonn pprreeddiiccaatteess


aattttvvaarr((_@_T_e_r_m))
    Succeeds  if _T_e_r_m is an attributed  variable.  Note that var/1  also
    succeeds on attributed  variables.  Attributed variables are created
    with put_attr/3.


ppuutt__aattttrr((_+_V_a_r_, _+_M_o_d_u_l_e_, _+_V_a_l_u_e))
    If  _V_a_r is  a variable  or attributed  variable, set  the value  for
    the  attribute named _M_o_d_u_l_e  to _V_a_l_u_e.   If  an attribute with  this
    name  is already  associated with  _V_a_r, the old  value is  replaced.
    Backtracking  will  restore the  old value  (i.e.,  an attribute  is
    a  mutable  term;  see also  setarg/3).    This predicate  raises  a
    representation  error if _V_a_r is not  a variable and a type error  if
    _M_o_d_u_l_e is not an atom.


ggeett__aattttrr((_+_V_a_r_, _+_M_o_d_u_l_e_, _-_V_a_l_u_e))
    Request  the  current _v_a_l_u_e  for the  attribute named  _M_o_d_u_l_e.    If
    _V_a_r  is not  an attributed variable  or the  named attribute is  not
    associated  to _V_a_r this predicate fails silently.  If _M_o_d_u_l_e  is not
    an atom, a type error is raised.


ddeell__aattttrr((_+_V_a_r_, _+_M_o_d_u_l_e))
    Delete  the named attribute.    If _V_a_r loses  its last attribute  it
    is  transformed back into a traditional Prolog variable.   If _M_o_d_u_l_e
    is  not an atom, a  type error is raised.   In all other cases  this
    predicate succeeds regardless  of whether or not the named attribute
    is present.


77..11..22 AAttttrriibbuutteedd vvaarriiaabbllee hhooookkss

Attribute  names  are linked  to  modules.    This  means  that  certain
operations  on attributed  variables cause  _h_o_o_k_s to  be  called in  the
module whose name matches the attribute name.


aattttrr__uunniiffyy__hhooookk((_+_A_t_t_V_a_l_u_e_, _+_V_a_r_V_a_l_u_e))
    A  hook that must  be defined in the  module to which an  attributed
    variable  refers.   It is called  _a_f_t_e_r the attributed variable  has
    been  unified  with  a non-var  term,  possibly  another  attributed
    variable.    _A_t_t_V_a_l_u_e is the  attribute that  was associated to  the
    variable  in  this module  and  _V_a_r_V_a_l_u_e is  the  new value  of  the
    variable.     Normally this  predicate  fails  to veto  binding  the
    variable to _V_a_r_V_a_l_u_e,  forcing backtracking to undo the binding.  If
    _V_a_r_V_a_l_u_e is another  attributed variable the hook often combines the
    two  attributes and associates the combined attribute  with _V_a_r_V_a_l_u_e
    using put_attr/3.


aattttrr__ppoorrttrraayy__hhooookk((_+_A_t_t_V_a_l_u_e_, _+_V_a_r))                          _[_d_e_p_r_e_c_a_t_e_d_]
    Called by  write_term/2and friends for each  attribute if the option
    attributes(_p_o_r_t_r_a_y)  is  in  effect.    If  the  hook  succeeds  the
    attribute is considered  printed.  Otherwise Module = ... is printed
    to  indicate  the  existence of  a  variable.    New  infrastructure
    dealing  with  communicating  attribute  values  must  be  based  on
    copy_term/3 and its hook attribute_goals//1.


aattttrriibbuuttee__ggooaallss((_+_V_a_r)) //
    This  nonterminal,  if  it  is  defined in  a  module,  is  used  by
    copy_term/3 to project attributes of that  module to residual goals.
    It  is also used  by the  top level to  obtain residual goals  after
    executing a query.


pprroojjeecctt__aattttrriibbuutteess((_A))
    hook  that can be defined in  each module to project constraints  on
    newly  introduced variables back to the query variables.   _Q_u_e_r_y_V_a_r_s
    is  the list of  variables occurring in  the query and  _R_e_s_i_d_u_a_l_V_a_r_s
    is  a  list of  variables  that have  attributes  attached.    There
    may  be  variables   that  occur  in  both  lists.     If  possible,
    project_attributes/2  should  change  the  attributes  so  that  all
    constraints  are  expressed as  residual goals  that  refer only  to
    _Q_u_e_r_y_V_a_r_s, while other variables are existentially quantified.


77..11..33 OOppeerraattiioonnss oonn tteerrmmss wwiitthh aattttrriibbuutteedd vvaarriiaabblleess


ccooppyy__tteerrmm((_+_T_e_r_m_, _-_C_o_p_y_, _-_G_s))
    Create  a  regular  term  _C_o_p_y  as  a  copy  of  _T_e_r_m  (without  any
    attributes), and a  list _G_s of goals that represents the attributes.
    The  goal maplist(call,_G_s) recreates the  attributes for _C_o_p_y.   The
    nonterminal  attribute_goals//1,  as  defined  in  the  modules  the
    attributes  stem from,  is used  to convert attributes  to lists  of
    goals.

    This  building block  is used  by the  top level  to report  pending
    attributes  in  a   portable  and  understandable  fashion.     This
    predicate  is  the preferred  way to  reason  about and  communicate
    terms with constraints.


ccooppyy__tteerrmm__nnaatt((_+_T_e_r_m_, _-_C_o_p_y))
    As  copy_term/2.   Attributes, however,  are _n_o_t copied but  replaced
    by fresh variables.


tteerrmm__aattttvvaarrss((_+_T_e_r_m_, _-_A_t_t_V_a_r_s))
    _A_t_t_V_a_r_s  is  a   list  of  all  attributed  variables  in  _T_e_r_m  and
    its   attributes.     That  is,   term_attvars/2  works  recursively
    through  attributes.    This  predicate is  cycle-safe.    The  goal
    term_attvars(_T_e_r_m_,  _[_])  in  an  efficient test  that  _T_e_r_m  has  _n_o
    attributes; scanning the  term is aborted after the first attributed
    variable is found.


77..11..44 SSppeecciiaall ppuurrppoossee pprreeddiiccaatteess ffoorr aattttrriibbuutteess

Normal user code should deal with put_attr/3, get_attr/3 and del_attr/2.
The routines in this  section fetch or set the entire attribute  list of
a variable.  Use of these predicates is anticipated  to be restricted to
printing and other special purpose operations.


ggeett__aattttrrss((_+_V_a_r_, _-_A_t_t_r_i_b_u_t_e_s))
    Get  all  attributes of  _V_a_r.   _A_t_t_r_i_b_u_t_e_s  is a  term  of the  form
    att(_M_o_d_u_l_e_,  _V_a_l_u_e_, _M_o_r_e_A_t_t_r_i_b_u_t_e_s), where _M_o_r_e_A_t_t_r_i_b_u_t_e_s is  [] for
    the last attribute.


ppuutt__aattttrrss((_+_V_a_r_, _-_A_t_t_r_i_b_u_t_e_s))
    Set  all attributes of  _V_a_r.  See  get_attrs/2 for a description  of
    _A_t_t_r_i_b_u_t_e_s.


ddeell__aattttrrss((_+_V_a_r))
    If  _V_a_r is an attributed  variable, delete _a_l_l  its attributes.   In
    all other cases, this predicate succeeds without side-effects.


77..22 CCoorroouuttiinniinngg

Coroutining  deals with  having  Prolog  goals scheduled  for  execution
as  soon  as  some  conditions are  fulfilled.     In  Prolog  the  most
commonly used  condition is the instantiation  (binding) of a  variable.
Scheduling  a goal  to execute  immediately after  a  variable is  bound
can be used  to avoid instantiation errors for some  built-in predicates
(e.g. arithmetic),  do work _l_a_z_y, prevent  the binding of a variable  to
a particular  value, etc.   Using freeze/2 for  example we can define  a
variable that can only be assigned an even number:

________________________________________________________________________|                                                                        |
|?- freeze(X, X mod 2 =:= 0), X = 3                                      |

|                                                                        |
|No|____________________________________________________________________ |  |


ffrreeeezzee((_+_V_a_r_, _:_G_o_a_l))
    Delay  the execution  of  _G_o_a_l until  _V_a_r is  bound (i.e.  is not  a
    variable  or  attributed  variable).    If  _V_a_r is  bound  on  entry
    freeze/2  is  equivalent  to call/1.     The freeze/2  predicate  is
    realised  using an  attributed variable associated  with the  module
    freeze.   Use frozen(Var, Goal) to find out whether and  which goals
    are delayed on _V_a_r.


ffrroozzeenn((_@_V_a_r_, _-_G_o_a_l))
    Unify  _G_o_a_l with the  goal or conjunction  of goals delayed on  _V_a_r.
    If no goals are frozen on _V_a_r, _G_o_a_l is unified to true.


wwhheenn((_@_C_o_n_d_i_t_i_o_n_, _:_G_o_a_l))
    Execute  _G_o_a_l when  _C_o_n_d_i_t_i_o_n becomes  true.   _C_o_n_d_i_t_i_o_n  is one  of
    ?=(_X_, _Y), nonvar(_X), ground(_X),  ,(_C_o_n_d_1_, _C_o_n_d_2) or ;(_C_o_n_d_1_, _C_o_n_d_2).
    See  also freeze/2  and dif/2.    The implementation  can deal  with
    cyclic terms in _X and _Y.

    The   when/2  predicate  is  realised  using   attributed  variables
    associated  with the module  when.   It is  defined in the  autoload
    library when.


ddiiff((_@_A_, _@_B))
    The  dif/2 predicate  provides  a constraint  stating that  _A and  _B
    are  different terms.   If _A and _B  can never unify, dif/2  succeeds
    deterministically.   If _A and _B are identical it  fails immediately,
    and  finally, if _A and _B  can unify, goals are delayed  that prevent
    _A  and  _B to  become  equal.    The dif/2  predicate behaves  as  if
    defined  by  dif(X, Y) :- when(?=(X, Y), X \== Y).  See  also  ?=/2.
    The implementation can deal with cyclic terms.

    The   dif/2  predicate  is   realised  using  attributed   variables
    associated  with the  module dif.   It  is defined  in the  autoload
    library dif.


ccaallll__rreessiidduuee__vvaarrss((_:_G_o_a_l_, _-_V_a_r_s))
    Find residual attributed  variables left by _G_o_a_l.  This predicate is
    intended  for debugging programs  using coroutining or  constraints.
    Consider  a  program  that  poses  contradicting  constraints  on  a
    variable.   Such programs should fail, but sometimes succeed because
    the  constraint  solver is  too weak  to  detect the  contradiction.
    Ideally,  delayed goals and constraints are all executed at  the end
    of  the computation.   The meta  predicate call_residue_vars/2 finds
    variables  that are  given attribute variables  or whose  attributes
    are  modified by _G_o_a_l, regardless of whether or not  these variables
    are reachable from the arguments of _G_o_a_l..


77..33 GGlloobbaall vvaarriiaabblleess

Global  variables are  associations  between  names (atoms)  and  terms.
They differ in  various ways from storing information using  assert/1 or
recorda/3.

  o The  value lives on  the Prolog (global) stack.   This implies  that
    lookup  time  is independent  of the  size of  the term.    This  is
    particularly  interesting for large  data structures such as  parsed
    XML documents or the CHR global constraint store.

  o They   support  both   global  assignment   using  nb_setval/2   and
    backtrackable assignment using b_setval/2.

  o Only  one value (which can be an arbitrary complex Prolog  term) can
    be associated to a variable at a time.

  o Their  value cannot be  shared among threads.   Each thread has  its
    own namespace and values for global variables.

  o Currently  global variables are  scoped globally.   We may  consider
    module scoping in future versions.

Both  b_setval/2 and nb_setval/2  implicitly create  a  variable if  the
referenced name does not already refer to a variable.

Global  variables  may  be initialised  from  directives  to  make  them
available  during the  program  lifetime,  but some  considerations  are
necessary  for  saved  states  and  threads.     Saved   states  do  not
store global  variables, which  implies they  have to  be declared  with
initialization/1 to recreate them  after loading the saved state.   Each
thread  has its  own set  of global  variables, starting  with an  empty
set.  Using thread_initialization/1 to define a global  variable it will
be defined,  restored after reloading a saved  state and created in  all
threads  that are  created  _a_f_t_e_r the  registration.    Finally,  global
variables can be initialised using the exception hook exception/3.   The
latter technique is used by CHR (see chapter 8).


bb__sseettvvaall((_+_N_a_m_e_, _+_V_a_l_u_e))
    Associate  the  term  _V_a_l_u_e  with  the  atom  _N_a_m_e  or  replace  the
    currently  associated value  with _V_a_l_u_e.    If _N_a_m_e  does not  refer
    to  an existing global  variable, a variable  with initial value  []
    is  created (the  empty list).   On  backtracking the assignment  is
    reversed.


bb__ggeettvvaall((_+_N_a_m_e_, _-_V_a_l_u_e))
    Get the value  associated with the global variable _N_a_m_e and unify it
    with _V_a_l_u_e.   Note that this unification may further instantiate the
    value  of the global  variable.  If  this is undesirable the  normal
    precautions  (double negation or  copy_term/2) must be  taken.   The
    b_getval/2 predicate generates errors if _N_a_m_e is not  an atom or the
    requested variable does not exist.


nnbb__sseettvvaall((_+_N_a_m_e_, _+_V_a_l_u_e))
    Associates  a copy of  _V_a_l_u_e created with duplicate_term/2 with  the
    atom  _N_a_m_e.   Note that  this can be  used to  set an initial  value
    other than [] prior to backtrackable assignment.


nnbb__ggeettvvaall((_+_N_a_m_e_, _-_V_a_l_u_e))
    The  nb_getval/2 predicate is  a synonym for  b_getval/2,  introduced
    for  compatibility  and  symmetry.    As  most  scenarios  will  use
    a   particular  global   variable  using  either   non-backtrackable
    or   backtrackable  assignment,   using  nb_getval/2  can  be   used
    to  document  that  the  variable  is  non-backtrackable.     Raises
    existence_error(_v_a_r_i_a_b_l_e_, _N_a_m_e) if the variable does not exist.


nnbb__lliinnkkvvaall((_+_N_a_m_e_, _+_V_a_l_u_e))
    Associates  the term _V_a_l_u_e  with the atom  _N_a_m_e without copying  it.
    This  is a  fast special-purpose  variation of  nb_setval/2 intended
    for  expert  users   only  because  the  semantics  on  backtracking
    to  a  point  before  creating  the  link  are  poorly  defined  for
    compound  terms.    The  principal term  is always  left  untouched,
    but  backtracking behaviour on arguments  is undone if the  original
    assignment  was  _t_r_a_i_l_e_d and  left  alone otherwise,  which  implies
    that  the history  that created  the term affects  the behaviour  on
    backtracking.  Consider the following example:

    ____________________________________________________________________|                                                                    |
    | demo_nb_linkval :-                                                 |

    |         T = nice(N),                                               |
    |         (   N = world,                                             |
    |             nb_linkval(myvar, T),                                  |
    |             fail                                                   |
    |         ;   nb_getval(myvar, V),                                   |
    |             writeln(V)                                             |
    ||________).________________________________________________________ ||


nnbb__ccuurrrreenntt((_?_N_a_m_e_, _?_V_a_l_u_e))
    Enumerate  all defined  variables with their  value.   The order  of
    enumeration is  undefined.  Note that nb_current/2 can be used as an
    alternative  for nb_getval/2 to request the value of a  variable and
    fail silently if the variable does not exists.


nnbb__ddeelleettee((_+_N_a_m_e))
    Delete  the  named global  variable.   Succeeds  also  if the  named
    variable does not exist.


77..33..11 CCoommppaattiibbiilliittyy ooff SSWWII--PPrroolloogg GGlloobbaall VVaarriiaabblleess

Global variables have been introduced by  various Prolog implementations
recently.  The implementation of them in SWI-Prolog  is based on hProlog
by  Bart Demoen.    In  discussion with  Bart it  was  decided that  the
semantics of  hProlog nb_setval/2, which is equivalent  to nb_linkval/2,
is  not  acceptable  for  normal  Prolog  users  as   the  behaviour  is
influenced  by how  built-in predicates  that  construct terms  (read/1,
=../2, etc.)  are implemented.

GNU-Prolog provides  a rich set of  global variables, including  arrays.
Arrays  can be  implemented  easily in  SWI-Prolog using  functor/3  and
setarg/3 due to the unrestricted arity of compound terms.


CChhaapptteerr 88..  CCHHRR:: CCOONNSSTTRRAAIINNTT HHAANNDDLLIINNGG RRUULLEESS

This chapter is written by Tom Schrijvers, K.U.  Leuven, and adjustments
by Jan Wielemaker.

The CHR system of SWI-Prolog is the _K_._U_._L_e_u_v_e_n _C_H_R _s_y_s_t_e_m.   The runtime
environment is  written by Christian Holzbaur  and Tom Schrijvers  while
the compiler  is written by  Tom Schrijvers.   Both are integrated  with
SWI-Prolog  and licensed  under  compatible conditions  with  permission
from the authors.

The main reference for the K.U.Leuven CHR system is:

  o T.   Schrijvers,  and   B.  Demoen,   _T_h_e  _K_._U_._L_e_u_v_e_n  _C_H_R   _S_y_s_t_e_m_:
    _I_m_p_l_e_m_e_n_t_a_t_i_o_n   _a_n_d  _A_p_p_l_i_c_a_t_i_o_n,  First  Workshop   on  Constraint
    Handling Rules:   Selected Contributions (Fr"uhwirth, T. and Meister,
    M., eds.), pp.  1--5, 2004.

On the K.U.Leuven CHR website (http://dtai.cs.kuleuven.be/CHR/)  you can
find more related papers, references and example programs.


88..11 IInnttrroodduuccttiioonn

Constraint  Handling  Rules  (CHR)  is  a   committed-choice  rule-based
language embedded  in Prolog.    It is designed  for writing  constraint
solvers and  is particularly  useful for providing  application-specific
constraints.   It  has been  used in  many kinds  of applications,  like
scheduling,  model checking, abduction,  and type  checking, among  many
others.

CHR has  previously been implemented in  other Prolog systems  (SICStus,
Eclipse,  Yap), Haskell  and Java.    This CHR  system is  based on  the
compilation scheme and runtime environment of CHR in SICStus.

In this documentation  we restrict ourselves to giving a  short overview
of  CHR  in general  and  mainly  focus  on elements  specific  to  this
implementation.    For  a  more thorough  review  of  CHR we  refer  the
reader to  [Fr"uhwirth, 2009].   More background on CHR  can be found  at
[Fr"uhwirth,].

In  section 8.2  we present  the syntax  of CHR  in  Prolog and  explain
informally its  operational semantics.    Next, section  8.3 deals  with
practical issues  of writing  and compiling  Prolog programs  containing
CHR.  Section  8.4  explains the  (currently  primitive)  CHR  debugging
facilities.  Section  8.4.3 provides a few useful predicates  to inspect
the constraint store,  and section 8.5 illustrates CHR with  two example
programs.   Section 8.6 describes  some compatibility issues with  older
versions of this system  and SICStus' CHR system.  Finally,  section 8.7
concludes with a few practical guidelines for using CHR.


88..22 SSyynnttaaxx aanndd SSeemmaannttiiccss


88..22..11 SSyynnttaaxx ooff CCHHRR rruulleess

________________________________________________________________________________________________________________________________________________||                                                                        ||
||rules --> rule, rules ; [].                                             |
|                                                                        |
|rule --> name, actual_rule, pragma, [atom('.')].                        |

|                                                                        |
|name --> atom, [atom('@')] ; [].                                        |
|                                                                        |
|actual_rule --> simplification_rule.                                    |
|actual_rule --> propagation_rule.                                       |
|actual_rule --> simpagation_rule.                                       |
|                                                                        |
|simplification_rule --> head, [atom('<=>')], guard, body.               |

|propagation_rule --> head, [atom('==>')], guard, body.                  |
|simpagation_rule --> head, [atom('\')], head, [atom('<=>')],            |
|                     guard, body.                                       |
|                                                                        |
|head --> constraints.                                                   |
|                                                                        |
|constraints --> constraint, constraint_id.                              |

|constraints --> constraint, constraint_id,                              |
|                [atom(',')], constraints.                               |
|                                                                        |
|constraint --> compound_term.                                           |
|                                                                        |
|constraint_id --> [].                                                   |
|constraint_id --> [atom('#')], variable.                                |
|constraint_id --> [atom('#')], [atom('passive')] .                      |

|                                                                        |
|guard --> [] ; goal, [atom('|')].                                       |
|                                                                        |
|body --> goal.                                                          |
|                                                                        |
|pragma --> [].                                                          |
|pragma --> [atom('pragma')], actual_pragmas.                            |

|                                                                        |
|actual_pragmas --> actual_pragma.                                       |
|actual_pragmas --> actual_pragma, [atom(',')], actual_pragmas.          |
|                                                                        |
|actual_pragma|-->_[atom('passive(')],_variable,_[atom(')')].___________ |             |

Note that  the guard of  a rule may  not contain any  goal that binds  a
variable in  the head of  the rule with a  non-variable or with  another
variable in  the head  of the  rule.   It may,  however, bind  variables
that do not appear  in the head of the rule, e.g. an  auxiliary variable
introduced in the guard.


88..22..22 SSeemmaannttiiccss

In  this subsection  the  operational semantics  of  CHR in  Prolog  are
presented informally.   They  do not differ  essentially from other  CHR
systems.

When a constraint is  called, it is considered an active  constraint and
the system  will try  to apply the  rules to it.    Rules are tried  and
executed sequentially in the order they are written.

A rule is conceptually  tried for an active constraint in  the following
way.  The active constraint is matched with a constraint  in the head of
the rule.  If  more constraints appear in the head, they are  looked for
among the  suspended constraints, which  are called passive  constraints
in this context.  If the necessary passive constraints  can be found and
all match with the head of the rule and the guard  of the rule succeeds,
then the rule  is committed and the body of  the rule executed.   If not
all the  necessary passive  constraints can  be found,  or the  matching
or the  guard fails, then the  body is not  executed and the process  of
trying and  executing simply  continues with  the following rules.    If
for  a rule  there are  multiple  constraints in  the head,  the  active
constraint  will try  the rule  sequentially multiple  times, each  time
trying to match with another constraint.

This process ends either when the active constraint  disappears, i.e. it
is removed by some rule, or after the last rule has  been processed.  In
the latter case the active constraint becomes suspended.

A  suspended constraint  is  eligible as  a  passive constraint  for  an
active constraint.   The other way it may interact again with  the rules
is when a variable  appearing in the constraint becomes bound  to either
a non-variable or another variable involved in one  or more constraints.
In that  case the  constraint is triggered,  i.e. it  becomes an  active
constraint and all the rules are tried.

RRuullee  TTyyppeess There are  three different  kinds of  rules,  each with  its
specific semantics:

  o _s_i_m_p_l_i_f_i_c_a_t_i_o_n
    The  simplification rule  removes the  constraints in  its head  and
    calls its body.

  o _p_r_o_p_a_g_a_t_i_o_n
    The   propagation  rule  calls  its   body  exactly  once  for   the
    constraints in its head.

  o _s_i_m_p_a_g_a_t_i_o_n
    The  simpagation rule removes the constraints in its head  after the
    \ and then  calls its body.  It is an optimization of simplification
    rules of the form:

                  constraints1;constraints2<=> constraints1;body

    Namely, in the simpagation form:

                       constraints1\constraints2<=> body
    The constraints1constraints are not called in the body.

RRuullee NNaammeess

Naming  a rule  is  optional and  has  no semantic  meaning.    It  only
functions as documentation for the programmer.

PPrraaggmmaass The semantics of the pragmas are:

ppaassssiivvee((_I_d_e_n_t_i_f_i_e_r))
    The  constraint in the  head of a rule  _I_d_e_n_t_i_f_i_e_r can only match  a
    passive  constraint in that  rule.   There is an abbreviated  syntax
    for this pragma.  Instead of:

    ____________________________________________________________________|                                                                    |

    ||________________...,_c_#_Id,_..._<=>_..._pragma_passive(Id)_______ ||

    you can also write

    ____________________________________________________________________|                                                                    |
    ||________________...,_c_#_passive,_..._<=>_..._____________________ ||

Additional pragmas may be released in the future.


::-- cchhrr__ooppttiioonn((_+_O_p_t_i_o_n_, _+_V_a_l_u_e))
    It  is  possible  to specify  options  that  apply to  all  the  CHR
    rules  in the module.   Options are specified  with the chr_option/2
    declaration:

    ____________________________________________________________________|                                                                    |
    ||:-_chr_option(Option,Value).______________________________________ ||

    and  may appear  in the  file anywhere after  the first  constraints
    declaration.

    Available options are:

    cchheecckk__gguuaarrdd__bbiinnddiinnggss
         This  option controls  whether  guards  should be  checked  for
         (illegal) variable bindings or  not.  Possible values  for this
         option are  on to  enable the checks,  and off  to disable  the
         checks.   If this option is on,  any guard fails when it  binds
         a variable  that appears in  the head of  the rule.   When  the
         option is  off (default),  the behaviour  of a  binding in  the
         guard is undefined.

    ooppttiimmiizzee
         This option  controls the  degree  of optimization.    Possible
         values are  full  to enable  all available  optimizations,  and
         off  (default) to  disable  all  optimizations.    The  default
         is derived  from the  SWI-Prolog flag optimise,  where true  is
         mapped to full.  Therefore the command line  option -O provides
         full CHR optimization.   If optimization is enabled,  debugging
         must be disabled.

    ddeebbuugg
         This option enables  or disables the  possibility to debug  the
         CHR code.    Possible values  are on (default)  and off.    See
         section 8.4  for more  details on debugging.    The default  is
         derived  from the  Prolog  flag  generate_debug_info,  which  is
         true by  default.   See  -nodebug.   If  debugging is  enabled,
         optimization must be disabled.


88..33 CCHHRR iinn SSWWII--PPrroolloogg PPrrooggrraammss


88..33..11 EEmmbbeeddddiinngg iinn PPrroolloogg PPrrooggrraammss

The CHR constraints defined in a .pl file are  associated with a module.
The default module is  user.  One should never load different  .pl files
with the same CHR module name.


88..33..22 CCoonnssttrraaiinntt ddeeccllaarraattiioonn


::-- cchhrr__ccoonnssttrraaiinntt((_+_S_p_e_c_i_f_i_e_r))
    Every  constraint  used in  CHR  rules has  to  be declared  with  a
    chr_constraint/1  declaration  by the  _c_o_n_s_t_r_a_i_n_t  _s_p_e_c_i_f_i_e_r.    For
    convenience  multiple constraints may be  declared at once with  the
    same  chr_constraint/1  declaration followed  by  a  comma-separated
    list of constraint specifiers.

    A  constraint specifier is,  in its compact form,  F/A where F  and
    A  are respectively the  functor name and arity  of the constraint,
    e.g.:

    ____________________________________________________________________|                                                                    |
    | :- chr_constraint foo/1.                                           |

    ||:-_chr_constraint_bar/2,_baz/3.___________________________________ ||

    In  its extended form, a constraint specifier is c(A1,...,An) where
    c  is the constraint's functor, n its arity and  the Aiare  argument
    specifiers.   An argument  specifier is a mode, optionally  followed
    by a type.  Example:

    ____________________________________________________________________|                                                                    |
    | :- chr_constraint get_value(+,?).                                  |
    | :- chr_constraint domain(?int, +list(int)),                        |
    ||__________________alldifferent(?list(int))._______________________ ||

MMooddeess

A mode is one of:

-
    The corresponding argument  of every occurrence of the constraint is
    always unbound.

+
    The corresponding argument  of every occurrence of the constraint is
    always ground.

?
    The  corresponding argument  of every occurrence  of the  constraint
    can  have any instantiation,  which may change over  time.  This  is
    the default value.

TTyyppeess

A type can be a user-defined type or one of the built-in  types.  A type
comprises a  (possibly infinite) set  of values.   The type  declaration
for  a  constraint  argument means  that  for  every  instance  of  that
constraint the  corresponding argument is only  ever bound to values  in
that set.   It does  not state that the  argument necessarily has to  be
bound to a value.

The built-in types are:

iinntt
    The corresponding argument  of every occurrence of the constraint is
    an integer number.

ddeennssee__iinntt
    The corresponding argument  of every occurrence of the constraint is
    an  integer that can be used as an  array index.  Note that  if this
    argument takes values in [0; n], the array takes O(n) space.

ffllooaatt
    ...a floating point number.

nnuummbbeerr
    ...a number.

nnaattuurraall
    ...a positive integer.

aannyy
    The  corresponding argument  of every occurrence  of the  constraint
    can have any type.  This is the default value.


::-- cchhrr__ttyyppee((_+_T_y_p_e_D_e_c_l_a_r_a_t_i_o_n))
    User-defined  types are algebraic  data types,  similar to those  in
    Haskell  or the discriminated unions in Mercury.  An  algebraic data
    type is defined using chr_type/1:

    ____________________________________________________________________|                                                                    |
    ||:-_chr_type_type_--->_body._______________________________________ ||

    If  the type term is a functor  of arity zero (i.e. one  having zero
    arguments),  it names  a monomorphic type.   Otherwise,  it names  a
    polymorphic  type;  the arguments of  the functor  must be  distinct
    type  variables.     The body  term  is  defined as  a  sequence  of
    constructor definitions separated by semi-colons.

    Each  constructor  definition  must  be a  functor  whose  arguments
    (if  any)  are  types.    Discriminated  union definitions  must  be
    transparent:   all type  variables occurring in  the body must  also
    occur in the type.

    Here are some examples of algebraic data type definitions:

    ____________________________________________________________________|                                                                    |

    | :- chr_type color ---> red ; blue ; yellow ; green.                |
    |                                                                    |
    | :- chr_type tree --->  empty ; leaf(int) ; branch(tree, tree).     |
    |                                                                    |
    | :- chr_type list(T) ---> [] ; [T | list(T)].                       |
    |                                                                    |

    ||:-_chr_type_pair(T1,_T2)_--->_(T1_-_T2).__________________________ ||

    Each  algebraic data  type  definition introduces  a distinct  type.
    Two  algebraic data types that  have the same bodies are  considered
    to be distinct types (name equivalence).

    Constructors may be  overloaded among different types:  there may be
    any  number of constructors with a given name and arity, so  long as
    they all have different types.

    Aliases can be defined  using ==.  For example, if your program uses
    lists of lists of integers, you can define an alias as follows:

    ____________________________________________________________________|                                                                    |
    ||:-_chr_type_lli_==_list(list(int))._______________________________ ||

TTyyppee CChheecckkiinngg

Currently two complementary forms of type checking are performed:

 1. Static  type checking is  always performed by the  compiler.  It  is
    limited to CHR rule heads and CHR constraint calls in rule bodies.

    Two  kinds  of type  error  are detected.    The  first is  where  a
    variable has to belong to two types.  For example, in the program:

    ____________________________________________________________________|                                                                    |
    | :-chr_type foo ---> foo.                                           |
    | :-chr_type bar ---> bar.                                           |

    |                                                                    |
    | :-chr_constraint abc(?foo).                                        |
    | :-chr_constraint def(?bar).                                        |
    |                                                                    |
    ||foobar_@_abc(X)_<=>_def(X)._______________________________________ ||

    the  variable  X has  to be  of both  type foo  and bar.    This  is
    reported as a type clash error:

    ____________________________________________________________________|                                                                    |
    | CHR compiler ERROR:                                                |
    |     `--> Type clash for variable _ in rule foobar:                 |

    |                 expected type foo in body goal def(_, _)           |
    ||________________expected_type_bar_in_head_def(_,__)_______________ ||

    The  second kind of error is where  a functor is used that  does not
    belong to the declared type.  For example in:

    ____________________________________________________________________|                                                                    |
    | :- chr_type foo ---> foo.                                          |
    | :- chr_type bar ---> bar.                                          |
    |                                                                    |
    | :- chr_constraint abc(?foo).                                       |

    |                                                                    |
    ||foo_@_abc(bar)_<=>_true.__________________________________________ ||

    bar  appears in the head of the rule where something of type  foo is
    expected.  This is reported as:

    ____________________________________________________________________|                                                                    |
    | CHR compiler ERROR:                                                |
    |     `--> Invalid functor in head abc(bar) of rule foo:             |
    |                 found `bar',                                       |

    ||________________expected_type_`foo'!______________________________ ||

    No runtime overhead is incurred in static type checking.

 2. Dynamic  type checking checks at runtime, during  program execution,
    whether  the arguments  of  CHR constraints  respect their  declared
    types.   The  when/2 co-routining library  is used to delay  dynamic
    type checks until variables are instantiated.

    The  kind of  error detected  by dynamic  type checking  is where  a
    functor  is used that  does not belong  to the declared  type.   For
    example, for the program:

    ____________________________________________________________________|                                                                    |

    | :-chr_type foo ---> foo.                                           |
    |                                                                    |
    ||:-chr_constraint_abc(?foo)._______________________________________ ||

    we get the following error in an erroneous query:

    ____________________________________________________________________|                                                                    |
    | ?- abc(bar).                                                       |
    | ERROR: Type error: `foo' expected, found `bar'                     |
    ||_______(CHR_Runtime_Type_Error)___________________________________ ||

    Dynamic  type checking is  weaker than static  type checking in  the
    sense  that it only checks the particular program execution  at hand
    rather  than all possible executions.   It is stronger in the  sense
    that it tracks types throughout the whole program.

    Note  that it  is enabled  only in  debug  mode, as  it incurs  some
    (minor) runtime overhead.


88..33..33 CCoommppiillaattiioonn

The  SWI-Prolog   CHR  compiler   exploits  term_expansion/2  rules   to
translate the constraint  handling rules to plain  Prolog.  These  rules
are loaded  from the library chr.   They  are activated if the  compiled
file  has the  .chr extension  or  after finding  a declaration  in  the
following format:

________________________________________________________________________|                                                                        |
|:-|chr_constraint_...__________________________________________________ |  |

It is  advised to define CHR  rules in a  module file, where the  module
declaration  is  immediately  followed  by  including  the  library(chr)
library as exemplified below:

________________________________________________________________________|                                                                        |

|:- module(zebra, [ zebra/0 ]).                                          |
|:- use_module(library(chr)).                                            |
|                                                                        |
|:-|chr_constraint_...__________________________________________________ |  |

Using this style, CHR rules can be defined in  ordinary Prolog .pl files
and the operator  definitions required by CHR  do not leak into  modules
where they might cause conflicts.


88..44 DDeebbuuggggiinngg

The  CHR  debugging facilities  are  currently  rather limited.     Only
tracing is  currently available.   To use  the CHR debugging  facilities
for a  CHR file it  must be  compiled for debugging.   Generating  debug
info is  controlled by the  CHR option debug,  whose default is  derived
from the SWI-Prolog  flag generate_debug_info.   Therefore debug info  is
provided unless the -nodebug is used.


88..44..11 PPoorrttss

For CHR constraints the four standard ports are defined:

ccaallll
    A new constraint is called and becomes active.

eexxiitt
    An  active  constraint  exits:    it has  either  been  inserted  in
    the  store  after trying  all rules  or has  been  removed from  the
    constraint store.

ffaaiill
    An active constraint fails.

rreeddoo
    An active constraint starts looking for an alternative solution.

In addition  to the above  ports, CHR  constraints have five  additional
ports:

wwaakkee
    A suspended constraint is woken and becomes active.

iinnsseerrtt
    An  active constraint has  tried all rules  and is suspended in  the
    constraint store.

rreemmoovvee
    An  active  or passive  constraint is  removed  from the  constraint
    store.

ttrryy
    An  active  constraint  tries  a rule  with  possibly  some  passive
    constraints.  The  try port is entered just before committing to the
    rule.

aappppllyy
    An  active constraint commits to  a rule with possibly some  passive
    constraints.   The  apply port is  entered just after committing  to
    the rule.


88..44..22 TTrraacciinngg

Tracing is enabled with the chr_trace/0 predicate and disabled  with the
chr_notrace/0 predicate.

When enabled  the tracer will  step through the  call, exit, fail,  wake
and apply  ports, accepting  debug commands,  and simply  write out  the
other ports.

The following debug commands are currently supported:

        CHR debug options:

                <cr>    creep           c       creep
                s       skip
                g       ancestors
                n       nodebug
                b       break
                a       abort
                f       fail
                ?       help            h       help

Their meaning is:

ccrreeeepp
    Step to the next port.

sskkiipp
    Skip to exit port of this call or wake port.

aanncceessttoorrss
    Print list of ancestor call and wake ports.

nnooddeebbuugg
    Disable the tracer.

bbrreeaakk
    Enter a recursive Prolog top level.  See break/0.

aabboorrtt
    Exit to the top level.  See abort/0.

ffaaiill
    Insert failure in execution.

hheellpp
    Print the above available debug options.


88..44..33 CCHHRR DDeebbuuggggiinngg PPrreeddiiccaatteess

The chr  module contains  several predicates that  allow inspecting  and
printing the content of the constraint store.


cchhrr__ttrraaccee
    Activate  the CHR tracer.   By default  the CHR tracer is  activated
    and  deactivated automatically by the Prolog predicates  trace/0 and
    notrace/0.


cchhrr__nnoottrraaccee
    Deactivate  the CHR tracer.  By default the CHR tracer  is activated
    and  deactivated automatically by the Prolog predicates  trace/0 and
    notrace/0.


cchhrr__lleeaasshh((_+_S_p_e_c))
    Define  the set of CHR ports on  which the CHR tracer asks  for user
    intervention  (i.e. stops).    _S_p_e_c  is either  a list  of ports  as
    defined  in section 8.4.1 or a predefined `alias'.   Defined aliases
    are:   full to  stop at all ports,  none or off  to never stop,  and
    default to stop at  the call, exit, fail, wake and apply ports.  See
    also leash/1.


cchhrr__sshhooww__ssttoorree((_+_M_o_d))
    Prints  all  suspended constraints  of module  _M_o_d  to the  standard
    output.   This predicate  is automatically called by the  SWI-Prolog
    top  level at the end of  each query for every CHR module  currently
    loaded.    The Prolog flag  chr_toplevel_show_store controls  whether
    the  top level shows the constraint stores.  The value  true enables
    it.  Any other value disables it.


ffiinndd__cchhrr__ccoonnssttrraaiinntt((_-_C_o_n_s_t_r_a_i_n_t))
    Returns  a constraint in  the constraint store.   Via  backtracking,
    all constraints in the store can be enumerated.


88..55 EExxaammpplleess

Here are two example constraint solvers written in CHR.

  o The  program below  defines a  solver with  one constraint,  leq/2/,
    which  is a less-than-or-equal constraint,  also known as a  partial
    order constraint.

    ____________________________________________________________________|                                                                    |
    | :- module(leq,[leq/2]).                                            |

    | :- use_module(library(chr)).                                       |
    |                                                                    |
    | :- chr_constraint leq/2.                                           |
    | reflexivity  @ leq(X,X) <=> true.                                  |
    | antisymmetry @ leq(X,Y), leq(Y,X) <=> X = Y.                       |
    | idempotence  @ leq(X,Y) \ leq(X,Y) <=> true.                       |
    ||transitivity_@_leq(X,Y),_leq(Y,Z)_==>_leq(X,Z).___________________ ||

    When the above program  is saved in a file and loaded in SWI-Prolog,
    you can call the leq/2 constraints in a query, e.g.:

    ____________________________________________________________________|                                                                    |

    | ?- leq(X,Y), leq(Y,Z).                                             |
    | leq(_G23837, _G23841)                                              |
    | leq(_G23838, _G23841)                                              |
    | leq(_G23837, _G23838)                                              |
    ||true_.____________________________________________________________ ||

    When  the  query  succeeds,  the  SWI-Prolog top  level  prints  the
    content  of  the  CHR constraint  store  and displays  the  bindings
    generated  during  the query.    Some  of  the query  variables  may
    have  been bound to  attributed variables, as  you see in the  above
    example.

  o The  program  below implements  a  simple finite  domain  constraint
    solver.

    ____________________________________________________________________|                                                                    |
    | :- module(dom,[dom/2]).                                            |

    | :- use_module(library(chr)).                                       |
    |                                                                    |
    | :- chr_constraint dom(?int,+list(int)).                            |
    | :- chr_type list(T) ---> [] ; [T|list(T)].                         |
    |                                                                    |
    | dom(X,[]) <=> fail.                                                |
    | dom(X,[Y]) <=> X = Y.                                              |
    | dom(X,L) <=> nonvar(X) | memberchk(X,L).                           |

    ||dom(X,L1),_dom(X,L2)_<=>_intersection(L1,L2,L3),_dom(X,L3)._______ ||

    When the above program  is saved in a file and loaded in SWI-Prolog,
    you can call the dom/2 constraints in a query, e.g.:

    ____________________________________________________________________|                                                                    |
    | ?- dom(A,[1,2,3]), dom(A,[3,4,5]).                                 |
    ||A_=_3.____________________________________________________________ ||


88..66 BBaacckkwwaarrddss CCoommppaattiibbiilliittyy


88..66..11 TThhee OOlldd SSIICCSSttuuss CCHHRR iimmpplleemmeennaattiioonn

There are  small differences between the  current K.U.Leuven CHR  system
in  SWI-Prolog, older  versions of  the same  system,  and SICStus'  CHR
system.

The  current  system maps  old  syntactic  elements onto  new  ones  and
ignores a number  of no longer required elements.   However, for each  a
_d_e_p_r_e_c_a_t_e_d warning  is issued.   You  are strongly  urged to replace  or
remove deprecated features.

Besides  differences in  available options  and pragmas,  the  following
differences should be noted:

  o _T_h_e constraints/1 _d_e_c_l_a_r_a_t_i_o_n
    This  declaration is  deprecated.   It  has been  replaced with  the
    chr_constraint/1 declaration.

  o _T_h_e option/2 _d_e_c_l_a_r_a_t_i_o_n
    This  declaration is  deprecated.   It  has been  replaced with  the
    chr_option/2 declaration.

  o _T_h_e handler/1 _d_e_c_l_a_r_a_t_i_o_n
    In  SICStus  every  CHR  module  requires  a  handler/1  declaration
    declaring  a unique handler name.  This declaration is  valid syntax
    in  SWI-Prolog, but will have  no effect.   A warning will be  given
    during compilation.

  o _T_h_e rules/1 _d_e_c_l_a_r_a_t_i_o_n
    In  SICStus, for every  CHR module it is  possible to only enable  a
    subset of the  available rules through the rules/1 declaration.  The
    declaration  is valid syntax in  SWI-Prolog, but has  no effect.   A
    warning is given during compilation.

  o _G_u_a_r_d _b_i_n_d_i_n_g_s
    The   check_guard_bindings  option   only  turns  invalid  calls   to
    unification  into failure.   In SICStus this  option does more:   it
    intercepts  instantiation errors from Prolog built-ins such  as is/2
    and turns them into  failure.  In SWI-Prolog, we do not go this far,
    as we like to  separate concerns more.  The CHR compiler is aware of
    the CHR code,  the Prolog system, and the programmer should be aware
    of  the appropriate meaning of the  Prolog goals used in guards  and
    bodies of CHR rules.


88..66..22 TThhee OOlldd EECCLLiiPPSSee CCHHRR iimmpplleemmeennaattiioonn

The old  ECLiPSe CHR  implementation features  a label_with/1  construct
for  labeling variables  in CHR  constraints.    This feature  has  long
since been abandoned.   However, a simple transformation is all  that is
required to port the functionality.

________________________________________________________________________|                                                                        |
|label_with Constraint1 if Condition1.                                   |
|...                                                                     |
|label_with ConstraintN if ConditionN.                                   |

|Constraint1 :- Body1.                                                   |
|...                                                                     |
|ConstraintN|:-_BodyN.__________________________________________________ |           |

is transformed into

________________________________________________________________________|                                                                        |
|:- chr_constraint my_labeling/0.                                        |

|                                                                        |
|my_labeling \ Constraint1 <=> Condition1 | Body1.                       |
|...                                                                     |
|my_labeling \ ConstraintN <=> ConditionN | BodyN.                       |
|my_labeling|<=>_true.__________________________________________________ |           |

Be sure to  put this code after all other  rules in your program!   With
my_labeling/0 (or another predicate name of your choosing)  the labeling
is initiated, rather than ECLiPSe's chr_labeling/0.


88..77 PPrrooggrraammmmiinngg TTiippss aanndd TTrriicckkss

In this section we  cover several guidelines on how to use CHR  to write
constraint solvers and how to do so efficiently.

  o _C_h_e_c_k _g_u_a_r_d _b_i_n_d_i_n_g_s _y_o_u_r_s_e_l_f
    It  is considered bad practice  to write guards that bind  variables
    of  the head and to  rely on the system  to detect this at  runtime.
    It is inefficient and obscures the working of the program.

  o _S_e_t _s_e_m_a_n_t_i_c_s
    The  CHR system allows the  presence of identical constraints,  i.e.
    multiple  constraints with  the same functor,  arity and  arguments.
    For  most constraint  solvers, this  is not desirable:   it  affects
    efficiency and possibly  termination.  Hence appropriate simpagation
    rules should be added of the form:

                         constraint\constraint <=>true

  o _M_u_l_t_i_-_h_e_a_d_e_d _r_u_l_e_s
    Multi-headed   rules  are   executed  more   efficiently  when   the
    constraints share one or more variables.

  o _M_o_d_e _a_n_d _t_y_p_e _d_e_c_l_a_r_a_t_i_o_n_s
    Provide  mode and  type declarations to  get more efficient  program
    execution.     Make sure  to  disable  debug (-nodebug)  and  enable
    optimization (-O).

  o _C_o_m_p_i_l_e _o_n_c_e_, _r_u_n _m_a_n_y _t_i_m_e_s
    Does  consulting your CHR  program take a  long time in  SWI-Prolog?
    Probably  it  takes the  CHR compiler  a long  time  to compile  the
    CHR  rules into  Prolog code.   When  you disable optimizations  the
    CHR  compiler will be a lot  quicker, but you may lose  performance.
    Alternatively, you  can just use SWI-Prolog's qcompile/1 to generate
    a  .qlf  file once  from your  .pl file.    This  .qlf contains  the
    generated  code of  the CHR  compiler (be  it in  a binary  format).
    When you consult the  .qlf file, the CHR compiler is not invoked and
    consultation is much faster.

  o _F_i_n_d_i_n_g _C_o_n_s_t_r_a_i_n_t_s
    The  find_chr_constraint/1 predicate  is fairly  expensive.    Avoid
    it,  if  possible.   If  you must  use it,  try  to use  it with  an
    instantiated top-level constraint symbol.


88..88 CCoommppiilleerr EErrrroorrss aanndd WWaarrnniinnggss

In  this section  we  summarize the  most  important error  and  warning
messages of the CHR compiler.


88..88..11 CCHHRR CCoommppiilleerr EErrrroorrss

TTyyppee ccllaasshh  for variable ...  in rule ...

    This  error indicates  an inconsistency  between declared  types;  a
    variable can not belong to two types.  See static type checking.

IInnvvaalliidd ffuunnccttoorr  in head ...  of rule ...

    This  error indicates an inconsistency  between a declared type  and
    the use of a functor in a rule.  See static type checking.

CCyycclliicc aalliiaass  definition:  ...  == ...

    You  have defined a type alias  in terms of itself, either  directly
    or indirectly.

AAmmbbiigguuoouuss ttyyppee aalliiaasseess  You have defined two overlapping type aliases.

MMuullttiippllee ddeeffiinniittiioonnss  for type

    You have defined the same type multiple times.

NNoonn--ggrroouunndd ttyyppee  in constraint definition:  ...

    You have declared a non-ground type for a constraint argument.

CCoouulldd nnoott ffiinndd ttyyppee ddeeffiinniittiioonn  for ...

    You have used an undefined type in a type declaration.

IIlllleeggaall mmooddee//ttyyppee ddeeccllaarraattiioonn  You  have  used   invalid  syntax  in   a
    constraint declaration.

CCoonnssttrraaiinntt mmuullttiippllyy ddeeffiinneedd  There is more than one declaration  for the
    same constraint.

UUnnddeeccllaarreedd ccoonnssttrraaiinntt  ...  in head of ...

    You have used an  undeclared constraint in the head of a rule.  This
    often  indicates a  misspelled constraint  name or  wrong number  of
    arguments.

IInnvvaalliidd pprraaggmmaa  ...  in ...  Pragma should not be a variable.

    You  have used  a variable  as a  pragma in  a rule.    This is  not
    allowed.

IInnvvaalliidd iiddeennttiiffiieerr  ...  in pragma passive in ...

    You  have  used an  identifier in  a passive  pragma  that does  not
    correspond  to an identifier in  the head of the  rule.  Likely  the
    identifier name is misspelled.

UUnnkknnoowwnn pprraaggmmaa  ...  in ...

    You  have used an unknown  pragma in a rule.   Likely the pragma  is
    misspelled or not supported.

SSoommeetthhiinngg uunneexxppeecctteedd  happened in the CHR compiler

    You have most likely  bumped into a bug in the CHR compiler.  Please
    contact Tom Schrijvers to notify him of this error.


CChhaapptteerr 99..  MMUULLTTIITTHHRREEAADDEEDD AAPPPPLLIICCAATTIIOONNSS

SWI-Prolog multithreading is  based on standard C language  multithread-
ing support.   It is not  like _P_a_r_L_o_g or other parallel  implementations
of the Prolog language.   Prolog threads have their own stacks  and only
share the  Prolog _h_e_a_p:   predicates,  records, flags  and other  global
non-backtrackable data.  SWI-Prolog thread support is  designed with the
following goals in mind.

  o _M_u_l_t_i_t_h_r_e_a_d_e_d _s_e_r_v_e_r _a_p_p_l_i_c_a_t_i_o_n_s
    Today's   computing  services  often  focus  on   (internet)  server
    applications.   Such applications often have need  for communication
    between  services  and/or  fast  non-blocking  service  to  multiple
    concurrent  clients.  The  shared heap provides fast  communication,
    and thread creation is relatively cheap.

  o _I_n_t_e_r_a_c_t_i_v_e _a_p_p_l_i_c_a_t_i_o_n_s
    Interactive   applications   often   need   to   perform   extensive
    computation.   If  such computations are  executed in a new  thread,
    the  main thread  can process events  and allow  the user to  cancel
    the  ongoing computation.    User interfaces can  also use  multiple
    threads,  each thread dealing  with input from  a distinct group  of
    windows.  See also section 9.7.

  o _N_a_t_u_r_a_l _i_n_t_e_g_r_a_t_i_o_n _w_i_t_h _f_o_r_e_i_g_n _c_o_d_e
    Each Prolog thread  runs in a native thread of the operating system,
    automatically  making them cooperate with _M_T_-_s_a_f_e foreign code.   In
    addition,  any foreign thread can  create its own Prolog engine  for
    dealing with calling Prolog from C code.

SWI-Prolog  multithreading  is  based  on  the   POSIX  thread  standard
[Butenhof, 1997] used  on most  popular systems  except for  MS-Windows.
On Windows  it uses the pthread-win32  emulation of POSIX threads  mixed
with the  Windows native  API for smoother  and faster  operation.   The
SWI-Prolog  thread implementation  has been  discussed in  the ISO  WG17
working group and is largely addopted by YAP and XSB Prolog.


99..11 CCrreeaattiinngg aanndd ddeessttrrooyyiinngg PPrroolloogg tthhrreeaaddss


tthhrreeaadd__ccrreeaattee((_:_G_o_a_l_, _-_I_d_, _+_O_p_t_i_o_n_s))
    Create  a new Prolog thread (and  underlying C thread) and start  it
    by  executing _G_o_a_l.    If the  thread is  created successfully,  the
    thread  identifier of the created thread is unified to _I_d.   _O_p_t_i_o_n_s
    is  a list of  options.   The currently  defined options are  below.
    Stack  size options can also take  the value inf or infinite,  which
    is mapped to the maximum stack size supported by the platform.

    aalliiaass((_A_l_i_a_s_N_a_m_e))
         Associate an `alias  name' with the thread.   This name may  be
         used to refer to the thread and remains valid  until the thread
         is joined (see thread_join/2).

    aatt__eexxiitt((_:_A_t_E_x_i_t))
         Register _A_t_E_x_i_t  as using thread_at_exit/1 before entering  the
         thread  goal.    Unlike  calling  thread_at_exit/1 as  part  of
         the normal  _G_o_a_l, this  _e_n_s_u_r_e_s the  _A_t_E_x_i_t is called.    Using
         thread_at_exit/1,  the thread  may be  signalled or  run out  of
         resources before thread_at_exit/1is reached.

    ddeebbuugg((_+_B_o_o_l))
         Enable/disable debugging  the new  thread.   If false  (default
         true),   the  new   thread  is   created   with  the   property
         debug(_f_a_l_s_e) and  debugging is disabled  before the new  thread
         is started.   The  thread debugging  predicates such as  tspy/1
         and tdebug/0 do not signal threads with the  debug property set
         to false.

    ddeettaacchheedd((_B_o_o_l))
         If  false  (default),  the  thread  can  be  waited  for  using
         thread_join/2.   thread_join/2 must  be called  on this  thread
         to  reclaim all  resources  associated with  the  thread.    If
         true,  the   system  will  reclaim  all  associated   resources
         automatically after  the thread  finishes.    Please note  that
         thread identifiers are freed for reuse after  a detached thread
         finishes  or a  normal  thread  has  been joined.     See  also
         thread_join/2 and thread_detach/1.

         If  a  detached  thread  dies  due  to   failure  or  exception
         of  the  initial  goal,  the  thread  prints  a  message  using
         print_message/2.  If such termination is considered normal, the
         code must be  wrapped using ignore/1  and/or catch/3 to  ensure
         successful completion.

    iinnhheerriitt__ffrroomm((_+_T_h_r_e_a_d_I_d))
         Inherit  defaults  from  the  given  _T_h_r_e_a_d_I_d  instead  of  the
         calling thread.    This  option was  added to  ensure that  the
         __thread_pool_manager  (see thread_create_in_pool/4),  which  is
         created  lazily,  has  a predictable  state.     The  following
         properties are inherited:

           o The prompt (see prompt/2)

           o The _t_y_p_e_i_n module (see module/1)

           o The standard streams (user_input, etc.)

           o The default encoding (see encoding)

           o The default locale (see setlocale/1)

           o All prolog flags

           o The limits of Prolog stacks (see set_prolog_stack/2)

    gglloobbaall((_K_-_B_y_t_e_s))
         Set the  limit to  which the global  stack of  this thread  may
         grow.   If omitted,  the limit of the  calling thread is  used.
         See also the -G command line option.

    llooccaall((_K_-_B_y_t_e_s))
         Set the  limit to  which  the local  stack of  this thread  may
         grow.   If omitted,  the limit of the  calling thread is  used.
         See also the -L command line option.

    cc__ssttaacckk((_K_-_B_y_t_e_s))
         Set  the  limit  to which  the  system  stack  of  this  thread
         may  grow.    The  default,  minimum  and  maximum  values  are
         system-dependent.

    ttrraaiill((_K_-_B_y_t_e_s))
         Set the  limit to  which  the trail  stack of  this thread  may
         grow.   If omitted,  the limit of the  calling thread is  used.
         See also the -T command line option.

    The _G_o_a_l argument is  _c_o_p_i_e_d to the new Prolog engine.  This implies
    that  further instantiation of this  term in either thread does  not
    have  consequences for  the  other thread:   Prolog  threads do  not
    share data from their stacks.


tthhrreeaadd__sseellff((_-_I_d))
    Get  the Prolog thread  identifier of  the running thread.   If  the
    thread has an alias, the alias name is returned.


tthhrreeaadd__jjooiinn((_+_I_d_, _-_S_t_a_t_u_s))
    Wait  for the termination  of the thread  with the given  _I_d.   Then
    unify  the result  status of  the thread with  _S_t_a_t_u_s.   After  this
    call,  _I_d  becomes invalid  and all  resources  associated with  the
    thread  are  reclaimed.     Note that  threads  with  the  attribute
    detached(_t_r_u_e) cannot be joined.  See also thread_property/2.

    A thread  that has been completed without thread_join/2 being called
    on  it is partly reclaimed:  the Prolog stacks are released  and the
    C  thread is  destroyed.   A small  data structure representing  the
    exit status  of the thread is retained until thread_join/2 is called
    on the thread.  Defined values for _S_t_a_t_u_s are:

    ttrruuee
         The goal has been proven successfully.

    ffaallssee
         The goal has failed.

    eexxcceeppttiioonn((_T_e_r_m))
         The thread is terminated on an  exception.  See print_message/2
         to turn system exceptions into readable messages.

    eexxiitteedd((_T_e_r_m))
         The thread  is terminated on  thread_exit/1 using the  argument
         _T_e_r_m.


tthhrreeaadd__ddeettaacchh((_+_I_d))
    Switch  thread into  detached  state (see  detached(_B_o_o_l) option  at
    thread_create/3) at  runtime.   _I_d is the  identifier of the  thread
    placed in detached state.  This may be the result of thread_self/1.

    One   of  the  possible  applications  is  to   simplify  debugging.
    Threads  that  are  created as  _d_e_t_a_c_h_e_d  leave  no traces  if  they
    crash.   For non-detached threads the status can be  inspected using
    thread_property/2.   Threads  nobody is waiting  for may be  created
    normally  and detach themselves  just before completion.   This  way
    they  leave no  traces  on normal  completion and  their reason  for
    failure can be inspected.


tthhrreeaadd__eexxiitt((_+_T_e_r_m))                                          _[_d_e_p_r_e_c_a_t_e_d_]
    Terminates  the thread immediately,  leaving exited(_T_e_r_m) as  result
    state  for   thread_join/2.     If  the   thread  has  the  attribute
    detached(_t_r_u_e)  it  terminates,   but  its  exit  status  cannot  be
    retrieved using  thread_join/2, making the value  of _T_e_r_m irrelevant.
    The Prolog stacks and C thread are reclaimed.

    The  current  implementation  does not  guarantee  proper  releasing
    of  all  mutexes and  proper cleanup  in  setup_call_cleanup/3,  etc.
    Please  use the  exception  mechanism (throw/1)  to abort  execution
    using non-standard control.


tthhrreeaadd__iinniittiiaalliizzaattiioonn((_:_G_o_a_l))
    Run  _G_o_a_l when  thread is  started.   This predicate  is similar  to
    initialization/1,  but is intended for initialization  operations of
    the  runtime stacks, such as  setting global variables as  described
    in  section 7.3.   _G_o_a_l is run  on four occasions:   at the call  to
    this  predicate,  after loading  a saved  state, on  starting a  new
    thread  and on  creating a  Prolog engine through  the C  interface.
    On  loading  a  saved state,  _G_o_a_l  is  executed _a_f_t_e_r  running  the
    initialization/1 hooks.


tthhrreeaadd__aatt__eexxiitt((_:_G_o_a_l))
    Run  _G_o_a_l  just before  releasing the  thread resources.    This  is
    to  be  compared to  at_halt/1, but  only  for the  current  thread.
    These  hooks are run regardless of  why the execution of the  thread
    has  been completed.    When these hooks  are run,  the return  code
    is  already  available through  thread_property/2 using  the  result
    of  thread_self/1  as  thread  identifier.    Note  that  there  are
    two  scenarios  for using  exit hooks.    Using  thread_at_exit/1 is
    typically  used if  the thread  creates a side-effect  that must  be
    reverted if the thread  dies.  Another scenario is where the creator
    of  the thread  wants to be  informed when  the thread ends.    That
    cannot  be  guaranteed by  means of  thread_at_exit/1 because it  is
    possible that the  thread cannot be created or dies almost instantly
    due  to a  signal or resource  error.   The at_exit(_G_o_a_l) option  of
    thread_create/3 is designed to deal with this scenario.


tthhrreeaadd__sseettccoonnccuurrrreennccyy((_-_O_l_d_, _+_N_e_w))
    Determine  the concurrency of the  process, which is defined as  the
    maximum number of  concurrently active threads.  `Active' here means
    they  are using CPU  time.   This option is  provided if the  thread
    implementation  provides  pthread_setconcurrency().    Solaris  is  a
    typical  example of this  family.   On other systems this  predicate
    unifies _O_l_d to 0 (zero) and succeeds silently.


99..22 MMoonniittoorriinngg tthhrreeaaddss

Normal multithreaded  applications should not  need the predicates  from
this section  because almost any  usage of  these predicates is  unsafe.
For example checking the  existence of a thread before signalling  it is
of no use as it  may vanish between the two calls.   Catching exceptions
using  catch/3  is the  only  safe  way to  deal  with  thread-existence
errors.

These predicates are provided  for diagnosis and monitoring tasks.   See
also section 9.5, describing more high-level primitives.


tthhrreeaadd__pprrooppeerrttyy((_?_I_d_, _?_P_r_o_p_e_r_t_y))
    True  if thread  _I_d  has _P_r_o_p_e_r_t_y.    Either or  both arguments  may
    be  unbound, enumerating  all relations  on backtracking.    Calling
    thread_property/2  does  not  influence  any  thread.      See  also
    thread_join/2.   For threads that have  an alias name, this name  is
    returned  in _I_d instead  of the opaque  thread identifier.   Defined
    properties are:

    aalliiaass((_A_l_i_a_s))
         _A_l_i_a_s is the alias name of thread _I_d.

    ddeettaacchheedd((_B_o_o_l_e_a_n))
         Current detached status of the thread.

    ssttaattuuss((_S_t_a_t_u_s))
         Current status of the thread.  _S_t_a_t_u_s is one of:

         rruunnnniinngg
             The  thread is running.   This is  the initial status of  a
             thread.   Please  note that  threads waiting for  something
             are considered running too.

         ffaallssee
             The _G_o_a_l of the thread has been completed and failed.

         ttrruuee
             The _G_o_a_l of the thread has been completed and succeeded.

         eexxiitteedd((_T_e_r_m))
             The   _G_o_a_l  of  the  thread   has  been  terminated   using
             thread_exit/1 with  _T_e_r_m as  argument.   If the  underlying
             native  thread has  exited  (using pthread_exit()) _T_e_r_m  is
             unbound.

         eexxcceeppttiioonn((_T_e_r_m))
             The  _G_o_a_l  of the  thread has  been  terminated due  to  an
             uncaught exception (see throw/1 and catch/3).

    See  also thread_statistics/3 to  obtain resource usage  information
    and  message_queue_property/2 to get the  number of queued  messages
    for a thread.


tthhrreeaadd__ssttaattiissttiiccss((_+_I_d_, _+_K_e_y_, _-_V_a_l_u_e))
    Obtains  statistical information on  thread _I_d as statistics/2  does
    in  single-threaded applications.   This call  supports all keys  of
    statistics/2,  although only  stack sizes,  cputime, inferences  and
    epoch yield different values for each thread.


mmuutteexx__ssttaattiissttiiccss
    Print  usage statistics on  internal mutexes and mutexes  associated
    with  dynamic predicates.  For  each mutex two numbers are  printed:
    the  number  of times  the  mutex was  acquired  and the  number  of
    _c_o_l_l_i_s_i_o_n_s:   the  number of times  the calling  thread has to  wait
    for  the mutex.    Generally  collision count  is close  to zero  on
    single-CPU hardware.


99..33 TThhrreeaadd ccoommmmuunniiccaattiioonn


99..33..11 MMeessssaaggee qquueeuueess

Prolog  threads can  exchange data  using dynamic  predicates,  database
records,  and other globally  shared data.   These  provide no  suitable
means to wait for data or a condition as they can  only be checked in an
expensive polling loop.   _M_e_s_s_a_g_e _q_u_e_u_e_s provide a means for  threads to
wait for data or conditions without using the CPU.

Each thread  has a message  queue attached to it  that is identified  by
the thread.  Additional queues are created using message_queue_create/1.
Explicitly created queues  come in two flavours.   When given an  _a_l_i_a_s,
they  must be  destroyed by  the user.    _A_n_o_n_y_m_o_u_s  message queues  are
identified  by  a _b_l_o_b  (see  section  10.4.7) and  subject  to  garbage
collection.


tthhrreeaadd__sseenndd__mmeessssaaggee((_+_Q_u_e_u_e_O_r_T_h_r_e_a_d_I_d_, _+_T_e_r_m))
    Place  _T_e_r_m in  the given queue  or default  queue of the  indicated
    thread  (which  can  even  be  the  message  queue  of  itself,  see
    thread_self/1).   Any  term can be  placed in a  message queue,  but
    note  that the term is copied  to the receiving thread and  variable
    bindings are thus lost.  This call returns immediately.

    If  more than one thread is waiting for messages on the  given queue
    and  at least one of these is waiting with a  partially instantiated
    _T_e_r_m, the waiting  threads are _a_l_l sent a wake-up signal, starting a
    rush  for the available messages in  the queue.  This behaviour  can
    seriously  harm performance  with many threads  waiting on the  same
    queue  as all-but-the-winner  perform a useless  scan of the  queue.
    If  there is  only one waiting  thread or  all waiting threads  wait
    with  an unbound variable, an arbitrary thread is restarted  to scan
    the queue.


tthhrreeaadd__sseenndd__mmeessssaaggee((_+_Q_u_e_u_e_, _+_T_e_r_m_, _+_O_p_t_i_o_n_s))                   _[_s_e_m_i_d_e_t_]
    As  thread_send_message/2, but  providing additional _O_p_t_i_o_n_s.   These
    are  to deal  with  the case  that the  queue has  a finite  maximum
    size  and is full:   whereas thread_send_message/2 will block  until
    the  queue  has  drained  sufficiently  to  accept  a  new  message,
    thread_send_message/3 can accept a time-out or  deadline analogously
    to thread_get_message/3.  The options are:

    ddeeaaddlliinnee((_+_A_b_s_T_i_m_e))
         The call  fails (silently)  if  no space  has become  available
         before  _A_b_s_T_i_m_e.    See get_time/1  for the  representation  of
         absolute time.   If _A_b_s_T_i_m_e is  earlier then the current  time,
         thread_send_message/3 fails immediately.   Both resolution  and
         maximum wait time is platform-dependent.

    ttiimmeeoouutt((_+_T_i_m_e))
         _T_i_m_e is a  float or integer and  specifies the maximum time  to
         wait in  seconds.    This  is a  relative-time version  of  the
         deadline option.   If  both options are  provided, the  earlier
         time is effective.

         If _T_i_m_e is  0 or 0.0, thread_send_message/3 examines the  queue
         and sends  the  message if  space is  availabel,  but does  not
         suspend if no space is available, failing immediately instead.

         If _T_i_m_e  < 0, thread_send_message/3 fails  immediately without
         sending the message.


tthhrreeaadd__ggeett__mmeessssaaggee((_?_T_e_r_m))
    Examines the thread  message queue and if necessary blocks execution
    until  a term that unifies  to _T_e_r_m arrives in  the queue.  After  a
    term  from the queue has been  unified to _T_e_r_m, the term  is deleted
    from the queue.

    Please  note that non-unifying messages remain in the queue.   After
    the  following has been  executed, thread 1  has the term b(_g_n_u)  in
    its queue and continues execution using _A = gnat.

    ____________________________________________________________________|                                                                    |
    |    <thread 1>                                                      |

    |    thread_get_message(a(A)),                                       |
    |                                                                    |
    |    <thread 2>                                                      |
    |    thread_send_message(Thread_1, b(gnu)),                          |
    ||___thread_send_message(Thread_1,_a(gnat)),________________________ ||

    See also thread_peek_message/1.


tthhrreeaadd__ppeeeekk__mmeessssaaggee((_?_T_e_r_m))
    Examines  the thread  message queue  and compares  the queued  terms
    with   _T_e_r_m  until  one  unifies  or  the  end  of  the   queue  has
    been  reached.    In  the first  case  the call  succeeds,  possibly
    instantiating  _T_e_r_m.  If no  term from the queue unifies,  this call
    fails.   I.e., thread_peek_message/1never waits and  does not remove
    any term from the queue.  See also thread_get_message/3.


mmeessssaaggee__qquueeuuee__ccrreeaattee((_?_Q_u_e_u_e))
    Equivalent  to  message_queue_create(Queue,[]).     For  compatibil-
    ity,    calling   message_queue_create(_+_A_t_o_m)   is   equivalent   to
    message_queue_create(_Q_u_e_u_e_,  _[_a_l_i_a_s_(_A_t_o_m_)_]).   New  code should  use
    message_queue_create/2 to create a named queue.


mmeessssaaggee__qquueeuuee__ccrreeaattee((_-_Q_u_e_u_e_, _+_O_p_t_i_o_n_s))
    Create a message queue from _O_p_t_i_o_n_s.  Defined options are:

    aalliiaass((_+_A_l_i_a_s))
         Create  a  message  queue  that  is  identified   by  the  atom
         _A_l_i_a_s.   Message  queues created  this way  must be  explicitly
         destroyed by  the user.   If  the alias option  is omitted,  an
         _A_n_o_n_y_m_o_u_s queue is created  that is indentified by a  _b_l_o_b (see
         section 10.4.7) and subject to garbage collection.

    mmaaxx__ssiizzee((_+_S_i_z_e))
         Maximum number  of  terms in  the queue.    If  this number  is
         reached,  thread_send_message/2 will  suspend until  the  queue
         is drained.   The  option can  be used if  the source,  sending
         messages to the queue, is faster than the  drain, consuming the
         messages.


mmeessssaaggee__qquueeuuee__ddeessttrrooyy((_+_Q_u_e_u_e))                                      _[_d_e_t_]
    Destroy  a  message queue  created with  message_queue_create/1.    A
    permission  error is raised  if _Q_u_e_u_e refers  to (the default  queue
    of)  a thread.    Other  threads that  are waiting  for _Q_u_e_u_e  using
    thread_get_message/2 receive an existence error.


tthhrreeaadd__ggeett__mmeessssaaggee((_+_Q_u_e_u_e_, _?_T_e_r_m))                                  _[_d_e_t_]
    As  thread_get_message/1, operating on a given queue.   It is allowed
    (but  not advised) to get messages from the queue of  other threads.
    This predicate raises  an existence error exception if _Q_u_e_u_e doesn't
    exist  or  is  destroyed  using  message_queue_destroy/1 while  this
    predicate is waiting.


tthhrreeaadd__ggeett__mmeessssaaggee((_+_Q_u_e_u_e_, _?_T_e_r_m_, _+_O_p_t_i_o_n_s))                    _[_s_e_m_i_d_e_t_]
    As thread_get_message/2, but providing additional _O_p_t_i_o_n_s:

    ddeeaaddlliinnee((_+_A_b_s_T_i_m_e))
         The call  fails (silently)  if  no message  has arrived  before
         _A_b_s_T_i_m_e.   See  get_time/1 for the  representation of  absolute
         time.     If   _A_b_s_T_i_m_e  is  earlier  then  the   current  time,
         thread_get_message/3 fails immediately.    Both resolution  and
         maximum wait time is platform-dependent.

    ttiimmeeoouutt((_+_T_i_m_e))
         _T_i_m_e is a  float or integer and  specifies the maximum time  to
         wait in  seconds.    This  is a  relative-time version  of  the
         deadline option.   If  both options are  provided, the  earlier
         time is effective.

         If _T_i_m_e  is 0 or  0.0, thread_get_message/3 examines the  queue
         but does not  suspend if no matching  term is available.   Note
         that unlike  thread_peek_message/2, a  matching term is  removed
         from the queue.

         If  _T_i_m_e < 0,  thread_get_message/3 fails  immediately without
         removing any message from the queue.


tthhrreeaadd__ppeeeekk__mmeessssaaggee((_+_Q_u_e_u_e_, _?_T_e_r_m))                             _[_s_e_m_i_d_e_t_]
    As  thread_peek_message/1,  operating on  a  given  queue.    It  is
    allowed  to peek into another  thread's message queue, an  operation
    that  can be used to check whether a thread has swallowed  a message
    sent to it.


mmeessssaaggee__qquueeuuee__pprrooppeerrttyy((_?_Q_u_e_u_e_, _?_P_r_o_p_e_r_t_y))
    True if _P_r_o_p_e_r_t_y is a property of _Q_u_e_u_e.  Defined properties are:

    aalliiaass((_A_l_i_a_s))
         Queue has the given alias name.

    mmaaxx__ssiizzee((_S_i_z_e))
         Maximum  number of  terms  that  can be  in  the queue.     See
         message_queue_create/2.   This property is not present  if there
         is no limit (default).

    ssiizzee((_S_i_z_e))
         Queue  currently  contains  _S_i_z_e terms.     Note  that  due  to
         concurrent access the returned value may be  outdated before it
         is returned.  It can be used for debugging purposes  as well as
         work distribution purposes.

    The  size(_S_i_z_e)  property  is always  present  and  may be  used  to
    enumerate  the created  message queues.   Note  that this  predicate
    does _n_o_t _e_n_u_m_e_r_a_t_e  threads, but can be used to query the properties
    of the default queue of a thread.

Explicit  message queues  are  designed with  the _w_o_r_k_e_r_-_p_o_o_l  model  in
mind,  where  multiple  threads wait  on  a  single queue  and  pick  up
the first  goal to  execute.   Below  is a  simple implementation  where
the workers  execute arbitrary  Prolog goals.   Note  that this  example
provides no means to tell when all work is done.   This must be realised
using additional synchronisation.

________________________________________________________________________|                                                                        |
|%%      create_workers(?Id, +N)                                         |
|%                                                                       |
|%       Create a pool with Id and number of workers.                    |

|%       After the pool is created, post_job/1 can be used to            |
|%       send jobs to the pool.                                          |
|                                                                        |
|create_workers(Id, N) :-                                                |
|        message_queue_create(Id),                                       |
|        forall(between(1, N, _),                                        |
|               thread_create(do_work(Id), _, [])).                      |
|                                                                        |

|do_work(Id) :-                                                          |
|        repeat,                                                         |
|          thread_get_message(Id, Goal),                                 |
|          (   catch(Goal, E, print_message(error, E))                   |
|          ->  true                                                      |
|          ;   print_message(error, goal_failed(Goal, worker(Id)))       |
|          ),                                                            |

|        fail.                                                           |
|                                                                        |
|%%      post_job(+Id, +Goal)                                            |
|%                                                                       |
|%       Post a job to be executed by one of the pool's workers.         |
|                                                                        |
|post_job(Id, Goal) :-                                                   |
||_______thread_send_message(Id,_Goal)._________________________________ ||


99..33..22 SSiiggnnaalllliinngg tthhrreeaaddss

These  predicates provide  a mechanism  to make  another thread  execute
some  goal as  an  _i_n_t_e_r_r_u_p_t.    Signalling  threads  is safe  as  these
interrupts  are only  checked at  safe points  in  the virtual  machine.
Nevertheless,   signalling  in  multithreaded  environments  should   be
handled  with  care as  the  receiving  thread  may hold  a  _m_u_t_e_x  (see
with_mutex/2).  Signalling probably only makes sense to  start debugging
threads and to  cancel no-longer-needed threads with throw/1,  where the
receiving thread  should be designed carefully  to handle exceptions  at
any point.


tthhrreeaadd__ssiiggnnaall((_+_T_h_r_e_a_d_I_d_, _:_G_o_a_l))
    Make thread _T_h_r_e_a_d_I_d execute  _G_o_a_l at the first opportunity.  In the
    current  implementation, this implies at the first pass  through the
    _C_a_l_l  _p_o_r_t.  The  predicate thread_signal/2 itself places _G_o_a_l  into
    the signalled thread's signal queue and returns immediately.

    Signals  (interrupts)  do  not  cooperate well  with  the  world  of
    multithreading,  mainly  because  the status  of mutexes  cannot  be
    guaranteed  easily.   At the call port,  the Prolog virtual  machine
    holds no locks and therefore the asynchronous execution is safe.

    _G_o_a_l  can  be  any valid  Prolog  goal,  including throw/1  to  make
    the  receiving thread generate  an exception,  and trace/0 to  start
    tracing the receiving thread.

    In  the Windows version,  the receiving thread immediately  executes
    the  signal  if  it  reaches  a  Windows  GetMessage()  call,  which
    generally happens if the thread is waiting for (user) input.


99..33..33 TThhrreeaaddss aanndd ddyynnaammiicc pprreeddiiccaatteess

Besides  queues (section  9.3.1)  threads can  share and  exchange  data
using dynamic  predicates.   The multithreaded  version knows about  two
types of dynamic predicates.   By default, a predicate  declared _d_y_n_a_m_i_c
(see dynamic/1)  is shared  by all  threads.   Each  thread may  assert,
retract and  run the dynamic predicate.   Synchronisation inside  Prolog
guarantees  the consistency  of the  predicate.    Updates are  _l_o_g_i_c_a_l:
visible  clauses  are  not affected  by  assert/retract  after  a  query
started on  the predicate.   In many cases  primitives from section  9.4
should be  used to ensure that  application invariants on the  predicate
are maintained.

Besides shared predicates,  dynamic predicates can be declared  with the
thread_local/1 directive.   Such predicates share their attributes,  but
the clause list is different in each thread.


tthhrreeaadd__llooccaall _+_F_u_n_c_t_o_r_/_+_A_r_i_t_y_, _._._.
    This  directive is  related to the  dynamic/1 directive.   It  tells
    the  system  that  the predicate  may  be modified  using  assert/1,
    retract/1,  etc., during  execution of the program.   Unlike  normal
    shared  dynamic data, however, each  thread has its own clause  list
    for  the predicate.  As a thread starts, this clause list  is empty.
    If  there are still  clauses when the  thread terminates, these  are
    automatically  reclaimed by the system  (see also volatile/1).   The
    thread_local property implies the properties _d_y_n_a_m_i_c and _v_o_l_a_t_i_l_e.

    Thread-local   dynamic  predicates  are  intended  for   maintaining
    thread-specific state or intermediate results of a computation.

    It  is not recommended to  put clauses for a thread-local  predicate
    into  a file, as  in the example below,  because the clause is  only
    visible  from the thread  that loaded  the source file.   All  other
    threads start with an empty clause list.

    ____________________________________________________________________|                                                                    |
    | :- thread_local                                                    |

    |         foo/1.                                                     |
    |                                                                    |
    ||foo(gnat).________________________________________________________ ||

    DDIISSCCLLAAIIMMEERR  Whether or  not this declaration  is appropriate in  the
    sense  of the proper mechanism to  reach the goal is still  debated.
    If you have  strong feelings in favour or against, please share them
    in the SWI-Prolog mailing list.


99..44 TThhrreeaadd ssyynncchhrroonniissaattiioonn

All  internal Prolog  operations are  thread-safe.    This implies  that
two Prolog  threads can operate  on the  same dynamic predicate  without
corrupting the consistency  of the predicate.   This section deals  with
user-level  _m_u_t_e_x_e_s (called  _m_o_n_i_t_o_r_s  in ADA  or _c_r_i_t_i_c_a_l  _s_e_c_t_i_o_n_s  by
Microsoft).   A mutex is a  MMUUTTual EEXXclusive device, which implies  that
at most one thread can _h_o_l_d a mutex.

Mutexes are  used to  realise related  updates to  the Prolog  database.
With `related', we refer to the situation where  a `transaction' implies
two  or more  changes to  the Prolog  database.   For  example, we  have
a  predicate address/2,  representing the  address of  a  person and  we
want  to change  the address  by retracting  the old  and asserting  the
new address.    Between these  two operations the  database is  invalid:
this person  has either no  address or two  addresses, depending on  the
assert/retract order.

The  code   below  provides  a  solution   to  this  problem  based   on
with_mutex/2.    It  also illustrates  the  problem  of mutexes.     The
predicate with_mutex/2  behaves as once/1  with respect  to the  guarded
goal.   This  means that  our predicate address/2  is no  longer a  nice
logical non-deterministic  relation.  This  could be solved by  explicit
locking and  unlocking a  mutex using  setup_call_cleanup/2,  but at  the
risk of  deadlocking the  program if the  choice point  is left open  by
accident.

________________________________________________________________________|                                                                        |
|change_address(Id, Address) :-                                          |
|        with_mutex(addressbook,                                         |
|                   ( retractall(address(Id, _)),                        |

|                     asserta(address_db(Id, Address))                   |
|                   )).                                                  |
|                                                                        |
|address(Id, Address) :-                                                 |
|        with_mutex(addressbook,                                         |
||__________________address_db(Id,_Address)).___________________________ ||

Message queues  (see message_queue_create/3) often  provide simpler  and
more robust ways  for threads to communicate.   Still, mutexes can be  a
sensible solution and are therefore provided.


mmuutteexx__ccrreeaattee((_?_M_u_t_e_x_I_d))
    Create  a mutex.  If _M_u_t_e_x_I_d  is an atom, a _n_a_m_e_d mutex  is created.
    If  it is  a variable,  an  anonymous mutex  reference is  returned.
    Anonymous mutexes are subject to (atom) garbage collection.


mmuutteexx__ccrreeaattee((_-_M_u_t_e_x_I_d_, _+_O_p_t_i_o_n_s))
    Create a mutex using options.  Defined options are:

    aalliiaass((_A_l_i_a_s))
         Set the  alias name.   Using mutex_create(_X_, _[_a_l_i_a_s_(_n_a_m_e_)_])  is
         preferred over the equivalent mutex_create(_n_a_m_e).


mmuutteexx__ddeessttrrooyy((_+_M_u_t_e_x_I_d))
    Destroy  a mutex.  If the  mutex is not locked, it is  destroyed and
    further  access yields an existence_error exception.  As  of version
    7.1.19,  this behaviour is  reliable.  If  the mutex is locked,  the
    mutex  is sheduled for  _d_e_l_a_y_e_d _d_e_s_t_r_u_c_t_i_o_n:   it will be  destroyed
    when it becomes unlocked.


wwiitthh__mmuutteexx((_+_M_u_t_e_x_I_d_, _:_G_o_a_l))
    Execute  _G_o_a_l  while  holding  _M_u_t_e_x_I_d.     If  _G_o_a_l  leaves  choice
    points,   these are  destroyed  (as  in  once/1).     The  mutex  is
    unlocked  regardless of whether  _G_o_a_l succeeds,  fails or raises  an
    exception.    An exception  thrown by  _G_o_a_l is  re-thrown after  the
    mutex  has been successfully unlocked.   See also mutex_create/1 and
    setup_call_cleanup/3.

    Although  described in the  thread section,  this predicate is  also
    available  in the single-threaded  version, where it behaves  simply
    as once/1.


mmuutteexx__lloocckk((_+_M_u_t_e_x_I_d))
    Lock the mutex.   Prolog mutexes are _r_e_c_u_r_s_i_v_e mutexes:  they can be
    locked  multiple times by the same thread.  Only after  unlocking it
    as  many times as it is  locked does the mutex become available  for
    locking  by other threads.   If another thread has locked the  mutex
    the calling thread is suspended until the mutex is unlocked.

    If  _M_u_t_e_x_I_d is  an atom,  and there  is no current  mutex with  that
    name,  the  mutex  is  created automatically  using  mutex_create/1.
    This implies named mutexes need not be declared explicitly.

    Please  note that  locking and  unlocking mutexes  should be  paired
    carefully.     Especially  make  sure  to  unlock  mutexes  even  if
    the  protected  code  fails  or  raises an  exception.     For  most
    common  cases,  use with_mutex/2,  which provides  a  safer way  for
    handling  Prolog-level mutexes.   The predicate setup_call_cleanup/3
    is  another  way  to guarantee  that  the  mutex is  unlocked  while
    retaining non-determinism.


mmuutteexx__ttrryylloocckk((_+_M_u_t_e_x_I_d))
    As  mutex_lock/1,  but if the mutex  is held by another thread,  this
    predicates fails immediately.


mmuutteexx__uunnlloocckk((_+_M_u_t_e_x_I_d))
    Unlock  the mutex.  This can only be called if the mutex  is held by
    the  calling thread.   If this is  not the case,  a permission_error
    exception is raised.


mmuutteexx__uunnlloocckk__aallll                                            _[_d_e_p_r_e_c_a_t_e_d_]
    Unlock  all mutexes  held by  the current  thread.   This  predicate
    should  not  be   needed  if  mutex  unlocking  is  guaranteed  with
    with_mutex/2 or setup_call_cleanup/3.


mmuutteexx__pprrooppeerrttyy((_?_M_u_t_e_x_I_d_, _?_P_r_o_p_e_r_t_y))
    True if _P_r_o_p_e_r_t_y is a property of _M_u_t_e_x_I_d.  Defined properties are:

    aalliiaass((_A_l_i_a_s))
         Mutex has the defined alias name.  See mutex_create/2 using the
         `alias' option.

    ssttaattuuss((_S_t_a_t_u_s))
         Current status  of the mutex.    One of unlocked  if the  mutex
         is currently not  locked, or locked(_O_w_n_e_r_,  _C_o_u_n_t) if mutex  is
         locked _C_o_u_n_t times by thread _O_w_n_e_r.  Note that  unless _O_w_n_e_r is
         the calling thread, the  locked status can change at  any time.
         There is  no useful  application of this  property, except  for
         diagnostic purposes.


99..55 TThhrreeaadd ssuuppppoorrtt lliibbrraarryy((tthhrreeaadduuttiill))

This library  defines a  couple of useful  predicates for  demonstrating
and debugging  multithreaded applications.   This  library is  certainly
not complete.


tthhrreeaaddss
    Lists all current threads and their status.


jjooiinn__tthhrreeaaddss
    Join all terminated  threads.  For normal applications, dealing with
    terminated  threads must be  part of  the application logic,  either
    detaching  the thread before termination  or making sure it will  be
    joined.   The  predicate join_threads/0 is intended for  interactive
    sessions  to reclaim resources  from threads that died  unexpectedly
    during development.


iinntteerraaccttoorr
    Create  a new  console  and run  the Prolog  top level  in this  new
    console.   See also attach_console/0.  In the Windows version  a new
    interactor can also be created from the Run/New thread menu.


99..55..11 DDeebbuuggggiinngg tthhrreeaaddss

Support  for  debugging threads  is  still  very  limited.    Debug  and
trace  mode are  flags  that  are local  to  each  thread.    Individual
threads can  be debugged either using  the graphical debugger  described
in  section 3.5  (see tspy/1  and  friends) or  by attaching  a  console
to the  thread and running  the traditional  command line debugger  (see
attach_console/0).   When  using the  graphical debugger,  the  debugger
must  be _l_o_a_d_e_d  from  the main  thread  (for example  using  guitracer)
before gtrace/0 can be called from a thread.


aattttaacchh__ccoonnssoollee
    If  the  current thread  has no  console  attached yet,  attach  one
    and  redirect the  user streams (input,  output, and  error) to  the
    new  console  window.   On  Unix  systems the  console is  an  xterm
    application.    On  Windows systems  this requires  the GUI  version
    swipl-win.exe rather than the console-based swipl.exe.

    This  predicate has  a couple  of useful applications.    One is  to
    separate (debugging) I/O  of different threads.  Another is to start
    debugging  a thread that  is running in the  background.  If  thread
    10  is running,  the following  sequence starts the  tracer on  this
    thread:

    ____________________________________________________________________|                                                                    |
    ||?-_thread_signal(10,_(attach_console,_trace)).____________________ ||


ttddeebbuugg((_+_T_h_r_e_a_d_I_d))
    Prepare  _T_h_r_e_a_d_I_d for debugging  using the graphical  tracer.   This
    implies installing the  tracer hooks in the thread and switching the
    thread  to debug  mode using  debug/0.   The call  is injected  into
    the  thread using thread_signal/2.   We  refer to the  documentation
    of  this predicate for asynchronous  interaction with threads.   New
    threads  created  inherit  their debug  mode  from the  thread  that
    created them.


ttddeebbuugg
    Call tdebug/1 in all running threads.


ttnnooddeebbuugg((_+_T_h_r_e_a_d_I_d))
    Disable debugging thread _T_h_r_e_a_d_I_d.


ttnnooddeebbuugg
    Disable debugging in all threads.


ttssppyy((_:_S_p_e_c_, _+_T_h_r_e_a_d_I_d))
    Set  a spy point as spy/1 and enable the thread for  debugging using
    tdebug/1.   Note that  a spy point is  a global flag on a  predicate
    that  is visible from all threads.   Spy points are honoured  in all
    threads  that are in debug mode  and ignored in threads that are  in
    nodebug mode.


ttssppyy((_:_S_p_e_c))
    Set  a  spy point  as  spy/1 and  enable  debugging in  all  threads
    using  tdebug/0.   Note that removing spy  points can be done  using
    nospy/1.   Disabling spy points in a specific thread is  achieved by
    tnodebug/1.


99..55..22 PPrrooffiilliinngg tthhrreeaaddss

In the  current implementation, at  most one thread  can be profiled  at
any moment.   Any thread can call profile/1 to profile the  execution of
some part of  its code.   The predicate tprofile/1 allows for  profiling
the execution of another thread until the user  stops collecting profile
data.


ttpprrooffiillee((_+_T_h_r_e_a_d_I_d))
    Start  collecting profile data in _T_h_r_e_a_d_I_d  and ask the user to  hit
    <_r_e_t_u_r_n>  to stop the profiler.  See section 4.39 for details on the
    execution profiler.


99..66 MMuullttiitthhrreeaaddeedd mmiixxeedd CC aanndd PPrroolloogg aapppplliiccaattiioonnss

All  foreign code  linked to  the multithreading  version of  SWI-Prolog
should  be   thread-safe  (_r_e_e_n_t_r_a_n_t)   or  guarded   in  Prolog   using
with_mutex/2 from  simultaneous  access  from multiple  Prolog  threads.
If  you want  to write  mixed multithreaded  C  and Prolog  applications
you  should  first  familiarise  yourself  with   writing  multithreaded
applications in C (C++).

If you  are using SWI-Prolog  as an embedded  engine in a  multithreaded
application you  can access the Prolog  engine from multiple threads  by
creating an _e_n_g_i_n_e in  each thread from which you call Prolog.   Without
creating an engine, a thread can only use functions that  do _n_o_t use the
term_t type (for example PL_new_atom()).

The system supports  two models.   Section 9.6.1 describes the  original
one-to-one mapping.   In this schema  a native thread attaches a  Prolog
thread if  it needs  to call Prolog  and detaches it  when finished,  as
opposed to the model  from section 9.6.2, where threads  temporarily use
a Prolog engine.


99..66..11 AA PPrroolloogg tthhrreeaadd ffoorr eeaacchh nnaattiivvee tthhrreeaadd ((oonnee--ttoo--oonnee))

In  the  one-to-one  model,   the  thread  that  called  PL_initialise()
has  a  Prolog   engine  attached.      If  another  C  thread  in   the
system  wishes to  call Prolog  it  must first  attach an  engine  using
PL_thread_attach_engine() and call  PL_thread_destroy_engine()after  all
Prolog  work is  finished.    This  model  is especially  suitable  with
long  running threads  that  need to  do Prolog  work  regularly.    See
section 9.6.2 for the alternative many-to-many model.


int PPLL__tthhrreeaadd__sseellff()
    Returns  the  integer  Prolog identifier  of  the  engine or  -1  if
    the  calling thread has  no Prolog  engine.   This function is  also
    provided  in the  single-threaded version  of  SWI-Prolog, where  it
    returns -2.


int PPLL__uunniiffyy__tthhrreeaadd__iidd(_t_e_r_m___t _t_, _i_n_t _i)
    Unify  _t with the  Prolog thread  identifier for thread  _i.   Thread
    identifiers  are normally returned  from PL_thread_self().   Returns
    -1 if the thread does not exist or the unification fails.


int PPLL__tthhrreeaadd__aattttaacchh__eennggiinnee(_c_o_n_s_t _P_L___t_h_r_e_a_d___a_t_t_r___t _*_a_t_t_r)
    Creates  a new Prolog engine in the calling thread.  If  the calling
    thread  already has an engine the  reference count of the engine  is
    incremented.  The  _a_t_t_r argument can be NULL to create a thread with
    default  attributes.  Otherwise it is a pointer to a  structure with
    the  definition below.   For any field  with value `0', the  default
    is  used.    The cancel  field may  be filled  with a  pointer to  a
    function  that is  called when  PL_cleanup() terminates the  running
    Prolog  engines.  If this  function is not present or returns  FALSE
    pthread_cancel() is  used.   The flags  field defines the  following
    flags:

    PPLL__TTHHRREEAADD__NNOO__DDEEBBUUGG
         If this flag is  present, the thread starts in  normal no-debug
         status.   By default,  the debug status  is inherited from  the
         main thread.

    ____________________________________________________________________|                                                                    |
    | typedef struct                                                     |

    | { unsigned long     local_size;    /* Stack sizes (Kbytes) */      |
    |   unsigned long     global_size;                                   |
    |   unsigned long     trail_size;                                    |
    |   unsigned long     argument_size;                                 |
    |   char *            alias;         /* alias name */                |
    |   int              (*cancel)(int thread);                          |
    |   intptr_t          flags;                                         |
    ||}_PL_thread_attr_t;_______________________________________________ ||

    The  structure may be  destroyed after PL_thread_attach_engine() has
    returned.    On success  it returns  the Prolog  identifier for  the
    thread  (as returned by PL_thread_self()).   If an error occurs,  -1
    is returned.   If this Prolog is not compiled for multithreading, -2
    is returned.


int PPLL__tthhrreeaadd__ddeessttrrooyy__eennggiinnee()
    Destroy  the  Prolog engine  in  the calling  thread.    Only  takes
    effect  if  PL_thread_destroy_engine() is called  as many  times  as
    PL_thread_attach_engine() in this thread.   Returns TRUE on  success
    and  FALSE if the calling thread  has no engine or this Prolog  does
    not support threads.

    Please  note  that  construction  and  destruction  of  engines  are
    relatively  expensive  operations.     Only  destroy  an  engine  if
    performance is not critical and memory is a critical resource.


int PPLL__tthhrreeaadd__aatt__eexxiitt(_v_o_i_d _(_*_f_u_n_c_t_i_o_n_)_(_v_o_i_d _*_)_, _v_o_i_d _*_c_l_o_s_u_r_e_, _i_n_t _g_l_o_b_a_l)
    Register  a handle to be called  as the Prolog engine is  destroyed.
    The  handler function  is called  with one  void * argument  holding
    _c_l_o_s_u_r_e.    If  _g_l_o_b_a_l is  TRUE, the  handler is  installed _f_o_r  _a_l_l
    _t_h_r_e_a_d_s.     Globally  installed handlers  are  executed  after  the
    thread-local  handlers.  If the  handler is installed local for  the
    current thread only (_g_l_o_b_a_l  == FALSE) it is stored in the same FIFO
    queue as used by thread_at_exit/1.


99..66..22 PPoooolliinngg PPrroolloogg eennggiinneess ((mmaannyy--ttoo--mmaannyy))

In this model Prolog engines live as entities that  are independent from
threads.  If a  thread needs to call Prolog it takes one of  the engines
from the pool and returns the engine when done.   This model is suitable
in the following identified cases:

  o _C_o_m_p_a_t_i_b_i_l_i_t_y _w_i_t_h _t_h_e _s_i_n_g_l_e_-_t_h_r_e_a_d_e_d _v_e_r_s_i_o_n
    In  the  single-threaded  version,  foreign threads  must  serialise
    access  to the  one and  only thread engine.    Functions from  this
    section allow sharing one engine among multiple threads.

  o _M_a_n_y _n_a_t_i_v_e _t_h_r_e_a_d_s _w_i_t_h _i_n_f_r_e_q_u_e_n_t _P_r_o_l_o_g _w_o_r_k
    Prolog  threads are expensive in terms of memory and time  to create
    and  destroy them.  For systems  that use a large number  of threads
    that only infrequently need  to call Prolog, it is better to take an
    engine from a pool and return it there.

  o _P_r_o_l_o_g _s_t_a_t_u_s _m_u_s_t _b_e _h_a_n_d_e_d _t_o _a_n_o_t_h_e_r _t_h_r_e_a_d
    This  situation  has  been identified  by  Uwe Lesta  when  creating
    a  .NET interface  for SWI-Prolog.    .NET distributes  work for  an
    active  internet connection over  a pool  of threads.   If a  Prolog
    engine  contains the state for a connection, it must be  possible to
    detach  the engine from a thread and re-attach it to  another thread
    handling the same connection.


PL_engine_t PPLL__ccrreeaattee__eennggiinnee(_P_L___t_h_r_e_a_d___a_t_t_r___t _*_a_t_t_r_i_b_u_t_e_s)
    Create  a  new   Prolog  engine.     _a_t_t_r_i_b_u_t_e_s  is  described  with
    PL_thread_attach_engine().   Any  thread can  make  this call  after
    PL_initialise()  returns  success.    The  returned  engine  is  not
    attached  to any thread and lives  until PL_destroy_engine()is  used
    on the returned handle.

    In  the  single-threaded  version  this call  always  returns  NULL,
    indicating failure.


int PPLL__ddeessttrrooyy__eennggiinnee(_P_L___e_n_g_i_n_e___t _e)
    Destroy  the given engine.  Destroying an engine is only  allowed if
    the engine is not  attached to any thread or attached to the calling
    thread.    On success  this function  returns TRUE,  on failure  the
    return value is FALSE.


int PPLL__sseett__eennggiinnee(_P_L___e_n_g_i_n_e___t _e_n_g_i_n_e_, _P_L___e_n_g_i_n_e___t _*_o_l_d)
    Make  the calling thread ready  to use _e_n_g_i_n_e.   If _o_l_d is  non-NULL
    the  current engine  associated with  the calling  thread is  stored
    at  the  given  location.     If  _e_n_g_i_n_e equals  PL_ENGINE_MAIN  the
    initial  engine is attached  to the  calling thread.   If _e_n_g_i_n_e  is
    PL_ENGINE_CURRENT the  engine is  not  changed.   This  can be  used
    to  query the current  engine.   This call  returns PL_ENGINE_SET  if
    the  engine was switched successfully,  PL_ENGINE_INVAL if _e_n_g_i_n_e  is
    not  a  valid engine  handle and  PL_ENGINE_INUSE  if  the engine  is
    currently in use by another thread.

    Engines  can be changed  at any time.   For  example, it is  allowed
    to  select an engine to initiate a  Prolog goal, detach it and  at a
    later  moment execute the goal from another thread.   Note, however,
    that  the term_t, qid_t and fid_t types are interpreted relative  to
    the  engine for which they are created.  Behaviour when  passing one
    of these types from one engine to another is undefined.

    In  the single-threaded  version this call  only succeeds if  _e_n_g_i_n_e
    refers to the main engine.


99..77 MMuullttiitthhrreeaaddiinngg aanndd tthhee XXPPCCEE ggrraapphhiiccss ssyysstteemm

GUI applications  written in  XPCE can  benefit from  Prolog threads  if
they need  to do expensive computations  that would otherwise block  the
UI. The  XPCE message  passing system  is guarded with  a single  _m_u_t_e_x,
which synchronises  both access from Prolog  and activation through  the
GUI. In MS-Windows, GUI events are processed by  the thread that created
the  window in  which  the  event occurred,  whereas  in  Unix/X11  they
are processed  by the  thread that  dispatches messages.   In  practice,
the most  feasible approach  to graphical Prolog  implementations is  to
control XPCE from  a single thread and  deploy other threads for  (long)
computations.

Traditionally,  XPCE runs  in  the foreground  (main) thread.    We  are
working  towards  a  situation where  XPCE  can  run  comfortably  in  a
separate  thread.     A  separate  XPCE  thread  can  be  created  using
pce_dispatch/1.  It is also possible to create this thread  as the (pce)
is loaded by setting the xpce_threaded to true.

Threads other than the  thread in which XPCE runs are provided  with two
predicates to communicate with XPCE.


iinn__ppccee__tthhrreeaadd((_:_G_o_a_l))                                               _[_d_e_t_]
    Assuming  XPCE is running in the foreground thread, this  call gives
    background  threads  the  opportunity  to make  calls  to  the  XPCE
    thread.    A call to  in_pce_thread/1 succeeds immediately,  copying
    _G_o_a_l  to the XPCE  thread.   _G_o_a_l is added to  the XPCE event  queue
    and  executed  synchronous to  normal user  events  like typing  and
    clicking.


iinn__ppccee__tthhrreeaadd__ssyynncc((_:_G_o_a_l))                                       _[_s_e_m_i_d_e_t_]
    Same  as  in_pce_thread/1,  but  wait  for  _G_o_a_l  to  be  completed.
    Success  depends  on  the  success  of executing  _G_o_a_l.     Variable
    bindings  inside  _G_o_a_l are  visible to  the  caller, but  it  should
    be  noted that  the values  are being  _c_o_p_i_e_d.   If  _G_o_a_l throws  an
    exception,  this exception is re-thrown by  in_pce_thread/1.   If the
    calling  thread is the `pce thread', in_pce_thread_sync/1 executes a
    direct meta-call.  See also pce_thread/1.

    Note   that  in_pce_thread_sync/1  is  expensive   because  it   re-
    quires   copying   and  thread   communication.       For   example,
    in_pce_thread_synctrue runs at approximately 50,000 calls per second
    (AMD Phenom 9600B, Ubuntu 11.04).


ppccee__ddiissppaattcchh((_+_O_p_t_i_o_n_s))
    Create  a  Prolog thread  with the  alias name  pce  for XPCE  event
    handling.    In  the X11  version this  call creates  a thread  that
    executes  the X11  event-dispatch loop.   In  MS-Windows it  creates
    a  thread that  executes a windows  event-dispatch loop.   The  XPCE
    event-handling  thread has  the alias  pce.   _O_p_t_i_o_n_s specifies  the
    thread attributes as thread_create/3.


CChhaapptteerr 1100..  FFOORREEIIGGNN LLAANNGGUUAAGGEE IINNTTEERRFFAACCEE

SWI-Prolog      offers      a     powerful      interface      to      C
[Kernighan & Ritchie, 1978].     The  main  design   objectives  of  the
foreign language interface  are flexibility and performance.   A foreign
predicate is  a C  function that  has the  same number  of arguments  as
the predicate  represented.   C  functions are provided  to analyse  the
passed terms, convert  them to basic C  types as well as to  instantiate
arguments using unification.   Non-deterministic foreign predicates  are
supported,  providing the  foreign  function with  a handle  to  control
backtracking.

C can call  Prolog predicates, providing both  a query interface and  an
interface to extract multiple solutions from  a non-deterministic Prolog
predicate.    There is  no limit  to the  nesting of  Prolog calling  C,
calling Prolog, etc.   It is also possible to write the `main' in  C and
use Prolog as an embedded logical engine.


1100..11 OOvveerrvviieeww ooff tthhee IInntteerrffaaccee

A special include file called SWI-Prolog.h should be included  with each
C source  file that  is to be  loaded via  the foreign interface.    The
installation process installs this file in the directory  include in the
SWI-Prolog home directory (?- current_prolog_flag(home, Home).).  This C
header file  defines various data types,  macros and functions that  can
be used  to communicate with  SWI-Prolog.  Functions  and macros can  be
divided into the following categories:

  o Analysing Prolog terms

  o Constructing new terms

  o Unifying terms

  o Returning control information to Prolog

  o Registering foreign predicates with Prolog

  o Calling Prolog from C

  o Recorded database interactions

  o Global actions on Prolog (halt, break, abort, etc.)


1100..22 LLiinnkkiinngg FFoorreeiiggnn MMoodduulleess

Foreign modules  may be  linked to  Prolog in two  ways.   Using  _s_t_a_t_i_c
_l_i_n_k_i_n_g, the extensions,  a (short) file defining main()  which attaches
the extension  calls to  Prolog, and the  SWI-Prolog kernel  distributed
as a  C library, are linked  together to form a  new executable.   Using
_d_y_n_a_m_i_c _l_i_n_k_i_n_g,  the extensions  are linked  to a  shared library  (.so
file  on most  Unix  systems) or  dynamic  link  library (.DLL  file  on
Microsoft platforms) and loaded into the running Prolog process.


1100..22..11 WWhhaatt lliinnkkiinngg iiss pprroovviiddeedd??

The _s_t_a_t_i_c  _l_i_n_k_i_n_g schema can  be used on  all versions of  SWI-Prolog.
Whether or  not dynamic  linking is  supported can be  deduced from  the
Prolog  flag open_shared_object (see  current_prolog_flag/2).    If  this
Prolog flag yields true, open_shared_object/2 and related predicates are
defined.   See  section 10.2.3  for a suitable  high-level interface  to
these predicates.


1100..22..22 WWhhaatt kkiinndd ooff llooaaddiinngg sshhoouulldd II bbee uussiinngg??

All  described  approaches  have  their  advantages  and  disadvantages.
Static linking  is portable and allows  for debugging on all  platforms.
It is relatively  cumbersome and the libraries  you need to pass to  the
linker  may vary  from  system to  system,  though the  utility  program
swipl-ld described in  section 10.5 often hides these problems  from the
user.

Loading  shared objects  (DLL  files on  Windows) provides  sharing  and
protection  and is  generally the  best choice.    If a  saved state  is
created using qsave_program/[1,2], an initialization/1 directive  may be
used to load the appropriate library at startup.

Note  that  the  definition of  the  foreign  predicates  is  the  same,
regardless of the linking type used.


1100..22..33 lliibbrraarryy((sshhlliibb))::   UUttiilliittyy  lliibbrraarryy  ffoorr llooaaddiinngg  ffoorreeiiggnn  oobbjjeeccttss
       ((DDLLLLss,, sshhaarreedd oobbjjeeccttss))

This   section   discusses   the   functionality   of   the   (autoload)
library(shlib), providing an  interface to manage shared libraries.   We
describe the procedure for using a foreign resource (DLL  in Windows and
shared object in Unix) called mylib.

First,  one  must  assemble  the resource  and  make  it  compatible  to
SWI-Prolog.    The  details  for  this  vary between  platforms.     The
swipl-ld(1) utility can be used to deal with this  in a portable manner.
The typical commandline is:

________________________________________________________________________|                                                                        |
|swipl-ld|-o_mylib_file.{c,o,cc,C}_...__________________________________ |        |

Make  sure   that  one  of   the  files   provides  a  global   function
install_mylib()   that   initialises   the   module   using   calls   to
PL_register_foreign().   Here  is a  simple example  file mylib.c,  which
creates a Windows MessageBox:

________________________________________________________________________|                                                                        |

|#include <windows.h>                                                    |
|#include <SWI-Prolog.h>                                                 |
|                                                                        |
|static foreign_t                                                        |
|pl_say_hello(term_t to)                                                 |
|{ char *a;                                                              |

|                                                                        |
|  if ( PL_get_atom_chars(to, &a) )                                      |
|  { MessageBox(NULL, a, "DLL test", MB_OK|MB_TASKMODAL);                |
|                                                                        |
|    PL_succeed;                                                         |
|  }                                                                     |
|                                                                        |
|  PL_fail;                                                              |

|}                                                                       |
|                                                                        |
|install_t                                                               |
|install_mylib()                                                         |
|{ PL_register_foreign("say_hello", 1, pl_say_hello, 0);                 |
|}|_____________________________________________________________________ | |

Now write a file mylib.pl:

________________________________________________________________________|                                                                        |

|:- module(mylib, [ say_hello/1 ]).                                      |
|:-|use_foreign_library(foreign(mylib)).________________________________ |  |

The file  mylib.pl can be  loaded as a normal  Prolog file and  provides
the predicate defined in C.


llooaadd__ffoorreeiiggnn__lliibbrraarryy((_:_F_i_l_e_S_p_e_c))                                    _[_d_e_t_]


llooaadd__ffoorreeiiggnn__lliibbrraarryy((_:_F_i_l_e_S_p_e_c_, _+_E_n_t_r_y_:_a_t_o_m))                       _[_d_e_t_]
    Load  a  _s_h_a_r_e_d _o_b_j_e_c_t  or  _D_L_L. After  loading the  _E_n_t_r_y  function
    is  called  without  arguments.    The  default  entry  function  is
    composed  from =install_=, followed by  the file  base-name.   E.g.,
    the  load-call below  calls the  function install_mylib().   If  the
    platform  prefixes extern functions  with =_=,  this prefix is  added
    before calling.

    ____________________________________________________________________|                                                                    |
    |       ...                                                          |

    |       load_foreign_library(foreign(mylib)),                        |
    ||______..._________________________________________________________ ||

    ___________________________________________________________Arguments_
     _F_i_l_e_S_p_e_c  is  a  specification  for  absolute_file_name/3.
               If  searching  the file  fails, the  plain  name

               is   passed  to  the  OS  to  try  the   default
               method  of the OS for locating foreign  objects.
               The  default  definition  of  file_search_path/2
               searches  <prolog home>/lib/<arch> on Unix and
               <prolog home>/bin on Windows.

         SSeeee aallssoo use_foreign_library/1,2 are  intended for  use in
             directives.


uussee__ffoorreeiiggnn__lliibbrraarryy((_+_F_i_l_e_S_p_e_c))                                     _[_d_e_t_]


uussee__ffoorreeiiggnn__lliibbrraarryy((_+_F_i_l_e_S_p_e_c_, _+_E_n_t_r_y_:_a_t_o_m))                        _[_d_e_t_]
    Load  and install a foreign  library as load_foreign_library/1,2  and
    register  the installation  using initialization/2  with the  option
    now.  This is similar to using:

    ____________________________________________________________________|                                                                    |
    ||:-_initialization(load_foreign_library(foreign(mylib))).__________ ||

    but  using the  initialization/1 wrapper  causes the  library to  be
    loaded  _a_f_t_e_r loading of the file in which it appears  is completed,
    while  use_foreign_library/1 loads the  library _i_m_m_e_d_i_a_t_e_l_y.    I.e.
    the  difference is only relevant if  the remainder of the file  uses
    functionality of the C-library.


uunnllooaadd__ffoorreeiiggnn__lliibbrraarryy((_+_F_i_l_e_S_p_e_c))                                  _[_d_e_t_]


uunnllooaadd__ffoorreeiiggnn__lliibbrraarryy((_+_F_i_l_e_S_p_e_c_, _+_E_x_i_t_:_a_t_o_m))                      _[_d_e_t_]
    Unload  a _s_h_a_r_e_d  _o_b_j_e_c_t or  _D_L_L. After calling  the _E_x_i_t  function,
    the  shared  object  is removed  from  the  process.    The  default
    exit  function is composed  from =uninstall_=,  followed by the  file
    base-name.


ccuurrrreenntt__ffoorreeiiggnn__lliibbrraarryy((_?_F_i_l_e_, _?_P_u_b_l_i_c))
    Query currently loaded shared libraries.


rreellooaadd__ffoorreeiiggnn__lliibbrraarriieess
    Reload  all  foreign  libraries loaded  (after  restore of  a  state
    created using qsave_program/2.


1100..22..44 LLooww--lleevveell ooppeerraattiioonnss oonn sshhaarreedd lliibbrraarriieess

The interface  defined in this  section allows the  user to load  shared
libraries  (.so files  on most  Unix systems,  .dll  files on  Windows).
This  interface is  portable to  Windows  as well  as to  Unix  machines
providing  dlopen(2)  (Solaris,  Linux,  FreeBSD, Irix  and  many  more)
or  shl_open(2) (HP/UX).  It  is  advised to  use  the  predicates  from
section 10.2.3 in your application.


ooppeenn__sshhaarreedd__oobbjjeecctt((_+_F_i_l_e_, _-_H_a_n_d_l_e))
    _F_i_l_e  is  the name  of a  shared object  file  (DLL in  MS-Windows).
    This   file  is  attached  to   the  current  process,  and   _H_a_n_d_l_e
    is   unified  with  a  handle  to  the  library.      Equivalent  to
    open_shared_object(File, Handle, []).  See also open_shared_object/3
    and load_foreign_library/1.

    On  errors, an  exception shared_object(_A_c_t_i_o_n_, _M_e_s_s_a_g_e) is  raised.
    _M_e_s_s_a_g_e is the return value from dlerror().


ooppeenn__sshhaarreedd__oobbjjeecctt((_+_F_i_l_e_, _-_H_a_n_d_l_e_, _+_O_p_t_i_o_n_s))
    As  open_shared_object/2, but  allows  for  additional flags  to  be
    passed.   _O_p_t_i_o_n_s is a list of  atoms.  now implies the  symbols are
    resolved  immediately rather  than lazy (default).   global  implies
    symbols of the  loaded object are visible while loading other shared
    objects (by default they  are local).  Note that these flags may not
    be  supported by your operating system.  Check the  documentation of
    dlopen() or equivalent  on your operating system.  Unsupported flags
    are silently ignored.


cclloossee__sshhaarreedd__oobbjjeecctt((_+_H_a_n_d_l_e))
    Detach the shared object identified by _H_a_n_d_l_e.


ccaallll__sshhaarreedd__oobbjjeecctt__ffuunnccttiioonn((_+_H_a_n_d_l_e_, _+_F_u_n_c_t_i_o_n))
    Call the named function  in the loaded shared library.  The function
    is  called  without  arguments  and the  return  value  is  ignored.
    Normally  this function installs  foreign language predicates  using
    calls to PL_register_foreign().


1100..22..55 SSttaattiicc LLiinnkkiinngg

Below  is an  outline  of the  file  structure required  for  statically
linking SWI-Prolog  with foreign extensions.    .../swipl refers to  the
SWI-Prolog home directory (see the  Prolog flag home).  <_a_r_c_h> refers to
the architecture identifier  that may be obtained using the  Prolog flag
arch.

   .../swipl/runtime/<_a_r_c_h>/libswipl.a SWI-Library
   .../swipl/include/SWI-Prolog.h      Include file
   .../swipl/include/SWI-Stream.h      Stream I/O include file
   .../swipl/include/SWI-Exports       Export declarations (AIX only)
   .../swipl/include/stub.c            Extension stub

The definition  of the  foreign predicates  is the same  as for  dynamic
linking.      Unlike  with  dynamic  linking,   however,  there  is   no
initialisation  function.   Instead,  the file  .../swipl/include/stub.c
may  be copied  to  your project  and  modified  to define  the  foreign
extensions.   Below is  stub.c, modified to  link the lowercase  example
described later in this chapter:

________________________________________________________________________|                                                                        |
|#include <stdio.h>                                                      |
|#include <SWI-Prolog.h>                                                 |

|                                                                        |
|extern foreign_t pl_lowercase(term, term);                              |
|                                                                        |
|PL_extension predicates[] =                                             |
|{                                                                       |
|/*{ "name",      arity,  function,      PL_FA_<flags> },*/              |
|                                                                        |

|  { "lowercase", 2       pl_lowercase,  0 },                            |
|  { NULL,        0,      NULL,          0 } /* terminating line */      |
|};                                                                      |
|                                                                        |
|                                                                        |
|int                                                                     |
|main(int argc, char **argv)                                             |
|{ PL_register_extensions(predicates);                                   |

|                                                                        |
|  if ( !PL_initialise(argc, argv) )                                     |
|    PL_halt(1);                                                         |
|                                                                        |
|  PL_install_readline();                /* delete if not required */    |
|                                                                        |
|  PL_halt(PL_toplevel() ? 0 : 1);                                       |

|}|_____________________________________________________________________ | |

Now,  a  new  executable may  be  created  by compiling  this  file  and
linking  it to  libpl.a from  the runtime  directory  and the  libraries
required  by both  the  extensions and  the  SWI-Prolog  kernel.    This
may be  done by  hand, or  by using  the swipl-ld  utility described  in
section 10.5.   If the  linking is performed  by hand, the command  line
option -dump-runtime-variables (see  section 2.4) can be used to  obtain
the  required paths,  libraries  and linking  options  to link  the  new
executable.


1100..33 IInntteerrffaaccee DDaattaa TTyyppeess


1100..33..11 TTyyppee term_t::  aa rreeffeerreennccee ttoo aa PPrroolloogg tteerrmm

The principal data  type is term_t.   Type term_t is what Quintus  calls
QP_term_ref.   This name indicates  better what the type represents:   it
is a _h_a_n_d_l_e for a  term rather than the term itself.  Terms can  only be
represented and manipulated  using this type, as  this is the only  safe
way to  ensure the  Prolog kernel is  aware of  all terms referenced  by
foreign code  and thus allows the  kernel to perform garbage  collection
and/or stack-shifts while foreign  code is active, for example  during a
callback from C.

A term  reference is  a C unsigned  long, representing  the offset of  a
variable on the Prolog environment stack.  A  foreign function is passed
term references for the predicate arguments, one for each  argument.  If
references for intermediate  results are needed, such references  may be
created using PL_new_term_ref() or PL_new_term_refs().   These references
normally live till the foreign function returns control  back to Prolog.
Their scope can  be explicitly limited using PL_open_foreign_frame() and
PL_close_foreign_frame()/PL_discard_foreign_frame().

A term_t always refers to a valid Prolog term (variable,  atom, integer,
float  or compound  term).    A  term  lives either  until  backtracking
takes  us back  to a  point before  the term  was created,  the  garbage
collector  has collected  the term,  or  the term  was created  after  a
PL_open_foreign_frame()and PL_discard_foreign_frame()has been called.

The  foreign interface  functions can  either _r_e_a_d,  _u_n_i_f_y  or _w_r_i_t_e  to
term references.   In  this document we use  the following notation  for
arguments of type term_t:

     term_t +t  Accessed in  read-mode.  The  `+' indicates the
                argument is `input'.
     term_t -t  Accessed in write-mode.
     term_t ?t  Accessed in unify-mode.

Term references are obtained in any of the following ways:

  o _P_a_s_s_e_d _a_s _a_r_g_u_m_e_n_t
    The  C functions  implementing foreign predicates  are passed  their
    arguments  as term  references.   These  references may  be read  or
    unified.  Writing to these variables causes undefined behaviour.

  o _C_r_e_a_t_e_d _b_y PL_new_term_ref()
    A  term  created  by  PL_new_term_ref() is normally  used  to  build
    temporary terms or  to be written by one of the interface functions.
    For  example, PL_get_arg() writes a reference  to the term  argument
    in its last argument.

  o _C_r_e_a_t_e_d _b_y PL_new_term_refs(_i_n_t _n)
    This  function  returns  a set  of  term  references with  the  same
    characteristics as PL_new_term_ref().  See PL_open_query().

  o _C_r_e_a_t_e_d _b_y PL_copy_term_ref(_t_e_r_m___t _t)
    Creates a new term  reference to the same term as the argument.  The
    term may be written to.  See figure 10.2.

Term  references can  safely be  copied  to other  C variables  of  type
term_t, but all copies will always refer to the same term.


term_t PPLL__nneeww__tteerrmm__rreeff()
    Return  a fresh reference  to a  term.   The reference is  allocated
    on  the _l_o_c_a_l  stack.   Allocating a  term reference  may trigger  a
    stack-shift  on machines  that cannot use  sparse memory  management
    for  allocation  of  the Prolog  stacks.    The  returned  reference
    describes a variable.


term_t PPLL__nneeww__tteerrmm__rreeffss(_i_n_t _n)
    Return  _n  new  term  references.    The  first  term  reference  is
    returned.   The others are _t +1, _t +2, etc.   There are two reasons
    for  using this function.   PL_open_query()expects the  arguments as
    a  set of consecutive term  references, and _v_e_r_y time-critical  code
    requiring a number of term references can be written as:

    ____________________________________________________________________|                                                                    |
    | pl_mypredicate(term_t a0, term_t a1)                               |

    | { term_t t0 = PL_new_term_refs(2);                                 |
    |   term_t t1 = t0+1;                                                |
    |                                                                    |
    |   ...                                                              |
    ||}_________________________________________________________________ ||


term_t PPLL__ccooppyy__tteerrmm__rreeff(_t_e_r_m___t _f_r_o_m)
    Create a new term  reference and make it point initially to the same
    term  as _f_r_o_m.  This function  is commonly used to copy  a predicate
    argument to a term reference that may be written.


void PPLL__rreesseett__tteerrmm__rreeffss(_t_e_r_m___t _a_f_t_e_r)
    Destroy  all term  references that  have been  created after  _a_f_t_e_r,
    including  _a_f_t_e_r itself.    Any  reference to  the invalidated  term
    references after this call results in undefined behaviour.

    Note  that  returning  from  the  foreign  context  to  Prolog  will
    reclaim  all references  used in  the foreign  context.   This  call
    is  only necessary  if  references are  created inside  a loop  that
    never  exits  back to  Prolog.    See  also  PL_open_foreign_frame(),
    PL_close_foreign_frame() and PL_discard_foreign_frame().


1100..33..11..11 IInntteerraaccttiioonn wwiitthh tthhee ggaarrbbaaggee ccoolllleeccttoorr aanndd ssttaacckk--sshhiifftteerr

Prolog implements two  mechanisms for avoiding stack overflow:   garbage
collection and stack expansion.   On machines that allow for  it, Prolog
will use virtual  memory management to detect stack overflow  and expand
the  runtime stacks.    On  other machines  Prolog will  reallocate  the
stacks and  update all  pointers to them.    To do so,  Prolog needs  to
know which data  is referenced by C code.   As all Prolog data  known by
C is  referenced through  term references (term_t),  Prolog has all  the
information necessary to  perform its memory management without  special
precautions from the C programmer.


1100..33..22 OOtthheerr ffoorreeiiggnn iinntteerrffaaccee ttyyppeess

aattoomm__tt An atom in Prolog's internal representation.   Atoms are pointers
    to  an  opaque structure.    They are  a  unique representation  for
    represented  text, which  implies that  atom A  represents the same
    text as atom B  if and only if A and B are the same pointer.

    Atoms  are  the  central  representation for  textual  constants  in
    Prolog.    The transformation of  a character  string C  to an atom
    implies  a hash-table lookup.  If the same atom is needed  often, it
    is  advised to  store its reference  in a  global variable to  avoid
    repeated lookup.

ffuunnccttoorr__tt A  functor is  the  internal  representation of  a  name/arity
    pair.   They are used to find the name and arity of  a compound term
    as  well as to construct new compound  terms.  Like atoms  they live
    for the whole Prolog session and are unique.

pprreeddiiccaattee__tt Handle  to a  Prolog  predicate.    Predicate  handles  live
    forever (although they can lose their definition).

qqiidd__tt Query identifier.  Used by  PL_open_query(), PL_next_solution() and
    PL_close_query() to handle backtracking from C.

ffiidd__tt Frame   identifier.       Used   by   PL_open_foreign_frame()  and
    PL_close_foreign_frame().

mmoodduullee__tt A module is  a unique handle to a  Prolog module.  Modules  are
    used only to call predicates in a specific module.

ffoorreeiiggnn__tt Return type for a C function implementing a Prolog predicate.

ccoonnttrrooll__tt Passed  as additional  argument to  non-deterministic  foreign
    functions.  See PL_retry*() and PL_foreign_context*().

iinnssttaallll__tt Type for the install() and uninstall() functions  of shared or
    dynamic link libraries.  See section 10.2.3.

iinntt6644__tt Actually  part of  the C99  standard  rather than  Prolog.    As
    of  version  5.5.6,  Prolog integers  are  64-bit on  all  hardware.
    The  C99 type  int64_t is defined  in the  stdint.h standard  header
    and  provides platform-independent 64-bit  integers.  Portable  code
    accessing  Prolog should use this  type to exchange integer  values.
    Please  note that PL_get_long() can return FALSE on Prolog  integers
    that  cannot be represented  as a C  long.   Robust code should  not
    assume  any of the  integer fetching functions  to succeed, _e_v_e_n  if
    the Prolog term is known to be an integer.


1100..44 TThhee FFoorreeiiggnn IInncclluuddee FFiillee


1100..44..11 AArrgguummeenntt PPaassssiinngg aanndd CCoonnttrrooll

If  Prolog encounters  a foreign  predicate  at run  time it  will  call
a  function  specified  in  the  predicate  definition  of  the  foreign
predicate.   The arguments 1;:::; <_a_r_i_t_y>pass the  Prolog arguments to the
goal as  Prolog terms.   Foreign  functions should  be declared of  type
foreign_t.   Deterministic foreign  functions have  two alternatives  to
return control back to Prolog:


_(_r_e_t_u_r_n_) _f_o_r_e_i_g_n___t PPLL__ssuucccceeeedd(())
    Succeed deterministically.  PL_succeed is defined as return TRUE.


_(_r_e_t_u_r_n_) _f_o_r_e_i_g_n___t PPLL__ffaaiill(())
    Fail  and  start  Prolog  backtracking.     PL_fail  is  defined  as
    return FALSE.


1100..44..11..11 NNoonn--ddeetteerrmmiinniissttiicc FFoorreeiiggnn PPrreeddiiccaatteess

By  default   foreign  predicates   are  deterministic.      Using   the
PL_FA_NONDETERMINISTIC   attribute  (see   PL_register_foreign())  it   is
possible  to register  a  predicate  as a  non-deterministic  predicate.
Writing   non-deterministic   foreign  predicates   is   slightly   more
complicated  as  the  foreign function  needs  context  information  for
generating  the next  solution.   Note  that the  same foreign  function
should  be  prepared  to be  simultaneously  active  in  more  than  one
goal.     Suppose  the  natural_number_below_n/2  is  a  non-deterministic
foreign predicate, backtracking over all natural numbers  lower than the
first argument.  Now consider the following predicate:

________________________________________________________________________|                                                                        |
|quotient_below_n(Q, N) :-                                               |

|        natural_number_below_n(N, N1),                                  |
|        natural_number_below_n(N, N2),                                  |
||_______Q_=:=_N1_/_N2,_!.______________________________________________ ||

In  this predicate  the function  natural_number_below_n/2  simultaneously
generates solutions for both its invocations.

Non-deterministic foreign functions  should be prepared to handle  three
different calls from Prolog:

  o _I_n_i_t_i_a_l _c_a_l_l _(PL_FIRST_CALL_)
    Prolog  has just created a frame  for the foreign function and  asks
    it to produce the first answer.

  o _R_e_d_o _c_a_l_l _(PL_REDO_)
    The previous invocation  of the foreign function associated with the
    current  goal indicated it was possible  to backtrack.  The  foreign
    function should produce the next solution.

  o _T_e_r_m_i_n_a_t_e _c_a_l_l _(PL_PRUNED_)
    The choice point  left by the foreign function has been destroyed by
    a  cut.  The foreign function is given the opportunity to  clean the
    environment.

Both  the  context  information  and  the  type  of   call  is  provided
by  an  argument  of  type  control_t  appended  to  the  argument  list
for  deterministic foreign  functions.   The  macro PL_foreign_control()
extracts  the   type  of  call   from  the  control   argument.      The
foreign  function  can  pass  a context  handle  using  the  PL_retry*()
macros  and  extract  the handle  from  the  extra  argument  using  the
PL_foreign_context*() macro.


_(_r_e_t_u_r_n_) _f_o_r_e_i_g_n___t PPLL__rreettrryy((_i_n_t_p_t_r___t _v_a_l_u_e))
    The  foreign function  succeeds while leaving  a choice  point.   On
    backtracking  over this  goal the  foreign function  will be  called
    again,  but  the  control argument  now  indicates  it is  a  `Redo'
    call  and the macro  PL_foreign_context() returns the handle  passed
    via  PL_retry().   This handle is  a signed  value two bits  smaller
    than  a  pointer,  i.e.,  30  or 62  bits  (two bits  are  used  for
    status  indication).    Defined as  return _PL_retry(_n).    See  also
    PL_succeed().


_(_r_e_t_u_r_n_) _f_o_r_e_i_g_n___t PPLL__rreettrryy__aaddddrreessss((_v_o_i_d _*))
    As  PL_retry(),  but ensures  an address as  returned by malloc()  is
    correctly  recovered  by PL_foreign_context_address().    Defined  as
    return  _PL_retry_address(_n).  See also PL_succeed().


_i_n_t PPLL__ffoorreeiiggnn__ccoonnttrrooll((_c_o_n_t_r_o_l___t))
    Extracts  the type of  call from the control  argument.  The  return
    values  are  described above.    Note that  the  function should  be
    prepared  to handle the PL_PRUNED case and should be aware  that the
    other arguments are not valid in this case.


_i_n_t_p_t_r___t PPLL__ffoorreeiiggnn__ccoonntteexxtt((_c_o_n_t_r_o_l___t))
    Extracts  the context from the context  argument.  If the call  type
    is  PL_FIRST_CALL the context value is 0L. Otherwise it  is the value
    returned  by the last PL_retry() associated with this goal  (both if
    the call type is PL_REDO or PL_PRUNED).


_v_o_i_d _* PPLL__ffoorreeiiggnn__ccoonntteexxtt__aaddddrreessss((_c_o_n_t_r_o_l___t))
    Extracts an address as passed in by PL_retry_address().


_p_r_e_d_i_c_a_t_e___t PPLL__ffoorreeiiggnn__ccoonntteexxtt__pprreeddiiccaattee((_c_o_n_t_r_o_l___t))
    Fetch  the Prolog predicate that is  executing this function.   Note
    that if the  predicate is imported, the returned predicate refers to
    the  final definition rather than the imported predicate,  i.e., the
    module  reported by PL_predicate_info() is the  module in which  the
    predicate  is defined rather  than the module  where it was  called.
    See also PL_predicate_info().

Note:     If  a   non-deterministic  foreign   function  returns   using
PL_succeed() or  PL_fail(),  Prolog  assumes the  foreign  function  has
cleaned its environment.   NNoo call with control  argument PL_PRUNED will
follow.

The  code  of figure  10.1  shows  a skeleton  for  a  non-deterministic
foreign predicate definition.
________________________________________________________________________|                                                                        |
|typedef struct                  /* define a context structure */        |

|{ ...                                                                   |
|} context;                                                              |
|                                                                        |
|foreign_t                                                               |
|my_function(term_t a0, term_t a1, control_t handle)                     |
|{ struct context * ctxt;                                                |
|                                                                        |
|  switch( PL_foreign_control(handle) )                                  |

|  { case PL_FIRST_CALL:                                                 |
|        ctxt = malloc(sizeof(struct context));                          |
|        ...                                                             |
|        PL_retry_address(ctxt);                                         |
|    case PL_REDO:                                                       |
|        ctxt = PL_foreign_context_address(handle);                      |
|        ...                                                             |

|        PL_retry_address(ctxt);                                         |
|    case PL_PRUNED:                                                     |
|        ctxt = PL_foreign_context_address(handle);                      |
|        ...                                                             |
|        free(ctxt);                                                     |
|        PL_succeed;                                                     |
|  }                                                                     |
|}|_____________________________________________________________________ | |

     Figure 10.1:  Skeleton for non-deterministic foreign functions


1100..44..22 AAttoommss aanndd ffuunnccttoorrss

The  following  functions  provide for  communication  using  atoms  and
functors.


atom_t PPLL__nneeww__aattoomm(_c_o_n_s_t _c_h_a_r _*)
    Return  an  atom handle  for  the given  C-string.    This  function
    always  succeeds.    The returned  handle is  valid as  long as  the
    atom  is referenced  (see section  10.4.2.1).   The following  atoms
    are  provided as  macros,  giving access  to the  empty list  symbol
    and  the  name  of  the list  constructor.    Prior  to  version  7,
    ATOM_nil is  the same as PL_new_atom(_"_[_]_") and ATOM_dot is the  same
    as  PL_new_atom(_"_._").    This is  no  long  the case  in  SWI-Prolog
    version 7.


_a_t_o_m___t AATTOOMM__nniill((_A))
     tomic  constant  that  represents  the  empty  list.     It  is
     adviced  to  use  PL_get_nil(),  PL_put_nil() or  PL_unify_nil()
     where applicable.


_a_t_o_m___t AATTOOMM__ddoott((_A))
     tomic  constant that  represents  the  name of  the  list  con-
     structor.    The  list  constructor  itself  is  created  using
     PL_new_functor(_A_T_O_M___d_o_t_,_2).  It is adviced to use PL_get_list(),
     PL_put_list()or PL_unify_list() where applicable.


const char* PPLL__aattoomm__cchhaarrss(_a_t_o_m___t _a_t_o_m)
    Return  a C-string for the text represented by the given atom.   The
    returned  text will not  be changed by  Prolog.   It is not  allowed
    to  modify the  contents,  not even  `temporary' as  the string  may
    reside  in read-only memory.   The  returned string becomes  invalid
    if  the atom is garbage collected  (see section 10.4.2.1).   Foreign
    functions  that require  the text from  an atom  passed in  a term_t
    normally use PL_get_atom_chars() or PL_get_atom_nchars().


functor_t PPLL__nneeww__ffuunnccttoorr(_a_t_o_m___t _n_a_m_e_, _i_n_t _a_r_i_t_y)
    Returns  a _f_u_n_c_t_o_r  _i_d_e_n_t_i_f_i_e_r, a  handle for  the name/arity  pair.
    The returned handle is valid for the entire Prolog session.


atom_t PPLL__ffuunnccttoorr__nnaammee(_f_u_n_c_t_o_r___t _f)
    Return an atom representing the name of the given functor.


int PPLL__ffuunnccttoorr__aarriittyy(_f_u_n_c_t_o_r___t _f)
    Return the arity of the given functor.


1100..44..22..11 AAttoommss aanndd aattoomm ggaarrbbaaggee ccoolllleeccttiioonn

With  the introduction  of  atom garbage  collection in  version  3.3.0,
atoms  no  longer  live  as  long  as  the  process.    Instead,   their
lifetime is  guaranteed only as  long as  they are referenced.   In  the
single-threaded version,  atom garbage collections  are only invoked  at
the  _c_a_l_l_-_p_o_r_t.   In  the multithreaded  version (see  chapter 9),  they
appear asynchronously, except for the invoking thread.

For dealing with  atom garbage collection, two additional  functions are
provided:


void PPLL__rreeggiisstteerr__aattoomm(_a_t_o_m___t _a_t_o_m)
    Increment  the reference count  of the  atom by one.   PL_new_atom()
    performs  this automatically,  returning  an atom  with a  reference
    count of at least one.


void PPLL__uunnrreeggiisstteerr__aattoomm(_a_t_o_m___t _a_t_o_m)
    Decrement  the reference count of the atom.  If the  reference count
    drops below zero, an assertion error is raised.

Please note that the  following two calls are different with  respect to
atom garbage collection:

________________________________________________________________________|                                                                        |

|PL_unify_atom_chars(t, "text");                                         |
|PL_unify_atom(t,|PL_new_atom("text"));_________________________________ |                |

The  latter increments  the  reference count  of  the atom  text,  which
effectively ensures the atom will never be collected.   It is advised to
use the *_chars() or *_nchars() functions whenever applicable.


1100..44..33 AAnnaallyyssiinngg TTeerrmmss vviiaa tthhee FFoorreeiiggnn IInntteerrffaaccee

Each argument  of a foreign function  (except for the control  argument)
is of type term_t, an opaque  handle to a Prolog term.  Three  groups of
functions are  available for  the analysis  of terms.    The first  just
validates the  type,  like the  Prolog predicates var/1,  atom/1,  etc.,
and are  called PL_is_*().   The second  group attempts to translate  the
argument into a C primitive type.   These predicates take a term_t and a
pointer to the appropriate C type and return TRUE  or FALSE depending on
successful or unsuccessful translation.   If the translation fails,  the
pointed-to data is never modified.


1100..44..33..11 TTeessttiinngg tthhee ttyyppee ooff aa tteerrmm


int PPLL__tteerrmm__ttyyppee(_t_e_r_m___t)
    Obtain  the type  of a  term,  which should  be a  term returned  by
    one  of the  other interface  predicates or passed  as an  argument.
    The  function  returns the  type  of  the Prolog  term.    The  type
    identifiers  are listed below.   Note that the extraction  functions
    PL_get_*() also validate  the type and  thus the two sections  below
    are equivalent.

    ____________________________________________________________________|                                                                    |
    |         if ( PL_is_atom(t) )                                       |

    |         { char *s;                                                 |
    |                                                                    |
    |           PL_get_atom_chars(t, &s);                                |
    |           ...;                                                     |
    |         }                                                          |
    |                                                                    |
    | or                                                                 |
    |                                                                    |

    |         char *s;                                                   |
    |         if ( PL_get_atom_chars(t, &s) )                            |
    |         { ...;                                                     |
    ||________}_________________________________________________________ ||

    VVeerrssiioonn  77  added PL_NIL, PL_BLOB,  PL_LIST_PAIR  and PL_DICT.  Older
    versions  classify  PL_NIL  and PL_BLOB  as PL_ATOM,  PL_LIST_PAIR  as
    PL_TERM and do not have dicts.

    _______________________________________________________________
    | PL_VARIABLE            |A variable or attributed variable    |
    | PL_ATOM                |A Prolog atom                        |
    | PL_NIL                 |The constant []                      |
    | PL_BLOB                |A blob (see section 10.4.7.2)        |
    | PL_STRING              |A string (see section 5.2)           |
    | PL_INTEGER             |A integer                            |

    | PL_FLOAT               |A floating point number              |
    | PL_TERM                |A compound term                      |
    | PL_LIST_PAIR           |A list cell ([H|T])                  |
    |_PL_DICT________________|A_dict_(see_section_5.4))____________|

The functions PL_is_<_t_y_p_e> are an alternative to PL_term_type().  The test
PL_is_variable(_t_e_r_m) is equivalent to  PL_term_type(_t_e_r_m)== PL_VARIABLE,
but  the first  is considerably  faster.   On  the other  hand, using  a
switch over  PL_term_type() is faster  and more readable  then using  an
if-then-else using  the functions  below.   All  these functions  return
either TRUE or FALSE.


int PPLL__iiss__vvaarriiaabbllee(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is a variable.


int PPLL__iiss__ggrroouunndd(_t_e_r_m___t)
    Returns  non-zero if  _t_e_r_m is  a ground term.    See also  ground/1.
    This function is cycle-safe.


int PPLL__iiss__aattoomm(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is an atom.


int PPLL__iiss__ssttrriinngg(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is a string.


int PPLL__iiss__iinntteeggeerr(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is an integer.


int PPLL__iiss__ffllooaatt(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is a float.


int PPLL__iiss__ccaallllaabbllee(_t_e_r_m___t)
    Returns  non-zero if _t_e_r_m  is a callable term.   See callable/1  for
    details.


int PPLL__iiss__ccoommppoouunndd(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is a compound term.


int PPLL__iiss__ffuunnccttoorr(_t_e_r_m___t_, _f_u_n_c_t_o_r___t)
    Returns  non-zero if _t_e_r_m  is compound and  its functor is  _f_u_n_c_t_o_r.
    This  test is  equivalent to  PL_get_functor(),  followed by  testing
    the functor, but easier to write and faster.


int PPLL__iiss__lliisstt(_t_e_r_m___t)
    Returns  non-zero  if  _t_e_r_m  is  a  compound  term  using  the  list
    constructor  or  the list  terminator.    See also  PL_is_pair() and
    PL_skip_list().


int PPLL__iiss__ppaaiirr(_t_e_r_m___t)
    Returns  non-zero  if  _t_e_r_m  is  a  compound  term  using  the  list
    constructor.  See also PL_is_list() and PL_skip_list().


int PPLL__iiss__aattoommiicc(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is atomic (not variable or compound).


int PPLL__iiss__nnuummbbeerr(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is an integer or float.


int PPLL__iiss__aaccyycclliicc(_t_e_r_m___t)
    Returns non-zero if _t_e_r_m is acyclic (i.e. a finite tree).


1100..44..33..22 RReeaaddiinngg ddaattaa ffrroomm aa tteerrmm

The functions PL_get_*() read information from  a Prolog term.  Most  of
them take two arguments.  The first is the input  term and the second is
a pointer to the output value or a term reference.


int PPLL__ggeett__aattoomm(_t_e_r_m___t _+_t_, _a_t_o_m___t _*_a)
    If _t is an atom,  store the unique atom identifier over _a.  See also
    PL_atom_chars() and PL_new_atom().   If there is  no need to  access
    the data (characters)  of an atom, it is advised to manipulate atoms
    using  their handle.  As the  atom is referenced by _t, it  will live
    at  least as long as _t does.   If longer live-time is required,  the
    atom should be locked using PL_register_atom().


int PPLL__ggeett__aattoomm__cchhaarrss(_t_e_r_m___t _+_t_, _c_h_a_r _*_*_s)
    If  _t is an atom, store a  pointer to a 0-terminated C-string  in _s.
    It is explicitly  nnoott allowed to modify the contents of this string.
    Some  built-in  atoms may  have the  string  allocated in  read-only
    memory, so `temporary manipulation' can cause an error.


int PPLL__ggeett__ssttrriinngg__cchhaarrss(_t_e_r_m___t _+_t_, _c_h_a_r _*_*_s_, _i_n_t _*_l_e_n)
    If  _t  is  a  string  object,  store a  pointer  to  a  0-terminated
    C-string  in _s  and the  length of  the string in  _l_e_n.   Note  that
    this pointer is  invalidated by backtracking, garbage collection and
    stack-shifts,  so generally the only save operations are to  pass it
    immediately to a C function that doesn't involve Prolog.


int PPLL__ggeett__cchhaarrss(_t_e_r_m___t _+_t_, _c_h_a_r _*_*_s_, _u_n_s_i_g_n_e_d _f_l_a_g_s)
    Convert  the argument term _t to  a 0-terminated C-string.  _f_l_a_g_s  is
    a  bitwise disjunction  from two  groups of  constants.   The  first
    specifies  which  term  types should  be  converted and  the  second
    how  the argument  is stored.   Below  is a  specification of  these
    constants.   BUF_RING implies, if the data is  not static (as from an
    atom), that the data  is copied to the next buffer from a ring of 16
    buffers.   This is a convenient way of converting multiple arguments
    passed  to a foreign predicate to C-strings.  If BUF_MALLOC is used,
    the data must be freed using PL_free() when no longer needed.

    With  the introduction of wide characters (see section  2.18.1), not
    all  atoms can be converted into a char*.  This function  fails if _t
    is  of the wrong type, but  also if the text cannot  be represented.
    See the REP_* flags below for details.

    CCVVTT__AATTOOMM
         Convert if term is an atom.

    CCVVTT__SSTTRRIINNGG
         Convert if term is a string.

    CCVVTT__LLIISSTT
         Convert if term is a list of of character codes.

    CCVVTT__IINNTTEEGGEERR
         Convert if term is an integer.

    CCVVTT__FFLLOOAATT
         Convert if term  is a float.   The characters returned are  the
         same as write/1 would write for the floating point number.

    CCVVTT__NNUUMMBBEERR
         Convert if term is an integer or float.

    CCVVTT__AATTOOMMIICC
         Convert if term is atomic.

    CCVVTT__VVAARRIIAABBLLEE
         Convert variable to print-name

    CCVVTT__WWRRIITTEE
         Convert any  term that  is not converted  by any  of the  other
         flags using  write/1.   If  no BUF_* is  provided, BUF_RING  is
         implied.

    CCVVTT__WWRRIITTEE__CCAANNOONNIICCAALL
         As CVT_WRITE, but using write_canonical/2.

    CCVVTT__WWRRIITTEEQQ
         As CVT_WRITE, but using writeq/2.

    CCVVTT__AALLLL
         Convert if term  is any of  the above, except  for CVT_VARIABLE
         and CVT_WRITE*.

    CCVVTT__EEXXCCEEPPTTIIOONN
         If conversion fails  due to a type  error, raise a Prolog  type
         error exception in addition to failure

    BBUUFF__DDIISSCCAARRDDAABBLLEE
         Data must copied immediately

    BBUUFF__RRIINNGG
         Data is stored in a ring of buffers

    BBUUFF__MMAALLLLOOCC
         Data is copied to a new buffer  returned by PL_malloc(3).   When
         no longer needed the user must call PL_free() on the data.

    RREEPP__IISSOO__LLAATTIINN__11
         Text is  in ISO  Latin-1 encoding and  the call  fails if  text
         cannot be represented.   This flag has the value 0 and  is thus
         the default.

    RREEPP__UUTTFF88
         Convert the text to a UTF-8 string.  This works for all text.

    RREEPP__MMBB
         Convert  to  default locale-defined  8-bit  string.     Success
         depends on the locale.  Conversion is done  using the wcrtomb()
         C library function.


int PPLL__ggeett__lliisstt__cchhaarrss(_+_t_e_r_m___t _l_, _c_h_a_r _*_*_s_, _u_n_s_i_g_n_e_d _f_l_a_g_s)
    Same  as PL_get_chars(_l_, _s_, _C_V_T___L_I_S_T___f_l_a_g_s), provided _f_l_a_g_s  contains
    none of the CVT_* flags.


int PPLL__ggeett__iinntteeggeerr(_+_t_e_r_m___t _t_, _i_n_t _*_i)
    If  _t is  a Prolog  integer, assign  its value over  _i.   On  32-bit
    machines,  this is the  same as PL_get_long(), but avoids a  warning
    from the compiler.  See also PL_get_long().


int PPLL__ggeett__lloonngg(_t_e_r_m___t _+_t_, _l_o_n_g _*_i)
    If  _t is a Prolog integer that can be represented as a  long, assign
    its value over _i.   If _t is an integer that cannot be represented by
    a  C long,  this function returns  FALSE. If _t  is a floating  point
    number that can  be represented as a long, this function succeeds as
    well.  See also PL_get_int64().


int PPLL__ggeett__iinntt6644(_t_e_r_m___t _+_t_, _i_n_t_6_4___t _*_i)
    If  _t is  a Prolog integer  or float  that can be  represented as  a
    int64_t,  assign its value over  _i.   Currently all Prolog  integers
    can  be  represented  using this  type,  but  this might  change  if
    SWI-Prolog introduces unbounded integers.


int PPLL__ggeett__iinnttppttrr(_t_e_r_m___t _+_t_, _i_n_t_p_t_r___t _*_i)
    Get  an integer that  is at  least as wide  as a pointer.   On  most
    platforms  this is the same as PL_get_long(), but on  Win64 pointers
    are  8 bytes and longs  only 4.  Unlike  PL_get_pointer(), the  value
    is not modified.


int PPLL__ggeett__bbooooll(_t_e_r_m___t _+_t_, _i_n_t _*_v_a_l)
    If _t has the value  true or false, set _v_a_l to the C constant TRUE or
    FALSE and return success, otherwise return failure.


int PPLL__ggeett__ppooiinntteerr(_t_e_r_m___t _+_t_, _v_o_i_d _*_*_p_t_r)
    In the current  system, pointers are represented by Prolog integers,
    but  need some manipulation to make  sure they do not get  truncated
    due  to  the limited  Prolog integer  range.    PL_put_pointer() and
    PL_get_pointer() guarantee  pointers in  the range  of malloc()  are
    handled without truncating.


int PPLL__ggeett__ffllooaatt(_t_e_r_m___t _+_t_, _d_o_u_b_l_e _*_f)
    If _t is a float or integer, its value is assigned over _f.


int PPLL__ggeett__ffuunnccttoorr(_t_e_r_m___t _+_t_, _f_u_n_c_t_o_r___t _*_f)
    If  _t  is  compound  or  an  atom,   the  Prolog  representation  of
    the   name-arity  pair  will  be  assigned   over  _f.     See   also
    PL_get_name_arity() and PL_is_functor().


int PPLL__ggeett__nnaammee__aarriittyy(_t_e_r_m___t _+_t_, _a_t_o_m___t _*_n_a_m_e_, _i_n_t _*_a_r_i_t_y)
    If  _t is  compound or  an atom,  the functor name  will be  assigned
    over  _n_a_m_e and the arity over _a_r_i_t_y.   See also PL_get_functor() and
    PL_is_functor().


int PPLL__ggeett__ccoommppoouunndd__nnaammee__aarriittyy(_t_e_r_m___t _+_t_, _a_t_o_m___t _*_n_a_m_e_, _i_n_t _*_a_r_i_t_y)
    If  _t is compound term, the functor name will be assigned  over _n_a_m_e
    and  the arity over _a_r_i_t_y.  This is the same as  PL_get_name_arity(),
    but this function fails if _t is an atom.


int PPLL__ggeett__mmoodduullee(_t_e_r_m___t _+_t_, _m_o_d_u_l_e___t _*_m_o_d_u_l_e)
    If   _t  is  an  atom,  the  system  will  look  up   or  create  the
    corresponding  module  and  assign  an opaque  pointer  to  it  over
    _m_o_d_u_l_e.


int PPLL__ggeett__aarrgg(_i_n_t _i_n_d_e_x_, _t_e_r_m___t _+_t_, _t_e_r_m___t _-_a)
    If  _t is  compound and  index is  between 1  and arity  (inclusive),
    assign _a with a term reference to the argument.


int _PPLL__ggeett__aarrgg(_i_n_t _i_n_d_e_x_, _t_e_r_m___t _+_t_, _t_e_r_m___t _-_a)
    Same  as PL_get_arg(), but no checking is performed,  neither whether
    _t is actually a term nor whether _i_n_d_e_x is a valid argument index.


1100..44..33..33 EExxcchhaannggiinngg tteexxtt uussiinngg lleennggtthh aanndd ssttrriinngg

All  internal text  representation in  SWI-Prolog  is represented  using
char * plus length and  allow for _0_-_b_y_t_e_s in them.  The  foreign library
supports this by implementing  a *_nchars() function for  each applicable
*_chars()  function.   Below we briefly present  the signatures of  these
functions.  For full documentation consult the *_chars() function.


int PPLL__ggeett__aattoomm__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _*_l_e_n_, _c_h_a_r _*_*_s)
    See PL_get_atom_chars().


int PPLL__ggeett__lliisstt__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _*_l_e_n_, _c_h_a_r _*_*_s)
    See PL_get_list_chars().


int PPLL__ggeett__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _*_l_e_n_, _c_h_a_r _*_*_s_, _u_n_s_i_g_n_e_d _i_n_t _f_l_a_g_s)
    See PL_get_chars().


int PPLL__ppuutt__aattoomm__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_put_atom_chars().


int PPLL__ppuutt__ssttrriinngg__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_put_string_chars().


int PPLL__ppuutt__lliisstt__nnccooddeess(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_put_list_codes().


int PPLL__ppuutt__lliisstt__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_put_list_chars().


int PPLL__uunniiffyy__aattoomm__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_unify_atom_chars().


int PPLL__uunniiffyy__ssttrriinngg__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_unify_string_chars().


int PPLL__uunniiffyy__lliisstt__nnccooddeess(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_unify_codes().


int PPLL__uunniiffyy__lliisstt__nncchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    See PL_unify_list_chars().

In  addition, the  following functions  are available  for creating  and
inspecting atoms:


atom_t PPLL__nneeww__aattoomm__nncchhaarrss(_s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_s)
    Create  a new atom as PL_new_atom(), but using the given  length and
    characters.    If _l_e_n  is (size_t)-1, it  is computed  from _s  using
    strlen().


const char * PPLL__aattoomm__nncchhaarrss(_a_t_o_m___t _a_, _s_i_z_e___t _*_l_e_n)
    Extract the text and length of an atom.


1100..44..33..44 WWiiddee--cchhaarraacctteerr vveerrssiioonnss

Support  for   exchange  of  wide-character   strings  is  still   under
consideration.    The  functions dealing  with 8-bit  character  strings
return failure when operating on a wide-character atom  or Prolog string
object.  The  functions below can extract and unify both 8-bit  and wide
atoms and  string objects.   Wide character  strings are represented  as
C arrays  of objects of the  type pl_wchar_t,  which is guaranteed to  be
the same as wchar_t on platforms supporting this type.   For example, on
MS-Windows, this represents 16-bit UCS2 characters, while  using the GNU
C library (glibc) this represents 32-bit UCS4 characters.


atom_t PPLL__nneeww__aattoomm__wwcchhaarrss(_s_i_z_e___t _l_e_n_, _c_o_n_s_t _p_l___w_c_h_a_r___t _*_s)
    Create  atom from wide-character string as PL_new_atom_nchars() does
    for ISO-Latin-1 strings.   If _s only contains ISO-Latin-1 characters
    a  normal byte-array atom is created.   If _l_e_n is  (size_t)-1, it  is
    computed from _s using wcslen().


pl_wchar_t* PPLL__aattoomm__wwcchhaarrss(_a_t_o_m___t _a_t_o_m_, _i_n_t _*_l_e_n)
    Extract  characters from  a wide-character  atom.   Succeeds on  any
    atom  marked as `text'.  If the underlying atom is  a wide-character
    atom,  the returned pointer  is a pointer  into the atom  structure.
    If  it is an ISO-Latin-1 character, the returned pointer  comes from
    Prolog's `buffer ring' (see PL_get_chars()).


int PPLL__ggeett__wwcchhaarrss(_t_e_r_m___t _t_, _s_i_z_e___t _*_l_e_n_, _p_l___w_c_h_a_r___t _*_*_s_, _u_n_s_i_g_n_e_d _f_l_a_g_s)
    Wide-character  version of  PL_get_chars().   The  _f_l_a_g_s argument  is
    the same as for PL_get_chars().


int PPLL__uunniiffyy__wwcchhaarrss(_t_e_r_m___t _t_, _i_n_t _t_y_p_e_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _p_l___w_c_h_a_r___t _*_s)
    Unify _t with  a textual representation of the C wide-character array
    _s.   The _t_y_p_e argument defines the Prolog representation and  is one
    of PL_ATOM, PL_STRING, PL_CODE_LIST or PL_CHAR_LIST.


int PPLL__uunniiffyy__wwcchhaarrss__ddiiffff(_t_e_r_m___t _+_t_, _t_e_r_m___t _-_t_a_i_l_, _i_n_t _t_y_p_e_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _p_l___w_c_h_a_r___t _*_s)
    Difference  list version  of PL_unify_wchars(),  only supporting  the
    types  PL_CODE_LIST  and PL_CHAR_LIST. It serves  two purposes.    It
    allows  for returning very long lists  from data read from a  stream
    without  the need  for a  resizing buffer  in  C. Also,  the use  of
    difference  lists  is  often  practical for  further  processing  in
    Prolog.   Examples can be found in packages/clib/readutil.c from the
    source distribution.


1100..44..33..55 RReeaaddiinngg aa lliisstt

The functions from this section are intended to read  a Prolog list from
C. Suppose we expect a list of atoms; the following  code will print the
atoms, each on a line:

________________________________________________________________________|                                                                        |
|foreign_t                                                               |
|pl_write_atoms(term_t l)                                                |

|{ term_t head = PL_new_term_ref();   /* the elements */                 |
|  term_t list = PL_copy_term_ref(l); /* copy (we modify list) */        |
|                                                                        |
|  while( PL_get_list(list, head, list) )                                |
|  { char *s;                                                            |
|                                                                        |
|    if ( PL_get_atom_chars(head, &s) )                                  |
|      Sprintf("%s\n", s);                                               |

|    else                                                                |
|      PL_fail;                                                          |
|  }                                                                     |
|                                                                        |
|  return PL_get_nil(list);            /* test end for [] */             |
|}|_____________________________________________________________________ | |

Note that as  of version 7, lists  have a new representation unless  the
option --traditional is used.  see section 5.1.


int PPLL__ggeett__lliisstt(_t_e_r_m___t _+_l_, _t_e_r_m___t _-_h_, _t_e_r_m___t _-_t)
    If  _l is a list and not  the empty list, assign a term  reference to
    the head to _h and to the tail to _t.


int PPLL__ggeett__hheeaadd(_t_e_r_m___t _+_l_, _t_e_r_m___t _-_h)
    If  _l is a list and not  the empty list, assign a term  reference to
    the head to _h.


int PPLL__ggeett__ttaaiill(_t_e_r_m___t _+_l_, _t_e_r_m___t _-_t)
    If  _l is a list and not  the empty list, assign a term  reference to
    the tail to _t.


int PPLL__ggeett__nniill(_t_e_r_m___t _+_l)
    Succeeds if _l represents the list termination constant.


int PPLL__sskkiipp__lliisstt(_t_e_r_m___t _+_l_i_s_t_, _t_e_r_m___t _-_t_a_i_l_, _s_i_z_e___t _*_l_e_n)
    This is a multi-purpose  function to deal with lists.  It allows for
    finding the length  of a list, checking whether something is a list,
    etc.   The reference  _t_a_i_l is set to point  to the end of the  list,
    _l_e_n is filled  with the number of list-cells skipped, and the return
    value indicates the status of the list:

    PPLL__LLIISSTT
         The  list is  a `proper'  list:   one  that  ends in  the  list
         terminator constant  and  _t_a_i_l is  filled with  the  terminator
         constant.

    PPLL__PPAARRTTIIAALL__LLIISSTT
         The list is a `partial' list:  one that ends in  a variable and
         _t_a_i_l is a reference to this variable.

    PPLL__CCYYCCLLIICC__TTEERRMM
         The list  is  cyclic (e.g.    X  = [a_X]).  _t_a_i_l points  to  an
         arbitrary cell of the list  and _l_e_n is at most twice  the cycle
         length of the list.

    PPLL__NNOOTT__AA__LLIISSTT
         The  term _l_i_s_t  is  not a  list  at all.     _t_a_i_l is  bound  to
         the non-list term  and _l_e_n is set  to the number of  list-cells
         skipped.

    It is allowed to pass 0 for _t_a_i_l and NULL for _l_e_n.


1100..44..33..66 AAnn eexxaammppllee::  ddeeffiinniinngg write/1 iinn CC

Figure  10.2 shows  a  simplified definition  of write/1  to  illustrate
the described  functions.   This simplified version  does not deal  with
operators.    It is  called  display/1, because  it mimics  closely  the
behaviour of this Edinburgh predicate.
________________________________________________________________________|                                                                        |
|foreign_t                                                               |
|pl_display(term_t t)                                                    |
|{ functor_t functor;                                                    |

|  int arity, len, n;                                                    |
|  char *s;                                                              |
|                                                                        |
|  switch( PL_term_type(t) )                                             |
|  { case PL_VARIABLE:                                                   |
|    case PL_ATOM:                                                       |
|    case PL_INTEGER:                                                    |
|    case PL_FLOAT:                                                      |

|      PL_get_chars(t, &s, CVT_ALL);                                     |
|      Sprintf("%s", s);                                                 |
|      break;                                                            |
|    case PL_STRING:                                                     |
|      PL_get_string_chars(t, &s, &len);                                 |
|      Sprintf("\"%s\"", s);                                             |
|      break;                                                            |

|    case PL_TERM:                                                       |
|    { term_t a = PL_new_term_ref();                                     |
|                                                                        |
|      PL_get_name_arity(t, &name, &arity);                              |
|      Sprintf("%s(", PL_atom_chars(name));                              |
|      for(n=1; n<=arity; n++)                                           |
|      { PL_get_arg(n, t, a);                                            |
|        if ( n > 1 )                                                    |

|          Sprintf(", ");                                                |
|        pl_display(a);                                                  |
|      }                                                                 |
|      Sprintf(")");                                                     |
|      break;                                                            |
|    default:                                                            |
|      PL_fail;                          /* should not happen */         |

|    }                                                                   |
|  }                                                                     |
|                                                                        |
|  PL_succeed;                                                           |
|}|_____________________________________________________________________ | |

            Figure 10.2:  A Foreign definition of display/1


1100..44..44 CCoonnssttrruuccttiinngg TTeerrmmss

Terms  can  be  constructed  using  functions from  the  PL_put_*()  and
PL_cons_*()  families.    This  approach  builds the  term  `inside-out',
starting  at  the  leaves  and  subsequently  creating  compound  terms.
Alternatively,   terms  may  be  created   `top-down',  first   creating
a  compound  holding  only  variables  and   subsequently  unifying  the
arguments.   This section  discusses functions  for the first  approach.
This approach  is generally  used for  creating arguments  for PL_call()
and PL_open_query().


void PPLL__ppuutt__vvaarriiaabbllee(_t_e_r_m___t _-_t)
    Put  a fresh variable in the  term, resetting the term reference  to
    its initial state.


void PPLL__ppuutt__aattoomm(_t_e_r_m___t _-_t_, _a_t_o_m___t _a)
    Put  an  atom  in the  term  reference from  a  handle.    See  also
    PL_new_atom() and PL_atom_chars().


void PPLL__ppuutt__bbooooll(_t_e_r_m___t _-_t_, _i_n_t _v_a_l)
    Put  one of the atoms true or  false in the term reference  See also
    PL_put_atom(), PL_unify_bool()and PL_get_bool().


int PPLL__ppuutt__aattoomm__cchhaarrss(_t_e_r_m___t _-_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Put  an  atom  in the  term  reference  constructed from  the  zero-
    terminated  string.  The string  itself will never be referenced  by
    Prolog after this function.


int PPLL__ppuutt__ssttrriinngg__cchhaarrss(_t_e_r_m___t _-_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Put  a zero-terminated string in the term reference.  The  data will
    be copied.  See also PL_put_string_nchars().


int PPLL__ppuutt__ssttrriinngg__nncchhaarrss(_t_e_r_m___t _-_t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Put  a string,  represented by  a length/start pointer  pair in  the
    term  reference.  The data will be copied.  This  interface can deal
    with 0-bytes in the string.  See also section 10.4.20.


int PPLL__ppuutt__lliisstt__cchhaarrss(_t_e_r_m___t _-_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Put a list of ASCII values in the term reference.


int PPLL__ppuutt__iinntteeggeerr(_t_e_r_m___t _-_t_, _l_o_n_g _i)
    Put a Prolog integer in the term reference.


int PPLL__ppuutt__iinntt6644(_t_e_r_m___t _-_t_, _i_n_t_6_4___t _i)
    Put a Prolog integer in the term reference.


int PPLL__ppuutt__ppooiinntteerr(_t_e_r_m___t _-_t_, _v_o_i_d _*_p_t_r)
    Put a Prolog integer  in the term reference.  Provided _p_t_r is in the
    `malloc()-area', PL_get_pointer() will get the pointer back.


int PPLL__ppuutt__ffllooaatt(_t_e_r_m___t _-_t_, _d_o_u_b_l_e _f)
    Put a floating-point value in the term reference.


int PPLL__ppuutt__ffuunnccttoorr(_t_e_r_m___t _-_t_, _f_u_n_c_t_o_r___t _f_u_n_c_t_o_r)
    Create  a new compound  term from _f_u_n_c_t_o_r and  bind _t to this  term.
    All arguments of the  term will be variables.  To create a term with
    instantiated  arguments, either instantiate the arguments  using the
    PL_unify_*() functions or use PL_cons_functor().


int PPLL__ppuutt__lliisstt(_t_e_r_m___t _-_l)
    As  PL_put_functor(),  using  the list-cell  functor.     Note  that
    on  classical  Prolog  systems or  in  SWI-Prolog using  the  option
    --traditional,  this is ./2, while  on SWI-Prolog version 7 this  is
    [|]/2.


int PPLL__ppuutt__nniill(_t_e_r_m___t _-_l)
    Put  the list terminator constant in  _l.  Always returns TRUE.  Note
    that  in classical Prolog systems or in SWI-Prolog using  the option
    --traditional,  this is  the same  as PL_put_atom_chars(_"_[_]_").    See
    section 5.1.


void PPLL__ppuutt__tteerrmm(_t_e_r_m___t _-_t_1_, _t_e_r_m___t _+_t_2)
    Make _t_1 point to the same term as _t_2.


int PPLL__ccoonnss__ffuunnccttoorr(_t_e_r_m___t _-_h_, _f_u_n_c_t_o_r___t _f_, _._._.)
    Create  a term whose arguments  are filled from a variable  argument
    list  holding the same number of term_t objects as the arity  of the
    functor.  To create the term animal(gnu, 50), use:

    ____________________________________________________________________|                                                                    |
    | { term_t a1 = PL_new_term_ref();                                   |

    |   term_t a2 = PL_new_term_ref();                                   |
    |   term_t t  = PL_new_term_ref();                                   |
    |   functor_t animal2;                                               |
    |                                                                    |
    |   /* animal2 is a constant that may be bound to a global           |
    |      variable and re-used                                          |
    |   */                                                               |
    |   animal2 = PL_new_functor(PL_new_atom("animal"), 2);              |

    |                                                                    |
    |   PL_put_atom_chars(a1, "gnu");                                    |
    |   PL_put_integer(a2, 50);                                          |
    |   PL_cons_functor(t, animal2, a1, a2);                             |
    ||}_________________________________________________________________ ||

    After  this sequence, the term references _a_1 and _a_2 may be  used for
    other purposes.


int PPLL__ccoonnss__ffuunnccttoorr__vv(_t_e_r_m___t _-_h_, _f_u_n_c_t_o_r___t _f_, _t_e_r_m___t _a_0)
    Create  a compound term  like PL_cons_functor(),  but _a_0 is an  array
    of  term references as  returned by PL_new_term_refs().   The  length
    of  this array should match the number of arguments required  by the
    functor.


int PPLL__ccoonnss__lliisstt(_t_e_r_m___t _-_l_, _t_e_r_m___t _+_h_, _t_e_r_m___t _+_t)
    Create  a list (cons-) cell in  _l from the head _h  and tail _t.   The
    code  below creates a  list of atoms  from a char **.   The list  is
    built  tail-to-head.    The PL_unify_*() functions  can  be used  to
    build a list head-to-tail.

    ____________________________________________________________________|                                                                    |
    | void                                                               |
    | put_list(term_t l, int n, char **words)                            |
    | { term_t a = PL_new_term_ref();                                    |

    |                                                                    |
    |   PL_put_nil(l);                                                   |
    |   while( --n >= 0 )                                                |
    |   { PL_put_atom_chars(a, words[n]);                                |
    |     PL_cons_list(l, a, l);                                         |
    |   }                                                                |
    ||}_________________________________________________________________ ||

    Note  that _l can  be redefined  within a PL_cons_list call as  shown
    here because operationally  its old value is consumed before its new
    value is set.


1100..44..55 UUnniiffyyiinngg ddaattaa

The  functions  of  this  section  _u_n_i_f_y  terms  with   other  terms  or
translated C  data structures.   Except for PL_unify(), these  functions
are specific  to SWI-Prolog.    They have been  introduced because  they
shorten the code for returning data to Prolog and at  the same time make
this more  efficient by  avoiding the  need to  allocate temporary  term
references and reduce  the number of calls  to the Prolog API.  Consider
the case  where we want a  foreign function to  return the host name  of
the machine Prolog  is running on.   Using the PL_get_*() and PL_put_*()
functions, the code becomes:

________________________________________________________________________|                                                                        |
|foreign_t                                                               |
|pl_hostname(term_t name)                                                |

|{ char buf[100];                                                        |
|                                                                        |
|  if ( gethostname(buf, sizeof(buf)) )                                  |
|  { term_t tmp = PL_new_term_ref();                                     |
|                                                                        |
|    PL_put_atom_chars(tmp, buf);                                        |
|    return PL_unify(name, tmp);                                         |
|  }                                                                     |

|                                                                        |
|  PL_fail;                                                              |
|}|_____________________________________________________________________ | |

Using PL_unify_atom_chars(), this becomes:

________________________________________________________________________|                                                                        |
|foreign_t                                                               |
|pl_hostname(term_t name)                                                |

|{ char buf[100];                                                        |
|                                                                        |
|  if ( gethostname(buf, sizeof(buf)) )                                  |
|    return PL_unify_atom_chars(name, buf);                              |
|                                                                        |
|  PL_fail;                                                              |
|}|_____________________________________________________________________ | |

Note  that unification  functions  that  perform multiple  bindings  may
leave part  of the  bindings in  case of  failure.   See  PL_unify() for
details.


int PPLL__uunniiffyy(_t_e_r_m___t _?_t_1_, _t_e_r_m___t _?_t_2)
    Unify two Prolog terms and return TRUE on success.

    Care  is needed if PL_unify() returns FAIL and the  foreign function
    does  not _i_m_m_e_d_i_a_t_e_l_y  return to Prolog  with FAIL. Unification  may
    perform multiple changes to  either _t_1 or _t_2.  A failing unification
    may  have created  bindings  before failure  is detected.    _A_l_r_e_a_d_y
    _c_r_e_a_t_e_d  _b_i_n_d_i_n_g_s _a_r_e _n_o_t _u_n_d_o_n_e.   For example,  calling PL_unify()
    on a(_X_, _a) and  a(_c_,_b) binds _X to c and fails when trying to unify a
    to b.  If  control remains in C or even if we want to return success
    to  Prolog, we  _m_u_s_t undo  such bindings.   This  is achieved  using
    PL_open_foreign_frame() and  PL_rewind_foreign_frame(),  as shown  in
    the snippet below.

    ____________________________________________________________________|                                                                    |
    |     { fid_t fid = PL_open_foreign_frame();                         |

    |                                                                    |
    |       ...                                                          |
    |       if ( !PL_unify(t1, t2) )                                     |
    |         PL_rewind_foreign_frame(fid);                              |
    |       ...                                                          |
    |                                                                    |
    |       PL_close_foreign_frame(fid);                                 |
    ||____}_____________________________________________________________ ||

    In   addition,   PL_unify()  may  have  failed   on  an   eexxcceeppttiioonn,
    typically  a  resource  (stack)  overflow.     This  can  be  tested
    using  PL_exception(),  passing 0 (zero)  for the query-id  argument.
    Foreign  functions that encounter an  exception must return FAIL  to
    Prolog  as  soon as  possible or  call PL_clear_exception() if  they
    wish to ignore the exception.


int PPLL__uunniiffyy__aattoomm(_t_e_r_m___t _?_t_, _a_t_o_m___t _a)
    Unify _t with the atom _a and return non-zero on success.


int PPLL__uunniiffyy__bbooooll(_t_e_r_m___t _?_t_, _i_n_t _a)
    Unify _t with either true or false.


int PPLL__uunniiffyy__cchhaarrss(_t_e_r_m___t _?_t_, _i_n_t _f_l_a_g_s_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    New  function  to  deal  with  unification  of  char*  with  various
    encodings  to a  Prolog representation.    The _f_l_a_g_s  argument is  a
    bitwise  _o_r specifying the  Prolog target type  and the encoding  of
    _c_h_a_r_s.   A Prolog type is one of PL_ATOM, PL_STRING, PL_CODE_LIST or
    PL_CHAR_LIST. A  representation is one  of REP_ISO_LATIN_1,  REP_UTF8
    or REP_MB. See PL_get_chars() for a definition of the representation
    types.   If _l_e_n is -1  _c_h_a_r_s must be zero-terminated and  the length
    is computed from _c_h_a_r_s using strlen().

    If  _f_l_a_g_s includes PL_DIFF_LIST and  type is one  of PL_CODE_LIST  or
    PL_CHAR_LIST, the text is converted to a _d_i_f_f_e_r_e_n_c_e _l_i_s_t.   The tail
    of the difference list is t +1.


int PPLL__uunniiffyy__aattoomm__cchhaarrss(_t_e_r_m___t _?_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Unify  _t with  an atom  created from  _c_h_a_r_s and  return non-zero  on
    success.


int PPLL__uunniiffyy__lliisstt__cchhaarrss(_t_e_r_m___t _?_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Unify _t with a list of ASCII characters constructed from _c_h_a_r_s.


void PPLL__uunniiffyy__ssttrriinngg__cchhaarrss(_t_e_r_m___t _?_t_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Unify  _t  with  a  Prolog  string  object  created  from  the  zero-
    terminated  string  _c_h_a_r_s.   The  data will  be copied.    See  also
    PL_unify_string_nchars().


void PPLL__uunniiffyy__ssttrriinngg__nncchhaarrss(_t_e_r_m___t _?_t_, _s_i_z_e___t _l_e_n_, _c_o_n_s_t _c_h_a_r _*_c_h_a_r_s)
    Unify _t with  a Prolog string object created from the string created
    from  the _l_e_n/_c_h_a_r_s pair.  The data will be copied.   This interface
    can deal with 0-bytes in the string.  See also section 10.4.20.


int PPLL__uunniiffyy__iinntteeggeerr(_t_e_r_m___t _?_t_, _i_n_t_p_t_r___t _n)
    Unify _t with a Prolog integer from _n.


int PPLL__uunniiffyy__iinntt6644(_t_e_r_m___t _?_t_, _i_n_t_6_4___t _n)
    Unify _t with a Prolog integer from _n.


int PPLL__uunniiffyy__ffllooaatt(_t_e_r_m___t _?_t_, _d_o_u_b_l_e _f)
    Unify _t with a Prolog float from _f.


int PPLL__uunniiffyy__ppooiinntteerr(_t_e_r_m___t _?_t_, _v_o_i_d _*_p_t_r)
    Unify  _t with a  Prolog integer  describing the pointer.   See  also
    PL_put_pointer() and PL_get_pointer().


int PPLL__uunniiffyy__ffuunnccttoorr(_t_e_r_m___t _?_t_, _f_u_n_c_t_o_r___t _f)
    If  _t is a compound term with  the given functor, just succeed.   If
    it  is unbound,  create a  term and  bind the  variable, else  fail.
    Note  that this function does not  create a term if the argument  is
    already instantiated.   If _f is a functor with arity 0, _t is unified
    with an atom.  See also PL_unify_compound().


int PPLL__uunniiffyy__ccoommppoouunndd(_t_e_r_m___t _?_t_, _f_u_n_c_t_o_r___t _f)
    If  _t is a compound term with  the given functor, just succeed.   If
    it  is unbound,  create a  term and  bind the  variable, else  fail.
    Note  that this function does not  create a term if the argument  is
    already instantiated.   If _f is a functor with arity 0, _t is unified
    with compound without arguments.  See also PL_unify_functor().


int PPLL__uunniiffyy__lliisstt(_t_e_r_m___t _?_l_, _t_e_r_m___t _-_h_, _t_e_r_m___t _-_t)
    Unify  _l with a list-cell (./2).   If successful, write  a reference
    to  the head of the list into _h  and a reference to the tail  of the
    list  into _t.   This reference may be  used for subsequent calls  to
    this  function.   Suppose we  want to  return a list  of atoms  from
    a  char **.   We could  use the example  described by PL_put_list(),
    followed by  a call to PL_unify(), or we can use  the code below.  If
    the  predicate argument is unbound,  the difference is minimal  (the
    code  based on PL_put_list() is probably slightly  faster).  If  the
    argument  is bound, the code below may fail before reaching  the end
    of  the word list, but even  if the unification succeeds, this  code
    avoids a duplicate (garbage) list and a deep unification.

    ____________________________________________________________________|                                                                    |
    | foreign_t                                                          |

    | pl_get_environ(term_t env)                                         |
    | { term_t l = PL_copy_term_ref(env);                                |
    |   term_t a = PL_new_term_ref();                                    |
    |   extern char **environ;                                           |
    |   char **e;                                                        |
    |                                                                    |
    |   for(e = environ; *e; e++)                                        |
    |   { if ( !PL_unify_list(l, a, l) ||                                |

    |          !PL_unify_atom_chars(a, *e) )                             |
    |       PL_fail;                                                     |
    |   }                                                                |
    |                                                                    |
    |   return PL_unify_nil(l);                                          |
    ||}_________________________________________________________________ ||


int PPLL__uunniiffyy__nniill(_t_e_r_m___t _?_l)
    Unify _l with the atom [].


int PPLL__uunniiffyy__aarrgg(_i_n_t _i_n_d_e_x_, _t_e_r_m___t _?_t_, _t_e_r_m___t _?_a)
    Unifies the _i_n_d_e_x_-_t_h argument (1-based) of _t with _a.


int PPLL__uunniiffyy__tteerrmm(_t_e_r_m___t _?_t_, _._._.)
    Unify  _t with a (normally) compound  term.  The remaining  arguments
    are  a  sequence  of a  type  identifier  followed by  the  required
    arguments.      This  predicate  is  an  extension  to  the  Quintus
    and  SICStus foreign  interface  from which  the SWI-Prolog  foreign
    interface  has been  derived, but has  proved to  be a powerful  and
    comfortable  way to create compound terms from C. Due to  the vararg
    packing/unpacking and  the required type-switching this interface is
    slightly  slower than using the primitives.   Please note that  some
    bad  C compilers have fairly low  limits on the number of  arguments
    that may be passed to a function.

    Special  attention is required when  passing numbers.  C  `promotes'
    any  integral smaller than  int to int.   That  is, the types  char,
    short  and int are all passed as  int.  In addition, on  most 32-bit
    platforms  int and long  are the same.   Up  to version 4.0.5,  only
    PL_INTEGER  could  be specified,  which  was  taken from  the  stack
    as  long.   Such  code fails when  passing small  integral types  on
    machines  where int  is smaller than  long.   It is  advised to  use
    PL_SHORT, PL_INT or PL_LONG as appropriate.  Similarly,  C compilers
    promote  float to  double and  therefore PL_FLOAT and  PL_DOUBLE  are
    synonyms.

    The type identifiers are:

    PL_VARIABLE _n_o_n_e
         No op.  Used in arguments of PL_FUNCTOR.

    PL_BOOL _i_n_t
         Unify the argument with true or false.

    PL_ATOM _a_t_o_m___t
         Unify the argument with an atom, as in PL_unify_atom().

    PL_CHARS _c_o_n_s_t _c_h_a_r _*
         Unify the argument with an atom constructed from  the C char *,
         as in PL_unify_atom_chars().

    PL_NCHARS _s_i_z_e___t_, _c_o_n_s_t _c_h_a_r _*
         Unify the  argument with  an atom constructed  from length  and
         char* as in PL_unify_atom_nchars().

    PL_UTF8_CHARS _c_o_n_s_t _c_h_a_r _*
         Create an atom from a UTF-8 string.

    PL_UTF8_STRING _c_o_n_s_t _c_h_a_r _*
         Create a packed string object from a UTF-8 string.

    PL_MBCHARS _c_o_n_s_t _c_h_a_r _*
         Create an atom from a multi-byte string in the current locale.

    PL_MBCODES _c_o_n_s_t _c_h_a_r _*
         Create a list  of character codes  from a multi-byte string  in
         the current locale.

    PL_MBSTRING _c_o_n_s_t _c_h_a_r _*
         Create a packed string  object from a multi-byte string  in the
         current locale.

    PL_NWCHARS _s_i_z_e___t_, _c_o_n_s_t _w_c_h_a_r___t _*
         Create an atom from a length and a wide character pointer.

    PL_NWCODES _s_i_z_e___t_, _c_o_n_s_t _w_c_h_a_r___t _*
         Create a  list of  character  codes from  a length  and a  wide
         character pointer.

    PL_NWSTRING _s_i_z_e___t_, _c_o_n_s_t _w_c_h_a_r___t _*
         Create  a  packed  string object  from  a  length  and  a  wide
         character pointer.

    PL_SHORT _s_h_o_r_t
         Unify the argument  with an integer,  as in PL_unify_integer().
         As short is promoted to int, PL_SHORT is a synonym for PL_INT.

    PL_INTEGER _l_o_n_g
         Unify the argument with an integer, as in PL_unify_integer().

    PL_INT _i_n_t
         Unify the argument with an integer, as in PL_unify_integer().

    PL_LONG _l_o_n_g
         Unify the argument with an integer, as in PL_unify_integer().

    PL_INT64 _i_n_t_6_4___t
         Unify   the   argument   with   a  64-bit   integer,    as   in
         PL_unify_int64().

    PL_INTPTR _i_n_t_p_t_r___t
         Unify the  argument with an  integer with the  same width as  a
         pointer.  On most machines this is  the same as PL_LONG. but on
         64-bit MS-Windows pointers are 64 bits while longs  are only 32
         bits.

    PL_DOUBLE _d_o_u_b_l_e
         Unify  the  argument  with a  float,  as  in  PL_unify_float().
         Note  that,  as the  argument  is  passed using  the  C  vararg
         conventions, a float must be casted to a double explicitly.

    PL_FLOAT _d_o_u_b_l_e
         Unify the argument with a float, as in PL_unify_float().

    PL_POINTER _v_o_i_d _*
         Unify the argument with a pointer, as in PL_unify_pointer().

    PL_STRING _c_o_n_s_t _c_h_a_r _*
         Unify   the   argument   with   a   string   object,    as   in
         PL_unify_string_chars().

    PL_TERM _t_e_r_m___t
         Unify a  subterm.   Note  this  may be  the return  value of  a
         PL_new_term_ref()call to get access to a variable.

    PL_FUNCTOR _f_u_n_c_t_o_r___t_, _._._.
         Unify the argument  with a compound  term.  This  specification
         should be  followed by  exactly as many  specifications as  the
         number of arguments of the compound term.

    PL_FUNCTOR_CHARS _c_o_n_s_t _c_h_a_r _*_n_a_m_e_, _i_n_t _a_r_i_t_y_, _._._.
         Create a functor from the given name and arity  and then behave
         as PL_FUNCTOR.

    PL_LIST _i_n_t _l_e_n_g_t_h_, _._._.
         Create  a  list  of  the  indicated  length.     The  remaining
         arguments contain the elements of the list.

    For  example, to  unify an argument  with the term  language(dutch),
    the following skeleton may be used:

    ____________________________________________________________________|                                                                    |

    | static functor_t FUNCTOR_language1;                                |
    |                                                                    |
    | static void                                                        |
    | init_constants()                                                   |
    | { FUNCTOR_language1 = PL_new_functor(PL_new_atom("language"),1);   |

    | }                                                                  |
    |                                                                    |
    | foreign_t                                                          |
    | pl_get_lang(term_t r)                                              |
    | { return PL_unify_term(r,                                          |
    |                        PL_FUNCTOR, FUNCTOR_language1,              |
    |                            PL_CHARS, "dutch");                     |
    | }                                                                  |

    |                                                                    |
    | install_t                                                          |
    | install()                                                          |
    | { PL_register_foreign("get_lang", 1, pl_get_lang, 0);              |
    |   init_constants();                                                |
    ||}_________________________________________________________________ ||


int PPLL__cchhaarrss__ttoo__tteerrmm(_c_o_n_s_t _c_h_a_r _*_c_h_a_r_s_, _t_e_r_m___t _-_t)
    Parse  the string _c_h_a_r_s  and put the  resulting Prolog term into  _t.
    _c_h_a_r_s  may or may not  be closed using  a Prolog full-stop (i.e.,  a
    dot  followed by  a blank).   Returns  FALSE if a  syntax error  was
    encountered  and TRUE after successful  completion.  In addition  to
    returning  FALSE, the exception-term  is returned in  _t on a  syntax
    error.  See also term_to_atom/2.

    The  following example builds  a goal term  from a string and  calls
    it.

    ____________________________________________________________________|                                                                    |
    | int                                                                |
    | call_chars(const char *goal)                                       |
    | { fid_t fid = PL_open_foreign_frame();                             |

    |   term_t g = PL_new_term_ref();                                    |
    |   BOOL rval;                                                       |
    |                                                                    |
    |   if ( PL_chars_to_term(goal, g) )                                 |
    |     rval = PL_call(goal, NULL);                                    |
    |   else                                                             |
    |     rval = FALSE;                                                  |
    |                                                                    |

    |   PL_discard_foreign_frame(fid);                                   |
    |   return rval;                                                     |
    | }                                                                  |
    |   ...                                                              |
    |   call_chars("consult(load)");                                     |
    ||__..._____________________________________________________________ ||


int PPLL__wwcchhaarrss__ttoo__tteerrmm(_c_o_n_s_t _p_l___w_c_h_a_r___t _*_c_h_a_r_s_, _t_e_r_m___t _-_t)
    Wide character version of PL_chars_to_term().


char * PPLL__qquuoottee(_i_n_t _c_h_r_, _c_o_n_s_t _c_h_a_r _*_s_t_r_i_n_g)
    Return a quoted version of  _s_t_r_i_n_g.  If _c_h_r is '\'', the result is a
    quoted  atom.  If _c_h_r  is '"', the result is  a string.  The  result
    string  is stored in the same ring of buffers as described  with the
    BUF_RING argument of PL_get_chars();

    In  the current implementation, the string is surrounded by  _c_h_r and
    any occurrence of _c_h_r  is doubled.  In the future the behaviour will
    depend on the character_escapes Prolog flag.


1100..44..66 CCoonnvveenniieenntt ffuunnccttiioonnss ttoo ggeenneerraattee PPrroolloogg eexxcceeppttiioonnss

The  typical  implementation  of a  foreign  predicate  first  uses  the
PL_get_*() functions  to  extract C  data types  from the  Prolog  terms.
Failure of any  of these functions is  normally because the Prolog  term
is of  the wrong  type.   The  *_ex()  family of  functions are  wrappers
around (mostly)  the PL_get_*() functions,  such that  we can write  code
in  the  style  below  and get  proper  exceptions  if  an  argument  is
uninstantiated or of the wrong type.

________________________________________________________________________|                                                                        |
|/** set_size(+Name:atom, +Width:int, +Height:int) is det.               |

|                                                                        |
|static foreign_t                                                        |
|set_size(term_t name, term_t width, term_t height)                      |
|{ char *n;                                                              |
|  int w, h;                                                             |
|                                                                        |
|  if ( !PL_get_chars(name, &n, CVT_ATOM|CVT_EXCEPTION) ||               |
|       !PL_get_integer_ex(with, &w) ||                                  |

|       !PL_get_integer_ex(height, &h) )                                 |
|    return FALSE;                                                       |
|                                                                        |
|  ...                                                                   |
|                                                                        |
|}|_____________________________________________________________________ | |


int PPLL__ggeett__aattoomm__eexx(_t_e_r_m___t _t_, _a_t_o_m___t _*_a)
    As  PL_get_atom(), but raises  a type or instantiation error if  _t is
    not an atom.


int PPLL__ggeett__iinntteeggeerr__eexx(_t_e_r_m___t _t_, _i_n_t _*_i)
    As  PL_get_integer(), but raises  a type or instantiation error  if _t
    is  not an integer, or a representation error if the  Prolog integer
    does not fit in a C int.


int PPLL__ggeett__lloonngg__eexx(_t_e_r_m___t _t_, _l_o_n_g _*_i)
    As  PL_get_long(), but raises  a type or instantiation error if  _t is
    not  an atom, or a representation  error if the Prolog integer  does
    not fit in a C long.


int PPLL__ggeett__iinntt6644__eexx(_t_e_r_m___t _t_, _i_n_t_6_4___t _*_i)
    As  PL_get_int64(), but raises a type or instantiation error  if _t is
    not  an atom, or a representation  error if the Prolog integer  does
    not fit in a C int64_t.


int PPLL__ggeett__iinnttppttrr__eexx(_t_e_r_m___t _t_, _i_n_t_p_t_r___t _*_i)
    As  PL_get_intptr(), but  raises a type  or instantiation error if  _t
    is  not an  atom, or a  representation error  if the Prolog  integer
    does not fit in a C intptr_t.


int PPLL__ggeett__ssiizzee__eexx(_t_e_r_m___t _t_, _s_i_z_e___t _*_i)
    As  PL_get_size(), but raises  a type or instantiation error if  _t is
    not  an atom, or a representation  error if the Prolog integer  does
    not fit in a C size_t.


int PPLL__ggeett__bbooooll__eexx(_t_e_r_m___t _t_, _i_n_t _*_i)
    As  PL_get_bool(), but raises  a type or instantiation error if  _t is
    not an boolean.


int PPLL__ggeett__ffllooaatt__eexx(_t_e_r_m___t _t_, _d_o_u_b_l_e _*_f)
    As  PL_get_float(), but raises a type or instantiation error  if _t is
    not a float.


int PPLL__ggeett__cchhaarr__eexx(_t_e_r_m___t _t_, _i_n_t _*_p_, _i_n_t _e_o_f)
    Get  a character code  from _t, where  _t is either  an integer or  an
    atom with length one.   If _e_o_f is TRUE and _t is -1, _p is filled with
    -1.  Raises an appropriate error if the conversion is not possible.


int PPLL__ggeett__ppooiinntteerr__eexx(_t_e_r_m___t _t_, _v_o_i_d _*_*_a_d_d_r_p)
    As  PL_get_pointer(), but raises  a type or instantiation error  if _t
    is not a pointer.


int PPLL__ggeett__lliisstt__eexx(_t_e_r_m___t _l_, _t_e_r_m___t _h_, _t_e_r_m___t _t)
    As  PL_get_list(), but raises  a type or instantiation error if  _t is
    not a list.


int PPLL__ggeett__nniill__eexx(_t_e_r_m___t _l)
    As  PL_get_nil(), but  raises a type or  instantiation error if _t  is
    not the empty list.


int PPLL__uunniiffyy__lliisstt__eexx(_t_e_r_m___t _l_, _t_e_r_m___t _h_, _t_e_r_m___t _t)
    As PL_unify_list(), but raises a type error if _t is  not a variable,
    list-cell or the empty list.


int PPLL__uunniiffyy__nniill__eexx(_t_e_r_m___t _l)
    As  PL_unify_nil(), but raises  a type error if _t is not  a variable,
    list-cell or the empty list.


int PPLL__uunniiffyy__bbooooll__eexx(_t_e_r_m___t _t_, _i_n_t _v_a_l)
    As  PL_unify_bool(), but raises  a type error if _t is not  a variable
    or a boolean.

The  second  family   of  functions  in  this  section  simplifies   the
generation of  ISO compatible error  terms.   Any foreign function  that
calls  this function  must return  to  Prolog with  the return  code  of
the error  function or  the constant  FALSE. If  available, these  error
functions add the  name of the calling  predicate to the error  context.
See also PL_raise_exception().


int PPLL__iinnssttaannttiiaattiioonn__eerrrroorr(_t_e_r_m___t _c_u_l_p_r_i_t)
    Raise  instantiation_error.    _C_u_l_p_r_i_t  is ignored,  but  should  be
    bound  to  the  term  that  is insufficiently  instantiated.     See
    instantiation_error/1.


int PPLL__uunniinnssttaannttiiaattiioonn__eerrrroorr(_t_e_r_m___t _c_u_l_p_r_i_t)
    Raise  uninstantiation_error(culprit).   This should be called  if an
    argument  that must be unbound at entry  is bound to _c_u_l_p_r_i_t.   This
    error  is typically  raised for a  pure output  arguments such as  a
    newly created stream handle (e.g., the third argument of open/3).


int PPLL__rreepprreesseennttaattiioonn__eerrrroorr(_c_o_n_s_t _c_h_a_r _*_r_e_s_o_u_r_c_e)
    Raise representation_error(resource).  See representation_error/1.


int PPLL__ttyyppee__eerrrroorr(_c_o_n_s_t _c_h_a_r _*_e_x_p_e_c_t_e_d_, _t_e_r_m___t _c_u_l_p_r_i_t)
    Raise type_error(expected, culprit).  See type_error/2.


int PPLL__ddoommaaiinn__eerrrroorr(_c_o_n_s_t _c_h_a_r _*_e_x_p_e_c_t_e_d_, _t_e_r_m___t _c_u_l_p_r_i_t)
    Raise domain_error(expected, culprit).  See domain_error/2.


int PPLL__eexxiisstteennccee__eerrrroorr(_c_o_n_s_t _c_h_a_r _*_t_y_p_e_, _t_e_r_m___t _c_u_l_p_r_i_t)
    Raise existence_error(type, culprit).  See type_error/2.


int PPLL__ppeerrmmiissssiioonn__eerrrroorr(_c_o_n_s_t _c_h_a_r _*_o_p_e_r_a_t_i_o_n_, _c_o_n_s_t _c_h_a_r _*_t_y_p_e_, _t_e_r_m___t _c_u_l_p_r_i_t)
    Raise     permission_error(operation, type, culprit).            See
    permission_error/3.


int PPLL__rreessoouurrccee__eerrrroorr(_c_o_n_s_t _c_h_a_r _*_r_e_s_o_u_r_c_e)
    Raise resource_error(resource).  See resource_error/1.


int PPLL__ssyynnttaaxx__eerrrroorr(_c_o_n_s_t _c_h_a_r _*_m_e_s_s_a_g_e_, _I_O_S_T_R_E_A_M _*_i_n)
    Raise  syntax_error(message).   If _a_r_g  is not NULL, add  information
    about the current position of the input stream.


1100..44..77 BBLLOOBBSS:: UUssiinngg aattoommss ttoo ssttoorree aarrbbiittrraarryy bbiinnaarryy ddaattaa

SWI-Prolog atoms as well as strings can represent  arbitrary binary data
of arbitrary length.   This facility  is attractive for storing  foreign
data such  as images in an  atom.   An atom is  a unique handle to  this
data and the  atom garbage collector is  able to destroy atoms that  are
no longer  referenced by  the Prolog  engine.   This  property of  atoms
makes them  attractive as a  handle to foreign  resources, such as  Java
atoms, Microsoft's  COM objects, etc.,  providing safe combined  garbage
collection.

To  exploit   these  features  safely  and   in  an  organised   manner,
the  SWI-Prolog  foreign  interface allows  for  creating  `atoms'  with
additional type  information.   The type is  represented by a  structure
holding C  function pointers that  tell Prolog  how to handle  releasing
the  atom,  writing it,  sorting  it,  etc.    Two  atoms  created  with
different types  can represent the  same sequence of bytes.   Atoms  are
first ordered on the rank  number of the type and then on the  result of
the compare()  function.   Rank numbers  are assigned  when the type  is
registered.


1100..44..77..11 DDeeffiinniinngg aa BBLLOOBB ttyyppee

The  type PL_blob_t represents  a structure  with  the layout  displayed
below.  The structure contains additional fields at  the ...for internal
bookkeeping as well as future extensions.

________________________________________________________________________|                                                                        |
|typedef struct PL_blob_t                                                |

|{ uintptr_t     magic;          /* PL_BLOB_MAGIC */                     |
|  uintptr_t     flags;          /* Bitwise or of PL_BLOB_* */           |
|  char *        name;           /* name of the type */                  |
|  int           (*release)(atom_t a);                                   |
|  int           (*compare)(atom_t a, atom_t b);                         |
|  int           (*write)(IOSTREAM *s, atom_t a, int flags);             |
|  void          (*acquire)(atom_t a);                                   |
|  ...                                                                   |

|}|PL_blob_t;___________________________________________________________ | |

For each  type, exactly  one such structure  should be  allocated.   Its
first field must be initialised to PL_BLOB_MAGIC. The _f_l_a_g_s is a bitwise
_o_r of the following constants:

PPLL__BBLLOOBB__TTEEXXTT
    If  specified the blob is assumed to contain text and  is considered
    a normal Prolog atom.

PPLL__BBLLOOBB__UUNNIIQQUUEE
    If  specified the system  ensures that the  blob-handle is a  unique
    reference  for a blob with the given  type, length and content.   If
    this flag is not specified, each lookup creates a new blob.

PPLL__BBLLOOBB__NNOOCCOOPPYY
    By  default the  content of the  blob is  copied.   Using this  flag
    the  blob references  the external  data directly.    The user  must
    ensure  the provided  pointer is valid  as long  as the atom  lives.
    If  PL_BLOB_UNIQUE  is also  specified, uniqueness  is determined  by
    comparing the pointer rather than the data pointed at.

The _n_a_m_e  field represents the type  name as available  to Prolog.   See
also current_blob/2.  The  other fields are function pointers  that must
be initialised to proper functions or NULL to get  the default behaviour
of built-in atoms.  Below are the defined member functions:


void aaccqquuiirree(_a_t_o_m___t _a)
    Called  if a new blob of this  type is created through PL_put_blob()
    or  PL_unify_blob().   This  callback may be  used together with  the
    release hook to deal with reference-counted external objects.


int rreelleeaassee(_a_t_o_m___t _a)
    The  blob (atom)  _a is  about to  be released.    This function  can
    retrieve  the data of the blob using PL_blob_data().  If  it returns
    FALSE the atom garbage collector will _n_o_t reclaim the atom.


int ccoommppaarree(_a_t_o_m___t _a_, _a_t_o_m___t _b)
    Compare the blobs _a  and _b, both of which are of the type associated
    to  this blob type.   Return  values are, as  memcmp(), < 0 if _a is
    less than _b, = 0 if both are equal, and >0 otherwise.


int wwrriittee(_I_O_S_T_R_E_A_M _*_s_, _a_t_o_m___t _a_, _i_n_t _f_l_a_g_s)
    Write  the content  of the  blob _a to  the stream  _s respecting  the
    _f_l_a_g_s.   The _f_l_a_g_s are a bitwise _o_r  _o_f _z_e_r_o _o_r _m_o_r_e _o_f _t_h_e PL_WRT_*
    _f_l_a_g_s  _d_e_f_i_n_e_d _i_n SWI-Prolog.h_.  _T_h_i_s _p_r_o_t_o_t_y_p_e _i_s _a_v_a_i_l_a_b_l_e _i_f  _t_h_e
    _u_n_d_o_c_u_m_e_n_t_e_d SWI-Stream.h _i_s _i_n_c_l_u_d_e_d _b_e_f_o_r_e SWI-Prolog.h_.

    _I_f  _t_h_i_s _f_u_n_c_t_i_o_n _i_s _n_o_t _p_r_o_v_i_d_e_d_, write/1 _e_m_i_t_s _t_h_e _c_o_n_t_e_n_t  _o_f _t_h_e
    _b_l_o_b  _f_o_r _b_l_o_b_s _o_f _t_y_p_e PL_BLOB_TEXT _o_r _a _s_t_r_i_n_g _o_f  _t_h_e _f_o_r_m_a_t <#_h_e_x
    _d_a_t_a> _f_o_r _b_i_n_a_r_y _b_l_o_b_s_.

If  a blob  type is  registered from  a loadable  object (shared  object
or DLL)  the blob  type must be  deregistered before  the object may  be
released.


int PPLL__uunnrreeggiisstteerr__bblloobb__ttyyppee(_P_L___b_l_o_b___t _*_t_y_p_e)
    Unlink  the blob  type from  the registered type  and transform  the
    type  of possible  living blobs  to  unregistered, avoiding  further
    reference  to the type structure, functions referred by it,  as well
    as  the data.  This function  returns TRUE if no blobs of  this type
    existed  and FALSE otherwise.  PL_unregister_blob_type() is intended
    for  the  uninstall()  hook of  foreign  modules,  avoiding  further
    references to the module.


1100..44..77..22 AAcccceessssiinngg bblloobbss

The blob access  functions are similar to the atom  accessing functions.
Blobs being atoms, the  atom functions operate on blobs and  vice versa.
For clarity  and possible  future compatibility issues,  however, it  is
not advised to rely on this.


int PPLL__iiss__bblloobb(_t_e_r_m___t _t_, _P_L___b_l_o_b___t _*_*_t_y_p_e)
    Succeeds  if _t refers to a blob,  in which case _t_y_p_e is  filled with
    the type of the blob.


int PPLL__uunniiffyy__bblloobb(_t_e_r_m___t _t_, _v_o_i_d _*_b_l_o_b_, _s_i_z_e___t _l_e_n_, _P_L___b_l_o_b___t _*_t_y_p_e)
    Unify  _t  to  a  new  blob  constructed  from  the  given  data  and
    associated to the given type.  See also PL_unify_atom_nchars().


int PPLL__ppuutt__bblloobb(_t_e_r_m___t _t_, _v_o_i_d _*_b_l_o_b_, _s_i_z_e___t _l_e_n_, _P_L___b_l_o_b___t _*_t_y_p_e)
    Store  the described blob in _t.  The return value  indicates whether
    a  new blob  was allocated  (FALSE) or the  blob is  a reference  to
    an  existing  blob (TRUE).  Reporting new/existing  can  be used  to
    deal  with external objects having their  own reference counts.   If
    the  return is TRUE  this reference count  must be incremented,  and
    it  must be  decremented on  blob destruction  callback.   See  also
    PL_put_atom_nchars().


int PPLL__ggeett__bblloobb(_t_e_r_m___t _t_, _v_o_i_d _*_*_b_l_o_b_, _s_i_z_e___t _*_l_e_n_, _P_L___b_l_o_b___t _*_*_t_y_p_e)
    If  _t holds a blob or atom,  get the data and type and  return TRUE.
    Otherwise  return FALSE. Each result  pointer may be NULL, in  which
    case the requested information is ignored.


void * PPLL__bblloobb__ddaattaa(_a_t_o_m___t _a_, _s_i_z_e___t _*_l_e_n_, _P_L___b_l_o_b___t _*_*_t_y_p_e)
    Get  the  data  and  type associated  to  a  blob.    This  function
    is   mainly  used   from   the  callback   functions  described   in
    section 10.4.7.1.


1100..44..88 EExxcchhaannggiinngg GGMMPP nnuummbbeerrss

If  SWI-Prolog is  linked  with the  GNU Multiple  Precision  Arithmetic
Library  (GMP,  used   by  default),  the  foreign   interface  provides
functions  for   exchanging  numeric   values  to   GMP  types.       To
access  these functions  the  header  <gmp.h> must  be  included  _b_e_f_o_r_e
<SWI-Prolog.h>.   Foreign code using GMP  linked to SWI-Prolog asks  for
some considerations.

  o SWI-Prolog  normally   rebinds  the  GMP  allocation  functions  us-
    ing  mp_set_memory_functions().     This  means  SWI-Prolog  must  be
    initialised  before  the  foreign  code touches  any  GMP  function.
    You  can call \cfuncref{PL_action}{PL_GMP_SET_ALLOC_FUNCTIONS, TRUE}
    to   force   Prolog's   GMP   initialization   without   doing   the
    rest    of   the    Prolog   initialization.          If   you    do
    not    want   Prolog    rebinding   the   GMP    allocation,    call
    \cfuncref{PL_action}{PL_GMP_SET_ALLOC_FUNCTIONS, FALSE}  _b_e_f_o_r_e ini-
    tializing Prolog.

  o On  Windows, each DLL  has its own  memory pool.   To make  exchange
    of  GMP numbers between  Prolog and foreign  code possible you  must
    either  let Prolog rebind the allocation functions (default)  or you
    must  recompile  SWI-Prolog to  link to  a DLL  version  of the  GMP
    library.

Here is an example exploiting the function mpz_nextprime():

________________________________________________________________________|                                                                        |

|#include <gmp.h>                                                        |
|#include <SWI-Prolog.h>                                                 |
|                                                                        |
|static foreign_t                                                        |
|next_prime(term_t n, term_t prime)                                      |

|{ mpz_t mpz;                                                            |
|  int rc;                                                               |
|                                                                        |
|  mpz_init(mpz);                                                        |
|  if ( PL_get_mpz(n, mpz) )                                             |
|  { mpz_nextprime(mpz, mpz);                                            |
|                                                                        |
|    rc = PL_unify_mpz(prime, mpz);                                      |

|  } else                                                                |
|    rc = FALSE;                                                         |
|                                                                        |
|  mpz_clear(mpz);                                                       |
|  return rc;                                                            |
|}                                                                       |
|                                                                        |

|install_t                                                               |
|install()                                                               |
|{ PL_register_foreign("next_prime", 2, next_prime, 0);                  |
|}|_____________________________________________________________________ | |


int PPLL__ggeett__mmppzz(_t_e_r_m___t _t_, _m_p_z___t _m_p_z)
    If  _t represents an integer,  _m_p_z is filled  with the value and  the
    function  returns TRUE. Otherwise _m_p_z is untouched and  the function
    returns  FALSE.  Note that  _m_p_z must  have  been initialised  before
    calling  this  function and  must  be cleared  using  mpz_clear()  to
    reclaim any storage associated with it.


int PPLL__ggeett__mmppqq(_t_e_r_m___t _t_, _m_p_q___t _m_p_q)
    If  _t is an integer or rational number (term rdiv/2), _m_p_q  is filled
    with  the _n_o_r_m_a_l_i_s_e_d rational number and the function  returns TRUE.
    Otherwise  _m_p_q is  untouched and  the function  returns FALSE.  Note
    that  _m_p_q must  have been initialised  before calling this  function
    and  must  be  cleared  using  mpq_clear()  to  reclaim  any  storage
    associated with it.


int PPLL__uunniiffyy__mmppzz(_t_e_r_m___t _t_, _m_p_z___t _m_p_z)
    Unify  _t with the integer value  represented by _m_p_z and return  TRUE
    on success.  The _m_p_z argument is not changed.


int PPLL__uunniiffyy__mmppqq(_t_e_r_m___t _t_, _m_p_q___t _m_p_q)
    Unify  _t with a rational number  represented by _m_p_q and return  TRUE
    on  success.    Note  that  _t is  unified  with  an integer  if  the
    denominator is 1.  The _m_p_q argument is not changed.


1100..44..99 CCaalllliinngg PPrroolloogg ffrroomm CC

The  Prolog engine  can  be called  from  C.  There are  two  interfaces
for this.    For the  first, a  term is created  that could  be used  as
an  argument to  call/1,  and then  PL_call() is  used to  call  Prolog.
This  system is  simple, but  does not  allow to  inspect the  different
answers  to a  non-deterministic  goal and  is  relatively slow  as  the
runtime  system needs  to  find the  predicate.    The  other  interface
is  based on  PL_open_query(),  PL_next_solution() and  PL_cut_query() or
PL_close_query().     This mechanism  is  more powerful,  but  also  more
complicated to use.


1100..44..99..11 PPrreeddiiccaattee rreeffeerreenncceess

This  section  discusses   the  functions  used  to  communicate   about
predicates.     Though  a  Prolog  predicate  may  be  defined  or  not,
redefined,  etc.,  a  Prolog predicate  has  a handle  that  is  neither
destroyed nor moved.  This handle is known by the type predicate_t.


predicate_t PPLL__pprreedd(_f_u_n_c_t_o_r___t _f_, _m_o_d_u_l_e___t _m)
    Return  a handle to a predicate for the specified name/arity  in the
    given module.   This function always succeeds, creating a handle for
    an  undefined predicate if no handle  was available.  If the  module
    argument _m is NULL, the current context module is used.


predicate_t PPLL__pprreeddiiccaattee(_c_o_n_s_t _c_h_a_r _*_n_a_m_e_, _i_n_t _a_r_i_t_y_, _c_o_n_s_t _c_h_a_r_* _m_o_d_u_l_e)
    Same  as PL_pred(),  but provides a more convenient interface  to the
    C programmer.


void PPLL__pprreeddiiccaattee__iinnffoo(_p_r_e_d_i_c_a_t_e___t _p_, _a_t_o_m___t _*_n_, _i_n_t _*_a_, _m_o_d_u_l_e___t _*_m)
    Return  information on the  predicate _p.   The  name is stored  over
    _n,  the  arity  over _a,  while  _m  receives the  definition  module.
    Note  that  the  latter need  not  be  the same  as  specified  with
    PL_predicate().  If the predicate is imported  into the module given
    to  PL_predicate(),  this function will  return the module where  the
    predicate is defined.  Any of the arguments _n, _a and _m can be NULL.


1100..44..99..22 IInniittiiaattiinngg aa qquueerryy ffrroomm CC

This  section discusses  the  functions  for creating  and  manipulating
queries from C. Note that a foreign context can have  at most one active
query.   This implies that it is  allowed to make strictly nested  calls
between C  and Prolog  (Prolog calls C,  calls Prolog,  calls C,  etc.),
but it  is nnoott  allowed to  open multiple queries  and start  generating
solutions for  each of them by  calling PL_next_solution().   Be sure  to
call PL_cut_query() or PL_close_query() on any  query you opened  before
opening the next or returning control back to Prolog.


qid_t PPLL__ooppeenn__qquueerryy(_m_o_d_u_l_e___t _c_t_x_, _i_n_t _f_l_a_g_s_, _p_r_e_d_i_c_a_t_e___t _p_, _t_e_r_m___t _+_t_0)
    Opens  a  query and  returns  an identifier  for  it.   _c_t_x  is  the
    _c_o_n_t_e_x_t  _m_o_d_u_l_e  of  the  goal.    When  NULL,  the  context  module
    of  the  calling context  will  be used,  or  user  if there  is  no
    calling  context  (as  may  happen  in  embedded  systems).     Note
    that  the context  module  only matters  for _m_e_t_a_-_p_r_e_d_i_c_a_t_e_s.    See
    meta_predicate/1, context_module/1 and module_transparent/1.   The _p
    argument  specifies the  predicate, and  should be the  result of  a
    call  to PL_pred() or PL_predicate().   Note that  it is allowed  to
    store  this handle as global data  and reuse it for future  queries.
    The  term reference _t_0 is the  first of a vector of term  references
    as returned by PL_new_term_refs(_n).

    The  _f_l_a_g_s  arguments provides  some additional  options  concerning
    debugging  and  exception handling.    It  is a  bitwise _o_r  of  the
    following values:

    PL_Q_NORMAL
         Normal operation.  The debugger inherits its  settings from the
         environment.   If an  exception occurs that  is not handled  in
         Prolog,  a message  is printed  and the  tracer  is started  to
         debug the error.

    PL_Q_NODEBUG
         Switch off the debugger while executing the goal.   This option
         is used by many  calls to hook-predicates to avoid  tracing the
         hooks.   An example is  print/1 calling portray/1 from  foreign
         code.

    PL_Q_CATCH_EXCEPTION
         If an  exception is  raised while  executing the  goal, do  not
         report it, but make it available for PL_exception().

    PL_Q_PASS_EXCEPTION
         As PL_Q_CATCH_EXCEPTION,  but do  not invalidate the  exception-
         term  while   calling  PL_close_query().      This  option   is
         experimental.

    PL_open_query() can return the query identifier `0' if  there is not
    enough  space on  the environment  stack.   This function  succeeds,
    even  if  the  referenced  predicate  is  not  defined.     In  this
    case,  running  the query  using PL_next_solution()  will return  an
    existence_error.  See PL_exception().

    The example below opens  a query to the predicate is_a/2 to find the
    ancestor  of `me'.  The reference to the predicate is valid  for the
    duration of the process and may be cached by the client.

    ____________________________________________________________________|                                                                    |

    | char *                                                             |
    | ancestor(const char *me)                                           |
    | { term_t a0 = PL_new_term_refs(2);                                 |
    |   static predicate_t p;                                            |
    |                                                                    |

    |   if ( !p )                                                        |
    |     p = PL_predicate("is_a", 2, "database");                       |
    |                                                                    |
    |   PL_put_atom_chars(a0, me);                                       |
    |   PL_open_query(NULL, PL_Q_NORMAL, p, a0);                         |
    |   ...                                                              |
    ||}_________________________________________________________________ ||


int PPLL__nneexxtt__ssoolluuttiioonn(_q_i_d___t _q_i_d)
    Generate the first (next)  solution for the given query.  The return
    value  is TRUE if  a solution  was found, or  FALSE to indicate  the
    query  could not be proven.  This function may be  called repeatedly
    until it fails to generate all solutions to the query.


void PPLL__ccuutt__qquueerryy(_q_i_d___t _q_i_d)
    Discards  the query, but does not delete any of the data  created by
    the  query.   It just invalidates  _q_i_d, allowing for  a new call  to
    PL_open_query() in this context.


void PPLL__cclloossee__qquueerryy(_q_i_d___t _q_i_d)
    As  PL_cut_query(), but  all data and  bindings created by the  query
    are destroyed.


int PPLL__ccaallll__pprreeddiiccaattee(_m_o_d_u_l_e___t _m_, _i_n_t _f_l_a_g_s_, _p_r_e_d_i_c_a_t_e___t _p_r_e_d_, _t_e_r_m___t _+_t_0)
    Shorthand  for  PL_open_query(),  PL_next_solution(),  PL_cut_query(),
    generating  a single solution.   The arguments  are the same as  for
    PL_open_query(), the return value is the same as PL_next_solution().


int PPLL__ccaallll(_t_e_r_m___t _t_, _m_o_d_u_l_e___t _m)
    Call  term _t just  like the Prolog  predicate once/1.   _t is  called
    in  the module _m,  or in the  context module if  _m == NULL.  Returns
    TRUE  if the call succeeds, FALSE  otherwise.  Figure 10.3  shows an
    example  to obtain  the number  of defined atoms.    All checks  are
    omitted to improve readability.


1100..44..1100 DDiissccaarrddiinngg DDaattaa

The Prolog data  created and term references  needed to set up the  call
and/or analyse  the result can  in most cases  be discarded right  after
the  call.    PL_close_query() allows  for destroying  the  data,  while
leaving the  term references.   The calls below  may be used to  destroy
term references and data.  See figure 10.3 for an example.


fid_t PPLL__ooppeenn__ffoorreeiiggnn__ffrraammee()
    Create  a  foreign frame,  holding  a mark  that allows  the  system
    to  undo bindings  and destroy  data created  after it,  as well  as
    providing  the  environment  for creating  term  references.    This
    function   is  called  by  the  kernel  before  calling   a  foreign
    predicate.


void PPLL__cclloossee__ffoorreeiiggnn__ffrraammee(_f_i_d___t _i_d)
    Discard  all term  references created  after the  frame was  opened.
    All  other Prolog data is retained.  This function is called  by the
    kernel whenever a foreign function returns control back to Prolog.


void PPLL__ddiissccaarrdd__ffoorreeiiggnn__ffrraammee(_f_i_d___t _i_d)
    Same  as PL_close_foreign_frame(),  but also  undo all bindings  made
    since the open and destroy all Prolog data.


void PPLL__rreewwiinndd__ffoorreeiiggnn__ffrraammee(_f_i_d___t _i_d)
    Undo all bindings  and discard all term references created since the
    frame  was created, but  do not pop  the frame.   That is, the  same
    frame  can be rewound multiple times, and must eventually  be closed
    or discarded.

It is obligatory to call either of the two  closing functions to discard
a foreign frame.  Foreign frames may be nested.
________________________________________________________________________|                                                                        |
|int                                                                     |

|count_atoms()                                                           |
|{ fid_t fid = PL_open_foreign_frame();                                  |
|  term_t goal  = PL_new_term_ref();                                     |
|  term_t a1    = PL_new_term_ref();                                     |
|  term_t a2    = PL_new_term_ref();                                     |
|  functor_t s2 = PL_new_functor(PL_new_atom("statistics"), 2);          |
|  int atoms;                                                            |
|                                                                        |

|  PL_put_atom_chars(a1, "atoms");                                       |
|  PL_cons_functor(goal, s2, a1, a2);                                    |
|  PL_call(goal, NULL);         /* call it in current module */          |
|                                                                        |
|  PL_get_integer(a2, &atoms);                                           |
|  PL_discard_foreign_frame(fid);                                        |
|                                                                        |

|  return atoms;                                                         |
|}|_____________________________________________________________________ | |

                      Figure 10.3:  Calling Prolog


1100..44..1111 FFoorreeiiggnn CCooddee aanndd MMoodduulleess

Modules are  identified via a  unique handle.   The following  functions
are available to query and manipulate modules.


module_t PPLL__ccoonntteexxtt()
    Return the module  identifier of the context module of the currently
    active foreign predicate.


int PPLL__ssttrriipp__mmoodduullee(_t_e_r_m___t _+_r_a_w_, _m_o_d_u_l_e___t _*_m_, _t_e_r_m___t _-_p_l_a_i_n)
    Utility  function.  If  _r_a_w is a  term, possibly holding the  module
    construct <_m_o_d_u_l_e>:<_r_e_s_t>, this function will  make _p_l_a_i_n a reference
    to  <_r_e_s_t>  and fill  _m_o_d_u_l_e _*  with <_m_o_d_u_l_e>.    For further  nested
    module  constructs the  innermost module is  returned via _m_o_d_u_l_e  _*.
    If  _r_a_w is not a module construct, _r_a_w will simply be put  in _p_l_a_i_n.
    The  value  pointed  to by  _m  must  be initialized  before  calling
    PL_strip_module(), either to the  default module or to NULL.  A NULL
    value  is replaced by the current  context module if _r_a_w carries  no
    module.   The following example  shows how to obtain the plain  term
    and module if the default module is the user module:

    ____________________________________________________________________|                                                                    |
    | { module m = PL_new_module(PL_new_atom("user"));                   |
    |   term_t plain = PL_new_term_ref();                                |
    |                                                                    |

    |   PL_strip_module(term, &m, plain);                                |
    |   ...                                                              |
    ||}_________________________________________________________________ ||


atom_t PPLL__mmoodduullee__nnaammee(_m_o_d_u_l_e___t _m_o_d_u_l_e)
    Return the name of _m_o_d_u_l_e as an atom.


module_t PPLL__nneeww__mmoodduullee(_a_t_o_m___t _n_a_m_e)
    Find an existing module or create a new module with the name _n_a_m_e.


1100..44..1122 PPrroolloogg eexxcceeppttiioonnss iinn ffoorreeiiggnn ccooddee

This     section    discusses     PL_exception(),     PL_throw()     and
PL_raise_exception(),  the  interface functions  to  detect and  generate
Prolog exceptions from C code.  PL_throw() and PL_raise_exception() from
the  C interface  raise  an exception  from foreign  code.    PL_throw()
exploits  the  C  function  longjmp()  to  return   immediately  to  the
innermost  PL_next_solution().      PL_raise_exception() registers   the
exception term and returns FALSE. If a foreign  predicate returns FALSE,
while  an exception  term  is registered,  a  Prolog exception  will  be
raised by the virtual machine.

Calling these functions  outside the context of a function  implementing
a foreign predicate results in undefined behaviour.

PL_exception() may  be used  after a  call to  PL_next_solution() fails,
and returns a  term reference to an  exception term if an exception  was
raised, and 0 otherwise.

If  a C  function  implementing a  predicate  calls Prolog  and  detects
an  exception using  PL_exception(), it  can  handle this  exception  or
return  with the  exception.    Some caution  is required  though.    It
is  nnoott allowed  to call  PL_close_query() or  PL_discard_foreign_frame()
afterwards,  as  this  will  invalidate  the  exception  term.     Below
is  the  code  that calls  a  Prolog-defined  arithmetic  function  (see
arithmetic_function/1).

If PL_next_solution() succeeds,  the result  is analysed and  translated
to  a number,  after  which the  query  is closed  and all  Prolog  data
created  after  PL_open_foreign_frame() is  destroyed.    On  the  other
hand,  if  PL_next_solution() fails  and  if an  exception  was  raised,
just  pass it.     Otherwise generate  an  exception  (PL_error() is  an
internal  call  for  building  the  standard  error  terms  and  calling
PL_raise_exception()).    After this,  the Prolog  environment should  be
discarded  using  PL_cut_query() and  PL_close_foreign_frame() to  avoid
invalidating the exception term.

________________________________________________________________________|                                                                        |
|static int                                                              |

|prologFunction(ArithFunction f, term_t av, Number r)                    |
|{ int arity = f->proc->definition->functor->arity;                      |
|  fid_t fid = PL_open_foreign_frame();                                  |
|  qid_t qid;                                                            |
|  int rval;                                                             |
|                                                                        |
|  qid = PL_open_query(NULL, PL_Q_NORMAL, f->proc, av);                  |
|                                                                        |

|  if ( PL_next_solution(qid) )                                          |
|  { rval = valueExpression(av+arity-1, r);                              |
|    PL_close_query(qid);                                                |
|    PL_discard_foreign_frame(fid);                                      |
|  } else                                                                |
|  { term_t except;                                                      |
|                                                                        |

|    if ( (except = PL_exception(qid)) )                                 |
|    { rval = PL_throw(except);          /* pass exception */            |
|    } else                                                              |
|    { char *name = stringAtom(f->proc->definition->functor->name);      |
|                                                                        |
|                                        /* generate exception */        |
|      rval = PL_error(name, arity-1, NULL, ERR_FAILED, f->proc);        |
|    }                                                                   |

|                                                                        |
|    PL_cut_query(qid);                  /* donot destroy data */        |
|    PL_close_foreign_frame(fid);        /* same */                      |
|  }                                                                     |
|                                                                        |
|  return rval;                                                          |
|}|_____________________________________________________________________ | |


int PPLL__rraaiissee__eexxcceeppttiioonn(_t_e_r_m___t _e_x_c_e_p_t_i_o_n)
    Generate  an exception (as  throw/1) and return  FALSE. Below is  an
    example returning an exception from a foreign predicate:

    ____________________________________________________________________|                                                                    |
    | foreign_t                                                          |

    | pl_hello(term_t to)                                                |
    | { char *s;                                                         |
    |                                                                    |
    |   if ( PL_get_atom_chars(to, &s) )                                 |
    |   { Sprintf("Hello \"%s\"\n", s);                                  |
    |                                                                    |
    |     PL_succeed;                                                    |
    |   } else                                                           |

    |   { term_t except = PL_new_term_ref();                             |
    |                                                                    |
    |     PL_unify_term(except,                                          |
    |                   PL_FUNCTOR_CHARS, "type_error", 2,               |
    |                     PL_CHARS, "atom",                              |
    |                     PL_TERM, to);                                  |
    |                                                                    |

    |     return PL_raise_exception(except);                             |
    |   }                                                                |
    ||}_________________________________________________________________ ||


int PPLL__tthhrrooww(_t_e_r_m___t _e_x_c_e_p_t_i_o_n)
    Similar  to PL_raise_exception(),  but returns using the C  longjmp()
    function to the innermost PL_next_solution().


term_t PPLL__eexxcceeppttiioonn(_q_i_d___t _q_i_d)
    If  PL_next_solution() fails,  this  can be  due to  normal  failure
    of  the  Prolog  call, or  because  an  exception was  raised  using
    throw/1.   This function returns  a handle to the exception term  if
    an exception was raised,  or 0 if the Prolog goal simply failed.  If
    there is  an exception, PL_exception()allocates  a term-handle using
    PL_new_term_ref() that is used to return the exception term.

    Additionally,    \cfuncref{PL_exception}{0}  returns   the   pending
    exception  in the  current query or  0 if  no exception is  pending.
    This can be used  to check the error status after a failing call to,
    e.g., one of the unification functions.


void PPLL__cclleeaarr__eexxcceeppttiioonn(_v_o_i_d)
    Tells  Prolog that the encountered exception must be ignored.   This
    function  must be called  if control remains  in C after a  previous
    API call fails with an exception.


1100..44..1133 CCaattcchhiinngg SSiiggnnaallss ((SSooffttwwaarree IInntteerrrruuppttss))

SWI-Prolog offers both  a C and Prolog  interface to deal with  software
interrupts (signals).   The Prolog mapping  is defined in section  4.11.
This subsection deals with handling signals from C.

If a signal is not  used by Prolog and the handler does not  call Prolog
in any way, the native signal interface routines may be used.

Any handler that  wishes to call one  of the Prolog interface  functions
should call PL_signal() for its installation.


void (*)() PPLL__ssiiggnnaall(_s_i_g_, _f_u_n_c)
    This  function  is equivalent  to  the BSD-Unix  signal()  function,
    regardless  of the  platform used.   The  signal handler is  blocked
    while  the signal routine  is active, and automatically  reactivated
    after the handler returns.

    After  a  signal handler  is  registered using  this  function,  the
    native  signal interface  redirects the signal  to a generic  signal
    handler  inside  SWI-Prolog.   This  generic  handler validates  the
    environment,   creates  a  suitable  environment  for   calling  the
    interface functions described  in this chapter and finally calls the
    registered user-handler.

    By  default, signals are handled  asynchronously (i.e., at the  time
    they  arrive).   It is inherently  dangerous to call extensive  code
    fragments,  and especially exception related code  from asynchronous
    handlers.     The  interface  allows  for  _s_y_n_c_h_r_o_n_o_u_s  handling  of
    signals.   In  this case  the native OS  handler just schedules  the
    signal  using PL_raise(),  which is checked by PL_handle_signals() at
    the  call- and redo-port.  This behaviour is realised by  _o_r-ing _s_i_g
    with the constant PL_SIGSYNC.

    Signal    handling    routines    may   raise    exceptions    using
    PL_raise_exception().      The  use  of  PL_throw()  is  not   safe.
    If  a  synchronous handler  raises an  exception,  the exception  is
    delayed to the next call to PL_handle_signals();


int PPLL__rraaiissee(_i_n_t _s_i_g)
    Register  _s_i_g  for  _s_y_n_c_h_r_o_n_o_u_s handling  by  Prolog.    Synchronous
    signals  are  handled at  the  call-port or  if foreign  code  calls
    PL_handle_signals().  See also thread_signal/2.


int PPLL__hhaannddllee__ssiiggnnaallss(_v_o_i_d)
    Handle  any signals  pending from  PL_raise().   PL_handle_signals()
    is  called at each  pass through the call-  and redo-port at a  safe
    point.   Exceptions raised by the handler using PL_raise_exception()
    are properly passed to the environment.

    The  user  may   call  this  function  inside  long-running  foreign
    functions to handle  scheduled interrupts.  This routine returns the
    number  of signals handled.   If a handler raises an exception,  the
    return value is  -1 and the calling routine should return with FALSE
    as soon as possible.


int PPLL__ggeett__ssiiggnnuumm__eexx(_t_e_r_m___t _t_, _i_n_t _*_s_i_g)
    Extract  a signal specification from a  Prolog term and store as  an
    integer  signal number in _s_i_g.   The specification is an integer,  a
    lowercase  signal name without SIG or  the full signal name.   These
    refer  to the same:  9, kill and SIGKILL. Leaves a typed,  domain or
    instantiation error if the conversion fails.


1100..44..1144 MMiisscceellllaanneeoouuss


1100..44..1144..11 TTeerrmm CCoommppaarriissoonn


int PPLL__ccoommppaarree(_t_e_r_m___t _t_1_, _t_e_r_m___t _t_2)
    Compares  two terms using  the standard order  of terms and  returns
    -1, 0 or 1.  See also compare/3.


int PPLL__ssaammee__ccoommppoouunndd(_t_e_r_m___t _t_1_, _t_e_r_m___t _t_2)
    Yields TRUE if _t_1  and _t_2 refer to physically the same compound term
    and FALSE otherwise.


1100..44..1144..22 RReeccoorrddeedd ddaattaabbaassee

In some  applications it is  useful to store  and retrieve Prolog  terms
from C code.  For example, the XPCE graphical  environment does this for
storing arbitrary Prolog data as slot-data of XPCE objects.

Please note  that the  returned handles  have no meaning  at the  Prolog
level  and  the recorded  terms  are  not  visible from  Prolog.     The
functions PL_recorded() and PL_erase() are  the only functions that  can
operate on the stored term.

Two groups of functions are provided.   The first group (PL_record() and
friends) store Prolog terms on the Prolog heap for  retrieval during the
same session.   These functions are also used by recorda/3  and friends.
The recorded  database may be used  to communicate Prolog terms  between
threads.


record_t PPLL__rreeccoorrdd(_t_e_r_m___t _+_t)
    Record  the term _t into the Prolog database as recorda/3  and return
    an  opaque handle to  the term.   The returned handle remains  valid
    until  PL_erase() is called on  it.   PL_recorded() is used to  copy
    recorded terms back to the Prolog stack.


int PPLL__rreeccoorrddeedd(_r_e_c_o_r_d___t _r_e_c_o_r_d_, _t_e_r_m___t _-_t)
    Copy a recorded term  back to the Prolog stack.  The same record may
    be used to copy  multiple instances at any time to the Prolog stack.
    Returns  TRUE on  success, and FALSE  if there  is not enough  space
    on  the stack  to accommodate the  term.   See also  PL_record() and
    PL_erase().


void PPLL__eerraassee(_r_e_c_o_r_d___t _r_e_c_o_r_d)
    Remove  the recorded term from  the Prolog database, reclaiming  all
    associated memory resources.

The  second group  (headed  by PL_record_external()) provides  the  same
functionality, but the returned data has properties  that enable storing
the  data  on an  external  device.     It has  been  designed  to  make
it  possible to  store Prolog  terms  fast and  compact in  an  external
database.  Here are the main features:

  o _I_n_d_e_p_e_n_d_e_n_t _o_f _s_e_s_s_i_o_n
    Records  can  be communicated  to another  Prolog  session and  made
    visible using PL_recorded_external().

  o _B_i_n_a_r_y
    The representation is  binary for maximum performance.  The returned
    data may contain zero bytes.

  o _B_y_t_e_-_o_r_d_e_r _i_n_d_e_p_e_n_d_e_n_t
    The   representation  can  be  transferred  between   machines  with
    different byte order.

  o _N_o _a_l_i_g_n_m_e_n_t _r_e_s_t_r_i_c_t_i_o_n_s
    There are no  memory alignment restrictions and copies of the record
    can  thus be  moved freely.    For example,  it is  possible to  use
    this  representation to exchange  terms using shared memory  between
    different Prolog processes.

  o _C_o_m_p_a_c_t
    It  is  assumed  that a  smaller  memory footprint  will  eventually
    outperform slightly faster representations.

  o _S_t_a_b_l_e
    The  format is  designed  for future  enhancements without  breaking
    compatibility with older records.


char * PPLL__rreeccoorrdd__eexxtteerrnnaall(_t_e_r_m___t _+_t_, _s_i_z_e___t _*_l_e_n)
    Record  the term _t into the Prolog database as recorda/3  and return
    an  opaque handle to  the term.   The returned handle remains  valid
    until PL_erase_external() is called on it.

    It  is allowed  to copy the  data and use  PL_recorded_external() on
    the  copy.   The user  is responsible for  the memory management  of
    the  copy.    After copying,  the original  may  be discarded  using
    PL_erase_external().

    PL_recorded_external() is used to  copy such recorded terms back  to
    the Prolog stack.


int PPLL__rreeccoorrddeedd__eexxtteerrnnaall(_c_o_n_s_t _c_h_a_r _*_r_e_c_o_r_d_, _t_e_r_m___t _-_t)
    Copy a recorded term  back to the Prolog stack.  The same record may
    be used to copy  multiple instances at any time to the Prolog stack.
    See also PL_record_external() and PL_erase_external().


int PPLL__eerraassee__eexxtteerrnnaall(_c_h_a_r _*_r_e_c_o_r_d)
    Remove  the recorded term from  the Prolog database, reclaiming  all
    associated memory resources.


1100..44..1144..33 GGeettttiinngg ffiillee nnaammeess

The function PL_get_file_name() provides access to Prolog filenames  and
its  file-search mechanism  described  with absolute_file_name/3.    Its
existence is motivated to realise a uniform interface to  deal with file
properties, search, naming conventions, etc., from foreign code.


int PPLL__ggeett__ffiillee__nnaammee(_t_e_r_m___t _s_p_e_c_, _c_h_a_r _*_*_n_a_m_e_, _i_n_t _f_l_a_g_s)
    Translate  a Prolog  term into  a file  name.   The  name is  stored
    in  the static buffer  ring described with  th PL_get_chars() option
    BUF_RING.  Conversion from  the internal  UNICODE  encoding is  done
    using   standard  C  library  functions.     _f_l_a_g_s  is   a  bit-mask
    controlling the conversion process.  Options are:

    PL_FILE_ABSOLUTE
         Return an absolute path to the requested file.

    PL_FILE_OSPATH
         Return  the  name  using  the  hosting  OS  conventions.     On
         MS-Windows, \ is  used to separate directories rather than  the
         canonical /.

    PL_FILE_SEARCH
         Invoke  absolute_file_name/3.      This   implies  rules   from
         file_search_path/2are used.

    PL_FILE_EXIST
         Demand the path to refer to an existing entity.

    PL_FILE_READ
         Demand read-access on the result.

    PL_FILE_WRITE
         Demand write-access on the result.

    PL_FILE_EXECUTE
         Demand execute-access on the result.

    PL_FILE_NOERRORS
         Do not raise any exceptions.


int PPLL__ggeett__ffiillee__nnaammeeWW(_t_e_r_m___t _s_p_e_c_, _w_c_h_a_r___t _*_*_n_a_m_e_, _i_n_t _f_l_a_g_s)
    Same  as  PL_get_file_name(), but  returns the  filename  as a  wide-
    character  string.    This is  intended for  Windows  to access  the
    Unicode  version of the Win32 API. Note that the flag PL_FILE_OSPATH
    must  be provided to  fetch a filename in  OS native (e.g.,  C:\x\y)
    notation.


1100..44..1144..44 DDeeaalliinngg wwiitthh PPrroolloogg ffllaaggss ffrroomm CC

Foreign code can  set or create Prolog flags using  PL_set_prolog_flag().
See set_prolog_flag/2and create_prolog_flag/3.


int PPLL__sseett__pprroolloogg__ffllaagg(_c_o_n_s_t _c_h_a_r _*_n_a_m_e_, _i_n_t _t_y_p_e_, _._._.)
    Set/create  a Prolog flag from C.  _n_a_m_e is the name of the  affected
    flag.    _t_y_p_e  is  one of  the  values below,  which  also  dictates
    the  type of  the  final argument.    The function  returns TRUE  on
    success  and FALSE on failure.   This function can be called  _b_e_f_o_r_e
    PL_initialise(),  making the  flag available to  the Prolog  startup
    code.

    PL_BOOL
         Create a boolean  (true or false) flag.   The argument must  be
         an int.

    PL_ATOM
         Create a flag with an  atom as value.  The argument must  be of
         type const char *.

    PL_INTEGER
         Create a flag with an  integer as value.  The argument  must be
         of type intptr_t *.


1100..44..1155 EErrrroorrss aanndd wwaarrnniinnggss

PL_warning() prints a  standard Prolog warning  message to the  standard
error (user_error) stream.   Please note  that new code should  consider
using  PL_raise_exception() to  raise a  Prolog  exception.    See  also
section 4.10.


int PPLL__wwaarrnniinngg(_f_o_r_m_a_t_, _a_1_, _._._.)
    Print  an  error message  starting  with `[WARNING: ',  followed  by
    the  output from  _f_o_r_m_a_t, followed  by a `]'  and a newline.    Then
    start  the tracer.   _f_o_r_m_a_t and  the arguments are  the same as  for
    printf(2).  Always returns FALSE.


1100..44..1166 EEnnvviirroonnmmeenntt CCoonnttrrooll ffrroomm FFoorreeiiggnn CCooddee


int PPLL__aaccttiioonn(_i_n_t_, _._._.)
    Perform  some  action on  the  Prolog system.    _i_n_t  describes  the
    action.   Remaining arguments depend  on the requested action.   The
    actions are listed below:

    PPLL__AACCTTIIOONN__TTRRAACCEE
         Start Prolog tracer (trace/0).  Requires no arguments.

    PPLL__AACCTTIIOONN__DDEEBBUUGG
         Switch on Prolog debug mode (debug/0).  Requires no arguments.

    PPLL__AACCTTIIOONN__BBAACCKKTTRRAACCEE
         Print backtrace  on current output  stream.   The argument  (an
         int) is the number of frames printed.

    PPLL__AACCTTIIOONN__HHAALLTT
         Halt Prolog  execution.   This action  should be called  rather
         than Unix exit()  to give Prolog  the opportunity to clean  up.
         This call does not return.   The argument (an int) is  the exit
         code.  See halt/1.

    PPLL__AACCTTIIOONN__AABBOORRTT
         Generate a Prolog abort (abort/0).  This call  does not return.
         Requires no arguments.

    PPLL__AACCTTIIOONN__BBRREEAAKK
         Create a standard Prolog break environment (break/0).   Returns
         after the user  types the end-of-file  character.  Requires  no
         arguments.

    PPLL__AACCTTIIOONN__GGUUIIAAPPPP
         Windows:  Used to  indicate to the kernel that  the application
         is a GUI  application if the argument is  not 0, and a  console
         application if  the argument is 0.   If  a fatal error  occurs,
         the system uses  a windows messagebox to  report this on a  GUI
         application, and otherwise simply prints the error and exits.

    PPLL__AACCTTIIOONN__TTRRAADDIITTIIOONNAALL
         Same effect  as using  --traditional.   Must  be called  _b_e_f_o_r_e
         PL_initialise().

    PPLL__AACCTTIIOONN__WWRRIITTEE
         Write the argument, a char * to the current output stream.

    PPLL__AACCTTIIOONN__FFLLUUSSHH
         Flush the current output stream.  Requires no arguments.

    PPLL__AACCTTIIOONN__AATTTTAACCHH__CCOONNSSOOLLEE
         Attach a  console to a  thread if it  does not have  one.   See
         attach_console/0.

    PPLL__GGMMPP__SSEETT__AALLLLOOCC__FFUUNNCCTTIIOONNSS
         Takes  an integer  argument.    If  TRUE, the  GMP  allocations
         are immediately  bound  to the  Prolog functions.    If  FALSE,
         SWI-Prolog  will never  rebind  the GMP  allocation  functions.
         See mp_set_memory_functions() in  the GMP  documentation.    The
         action returns  FALSE if  there  is no  GMP support  or GMP  is
         already initialised.


int PPLL__bbaacckkttrraaccee(_i_n_t _d_e_p_t_h_, _i_n_t _f_l_a_g_s)
    Print  a Prolog backtrace to the  standard error stream.  The  _d_e_p_t_h
    argument  specifies the  maximum number  of frames  to print.    The
    _f_l_a_g_s  argument is  a bitwise or  of the constants  PL_BT_SAFE  (0x1)
    and  PL_BT_USER (0x2).   PL_BT_SAFE causes frames  not to be  printed
    as  normal Prolog goals,  but using  the predicate, program  counter
    and clause-number.   For example, the dump below indicates the frame
    is  executing the 2nd clause of  $autoload:load_library_index_p/0 at
    program pointer 25.   This can be interpreted by dumping the virtual
    machine code using vm_list/1.

    ____________________________________________________________________|                                                                    |
    ||__[34]_$autoload:load_library_index_p/0_[PC=19_in_clause_2]_______ ||

    If  the  constant  PL_BT_USER  is specified,  `no-debug'  frames  are
    ignored.    This predicate may  be used  from the C-debugger  (e.g.,
    gdb)  to get  the Prolog  stack at  a crash location.    Here is  an
    example dumping the top 20 frames of the Prolog stack.

    ____________________________________________________________________|                                                                    |

    ||(gdb)_call_PL_backtrace(20,0)_____________________________________ ||


1100..44..1177 QQuueerryyiinngg PPrroolloogg


long PPLL__qquueerryy(_i_n_t)
    Obtain  status  information  on  the  Prolog system.     The  actual
    argument  type depends on the  information required.  _i_n_t  describes
    what information is wanted.  The options are given in table 10.1.
    __________________________________________________________
    | PL_QUERY_ARGC          |Return  an  integer holding  the|
    |                        |number  of  arguments  given  to|
    |                        |Prolog from Unix.               |
    | PL_QUERY_ARGV          |Return  a  char **  holding  the|
    |                        |argument vector  given to Prolog|

    |                        |from Unix.                      |
    | PL_QUERY_SYMBOLFILE    |Return  a   char *  holding  the|
    |                        |current   symbol  file   of  the|
    |                        |running process.                |
    | PL_MAX_INTEGER         |Return a  long, representing the|
    |                        |maximal  integer   value  repre-|
    |                        |sented by a Prolog integer.     |

    | PL_MIN_INTEGER         |Return a  long, representing the|
    |                        |minimal integer value.          |
    | PL_QUERY_VERSION       |Return a  long, representing the|
    |                        |version  as  10;000M* +100m* +p,|
    |                        |where  M is  the  major, m  the |
    |                        |minor version  number and  p the|
    |                        |patch level.  For example, 20717|
    |                        |means 2.7.17.                   |

    | PL_QUERY_ENCODING      |Return the default stream encod-|
    |                        |ing of Prolog (of type IOENC).  |
    | PL_QUERY_USER_CPU      |Get amount  of user CPU  time of|
    |________________________|the_process_in_milliseconds.____|

                    Table 10.1:  PL_query() options


1100..44..1188 RReeggiisstteerriinngg FFoorreeiiggnn PPrreeddiiccaatteess


int PPLL__rreeggiisstteerr__ffoorreeiiggnn__iinn__mmoodduullee(_c_h_a_r _*_m_o_d_, _c_h_a_r _*_n_a_m_e_, _i_n_t _a_r_i_t_y_, _f_o_r_e_i_g_n___t _(_*_f_)_(_)_, _i_n_t _f_l_a_g_s_, _._._.)
    Register  the C function _f to  implement a Prolog predicate.   After
    this  call returns successfully a  predicate with name _n_a_m_e (a  char
    *)  and arity _a_r_i_t_y  (a C  int) is created  in module _m_o_d.   If  _m_o_d
    is  NULL, the  predicate is  created in  the module  of the  calling
    context, or if no context is present in the module user.

    When  called in Prolog,  Prolog will  call _f_u_n_c_t_i_o_n.   _f_l_a_g_s form  a
    bitwise _o_r'ed list of options for the installation.  These are:
    _______________________________________________________________
    | PL_FA_META             |Provide   meta-predicate  info   (see|
    |                        |below)                               |
    | PL_FA_TRANSPARENT      |Predicate   is   module   transparent|
    |                        |(deprecated)                         |

    | PL_FA_NONDETERMINISTIC |Predicate is non-deterministic.   See|
    |                        |also PL_retry().                     |
    | PL_FA_NOTRACE          |Predicate  cannot  be  seen  in   the|
    |                        |tracer                               |
    |_PL_FA_VARARGS__________|Use_alternative_calling_convention.__|

    If  PL_FA_META is provided,  PL_register_foreign_in_module()takes one
    extra  argument.    This argument  is  of type  const char*.    This
    string  must  be exactly  as  long as  the  number of  arguments  of
    the  predicate and  filled with  characters from  the set  0-9:^-+?.
    See  meta_predicate/1 for  details.    PL_FA_TRANSPARENT  is  implied
    if  at  least one  meta-argument is  provided (0-9:^).    Note  that
    meta-arguments  are _n_o_t  _a_l_w_a_y_s passed  as <_m_o_d_u_l_e>:<_t_e_r_m>.    Always
    use  PL_strip_module()to  extract the module  and plain term from  a
    meta-argument.

    Predicates    may   be   registered    either   before   or    after
    PL_initialise().      When  registered  before  initialisation   the
    registration  is recorded and  executed after installing the  system
    predicates and before loading the saved state.

    Default  calling (i.e. without PL_FA_VARARGS) _f_u_n_c_t_i_o_n is  passed the
    same  number of term_t arguments as the arity of the  predicate and,
    if  the predicate is  non-deterministic, an  extra argument of  type
    control_t  (see section  10.4.1.1).   If PL_FA_VARARGS is  provided,
    _f_u_n_c_t_i_o_n  is called  with three arguments.    The first argument  is
    a  term_t  handle to the  first argument.   Further arguments can  be
    reached  by adding  the offset (see  also PL_new_term_refs()).    The
    second  argument is  the arity,  which defines the  number of  valid
    term  references in the argument vector.  The last argument  is used
    for  non-deterministic  calls.   It  is  currently undocumented  and
    should be defined of type void*.  Here is an example:

    ____________________________________________________________________|                                                                    |

    | static foreign_t                                                   |
    | atom_checksum(term_t a0, int arity, void* context)                 |
    | { char *s;                                                         |
    |                                                                    |
    |   if ( PL_get_atom_chars(a0, &s) )                                 |
    |   { int sum;                                                       |

    |                                                                    |
    |     for(sum=0; *s; s++)                                            |
    |       sum += *s&0xff;                                              |
    |                                                                    |
    |     return PL_unify_integer(a0+1, sum&0xff);                       |
    |   }                                                                |
    |                                                                    |
    |   return FALSE;                                                    |

    | }                                                                  |
    |                                                                    |
    | install_t                                                          |
    | install()                                                          |
    | { PL_register_foreign("atom_checksum", 2,                          |
    |                       atom_checksum, PL_FA_VARARGS);               |
    ||}_________________________________________________________________ ||


int PPLL__rreeggiisstteerr__ffoorreeiiggnn(_c_o_n_s_t _c_h_a_r _*_n_a_m_e_, _i_n_t _a_r_i_t_y_, _f_o_r_e_i_g_n___t _(_*_f_u_n_c_t_i_o_n_)_(_)_, _i_n_t _f_l_a_g_s_, _._._.)
    Same   as  PL_register_foreign_in_module(),  passing  NULL   for  the
    _m_o_d_u_l_e.


void PPLL__rreeggiisstteerr__eexxtteennssiioonnss__iinn__mmoodduullee(_c_o_n_s_t _c_h_a_r _*_m_o_d_u_l_e_, _P_L___e_x_t_e_n_s_i_o_n _*_e)
    Register a series  of predicates from an array of definitions of the
    type  PL_extension in  the given _m_o_d_u_l_e.    If _m_o_d_u_l_e  is NULL,  the
    predicate is created in  the module of the calling context, or if no
    context  is present in  the module user.   The PL_extension type  is
    defined as

    ____________________________________________________________________|                                                                    |
    | typedef struct PL_extension                                        |
    | { char          *predicate_name; /* Name of the predicate */       |
    |   short         arity;           /* Arity of the predicate */      |

    |   pl_function_t function;        /* Implementing functions */      |
    |   short         flags;           /* Or of PL_FA_... */             |
    ||}_PL_extension;___________________________________________________ ||

    For  details,  see  PL_register_foreign_in_module().     Here  is  an
    example of its usage:

    ____________________________________________________________________|                                                                    |
    | static PL_extension predicates[] = {                               |
    | { "foo",        1,      pl_foo, 0 },                               |
    | { "bar",        2,      pl_bar, PL_FA_NONDETERMINISTIC },          |

    | { NULL,         0,      NULL,   0 }                                |
    | };                                                                 |
    |                                                                    |
    | main(int argc, char **argv)                                        |
    | { PL_register_extensions_in_module("user", predicates);            |
    |                                                                    |
    |   if ( !PL_initialise(argc, argv) )                                |

    |     PL_halt(1);                                                    |
    |                                                                    |
    |   ...                                                              |
    ||}_________________________________________________________________ ||


void PPLL__rreeggiisstteerr__eexxtteennssiioonnss( _P_L___e_x_t_e_n_s_i_o_n _*_e)
    Same as  PL_register_extensions_in_module()using  NULL for the _m_o_d_u_l_e
    argument.


1100..44..1199 FFoorreeiiggnn CCooddee HHooookkss

For various specific applications some hooks are provided.


PL_dispatch_hook_t PPLL__ddiissppaattcchh__hhooookk(_P_L___d_i_s_p_a_t_c_h___h_o_o_k___t)
    If this hook is  not NULL, this function is called when reading from
    the  terminal.   It is supposed  to dispatch events when  SWI-Prolog
    is  connected to a  window environment.   It can return two  values:
    PL_DISPATCH_INPUT  indicates  Prolog  input  is  available  on  file
    descriptor  0 or PL_DISPATCH_TIMEOUT to indicate a timeout.   The old
    hook is returned.  The type PL_dispatch_hook_t is defined as:

    ____________________________________________________________________|                                                                    |
    ||typedef_int__(*PL_dispatch_hook_t)(void);_________________________ ||


void PPLL__aabboorrtt__hhooookk(_P_L___a_b_o_r_t___h_o_o_k___t)
    Install  a hook  when abort/0 is  executed.   SWI-Prolog abort/0  is
    implemented  using C  setjmp()/longjmp() construct.   The hooks  are
    executed  in  the  reverse order  of  their registration  after  the
    longjmp()  took place and before the Prolog top level  is reinvoked.
    The type PL_abort_hook_t is defined as:

    ____________________________________________________________________|                                                                    |
    ||typedef_void_(*PL_abort_hook_t)(void);____________________________ ||


int PPLL__aabboorrtt__uunnhhooookk(_P_L___a_b_o_r_t___h_o_o_k___t)
    Remove  a hook installed with PL_abort_hook().  Returns FALSE  if no
    such hook is found, TRUE otherwise.


void PPLL__oonn__hhaalltt(_i_n_t _(_*_f_)_(_i_n_t_, _v_o_i_d _*_)_, _v_o_i_d _*_c_l_o_s_u_r_e)
    Register  the function _f to be called if SWI-Prolog is halted.   The
    function  is  called with  two  arguments:   the  exit code  of  the
    process  (0 if this cannot  be determined) and the _c_l_o_s_u_r_e  argument
    passed  to the PL_on_halt() call.   Handlers _m_u_s_t  return 0.   Other
    return  values are  reserved for future  use.   See  also at_halt/1.
    These  handlers are called _b_e_f_o_r_e  system cleanup and can  therefore
    access all normal Prolog resources.  See also PL_exit_hook().


void PPLL__eexxiitt__hhooookk(_i_n_t _(_*_f_)_(_i_n_t_, _v_o_i_d _*_)_, _v_o_i_d _*_c_l_o_s_u_r_e)
    Similar  to PL_on_halt(), but  the hooks  are executed  by PL_halt()
    instead of PL_cleanup() just before calling exit().


PL_agc_hook_t PPLL__aaggcc__hhooookk(_P_L___a_g_c___h_o_o_k___t _n_e_w)
    Register    a   hook   with   the   atom-garbage    collector   (see
    garbage_collect_atoms/0)  that  is  called  on  any  atom   that  is
    reclaimed.    The old hook  is returned.   If  no hook is  currently
    defined,  NULL is returned.  The argument of the called hook  is the
    atom  that is to be garbage collected.  The return value  is an int.
    If  the return value is zero, the  atom is nnoott reclaimed.   The hook
    may invoke any Prolog predicate.

    The  example  below  defines  a foreign  library  for  printing  the
    garbage collected atoms for debugging purposes.

    ____________________________________________________________________|                                                                    |
    | #include <SWI-Stream.h>                                            |

    | #include <SWI-Prolog.h>                                            |
    |                                                                    |
    | static int                                                         |
    | atom_hook(atom_t a)                                                |
    | { Sdprintf("AGC: deleting %s\n", PL_atom_chars(a));                |
    |                                                                    |
    |   return TRUE;                                                     |
    | }                                                                  |

    |                                                                    |
    | static PL_agc_hook_t old;                                          |
    |                                                                    |
    | install_t                                                          |
    | install()                                                          |
    | { old = PL_agc_hook(atom_hook);                                    |
    | }                                                                  |

    |                                                                    |
    | install_t                                                          |
    | uninstall()                                                        |
    | { PL_agc_hook(old);                                                |
    ||}_________________________________________________________________ ||


1100..44..2200 SSttoorriinngg ffoorreeiiggnn ddaattaa

When combining  foreign code with  Prolog, it can  be necessary to  make
data  represented in  the foreign  language available  to Prolog.    For
example, to  pass it to another  foreign function.   At the end of  this
section, there  is a partial  implementation of using foreign  functions
to manage  bit-vectors.   Another example is  the SGML/XML library  that
manages a `parser' object,  an object that represents the  current state
of  the parser  and that  can be  directed to  perform  actions such  as
parsing a document or make queries about the document content.

This section  provides some hints for  handling foreign data in  Prolog.
There are four options for storing such data:

  o _N_a_t_u_r_a_l _P_r_o_l_o_g _d_a_t_a
    Uses  the representation  one would choose  if no foreign  interface
    was  required.   For  example, a  bitvector representing  a list  of
    small integers can be represented as a Prolog list of integers.

  o _O_p_a_q_u_e _p_a_c_k_e_d _d_a_t_a _o_n _t_h_e _s_t_a_c_k_s
    It  is possible to  represent the raw  binary representation of  the
    foreign  object  as a  Prolog string  (see section  5.2).    Strings
    may  be created  from foreign data  using PL_put_string_nchars() and
    retrieved  using PL_get_string_chars().  It is good practice  to wrap
    the  string in a compound term with arity 1, so Prolog  can identify
    the  type.    The hook  portray/1 rules  may be  used to  streamline
    printing such terms during development.

  o _O_p_a_q_u_e _p_a_c_k_e_d _d_a_t_a _i_n _a _b_l_o_b
    Similar  to the  above solution,  binary data  can be  stored in  an
    atom.    The  blob interface  (section  10.4.7) provides  additional
    facilities to assign  a type and hook-functions that act on creation
    and destruction of the underlying atom.

  o _N_a_t_u_r_a_l _f_o_r_e_i_g_n _d_a_t_a_, _p_a_s_s_e_d _a_s _a _p_o_i_n_t_e_r
    An  alternative is to pass  a pointer to the  foreign data.   Again,
    the pointer is often wrapped in a compound term.

The choice may be guided using the following distinctions

  o _I_s _t_h_e _d_a_t_a _o_p_a_q_u_e _t_o _P_r_o_l_o_g
    With  `opaque' data, we refer to data handled in  foreign functions,
    passed  around  in  Prolog,  but  where Prolog  never  examines  the
    contents  of the data itself.  If the data is opaque to  Prolog, the
    selection  will be driven solely by simplicity of the  interface and
    performance.

  o _W_h_a_t _i_s _t_h_e _l_i_f_e_t_i_m_e _o_f _t_h_e _d_a_t_a
    With  `lifetime' we refer  to how it is  decided that the object  is
    (or can be) destroyed.  We can distinguish three cases:

     1.  The object must be destroyed on backtracking  and normal Prolog
         garbage collection  (i.e., it  acts as a  normal Prolog  term).
         In  this case,  representing  the  object as  a  Prolog  string
         (second option above) is the only feasible solution.

     2.  The data  must survive Prolog  backtracking.   This leaves  two
         options.   One is to represent  the object using a pointer  and
         use explicit  creation and destruction,  making the  programmer
         responsible.   The  alternative is to  use the  blob-interface,
         leaving destruction to the (atom) garbage collector.

     3.  The  data   lives  as   during  the  lifetime   of  a   foreign
         function  that  implements a  predicate.     If  the  predicate
         is deterministic,  foreign  automatic variables  are  suitable.
         If  the  predicate  is  non-deterministic,  the   data  may  be
         allocated using  malloc() and  a pointer may  be passed.    See
         section 10.4.1.1.


1100..44..2200..11 EExxaammpplleess ffoorr ssttoorriinngg ffoorreeiiggnn ddaattaa

In  this section,  we  outline some  examples, covering  typical  cases.
In  the  first  example,  we will  deal  with  extending  Prolog's  data
representation with integer sets, represented as bit-vectors.   Then, we
discuss the outline of the DDE interface.

IInntteeggeerr  sseettss with  not-too-far-apart upper-  and  lower-bounds  can  be
represented using  bit-vectors.  Common  set operations, such as  union,
intersection,  etc.,  are  reduced  to simple  _a_n_d'ing  and  _o_r'ing  the
bit-vectors.  This can be done using Prolog's unbounded integers.

For really demanding  applications, foreign representation will  perform
better,  especially  time-wise.    Bit-vectors are  naturally  expressed
using string  objects.   If the  string is wrapped  in bitvector/1,  the
lower-bound of the  vector is 0 and  the upper-bound is not defined;  an
implementation for  getting and putting  the sets as  well as the  union
predicate for it is below.

________________________________________________________________________|                                                                        |
|#include <SWI-Prolog.h>                                                 |

|                                                                        |
|#define max(a, b) ((a) > (b) ? (a) : (b))                               |
|#define min(a, b) ((a) < (b) ? (a) : (b))                               |
|                                                                        |
|static functor_t FUNCTOR_bitvector1;                                    |
|                                                                        |
|static int                                                              |
|get_bitvector(term_t in, int *len, unsigned char **data)                |

|{ if ( PL_is_functor(in, FUNCTOR_bitvector1) )                          |
|  { term_t a = PL_new_term_ref();                                       |
|                                                                        |
|    PL_get_arg(1, in, a);                                               |
|    return PL_get_string(a, (char **)data, len);                        |
|  }                                                                     |
|                                                                        |

|  PL_fail;                                                              |
|}                                                                       |
|                                                                        |
|static int                                                              |
|unify_bitvector(term_t out, int len, const unsigned char *data)         |
|{ if ( PL_unify_functor(out, FUNCTOR_bitvector1) )                      |
|  { term_t a = PL_new_term_ref();                                       |
|                                                                        |

|    PL_get_arg(1, out, a);                                              |
|                                                                        |
|    return PL_unify_string_nchars(a, len, (const char *)data);          |
|  }                                                                     |
|                                                                        |
|  PL_fail;                                                              |
|}                                                                       |

|                                                                        |
|static foreign_t                                                        |
|pl_bitvector_union(term_t t1, term_t t2, term_t u)                      |
|{ unsigned char *s1, *s2;                                               |
|  int l1, l2;                                                           |
|                                                                        |
|  if ( get_bitvector(t1, &l1, &s1) &&                                   |
|       get_bitvector(t2, &l2, &s2) )                                    |

|  { int l = max(l1, l2);                                                |
|    unsigned char *s3 = alloca(l);                                      |
|                                                                        |
|    if ( s3 )                                                           |
|    { int n;                                                            |
|      int ml = min(l1, l2);                                             |
|                                                                        |

|      for(n=0; n<ml; n++)                                               |
|        s3[n] = s1[n] | s2[n];                                          |
|      for( ; n < l1; n++)                                               |
|        s3[n] = s1[n];                                                  |
|      for( ; n < l2; n++)                                               |
|        s3[n] = s2[n];                                                  |
|                                                                        |
|      return unify_bitvector(u, l, s3);                                 |

|    }                                                                   |
|                                                                        |
|    return PL_warning("Not enough memory");                             |
|  }                                                                     |
|                                                                        |
|  PL_fail;                                                              |
|}                                                                       |

|                                                                        |
|                                                                        |
|install_t                                                               |
|install()                                                               |
|{ PL_register_foreign("bitvector_union", 3, pl_bitvector_union, 0);     |
|                                                                        |
|  FUNCTOR_bitvector1 = PL_new_functor(PL_new_atom("bitvector"), 1);     |
|}|_____________________________________________________________________ | |

TThhee DDDDEE  iinntteerrffaaccee (see section  4.41) represents  another common  usage
of  the foreign  interface:   providing communication  to new  operating
system features.  The DDE interface requires knowledge  about active DDE
server and  client channels.   These  channels contains various  foreign
data types.  Such an interface is normally  achieved using an open/close
protocol that creates and destroys a _h_a_n_d_l_e.  The  handle is a reference
to a foreign data structure containing the relevant information.

There are a  couple of possibilities for  representing the handle.   The
choice  depends on  responsibilities  and  debugging facilities.     The
simplest  approach is  to  use PL_unify_pointer()  and PL_get_pointer().
This  approach is  fast and  easy, but  has the  drawbacks of  (untyped)
pointers:   there  is no  reliable way  to detect  the  validity of  the
pointer,  nor to  verify  that it  is  pointing to  a structure  of  the
desired type.   The  pointer may  be wrapped into  a compound term  with
arity  1 (i.e.,  dde_channel(<_P_o_i_n_t_e_r>)),  making the  type-problem  less
serious.

Alternatively  (used in  the  DDE  interface),  the interface  code  can
maintain a  (preferably variable  length) array of  pointers and  return
the index in this  array.  This provides better protection.   Especially
for debugging  purposes, wrapping  the handle  in a compound  is a  good
suggestion.


1100..44..2211 EEmmbbeeddddiinngg SSWWII--PPrroolloogg iinn ootthheerr aapppplliiccaattiioonnss

With embedded Prolog we refer to the situation where  the `main' program
is not the Prolog application.  Prolog is sometimes  embedded in C, C++,
Java or  other languages  to provide  logic based services  in a  larger
application.   Embedding  loads the Prolog  engine as  a library to  the
external language.   Prolog itself only provides for embedding in  the C
language (compatible  with C++).   Embedding in  Java is achieved  using
JPL using a C-glue between the Java and Prolog C interfaces.

The  most   simple  embedded   program  is   below.      The   interface
function  PL_initialise()  mmuusstt  be  called  before  any  of  the  other
SWI-Prolog  foreign  language  functions  described  in   this  chapter,
except  for  PL_initialise_hook(),   PL_new_atom(),  PL_new_functor()  and
PL_register_foreign().   PL_initialise() interprets all the command  line
arguments,  except  for the  -t toplevel  flag  that is  interpreted  by
PL_toplevel().

________________________________________________________________________|                                                                        |
|int                                                                     |

|main(int argc, char **argv)                                             |
|{                                                                       |
|#ifdef READLINE /* Remove if you don't want readline */                 |
|  PL_initialise_hook(install_readline);                                 |
|#endif                                                                  |
|                                                                        |
|  if ( !PL_initialise(argc, argv) )                                     |
|    PL_halt(1);                                                         |

|                                                                        |
|  PL_halt(PL_toplevel() ? 0 : 1);                                       |
|}|_____________________________________________________________________ | |


int PPLL__iinniittiiaalliissee(_i_n_t _a_r_g_c_, _c_h_a_r _*_*_a_r_g_v)
    Initialises  the SWI-Prolog  heap and  stacks,  restores the  Prolog
    state, loads the  system and personal initialisation files, runs the
    initialization/1 hooks and finally runs the -g goal hook.

    Special  consideration  is required  for argv[0].    On  UUnniixx,  this
    argument passes the part  of the command line that is used to locate
    the  executable.   Prolog  uses this to  find the  file holding  the
    running executable.   The WWiinnddoowwss version uses this to find a _m_o_d_u_l_e
    of  the  running executable.    If the  specified  module cannot  be
    found, it tries  the module libpl.dll, containing the Prolog runtime
    kernel.   In  all these cases,  the resulting file  is used for  two
    purposes:

      o  See whether a Prolog saved  state is appended to the file.   If
         this is  the case,  this state  will be loaded  instead of  the
         default boot.prc file from the SWI-Prolog home directory.   See
         also qsave_program/[1,2] and section 10.5.

      o  Find the Prolog home  directory.  This process is  described in
         detail in section 10.6.

    PL_initialise()  returns 1  if all  initialisation  succeeded and  0
    otherwise.

    In  most cases, _a_r_g_c and _a_r_g_v will be passed from the  main program.
    It  is allowed to create your own argument vector,  provided argv[0]
    is constructed according to the rules above.  For example:

    ____________________________________________________________________|                                                                    |

    | int                                                                |
    | main(int argc, char **argv)                                        |
    | { char *av[10];                                                    |
    |   int ac = 0;                                                      |
    |                                                                    |

    |   av[ac++] = argv[0];                                              |
    |   av[ac++] = "-x";                                                 |
    |   av[ac++] = "mystate";                                            |
    |   av[ac]   = NULL;                                                 |
    |                                                                    |
    |   if ( !PL_initialise(ac, av) )                                    |
    |     PL_halt(1);                                                    |
    |   ...                                                              |

    ||}_________________________________________________________________ ||

    Please  note that the  passed argument vector  may be referred  from
    Prolog  at any time  and should  therefore be valid  as long as  the
    Prolog engine is used.

    A  good setup  in Windows is  to add  SWI-Prolog's bin directory  to
    your  PATH  and either  pass  a module  holding  a saved  state,  or
    "libpl.dll"  as argv[0].  If the  Prolog state is attached to  a DLL
    (see the -dll option of swipl-ld), pass the name of this DLL.


int PPLL__iiss__iinniittiiaalliisseedd(_i_n_t _*_a_r_g_c_, _c_h_a_r _*_*_*_a_r_g_v)
    Test  whether the  Prolog engine  is already initialised.    Returns
    FALSE  if Prolog  is not  initialised and TRUE  otherwise.   If  the
    engine is initialised  and _a_r_g_c is not NULL, the argument count used
    with  PL_initialise() is  stored in  _a_r_g_c.   Same  for the  argument
    vector _a_r_g_v.


void PPLL__iinnssttaallll__rreeaaddlliinnee()
    Installs  the GNU readline line editor.  Embedded  applications that
    do  not use the Prolog top  level should normally delete this  line,
    shrinking  the Prolog kernel significantly.   Note that the  Windows
    version does not use GNU readline.


int PPLL__ttoopplleevveell()
    Runs  the  goal of  the -t toplevel  switch  (default prolog/0)  and
    returns 1 if successful, 0 otherwise.


int PPLL__cclleeaannuupp(_i_n_t _s_t_a_t_u_s)
    This function  performs the reverse of PL_initialise().   It runs the
    PL_on_halt() and at_halt/1 handlers, closes all streams  (except for
    the  `standard I/O'  streams which  are  flushed only),  deallocates
    all  memory and restores all signal  handlers.  The _s_t_a_t_u_s  argument
    is  passed  to  the  various termination  hooks  and  indicates  the
    _e_x_i_t_-_s_t_a_t_u_s.

    The  function  returns  TRUE  if  successful  and  FALSE  otherwise.
    Currently,  FALSE  is  returned when  an  attempt  is made  to  call
    PL_cleanup() recursively or if one of the  exit handlers cancels the
    termination  using cancel_halt/1.    Exit handlers  may only  cancel
    termination if _s_t_a_t_u_s is 0.

    In  theory, this function allows deleting and restarting  the Prolog
    system  in the  same process.    In  practice, SWI-Prolog's  cleanup
    process is far  from complete, and trying to revive the system using
    PL_initialise()  will leak memory  in the best  case.   It can  also
    crash the appliction.

    In  this state,  there is  little practical use  for this  function.
    If  you want  to use Prolog  temporarily, consider  running it in  a
    separate  process.   If you want  to be able  to reset Prolog,  your
    options are (again) a separate process, modules or threads.


void PPLL__cclleeaannuupp__ffoorrkk()
    Stop intervaltimer that may  be running on behalf of profile/1.  The
    call is intended to be used in combination with fork():

    ____________________________________________________________________|                                                                    |
    |     if ( (pid=fork()) == 0 )                                       |
    |     { PL_cleanup_fork();                                           |
    |       <some exec variation>                                        |

    ||____}_____________________________________________________________ ||

    The  call behaves the same on  Windows, though there is probably  no
    meaningful application.


int PPLL__hhaalltt(_i_n_t _s_t_a_t_u_s)
    Clean  up the Prolog environment using PL_cleanup() and  if success-
    ful  call exit() with  the status argument.   Returns FALSE if  exit
    was cancelled by PL_cleanup().


1100..44..2211..11 TThhrreeaaddiinngg,, SSiiggnnaallss aanndd eemmbbeeddddeedd PPrroolloogg

This section  applies to  Unix-based environments that  have signals  or
multithreading.   The  Windows version is  compiled for  multithreading,
and Windows lacks proper signals.

We  can distinguish  two classes  of embedded  executables.   There  are
small C/C++  programs that act  as an  interfacing layer around  Prolog.
Most  of  these  programs  can  be  replaced  using  the  normal  Prolog
executable extended with  a dynamically loaded foreign extension and  in
most cases  this is  the preferred  route.   In other  cases, Prolog  is
embedded in a complex application that---like  Prolog---wants to control
the process  environment.   A good  example is Java.   Embedding  Prolog
is generally  the only  way to  get these environments  together in  one
process image.  Java applications, however, are  by nature multithreaded
and appear to do signal handling (software interrupts).

On Unix systems, SWI-Prolog uses three signals:

SSIIGGUUSSRR11  is used  to  sychronise  atom and  clause  garbage  collection.
    The  handler is  installed at  the start of  garbage collection  and
    reverted to the old setting after completion.

SSIIGGUUSSRR22  has an empty signal handler.   This signal is sent to  a thread
    after  sending a  thread-signal (see  thread_signal/2).   It  causes
    blocking  system calls to  return with EINTR,  which gives them  the
    opportunity to react to thread-signals.

SSIIGGIINNTT  is used by the top level to activate the tracer (typically bound
    to control-C). The  first control-C posts a request for starting the
    tracer  in a safe, synchronous fashion.   If control-C is  hit again
    before  the safe route is executed,  it prompts the user whether  or
    not a forced interrupt is desired.

The --nosignals option can be used to inhibit processing  of SIGINT. The
other signals  are vital  for the functioning  of SWI-Prolog.   If  they
conflict with  other applications, signal  handling of either  component
must be modified.  The SWI-Prolog signals are defined  in pl-thread.h of
the source distribution.


1100..55 LLiinnkkiinngg eemmbbeeddddeedd aapppplliiccaattiioonnss uussiinngg sswwiippll--lldd

The  utility program  swipl-ld (Win32:   swipl-ld.exe)  may  be used  to
link  a combination  of C  files  and Prolog  files into  a  stand-alone
executable.    swipl-ld  automates most  of  what  is described  in  the
previous sections.

In  normal usage,  a  copy is  made of  the default  embedding  template
.../swipl/include/stub.c.    The  main()  routine is  modified  to  suit
your  application.   PL_initialise()  mmuusstt be  passed the  program  name
(_a_r_g_v_[_0_])  (Win32:    the  executing  program  can   be  obtained  using
GetModuleFileName()).   The other  elements of the  command line may  be
modified.  Next, swipl-ld is typically invoked as:

________________________________________________________________________|                                                                        |
|swipl-ld|-o_output_stubfile.c_[other-c-or-o-files]_[plfiles]___________ |        |

swipl-ld will first split  the options into various groups for  both the
C compiler and the  Prolog compiler.  Next, it will add  various default
options to the  C compiler and call  it to create an executable  holding
the  user's C  code and  the Prolog  kernel.   Then,  it  will call  the
SWI-Prolog compiler  to create a  saved state  from the provided  Prolog
files  and finally,  it  will attach  this saved  state to  the  created
emulator to create the requested executable.

Below, it  is described how the options  are split and which  additional
options are passed.

-help
    Print brief synopsis.

-pl _p_r_o_l_o_g
    Select  the Prolog to use.   This Prolog  is used for two  purposes:
    get  the home directory as  well as the compiler/linker options  and
    create a saved state of the Prolog code.

-ld _l_i_n_k_e_r
    Linker  used to link the  raw executable.   Default is to use the  C
    compiler (Win32:  link.exe).

-cc _C _c_o_m_p_i_l_e_r
    Compiler  for .c files found  on the command line.   Default is  the
    compiler  used to  build  SWI-Prolog accessible  through the  Prolog
    flag c_cc (Win32:  cl.exe).

-c++ _C_+_+_-_c_o_m_p_i_l_e_r
    Compiler  for C++  source file (extensions  .cpp, .cxx,  .cc or  .C)
    found on the command  line.  Default is c++ or g++ if the C compiler
    is gcc (Win32:  cl.exe).

-nostate
    Just  relink  the  kernel,  do  not  add  any  Prolog  code  to  the
    new  kernel.     This  is  used  to  create  a  new  kernel  holding
    additional  foreign  predicates  on  machines that  do  not  support
    the  shared-library  (DLL)  interface,  or  if  building  the  state
    cannot  be  handled  by  the default  procedure  used  by  swipl-ld.
    In   the  latter   case  the   state  is   created  separately   and
    appended  to  the kernel  using  cat <_k_e_r_n_e_l> <_s_t_a_t_e> > <_o_u_t>(Win32:
    copy /b <_k_e_r_n_e_l>+<_s_t_a_t_e> <_o_u_t>).

-shared
    Link  C, C++ or object files into a shared object (DLL) that  can be
    loaded  by the  load_foreign_library/1predicate.    If used with  -c
    it  sets the proper  options to compile  a C or  C++ file ready  for
    linking into a shared object.

-dll
    _W_i_n_d_o_w_s  _o_n_l_y.     Embed  SWI-Prolog  into  a  DLL  rather  than  an
    executable.

-c
    Compile  C  or C++  source files  into  object files.    This  turns
    swipl-ld into a  replacement for the C or C++ compiler, where proper
    options  such as the  location of the  include directory are  passed
    automatically to the compiler.

-E
    Invoke the C preprocessor.   Used to make swipl-ld a replacement for
    the C or C++ compiler.

-pl-options _,_._._.
    Additional  options passed to Prolog when creating the  saved state.
    The  first character  immediately  following pl-options  is used  as
    separator  and  translated to  spaces when  the  argument is  built.
    Example:  -pl-options,-F,xpce  passes -F xpce as additional flags to
    Prolog.

-ld-options _,_._._.
    Passes options to the linker, similar to -pl-options.

-cc-options _,_._._.
    Passes options to the C/C++ compiler, similar to -pl-options.

-v
    Select  verbose operation,  showing the  various programs and  their
    options.

-o _o_u_t_f_i_l_e
    Reserved to specify the final output file.

-l_l_i_b_r_a_r_y
    Specifies  a  library for  the  C compiler.    By  default,  -lswipl
    (Win32:   libpl.lib) and the  libraries needed by the Prolog  kernel
    are given.

-L_l_i_b_r_a_r_y_-_d_i_r_e_c_t_o_r_y
    Specifies  a  library directory  for the  C compiler.    By  default
    the  directory  containing  the Prolog  C  library for  the  current
    architecture is passed.

-g | -I_i_n_c_l_u_d_e_-_d_i_r_e_c_t_o_r_y | -D_d_e_f_i_n_i_t_i_o_n
    These  options  are passed  to the  C  compiler.   By  default,  the
    include directory containing SWI-Prolog.h  is passed.  swipl-ld adds
    two additional * -Ddef flags:

    -D__SWI_PROLOG__
         Indicates the code is to be connected to SWI-Prolog.

    -D__SWI_EMBEDDED__
         Indicates the creation of an embedded program.

 _*_._o | _*_._c | _*_._C | _*_._c_x_x | _*_._c_p_p
    Passed as input files to the C compiler.

 _*_._p_l |_*_._q_l_f
    Passed  as input files  to the Prolog  compiler to create the  saved
    state.

 *
    All  other options.   These are  passed as linker  options to the  C
    compiler.


1100..55..11 AA ssiimmppllee eexxaammppllee

The  following is  a very  simple example  going through  all the  steps
outlined above.   It  provides an arithmetic expression  evaluator.   We
will call  the application calc  and define it in  the files calc.c  and
calc.pl.  The Prolog file is simple:

________________________________________________________________________|                                                                        |
|calc(Atom) :-                                                           |

|        term_to_atom(Expr, Atom),                                       |
|        A is Expr,                                                      |
|        write(A),                                                       |
||_______nl.____________________________________________________________ ||

The  C  part  of  the  application  parses  the  command  line  options,
initialises the  Prolog engine, locates  the calc/1 predicate and  calls
it.  The coder is in figure 10.4.

________________________________________________________________________|                                                                        |
|#include <stdio.h>                                                      |
|#include <SWI-Prolog.h>                                                 |
|                                                                        |
|#define MAXLINE 1024                                                    |

|                                                                        |
|int                                                                     |
|main(int argc, char **argv)                                             |
|{ char expression[MAXLINE];                                             |
|  char *e = expression;                                                 |
|  char *program = argv[0];                                              |
|  char *plav[2];                                                        |

|  int n;                                                                |
|                                                                        |
|  /* combine all the arguments in a single string */                    |
|                                                                        |
|  for(n=1; n<argc; n++)                                                 |
|  { if ( n != 1 )                                                       |
|      *e++ = ' ';                                                       |
|    strcpy(e, argv[n]);                                                 |

|    e += strlen(e);                                                     |
|  }                                                                     |
|                                                                        |
|  /* make the argument vector for Prolog */                             |
|                                                                        |
|  plav[0] = program;                                                    |
|  plav[1] = NULL;                                                       |

|                                                                        |
|  /* initialise Prolog */                                               |
|                                                                        |
|  if ( !PL_initialise(1, plav) )                                        |
|    PL_halt(1);                                                         |
|                                                                        |
|  /* Lookup calc/1 and make the arguments and call */                   |
|                                                                        |

|  { predicate_t pred = PL_predicate("calc", 1, "user");                 |
|    term_t h0 = PL_new_term_refs(1);                                    |
|    int rval;                                                           |
|                                                                        |
|    PL_put_atom_chars(h0, expression);                                  |
|    rval = PL_call_predicate(NULL, PL_Q_NORMAL, pred, h0);              |
|                                                                        |

|    PL_halt(rval ? 0 : 1);                                              |
|  }                                                                     |
|                                                                        |
|  return 0;                                                             |
|}|_____________________________________________________________________ | |

            Figure 10.4:  C source for the calc application

The application is now created using the following command line:

________________________________________________________________________|                                                                        |
|%|swipl-ld_-o_calc_calc.c_calc.pl______________________________________ | |

The following indicates the usage of the application:

________________________________________________________________________|                                                                        |

|% calc pi/2                                                             |
|1.5708|________________________________________________________________ |      |


1100..66 TThhee PPrroolloogg ``hhoommee'' ddiirreeccttoorryy

Executables  embedding SWI-Prolog  should  be able  to find  the  `home'
directory of the  development environment unless a self-contained  saved
state  has been  added to  the executable  (see qsave_program/[1,2]  and
section 10.5).

If Prolog starts up, it will try to  locate the development environment.
To do so, it will try the following steps until one succeeds:

 1. If the --home=DIR is provided, use this.

 2. If  the environment variable  SWI_HOME_DIRis  defined and points  to
    an existing directory, use this.

 3. If  the  environment variable  SWIPL  is defined  and points  to  an
    existing directory, use this.

 4. Locate  the  primary   executable  or  (Windows  only)  a  component
    (_m_o_d_u_l_e)  thereof  and check  whether the  parent  directory of  the
    directory  holding this file contains the  file swipl.  If so,  this
    file  contains the (relative) path to  the home directory.  If  this
    directory  exists, use this.   This is the normal mechanism  used by
    the binary distribution.

 5. If  the precompiled path exists, use it.  This is only  useful for a
    source installation.

If  all fails  and  there is  no state  attached  to the  executable  or
provided Windows module (see PL_initialise()), SWI-Prolog gives up.   If
a state is attached, the current working directory is used.

The file_search_path/2 alias swi is set  to point to the home  directory
located.


1100..77 EExxaammppllee ooff UUssiinngg tthhee FFoorreeiiggnn IInntteerrffaaccee

Below is an example  showing all stages of the declaration of  a foreign
predicate that transforms atoms possibly holding  uppercase letters into
an atom only holding lowercase letters.  Figure 10.5  shows the C source
file, figure 10.6 illustrates compiling and loading of foreign code.
________________________________________________________________________|                                                                        |
|/*  Include file depends on local installation */                       |
|#include <SWI-Prolog.h>                                                 |
|#include <stdlib.h>                                                     |

|#include <string.h>                                                     |
|#include <ctype.h>                                                      |
|                                                                        |
|foreign_t                                                               |
|pl_lowercase(term_t u, term_t l)                                        |
|{ char *copy;                                                           |
|  char *s, *q;                                                          |
|  int rval;                                                             |

|                                                                        |
|  if ( !PL_get_atom_chars(u, &s) )                                      |
|    return PL_warning("lowercase/2: instantiation fault");              |
|  copy = malloc(strlen(s)+1);                                           |
|                                                                        |
|  for( q=copy; *s; q++, s++)                                            |
|    *q = (isupper(*s) ? tolower(*s) : *s);                              |

|  *q = '\0';                                                            |
|                                                                        |
|  rval = PL_unify_atom_chars(l, copy);                                  |
|  free(copy);                                                           |
|                                                                        |
|  return rval;                                                          |
|}                                                                       |
|                                                                        |

|install_t                                                               |
|install()                                                               |
|{ PL_register_foreign("lowercase", 2, pl_lowercase, 0);                 |
|}|_____________________________________________________________________ | |

                  Figure 10.5:  Lowercase source file

________________________________________________________________________|                                                                        |
|% gcc -I/usr/local/lib/swipl-\plversion/include -fpic -c lowercase.c    |
|% gcc -shared -o lowercase.so lowercase.o                               |
|% swipl                                                                 |
|Welcome to SWI-Prolog (Version \plversion)                              |

|...                                                                     |
|                                                                        |
|1 ?- load_foreign_library(lowercase).                                   |
|true.                                                                   |
|                                                                        |
|2 ?- lowercase('Hello World!', L).                                      |
|L|=_'hello_world!'.____________________________________________________ | |

    Figure 10.6:  Compiling the C source and loading the object file


1100..88 NNootteess oonn UUssiinngg FFoorreeiiggnn CCooddee


1100..88..11 MMeemmoorryy AAllllooccaattiioonn

SWI-Prolog's heap  memory allocation is based  on the malloc(3)  library
routines.  SWI-Prolog  provides the functions below as a  wrapper around
malloc().    Allocation  errors  in these  functions  trap  SWI-Prolog's
fatal-error handler,  in which case  PL_malloc() or PL_realloc() do  not
return.

Portable applications must use PL_free() to release strings  returned by
PL_get_chars()using  the BUF_MALLOC argument.   Portable applications may
use both PL_malloc() and friends or malloc() and friends  but should not
mix these two sets of functions on the same memory.


void * PPLL__mmaalllloocc(_s_i_z_e___t _b_y_t_e_s)
    Allocate  _b_y_t_e_s  of memory.    On  failure SWI-Prolog's  fatal-error
    handler  is  called  and  PL_malloc()  does  not  return.     Memory
    allocated  using these functions must use PL_realloc() and PL_free()
    rather than realloc() and free().


void * PPLL__rreeaalllloocc(_v_o_i_d _*_m_e_m_, _s_i_z_e___t _s_i_z_e)
    Change  the size of the  allocated chunk, possibly  moving it.   The
    _m_e_m  argument  must  be  obtained  from a  previous  PL_malloc()  or
    PL_realloc() call.


void PPLL__ffrreeee(_v_o_i_d _*_m_e_m)
    Release  memory.  The _m_e_m argument must be obtained from  a previous
    PL_malloc() or PL_realloc() call.


1100..88..11..11 BBooeehhmm--GGCC ssuuppppoorrtt

To  accommodate future  use  of the  Boehm  garbage collector  for  heap
memory  allocation,  the  interface  provides  the  functions  described
below.  Foreign extensions that wish to use  the Boehm-GC facilities can
use these wrappers.   Please note that if SWI-Prolog is not  compiled to
use Boehm-GC  (default), the user  is responsible for  calling PL_free()
to reclaim memory.


void* PPLL__mmaalllloocc__aattoommiicc(_s_i_z_e___t _b_y_t_e_s)


void* PPLL__mmaalllloocc__uunnccoolllleeccttaabbllee(_s_i_z_e___t _b_y_t_e_s)


void* PPLL__mmaalllloocc__aattoommiicc__uunnccoolllleeccttaabbllee(_s_i_z_e___t _b_y_t_e_s)
    If  Boehm-GC is  not used,  these are all  the same  as PL_malloc().
    With  Boehm-GC, these map  to the corresponding Boehm-GC  functions.
    _A_t_o_m_i_c  means that the content  should not be scanned for  pointers,
    and  _u_n_c_o_l_l_e_c_t_a_b_l_e means  that the  object should  never be  garbage
    collected.


void* PPLL__mmaalllloocc__ssttuubbbboorrnn(_s_i_z_e___t _b_y_t_e_s)


void PPLL__eenndd__ssttuubbbboorrnn__cchhaannggee(_v_o_i_d _*_m_e_m_o_r_y)
    These  functions  allow  creating objects,  promising  GC  that  the
    content will not change after PL_end_stubborn_change().


1100..88..22 CCoommppaattiibbiilliittyy bbeettwweeeenn PPrroolloogg vveerrssiioonnss

Great  care  is   taken  to  ensure  binary  compatibility  of   foreign
extensions  between different  Prolog  versions.    Only the  much  less
frequently  used  stream  interface  has  been  responsible  for  binary
incompatibilities.

Source  code  that relies  on  new  features of  the  foreign  interface
can use  the macro  PLVERSION to  find the version  of SWI-Prolog.h  and
PL_query() using  the  option PL_QUERY_VERSION to  find the  version  of
the  attached Prolog  system.   Both  follow the  same numbering  schema
explained with PL_query().


1100..88..33 DDeebbuuggggiinngg aanndd pprrooffiilliinngg ffoorreeiiggnn ccooddee ((vvaallggrriinndd))

This section is only  relevant for Unix users on platforms  supported by
valgrind.   Valgrind  is an excellent  binary instrumentation  platform.
Unlike  many other  instrumentation platforms,  valgrind  can deal  with
code loaded through dlopen().

The callgrind  tool can  be used  to profile foreign  code loaded  under
SWI-Prolog.    Compile  the foreign  library  adding  -g option  to  gcc
or  swipl-ld.   By  setting the  environment variable  VALGRIND to  yes,
SWI-Prolog  will _n_o_t  release  loaded  shared objects  using  dlclose().
This trick is required to get source information on  the loaded library.
Without,  valgrind  claims  that  the shared  object  has  no  debugging
information.  Here is the complete sequence using bash as login shell:

________________________________________________________________________|                                                                        |
|% VALGRIND=yes valgrind --tool=callgrind pl <args>                      |

|<prolog interaction>                                                    |
|%|kcachegrind_callgrind.out.<pid>______________________________________ | |


1100..88..44 NNaammee CCoonnfflliiccttss iinn CC mmoodduulleess

In  the  current  version  of the  system  all  public  C  functions  of
SWI-Prolog are in the symbol table.  This can lead  to name clashes with
foreign code.    Someday I  should write a  program to  strip all  these
symbols from the symbol table  (why does Unix not have that?).   For now
I can  only suggest you  give your function  another name.   You can  do
this using the C preprocessor.  If---for  example---your foreign package
uses  a function  warning(), which  happens to  exist  in SWI-Prolog  as
well, the following macro should fix the problem:

________________________________________________________________________|                                                                        |
|#define|warning_warning________________________________________________ |       |

Note  that shared  libraries do  not  have this  problem as  the  shared
library loader  will only look  for symbols in  the main executable  for
symbols that are not defined in the library itself.


1100..88..55 CCoommppaattiibbiilliittyy ooff tthhee FFoorreeiiggnn IInntteerrffaaccee

The  term  reference   mechanism  was  first  used  by  Quintus   Prolog
version 3.   SICStus Prolog version 3  is strongly based on the  Quintus
interface.  The  described SWI-Prolog interface is similar to  using the
Quintus or SICStus interfaces, defining all  foreign-predicate arguments
of  type  +term.    SWI-Prolog  explicitly uses  type  functor_t,  while
Quintus  and SICStus  use  <_n_a_m_e> and  <_a_r_i_t_y>.    As  the  names of  the
functions differ  from Prolog to  Prolog, a  simple macro layer  dealing
with the names can also deal with this detail.  For example:

________________________________________________________________________|                                                                        |
|#define QP_put_functor(t, n, a) \                                       |

||_______PL_put_functor(t,_PL_new_functor(n,_a))________________________ ||

The  PL_unify_*()  functions are  lacking from  the  Quintus and  SICStus
interface.    They can  easily be  emulated, or  the put/unify  approach
should be used to write compatible code.

The PL_open_foreign_frame()/PL_close_foreign_frame() combination is lack-
ing from both other  Prologs.  SICStus has PL_new_term_refs(_0),  followed
by PL_reset_term_refs(), that allows for discarding term references.

The  Prolog interface  for  the graphical  user interface  package  XPCE
shares about  90% of the code  using a simple  macro layer to deal  with
different naming and calling conventions of the interfaces.


CChhaapptteerr 1111..  GGEENNEERRAATTIINNGG RRUUNNTTIIMMEE AAPPPPLLIICCAATTIIOONNSS

This  chapter  describes  the  features  of  SWI-Prolog  for  delivering
applications that can run without the development version  of the system
installed.

A SWI-Prolog runtime executable is a file consisting of two  parts.  The
first part  is the  _e_m_u_l_a_t_o_r, which  is machine-dependent.   The  second
part is the _r_e_s_o_u_r_c_e  _a_r_c_h_i_v_e, which contains the compiled program  in a
machine-independent format,  startup options  and possibly  user-defined
_r_e_s_o_u_r_c_e_s; see resource/3 and open_resource/3.

These two parts can be  connected in various ways.  The most  common way
for distributed  runtime applications is to  _c_o_n_c_a_t_e_n_a_t_e the two  parts.
This  can be  achieved using  external commands  (Unix:   cat,  Windows:
copy), or using  the stand_alone option to qsave_program/2.  The  second
option is  to attach  a startup  script in  front of  the resource  that
starts the emulator with the proper options.  This  is the default under
Unix.   Finally,  an emulator can  be told to  use a specified  resource
file using the -x command line switch.


qqssaavvee__pprrooggrraamm((_+_F_i_l_e_, _+_O_p_t_i_o_n_s))
    Saves  the current  state of  the program  to the  file _F_i_l_e.    The
    result  is  a   resource  archive  containing  a  saved  state  that
    expresses  all  Prolog   data  from  the  running  program  and  all
    user-defined  resources.   Depending on the stand_alone option,  the
    resource is headed  by the emulator, a Unix shell script or nothing.
    _O_p_t_i_o_n_s is a list of additional options:

    llooccaall((_+_K_B_y_t_e_s))
         Limit for the local stack.  See section 2.4.3.

    gglloobbaall((_+_K_B_y_t_e_s))
         Limit for the global stack.  See section 2.4.3.

    ttrraaiill((_+_K_B_y_t_e_s))
         Limit for the trail stack.  See section 2.4.3.

    ggooaall((_:_C_a_l_l_a_b_l_e))
         Initialization goal for the new executable (see -g).

    ttoopplleevveell((_:_C_a_l_l_a_b_l_e))
         Top-level goal for the new executable (see -t).

    iinniitt__ffiillee((_+_A_t_o_m))
         Default initialization file for the new executable.  See -f.

    ccllaassss((_+_C_l_a_s_s))
         If  runtime, only  read  resources  from the  state  (default).
         If  kernel, lock  all  predicates as  system  predicates.    If
         development, save  the predicates  in their  current state  and
         keep reading  resources from their  source (if  present).   See
         also resource/3.

    aauuttoollooaadd((_+_B_o_o_l_e_a_n))
         If true (default), run autoload/0 first.

    mmaapp((_+_F_i_l_e))
         Dump a human-readable trace of what has been saved in _F_i_l_e.

    oopp((_+_A_c_t_i_o_n))
         One of  save (default) to  save the  current operator table  or
         standard to use the initial table of the emulator.

    ssttaanndd__aalloonnee((_+_B_o_o_l_e_a_n))
         If true,  the emulator  is the  first part of  the state.    If
         the  emulator is  started  it will  test  whether a  boot  file
         (state)  is attached  to  the  emulator itself  and  load  this
         state.   Provided  the  application has  all libraries  loaded,
         the  resulting  executable is  completely  independent  of  the
         runtime environment or location  where it was built.   See also
         section 2.10.2.4.

    eemmuullaattoorr((_+_F_i_l_e))
         File to use  for the emulator.   Default is the running  Prolog
         image.

    ffoorreeiiggnn((_+_A_c_t_i_o_n))
         If save,  include shared objects (DLLs)  into the saved  state.
         See  current_foreign_library/2.     If   the  program  strip  is
         available, this is first used to reduce the size  of the shared
         object.   If  a state  is started,  use_foreign_library/1 first
         tries to locate the  foreign resource in the executable.   When
         found it  copies the  content of  the resource  to a  temporary
         file and loads  it.  If  possible (Unix), the temporary  object
         is deleted immediately after opening.


qqssaavvee__pprrooggrraamm((_+_F_i_l_e))
    Equivalent to qsave_program(File, []).


aauuttoollooaadd
    Check  the current Prolog program  for predicates that are  referred
    to,  are  undefined and  have a  definition in  the Prolog  library.
    Load the appropriate libraries.

    This  predicate is used  by qsave_program/[1,2] to ensure the  saved
    state  does  not depend  on  availability of  the  libraries.    The
    predicate  autoload/0 examines  all  clauses of  the loaded  program
    (obtained  with  clause/2)  and  analyzes the  body  for  referenced
    goals.  Such  an analysis cannot be complete in Prolog, which allows
    for  the creation of arbitrary terms at runtime and the use  of them
    as a goal.  The current analysis is limited to the following:

      o  Direct goals appearing in the body

      o  Arguments of declared  meta-predicates that are marked with  an
         integer (0..9).  See meta_predicate/1.

    The  analysis of meta-predicate arguments is limited to  cases where
    the  argument appears literally in  the clause or is assigned  using
    =/2  before  the meta-call.    That is,  the  following fragment  is
    processed correctly:

    ____________________________________________________________________|                                                                    |

    |         ...,                                                       |
    |         Goal = prove(Theory),                                      |
    |         forall(current_theory(Theory),                             |
    ||_______________Goal)),____________________________________________ ||

    But,  the calls to prove_simple/1 and prove_complex/1 in the example
    below  are _n_o_t discovered by the analysis and therefore  the modules
    that  define  these  predicates  must  be  loaded  explicitly  using
    use_module/1,2.

    ____________________________________________________________________|                                                                    |

    |         ...,                                                       |
    |         member(Goal, [ prove_simple(Theory),                       |
    |                        prove_complex(Theory)                       |
    |                      ]),                                           |
    |         forall(current_theory(Theory),                             |
    ||_______________Goal)),____________________________________________ ||

    It  is good practice  to use gxref/0 to  make sure that the  program
    has  sufficient  declarations  such  that the  analaysis  tools  can
    verify  that all required  predicates can be  resolved and that  all
    code  is  called.   See  meta_predicate/1, dynamic/1,  public/1  and
    prolog:called_by/2.


vvoollaattiillee _+_N_a_m_e_/_A_r_i_t_y_, _._._.
    Declare  that  the clauses  of specified  predicates  should nnoott  be
    saved to the program.   The volatile declaration is normally used to
    prevent  the clauses of dynamic  predicates that represent data  for
    the current session from being saved in the state file.


1111..11 LLiimmiittaattiioonnss ooff qqssaavvee__pprrooggrraamm

There  are  three  areas  that  require  special  attention  when  using
qsave_program/[1,2].

  o If  the  program  is an  embedded  Prolog  application or  uses  the
    foreign  language interface,  care has  to be taken  to restore  the
    appropriate foreign context.  See section 11.2 for details.

  o If  the program uses directives (:- goal. lines) that  perform other
    actions than  setting predicate attributes (dynamic, volatile, etc.)
    or  loading files  (consult,  etc.), the  directive may  need to  be
    prefixed with initialization/1.

  o Database  references as returned by clause/3, recorded/3,  etc., are
    not preserved and may thus not be part of the database when saved.


1111..22 RRuunnttiimmeess aanndd FFoorreeiiggnn CCooddee

Some  applications may  need  to  use the  foreign  language  interface.
Object code is  by definition machine-dependent and thus cannot  be part
of the saved program file.

To complicate the matter even further there are various  ways of loading
foreign code:

  o _U_s_i_n_g _t_h_e _l_i_b_r_a_r_y_(_s_h_l_i_b_) _p_r_e_d_i_c_a_t_e_s
    This  is the preferred way of dealing  with foreign code.   It loads
    quickly and ensures  an acceptable level of independence between the
    versions  of the emulator and the foreign code loaded.  It  works on
    Unix  machines supporting shared libraries and library  functions to
    load  them.  Most modern  Unixes, as well as Win32  (Windows 95/NT),
    satisfy this constraint.

  o _S_t_a_t_i_c _l_i_n_k_i_n_g
    This  mechanism works on  all machines,  but generally requires  the
    same  C compiler and linker to be  used for the external code  as is
    used to build SWI-Prolog itself.

To make  a runtime  executable that  can run on  multiple platforms  one
must make runtime  checks to find the correct  way of linking.   Suppose
we have a  source file myextension.c defining the installation  function
install().

If this file  is compiled into a  shared library, load_foreign_library/1
will load this library and call the installation  function to initialise
the  foreign code.    If it  is  loaded as  a static  extension,  define
install() as the predicate install/0:

________________________________________________________________________|                                                                        |

|static foreign_t                                                        |
|pl_install()                                                            |
|{ install();                                                            |
|                                                                        |
|  PL_succeed;                                                           |

|}                                                                       |
|                                                                        |
|PL_extension PL_extensions [] =                                         |
|{                                                                       |
|/*{ "name",     arity,  function,       PL_FA_<flags> },*/              |
|                                                                        |
|  { "install",  0,      pl_install,     0 },                            |
|  { NULL,       0,      NULL,           0 } /* terminating line */      |

|};|____________________________________________________________________ |  |

Now, use the following Prolog code to load the foreign library:

________________________________________________________________________|                                                                        |
|load_foreign_extensions :-                                              |
|        current_predicate(install, install), !, % static loaded         |
|        install.                                                        |
|load_foreign_extensions :-                      % shared library        |

|        load_foreign_library(foreign(myextension)).                     |
|                                                                        |
|:-|initialization_load_foreign_extensions._____________________________ |  |

The path  alias foreign  is defined by  file_search_path/2.   By  default
it  searches  the  directories <_h_o_m_e>/lib/<_a_r_c_h> and  <_h_o_m_e>/lib.     The
application can specify additional rules for file_search_path/2.


1111..33 UUssiinngg pprrooggrraamm rreessoouurrcceess

A _r_e_s_o_u_r_c_e  is very  similar to  a file.    Resources,  however, can  be
represented in two different formats:  on files, as well  as part of the
resource _a_r_c_h_i_v_e of a saved state (see qsave_program/2).

A resource has a _n_a_m_e  and a _c_l_a_s_s.  The _s_o_u_r_c_e data of the  resource is
a file.   Resources are declared by declaring the  predicate resource/3.
They are accessed using the predicate open_resource/3.

Before  going into  details,  let  us start  with  an  example.    Short
texts can  easily be  expressed in Prolog  source code,  but long  texts
are cumbersome.   Assume our application  defines a command `help'  that
prints a  helptext to the screen.   We put  the content of the  helptext
into a  file called help.txt.   The following  code implements our  help
command such that help.txt is incorporated into the runtime executable.

________________________________________________________________________|                                                                        |
|resource(help, text, 'help.txt').                                       |

|                                                                        |
|help :-                                                                 |
|        open_resource(help, text, In),                                  |
|        call_cleanup(copy_stream_data(In, user_output),                 |
||____________________close(In))._______________________________________ ||

The predicate  help/0 opens  the resource  as a Prolog  stream.   If  we
are executing this from the development environment,  this will actually
return a  stream to the file  help.txt itself.   When executed from  the
saved state, the stream will actually be a stream  opened on the program
resource file, taking care of the offset and length of the resource.


1111..33..11 RReessoouurrccee mmaanniippuullaattiioonn pprreeddiiccaatteess


rreessoouurrccee((_+_N_a_m_e_, _+_C_l_a_s_s_, _+_F_i_l_e_S_p_e_c))
    This  predicate is  defined  as a  dynamic predicate  in the  module
    user.    Clauses for  it may  be  defined in  any module,  including
    the  user module.    _N_a_m_e is  the name  of the  resource (an  atom).
    A  resource name  may contain  any character,  except for  $ and  :,
    which  are  reserved for  internal usage  by  the resource  library.
    _C_l_a_s_s  describes the  kind of  object stored in  the resource.    In
    the  current  implementation,  it is  just an  atom.    _F_i_l_e_S_p_e_c  is
    a  file  specification  that  may  exploit  file_search_path/2  (see
    absolute_file_name/2).

    Normally,  resources are  defined as unit  clauses (facts), but  the
    definition  of this  predicate also allows  for rules.   For  proper
    generation  of the  saved state,  it must be  possible to  enumerate
    the  available  resources by  calling this  predicate  with all  its
    arguments unbound.

    Dynamic  rules are useful to turn  all files in a certain  directory
    into  resources, without specifying a resource  for each file.   For
    example,  assume the file_search_path/2icons refers to  the resource
    directory  containing icon  files.   The following definition  makes
    all these images available as resources:

    ____________________________________________________________________|                                                                    |
    | resource(Name, image, icons(XpmName)) :-                           |

    |         atom(Name), !,                                             |
    |         file_name_extension(Name, xpm, XpmName).                   |
    | resource(Name, image, XpmFile) :-                                  |
    |         var(Name),                                                 |
    |         absolute_file_name(icons(.), [type(directory)], Dir)       |
    |         concat(Dir, '/*.xpm', Pattern),                            |
    |         expand_file_name(Pattern, XpmFiles),                       |
    ||________member(XpmFile,_XpmFiles).________________________________ ||


ooppeenn__rreessoouurrccee((_+_N_a_m_e_, _?_C_l_a_s_s_, _-_S_t_r_e_a_m))
    Opens the resource specified  by _N_a_m_e and _C_l_a_s_s.  If the latter is a
    variable,  it will  be unified to  the class  of the first  resource
    found that has the  specified _N_a_m_e.  If successful, _S_t_r_e_a_m becomes a
    handle to a  binary input stream, providing access to the content of
    the resource.

    The  predicate  open_resource/3  first  checks  resource/3.     When
    successful   it  will  open  the  returned  resource   source  file.
    Otherwise  it will look  in the program's  resource database.   When
    creating  a  saved state,  the system  normally  saves the  resource
    contents  into the resource archive, but does not save  the resource
    clauses.

    This   way,  the  development   environment  uses  the  files   (and
    modifications)   to   the  resource/3   declarations  and/or   files
    containing  resource info,  thus immediately  affecting the  running
    environment,  while the runtime  system quickly accesses the  system
    resources.


1111..33..22 TThhee swipl-rc pprrooggrraamm

The utility program swipl-rc  can be used to examine and  manipulate the
contents of  a SWI-Prolog resource  file.  The  options are inspired  by
the Unix ar program.  The basic command is:

________________________________________________________________________|                                                                        |
|%|swipl-rc_option_resource-file_member_..._____________________________ | |

The options are described below.

l
    List contents of the archive.

x
    Extract  named (or  all)  members of  the archive  into the  current
    directory.

a
    Add  files  to the  archive.    If the  archive already  contains  a
    member  with the  same name, the  contents are  replaced.   Anywhere
    in   the  sequence  of  members,   the  options  --class=_c_l_a_s_s   and
    --encoding=_e_n_c_o_d_i_n_g may appear.   They affect the class and encoding
    of subsequent files.  The initial class is data and encoding none.

d
    Delete named members from the archive.

This command is also described in the pl(1) Unix manual page.


1111..44 FFiinnddiinngg AApppplliiccaattiioonn ffiilleess

If your application  uses files that are  not part of the saved  program
such as database  files, configuration files, etc., the  runtime version
has to be able to  locate these files.  The file_search_path/2 mechanism
in combination with  the -palias command line argument is  the preferred
way to  locate runtime  files.   The first  step is to  define an  alias
for the  top-level directory  of your application.    We will call  this
directory gnatdir in our examples.

A  good  place  for storing  data  associated  with  SWI-Prolog  runtime
systems is  below the emulator's  home directory.   swi is a  predefined
alias for this directory.  The following is  a useful default definition
for the search path.

________________________________________________________________________|                                                                        |
|user:file_search_path(gnatdir,|swi(gnat))._____________________________ |                              |

The  application  should  locate   all  files  using  absolute_file_name.
Suppose  gnatdir  contains   a  file  config.pl  to  define  the   local
configuration.  Then use the code below to load this file:

________________________________________________________________________|                                                                        |

|configure_gnat :-                                                       |
|   (   absolute_file_name(gnatdir('config.pl'), ConfigFile)             |
|   ->  consult(ConfigFile)                                              |
|   ;   format(user_error, 'gnat: Cannot locate config.pl~n'),           |
|       halt(1)                                                          |
||__).__________________________________________________________________ ||


1111..44..11 SSppeecciiffyyiinngg aa ffiillee sseeaarrcchh ppaatthh ffrroomm tthhee ccoommmmaanndd lliinnee

Suppose   the  system   administrator  has   installed  the   SWI-Prolog
runtime  environment  in  /usr/local/lib/rt-pl-3.2.0.     A  user  wants
to  install  gnat,   but  gnat  will  look  for  its   configuration  in
/usr/local/lib/rt-pl-3.2.0/gnat where the user cannot write.

The user  decides to install the  gnat runtime files in  /users/bob/lib/
gnat.  For one-time  usage, the user may decide to start gnat  using the
command:

________________________________________________________________________|                                                                        |
|%|gnat_-p_gnatdir=/users/bob/lib/gnat__________________________________ | |


CChhaapptteerr 1122..  TTHHEE SSWWII--PPRROOLLOOGG LLIIBBRRAARRYY

This chapter documents  the SWI-Prolog library.  As  SWI-Prolog provides
auto-loading,  there is  little  difference between  library  predicates
and built-in predicates.   Part of  the library is therefore  documented
in the  rest of  the manual.   Library  predicates differ from  built-in
predicates in the following ways:

  o User  definition of a  built-in leads to  a permission error,  while
    using the name of a library predicate is allowed.

  o If  autoloading is disabled  explicitly or because trapping  unknown
    predicates  is disabled  (see unknown/2  and current_prolog_flag/2),
    library predicates must be loaded explicitly.

  o Using  libraries reduces  the footprint of  applications that  don't
    need them.

    _T_h_e  _d_o_c_u_m_e_n_t_a_t_i_o_n _o_f _t_h_e  _l_i_b_r_a_r_y _h_a_s _j_u_s_t _s_t_a_r_t_e_d_.   _M_a_t_e_r_i_a_l
    _f_r_o_m  _t_h_e _s_t_a_n_d_a_r_d _p_a_c_k_a_g_e_s _s_h_o_u_l_d _b_e _m_o_v_e_d _h_e_r_e_, _s_o_m_e _m_a_t_e_r_i_a_l
    _f_r_o_m  _o_t_h_e_r _p_a_r_t_s _o_f _t_h_e _m_a_n_u_a_l _s_h_o_u_l_d _b_e _m_o_v_e_d _t_o_o _a_n_d _v_a_r_i_o_u_s
    _l_i_b_r_a_r_i_e_s _a_r_e _n_o_t _d_o_c_u_m_e_n_t_e_d _a_t _a_l_l_.


1122..11 lliibbrraarryy((aaggggrreeggaattee))::     AAggggrreeggaattiioonn   ooppeerraattoorrss  oonn   bbaacckkttrraacckkaabbllee
     pprreeddiiccaatteess

    CCoommppaattiibbiilliittyy  Quintus,   SICStus  4.      The  forall/2  is  a
         SWI-Prolog built-in  and term_variables/3 is  a SWI-Prolog
         with a ddiiffffeerreenntt ddeeffiinniittiioonn.

    TToo bbee ddoonnee
         -  Analysing  the  aggregation  template and  compiling  a
         predicate for the list aggregation  can be done at compile
         time.
         -  aggregate_all/3 can  be rewritten  to  run  in constant
         space using non-backtrackable assignment on a term.

This  library provides  aggregating operators  over the  solutions of  a
predicate.  The operations are a generalisation of  the bagof/3, setof/3
and findall/3 built-in  predicates.  The defined aggregation  operations
are counting,  computing the sum, minimum,  maximum, a bag of  solutions
and a set of solutions.   We first give a simple example,  computing the
country with the smallest area:

________________________________________________________________________|                                                                        |

|smallest_country(Name, Area) :-                                         |
||_______aggregate(min(A,_N),_country(N,_A),_min(Area,_Name)).__________ ||

There  are  four   aggregation  predicates  (aggregate/3,   aggregate/4,
aggregate_all/3 and aggregate/4), distinguished on two properties.

aaggggrreeggaattee vvss..  aaggggrreeggaattee__aallll The   aggregate  predicates   use   setof/3
    (aggregate/4)  or bagof/3  (aggregate/3),  dealing with  existential
    qualified  variables  (Var^Goal)  and providing  multiple  solutions
    for  the  remaining free  variables in  Goal.   The  aggregate_all/3
    predicate  uses findall/3, implicitly qualifying all  free variables
    and  providing  exactly  one solution,  while  aggregate_all/4  uses
    sort/2  over  solutions  that Discriminator  (see  below)  generated
    using findall/3.

TThhee DDiissccrriimmiinnaattoorr aarrgguummeenntt  The versions  with 4  arguments  deduplicate
    redundant solutions of  Goal.  Solutions for which both the template
    variables  and Discriminator  are identical will  be treated as  one
    solution.   For example, if we wish to compute the  total population
    of  all countries,  and for  some reason  country(belgium, 11000000)
    may  succeed twice, we can use  the following to avoid counting  the
    population of Belgium twice:

    ____________________________________________________________________|                                                                    |
    ||____aggregate(sum(P),_Name,_country(Name,_P),_Total)______________ ||

All  aggregation predicates  support the  following  operators below  in
Template.    In addition,  they allow  for an  arbitrary named  compound
term,  where each  of  the arguments  is  a term  from the  list  below.
For example,  the term r(min(X), max(X))  computes both the minimum  and
maximum binding for X.

ccoouunntt
    Count number of solutions.  Same as sum(1).

ssuumm((_E_x_p_r))
    Sum of _E_x_p_r for all solutions.

mmiinn((_E_x_p_r))
    Minimum of _E_x_p_r for all solutions.

mmiinn((_E_x_p_r_, _W_i_t_n_e_s_s))
    A  term min(Min, Witness), where Min is the minimal version  of _E_x_p_r
    over  all solutions, and  _W_i_t_n_e_s_s is any  other template applied  to
    solutions  that produced  Min.   If multiple  solutions provide  the
    same minimum, _W_i_t_n_e_s_s corresponds to the first solution.

mmaaxx((_E_x_p_r))
    Maximum of _E_x_p_r for all solutions.

mmaaxx((_E_x_p_r_, _W_i_t_n_e_s_s))
    As min(Expr, Witness), but producing the maximum result.

sseett((_X))
    An ordered set with all solutions for _X.

bbaagg((_X))
    A list of all solutions for _X.

AAcckknnoowwlleeddggeemmeennttss

_T_h_e  _d_e_v_e_l_o_p_m_e_n_t   _o_f  _t_h_i_s  _l_i_b_r_a_r_y   _w_a_s  _s_p_o_n_s_o_r_e_d  _b_y   _S_e_c_u_r_i_t_E_a_s_e_,
http://www.securitease.com


aaggggrreeggaattee((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_R_e_s_u_l_t))                           _[_n_o_n_d_e_t_]
    Aggregate  bindings in _G_o_a_l according to _T_e_m_p_l_a_t_e.   The aggregate/3
    version performs bagof/3 on _G_o_a_l.


aaggggrreeggaattee((_+_T_e_m_p_l_a_t_e_, _+_D_i_s_c_r_i_m_i_n_a_t_o_r_, _:_G_o_a_l_, _-_R_e_s_u_l_t))           _[_n_o_n_d_e_t_]
    Aggregate  bindings in _G_o_a_l according to _T_e_m_p_l_a_t_e.   The aggregate/4
    version performs setof/3 on _G_o_a_l.


aaggggrreeggaattee__aallll((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_R_e_s_u_l_t))                       _[_s_e_m_i_d_e_t_]
    Aggregate   bindings  in   _G_o_a_l  according   to  _T_e_m_p_l_a_t_e.       The
    aggregate_all/3 version performs findall/3 on _G_o_a_l.   Note that this
    predicate fails if  _T_e_m_p_l_a_t_e contains one or more of min(X), max(X),
    min(X,Witness)  or max(X,Witness) and  _G_o_a_l has no solutions,  i.e.,
    the minumum and maximum of an empty set is undefined.


aaggggrreeggaattee__aallll((_+_T_e_m_p_l_a_t_e_, _+_D_i_s_c_r_i_m_i_n_a_t_o_r_, _:_G_o_a_l_, _-_R_e_s_u_l_t))       _[_s_e_m_i_d_e_t_]
    Aggregate   bindings  in   _G_o_a_l  according   to  _T_e_m_p_l_a_t_e.       The
    aggregate_all/4  version performs  findall/3 followed  by sort/2  on
    _G_o_a_l.    See aggregate_all/3 to  understand why  this predicate  can
    fail.


ffoorreeaacchh((_:_G_e_n_e_r_a_t_o_r_, _:_G_o_a_l))
    True  if conjunction  of results is  true.   Unlike forall/2,  which
    runs  a failure-driven loop  that proves _G_o_a_l  for each solution  of
    _G_e_n_e_r_a_t_o_r,  foreach/2 creates  a conjunction.   Each  member of  the
    conjunction  is  a  copy of  _G_o_a_l,  where  the variables  it  shares
    with  _G_e_n_e_r_a_t_o_r are  filled with the  values from the  corresponding
    solution.

    The  implementation executes forall/2 if  _G_o_a_l does not contain  any
    variables that are not shared with _G_e_n_e_r_a_t_o_r.

    Here is an example:

    ____________________________________________________________________|                                                                    |
    | ?- foreach(between(1,4,X), dif(X,Y)), Y = 5.                       |

    | Y = 5.                                                             |
    | ?- foreach(between(1,4,X), dif(X,Y)), Y = 3.                       |
    ||false.____________________________________________________________ ||

         bbuugg _G_o_a_l  is copied  repeatedly, which may  cause problems
             if attributed variables are involved.


ffrreeee__vvaarriiaabblleess((_:_G_e_n_e_r_a_t_o_r_, _+_T_e_m_p_l_a_t_e_, _+_V_a_r_L_i_s_t_0_, _-_V_a_r_L_i_s_t))         _[_d_e_t_]
    Find  free variables in  bagof/setof template.   In order to  handle
    variables  properly, we have to find all the  universally quantified
    variables  in  the _G_e_n_e_r_a_t_o_r.    All variables  as  yet unbound  are
    universally quantified, unless

     1.  they occur in the template

     2.  they are bound by X^P, setof/3, or bagof/3

    free_variables(Generator, Template, OldList, NewList)   finds   this
    set using OldList as an accumulator.

         aauutthhoorr
             - Richard O'Keefe
             - Jan Wielemaker (made some SWI-Prolog enhancements)

         lliicceennssee Public domain (from DEC10 library).

         TToo bbee ddoonnee
             -  Distinguish  between  control-structures  and  data
             terms.
             -   Exploit  our  built-in  term_variables/2  at  some
             places?


ssaannddbbooxx::ssaaffee__mmeettaa((_+_G_o_a_l_, _-_C_a_l_l_e_d))                    _[_s_e_m_i_d_e_t_,_m_u_l_t_i_f_i_l_e_]
    Declare  the aggregate meta-calls safe.   This cannot be proven  due
    to the manipulations of the argument _G_o_a_l.


1122..22 lliibbrraarryy((aappppllyy))::  AAppppllyy pprreeddiiccaatteess oonn aa lliisstt

    SSeeee aallssoo
         - apply_macros.pl provides compile-time expansion for part
         of this library.
         - http://www.cs.otago.ac.nz/staffpriv/ok/pllib.htm

    TToo bbee ddoonnee  Add include/4, include/5, exclude/4, exclude/5

This  module defines  meta-predicates  that  apply a  predicate  on  all
members of a list.


iinncclluuddee((_:_G_o_a_l_, _+_L_i_s_t_1_, _?_L_i_s_t_2))                                    _[_d_e_t_]
    Filter  elements for which  _G_o_a_l succeeds.   True if _L_i_s_t_2  contains
    those elements Xi of _L_i_s_t_1 for which call(Goal, Xi) succeeds.

         SSeeee aallssoo Older  versions of SWI-Prolog  had sublist/3 with
             the same arguments and semantics.


eexxcclluuddee((_:_G_o_a_l_, _+_L_i_s_t_1_, _?_L_i_s_t_2))                                    _[_d_e_t_]
    Filter elements for which  _G_o_a_l fails.  True if _L_i_s_t_2 contains those
    elements Xi of _L_i_s_t_1 for which call(Goal, Xi) fails.


ppaarrttiittiioonn((_:_P_r_e_d_, _+_L_i_s_t_, _?_I_n_c_l_u_d_e_d_, _?_E_x_c_l_u_d_e_d))                     _[_d_e_t_]
    Filter  elements  of _L_i_s_t  according  to _P_r_e_d.    True  if  _I_n_c_l_u_d_e_d
    contains all elements  for which call(Pred, X) succeeds and _E_x_c_l_u_d_e_d
    contains the remaining elements.


ppaarrttiittiioonn((_:_P_r_e_d_, _+_L_i_s_t_, _?_L_e_s_s_, _?_E_q_u_a_l_, _?_G_r_e_a_t_e_r))              _[_s_e_m_i_d_e_t_]
    Filter  _L_i_s_t according to _P_r_e_d in three  sets.  For each  element Xi
    of  _L_i_s_t, its  destination is  determined by  call(Pred, Xi, Place),
    where  Place must be  unified to one  of <, =  or >.   _P_r_e_d must  be
    deterministic.


mmaapplliisstt((_:_G_o_a_l_, _?_L_i_s_t))
    True  if _G_o_a_l can successfully be  applied on all elements of  _L_i_s_t.
    Arguments  are reordered to gain performance as well as to  make the
    predicate deterministic under normal circumstances.


mmaapplliisstt((_:_G_o_a_l_, _?_L_i_s_t_1_, _?_L_i_s_t_2))
    As maplist/2, operating on pairs of elements from two lists.


mmaapplliisstt((_:_G_o_a_l_, _?_L_i_s_t_1_, _?_L_i_s_t_2_, _?_L_i_s_t_3))
    As maplist/2, operating on triples of elements from three lists.


mmaapplliisstt((_:_G_o_a_l_, _?_L_i_s_t_1_, _?_L_i_s_t_2_, _?_L_i_s_t_3_, _?_L_i_s_t_4))
    As maplist/2, operating on quadruples of elements from four lists.


ffoollddll((_:_G_o_a_l_, _+_L_i_s_t_, _+_V_0_, _-_V))


ffoollddll((_:_G_o_a_l_, _+_L_i_s_t_1_, _+_L_i_s_t_2_, _+_V_0_, _-_V))


ffoollddll((_:_G_o_a_l_, _+_L_i_s_t_1_, _+_L_i_s_t_2_, _+_L_i_s_t_3_, _+_V_0_, _-_V))


ffoollddll((_:_G_o_a_l_, _+_L_i_s_t_1_, _+_L_i_s_t_2_, _+_L_i_s_t_3_, _+_L_i_s_t_4_, _+_V_0_, _-_V))
    Fold  a list, using  arguments of the  list as left  argument.   The
    foldl family of predicates is defined by:

    ____________________________________________________________________|                                                                    |
    | foldl(P, [X11,...,X1n], ..., [Xm1,...,Xmn], V0, Vn) :-             |

    |       P(X11, ..., Xm1, V0, V1),                                    |
    |       ...                                                          |
    ||______P(X1n,_...,_Xmn,_V',_Vn).___________________________________ ||


ssccaannll((_:_G_o_a_l_, _+_L_i_s_t_, _+_V_0_, _-_V_a_l_u_e_s))


ssccaannll((_:_G_o_a_l_, _+_L_i_s_t_1_, _+_L_i_s_t_2_, _+_V_0_, _-_V_a_l_u_e_s))


ssccaannll((_:_G_o_a_l_, _+_L_i_s_t_1_, _+_L_i_s_t_2_, _+_L_i_s_t_3_, _+_V_0_, _-_V_a_l_u_e_s))


ssccaannll((_:_G_o_a_l_, _+_L_i_s_t_1_, _+_L_i_s_t_2_, _+_L_i_s_t_3_, _+_L_i_s_t_4_, _+_V_0_, _-_V_a_l_u_e_s))
    Left  scan  of  list.     The scanl  family  of  higher  order  list
    operations is defined by:

    ____________________________________________________________________|                                                                    |
    | scanl(P, [X11,...,X1n], ..., [Xm1,...,Xmn], V0,                    |

    |       [V0,V1,...,Vn]) :-                                           |
    |       P(X11, ..., Xmn, V0, V1),                                    |
    |       ...                                                          |
    ||______P(X1n,_...,_Xmn,_V',_Vn).___________________________________ ||


1122..33 lliibbrraarryy((aassssoocc))::  AAssssoocciiaattiioonn lliissttss

      Authors:  _R_i_c_h_a_r_d _A_. _O_'_K_e_e_f_e_, _L_._D_a_m_a_s_, _V_._S_._C_o_s_t_a _a_n_d _M_a_r_k_u_s _T_r_i_s_k_a

Elements of an association  list have 2 components:  A (unique)  _k_e_y and
a _v_a_l_u_e.   Keys should be  ground, values need not  be.  An  association
list can be used  to fetch elements via their keys and to  enumerate its
elements in ascending  order of their keys.   The assoc module uses  AVL
trees to  implement association lists.   This makes inserting,  changing
and fetching a single  element an O(log(N)) (where N denotes  the number
of elements in the list) expected time (and worst-case time) operation.


aassssoocc__ttoo__lliisstt((_+_A_s_s_o_c_, _-_L_i_s_t))
    _L_i_s_t is a  list of Key-Value pairs corresponding to the associations
    in _A_s_s_o_c in ascending order of keys.


aassssoocc__ttoo__kkeeyyss((_+_A_s_s_o_c_, _-_L_i_s_t))
    _L_i_s_t  is a list of Keys  corresponding to the associations in  _A_s_s_o_c
    in ascending order.


aassssoocc__ttoo__vvaalluueess((_+_A_s_s_o_c_, _-_L_i_s_t))
    _L_i_s_t is a  list of Values corresponding to the associations in _A_s_s_o_c
    in ascending order of the keys they are associated to.


eemmppttyy__aassssoocc((_?_A_s_s_o_c))
    _A_s_s_o_c is unified with an empty association list.


ggeenn__aassssoocc((_?_K_e_y_, _+_A_s_s_o_c_, _?_V_a_l_u_e))
    Enumerate  matching elements  of _A_s_s_o_c in  ascending order of  their
    keys via backtracking.


ggeett__aassssoocc((_+_K_e_y_, _+_A_s_s_o_c_, _?_V_a_l_u_e))
    _V_a_l_u_e  is the  value  associated with  _K_e_y in  the association  list
    _A_s_s_o_c.


ggeett__aassssoocc((_+_K_e_y_, _+_A_s_s_o_c_, _?_O_l_d_, _?_N_e_w_A_s_s_o_c_, _?_N_e_w))
    _N_e_w_A_s_s_o_c  is an association list identical to _A_s_s_o_c except  that the
    value associated with _K_e_y is _N_e_w instead of _O_l_d.


lliisstt__ttoo__aassssoocc((_+_L_i_s_t_, _-_A_s_s_o_c))
    _A_s_s_o_c  is an association list  corresponding to the Key-Value  pairs
    in _L_i_s_t.  _L_i_s_t must not contain duplicate keys.


mmaapp__aassssoocc((_:_G_o_a_l_, _+_A_s_s_o_c))
    _G_o_a_l_(_V_) is true for every value V in _A_s_s_o_c.


mmaapp__aassssoocc((_:_G_o_a_l_, _+_A_s_s_o_c_I_n_, _?_A_s_s_o_c_O_u_t))
    _A_s_s_o_c_O_u_t is _A_s_s_o_c_I_n  with _G_o_a_l applied to all corresponding pairs of
    values.


mmaaxx__aassssoocc((_+_A_s_s_o_c_, _?_K_e_y_, _?_V_a_l_u_e))
    _K_e_y and _V_a_l_u_e are  key and value of the element with the largest key
    in _A_s_s_o_c.


mmiinn__aassssoocc((_+_A_s_s_o_c_, _?_K_e_y_, _?_V_a_l_u_e))
    _K_e_y  and _V_a_l_u_e are  key and value of  the element with the  smallest
    key in _A_s_s_o_c.


oorrdd__lliisstt__ttoo__aassssoocc((_+_L_i_s_t_, _-_A_s_s_o_c))
    _A_s_s_o_c  is an association list  correspond to the Key-Value pairs  in
    _L_i_s_t, which must occur in strictly ascending order of their keys.


ppuutt__aassssoocc((_+_K_e_y_, _+_A_s_s_o_c_, _+_V_a_l_u_e_, _?_N_e_w_A_s_s_o_c))
    _N_e_w_A_s_s_o_c  is an association list identical to _A_s_s_o_c except  that _K_e_y
    is  associated with _V_a_l_u_e.   This can be  used to insert and  change
    associations.


iiss__aassssoocc((_+_A_s_s_o_c))
    True if Assoc is  a valid association list.  This predicate verifies
    the validity of each node in the AVL tree.


1122..44 lliibbrraarryy((bbrrooaaddccaasstt))::  BBrrooaaddccaasstt aanndd rreecceeiivvee eevveenntt nnoottiiffiiccaattiioonnss

The  broadcast  library   was  invented  to  realise  GUI   applications
consisting of  stand-alone components that use  the Prolog database  for
storing  the application  data.    Figure  ????  illustrates the  flow  of
information using this design

The  broadcasting service  provides two  services.    Using the  `shout'
service, an unknown number of agents may listen to  the message and act.
The broadcaster is not (directly) aware of the implications.   Using the
`request' service, listening  agents are asked for an  answer one-by-one
and the  broadcaster is allowed  to reject  answers using normal  Prolog
failure.

Shouting  is  often used  to  inform  about  changes made  to  a  common
database.  Other messages can be ``save yourself'' or ``show this''.

Requesting  is used  to get  information while  the  broadcaster is  not
aware who might  be able to answer the  question.  For example ``who  is
showing X?''.


bbrrooaaddccaasstt((_+_T_e_r_m))
    Broadcast  _T_e_r_m.   There are  no limitations to  _T_e_r_m, though  being
    a  global service,  it is  good practice  to use  a descriptive  and
    unique  principal  functor.     All  associated  goals  are  started
    and  regardless  of their  success  or failure,  broadcast/1  always
    succeeds.  Exceptions are passed.


bbrrooaaddccaasstt__rreeqquueesstt((_+_T_e_r_m))
    Unlike  broadcast/1,  this  predicate stops  if an  associated  goal
    succeeds.    Backtracking  causes it  to  try other  listeners.    A
    broadcast  request is used to fetch information without  knowing the
    identity  of the agent  providing it.   C.f. ``Is there someone  who
    knows the age of John?''  could be asked using

    ____________________________________________________________________|                                                                    |
    |         ...,                                                       |

    ||________broadcast_request(age_of('John',_Age)),___________________ ||

    If there is  an agent (_l_i_s_t_e_n_e_r) that registered an `age-of' service
    and knows about the age of `John' this question will be answered.


lliisstteenn((_+_T_e_m_p_l_a_t_e_, _:_G_o_a_l))
    Register  a  _l_i_s_t_e_n channel.    Whenever  a term  unifying  _T_e_m_p_l_a_t_e
    is  broadcasted,  call  _G_o_a_l.    The  following  example  traps  all
    broadcasted  messages as a variable unifies  to any message.  It  is
    commonly used to debug usage of the library.

    ____________________________________________________________________|                                                                    |
    | ?- listen(Term, (writeln(Term),fail)).                             |

    | ?- broadcast(hello(world)).                                        |
    | hello(world)                                                       |
    ||true._____________________________________________________________ ||


lliisstteenn((_+_L_i_s_t_e_n_e_r_, _+_T_e_m_p_l_a_t_e_, _:_G_o_a_l))
    Declare  _L_i_s_t_e_n_e_r as the  owner of  the channel.   Unlike a  channel
    opened  using listen/2,  channels that have  an owner can  terminate
    the  channel.  This  is commonly used if  an object is listening  to
    broadcast  messages.  In the  example below we define a  `name-item'
    displaying  the name of an  identifier represented by the  predicate
    name_of/2.

    ____________________________________________________________________|                                                                    |
    | :- pce_begin_class(name_item, text_item).                          |
    |                                                                    |
    | variable(id,    any,    get, "Id visualised").                     |

    |                                                                    |
    | initialise(NI, Id:any) :->                                         |
    |         name_of(Id, Name),                                         |
    |         send_super(NI, initialise, name, Name,                     |
    |                    message(NI, set_name, @arg1)),                  |
    |         send(NI, slot, id, Id),                                    |
    |         listen(NI, name_of(Id, Name),                              |

    |                send(NI, selection, Name)).                         |
    |                                                                    |
    | unlink(NI) :->                                                     |
    |         unlisten(NI),                                              |
    |         send_super(NI, unlink).                                    |
    |                                                                    |
    | set_name(NI, Name:name) :->                                        |
    |         get(NI, id, Id),                                           |

    |         retractall(name_of(Id, _)),                                |
    |         assert(name_of(Id, Name)),                                 |
    |         broadcast(name_of(Id, Name)).                              |
    |                                                                    |
    ||:-_pce_end_class._________________________________________________ ||


uunnlliisstteenn((_+_L_i_s_t_e_n_e_r))
    Deregister all entries created with listen/3 whose _L_i_s_t_e_n_e_r unify.


uunnlliisstteenn((_+_L_i_s_t_e_n_e_r_, _+_T_e_m_p_l_a_t_e))
    Deregister  all entries  created  with listen/3  whose _L_i_s_t_e_n_e_r  and
    _T_e_m_p_l_a_t_e unify.


uunnlliisstteenn((_+_L_i_s_t_e_n_e_r_, _+_T_e_m_p_l_a_t_e_, _:_G_o_a_l))
    Deregister  all   entries  created  with  listen/3  whose  _L_i_s_t_e_n_e_r,
    _T_e_m_p_l_a_t_e and _G_o_a_l unify.


lliisstteenniinngg((_?_L_i_s_t_e_n_e_r_, _?_T_e_m_p_l_a_t_e_, _?_G_o_a_l))
    Examine  the  current  listeners.    This  predicate is  useful  for
    debugging purposes.


1122..55 lliibbrraarryy((cchhaarrssiioo))::  II//OO oonn LLiissttss ooff CChhaarraacctteerr CCooddeess

    CCoommppaattiibbiilliittyy  The  naming  of  this  library  is not  in  line
         with the  ISO standard.   We  believe that  the SWI-Prolog
         native predicates form a more elegant alternative for this
         library.

This module emulates the Quintus/SICStus library  charsio.pl for reading
and writing from/to lists of character codes.   Most of these predicates
are straight calls  into similar SWI-Prolog primitives.   Some can  even
be replaced by ISO standard predicates.


ffoorrmmaatt__ttoo__cchhaarrss((_+_F_o_r_m_a_t_, _+_A_r_g_s_, _-_C_o_d_e_s))                            _[_d_e_t_]
    Use format/2 to write to a list of character codes.


ffoorrmmaatt__ttoo__cchhaarrss((_+_F_o_r_m_a_t_, _+_A_r_g_s_, _-_C_o_d_e_s_, _?_T_a_i_l))                     _[_d_e_t_]
    Use format/2 to write to a difference list of character codes.


wwrriittee__ttoo__cchhaarrss((_+_T_e_r_m_, _-_C_o_d_e_s))
    Write  a  term to  a  code list.    True  when _C_o_d_e_s  is a  list  of
    character codes written by write/1 on _T_e_r_m.


wwrriittee__ttoo__cchhaarrss((_+_T_e_r_m_, _-_C_o_d_e_s_, _?_T_a_i_l))
    Write  a term to a  code list.   _C_o_d_e_s\_T_a_i_l is a difference list  of
    character codes produced by write/1 on _T_e_r_m.


aattoomm__ttoo__cchhaarrss((_+_A_t_o_m_, _-_C_o_d_e_s))                                       _[_d_e_t_]
    Convert _A_t_o_m into a list of character codes.

         ddeepprreeccaatteedd Use ISO atom_codes/2.


aattoomm__ttoo__cchhaarrss((_+_A_t_o_m_, _-_C_o_d_e_s_, _?_T_a_i_l))                                _[_d_e_t_]
    Convert _A_t_o_m into a difference list of character codes.


nnuummbbeerr__ttoo__cchhaarrss((_+_N_u_m_b_e_r_, _-_C_o_d_e_s))                                   _[_d_e_t_]
    Convert Atom into a list of character codes.

         ddeepprreeccaatteedd Use ISO number_codes/2.


nnuummbbeerr__ttoo__cchhaarrss((_+_N_u_m_b_e_r_, _-_C_o_d_e_s_, _?_T_a_i_l))                            _[_d_e_t_]
    Convert _N_u_m_b_e_r into a difference list of character codes.


rreeaadd__ffrroomm__cchhaarrss((_+_C_o_d_e_s_, _-_T_e_r_m))                                     _[_d_e_t_]
    Read _C_o_d_e_s into _T_e_r_m.

         CCoommppaattiibbiilliittyy The  SWI-Prolog  version  does  not  require
             _C_o_d_e_s to end in a full-stop.


rreeaadd__tteerrmm__ffrroomm__cchhaarrss((_+_C_o_d_e_s_, _-_T_e_r_m_, _+_O_p_t_i_o_n_s))                       _[_d_e_t_]
    Read _C_o_d_e_s into _T_e_r_m.  _O_p_t_i_o_n_s are processed by read_term/3.

         CCoommppaattiibbiilliittyy sicstus


ooppeenn__cchhaarrss__ssttrreeaamm((_+_C_o_d_e_s_, _-_S_t_r_e_a_m))                                 _[_d_e_t_]
    Open _C_o_d_e_s as an input stream.

         SSeeee aallssoo open_string/2.


wwiitthh__oouuttppuutt__ttoo__cchhaarrss((_:_G_o_a_l_, _-_C_o_d_e_s))                                 _[_d_e_t_]
    Run  _G_o_a_l  as with  once/1.   Output  written  to current_output  is
    collected in _C_o_d_e_s.


wwiitthh__oouuttppuutt__ttoo__cchhaarrss((_:_G_o_a_l_, _-_C_o_d_e_s_, _?_T_a_i_l))                          _[_d_e_t_]
    Run  _G_o_a_l  as with  once/1.   Output  written  to current_output  is
    collected in _C_o_d_e_s\_T_a_i_l.


wwiitthh__oouuttppuutt__ttoo__cchhaarrss((_:_G_o_a_l_, _-_S_t_r_e_a_m_, _-_C_o_d_e_s_, _?_T_a_i_l))                 _[_d_e_t_]
    Same  as  with_output_to_chars/3 using  an  explicit stream.     The
    difference  list _C_o_d_e_s\_T_a_i_l contains  the character codes that  _G_o_a_l
    has written to _S_t_r_e_a_m.


1122..66 lliibbrraarryy((cchheecckk))::  CCoonnssiisstteennccyy cchheecckkiinngg

    SSeeee aallssoo
         - gxref/0 provides a graphical cross referencer
         - PceEmacs performs real time consistency checks while you
         edit
         -   library(prolog_xref)   implements   `offline'   cross-
         referencing
         - library(prolog_codewalk) implements `online' analysis

This  library provides  some consistency  checks for  the loaded  Prolog
program.   The predicate make/0 runs list_undefined/0 to find  undefined
predicates in `user' modules.


cchheecckk                                                             _[_d_e_t_]
    Run all consistency  checks defined by checker/2.  Checks enabled by
    default are:

      o  list_undefined/0 reports undefined predicates

      o  list_trivial_fails/0 reports  calls  for   which  there  is  no
         matching clause.

      o  list_redefined/0  reports   predicates   that  have   a   local
         definition and a  global definition.   Note that these are  nnoott
         errors.

      o  list_autoload/0  lists  predicates  that  will  be  defined  at
         runtime using the autoloader.


lliisstt__uunnddeeffiinneedd                                                     _[_d_e_t_]


lliisstt__uunnddeeffiinneedd((_+_O_p_t_i_o_n_s))                                           _[_d_e_t_]
    Report  undefined  predicates.     This  predicate  finds  undefined
    predciates  by decompiling  and analyzing the  body of all  clauses.
    _O_p_t_i_o_n_s:

    mmoodduullee__ccllaassss((_+_C_l_a_s_s_e_s))
         Process modules of the given _C_l_a_s_s_e_s.  The  default for classes
         is [user].    For example,  to include the  libraries into  the
         examination, use [user,library].

         SSeeee aallssoo
             - gxref/0 provides a graphical cross-referencer.
             - make/0 calls list_undefined/0


lliisstt__aauuttoollooaadd                                                      _[_d_e_t_]
    Report  predicates that may  be auto-loaded.   These are  predicates
    that are not defined, but will be loaded on demand if referenced.

         SSeeee aallssoo autoload/0

         TToo bbee ddoonnee This  predicate  uses  an  older mechanism  for
             finding undefined  predicates.  Should be synchronized
             with list undefined.


lliisstt__rreeddeeffiinneedd
    Lists predicates that  are defined in the global module user as well
    as  in a  normal module;  that is,  predicates for  which the  local
    definition overrules the global default definition.


lliisstt__vvooiidd__ddeeccllaarraattiioonnss                                             _[_d_e_t_]
    List predicates that have declared attributes, but no clauses.


lliisstt__ttrriivviiaall__ffaaiillss                                                 _[_d_e_t_]


lliisstt__ttrriivviiaall__ffaaiillss((_+_O_p_t_i_o_n_s))                                       _[_d_e_t_]
    List goals that  trivially fail because there is no matching clause.
    _O_p_t_i_o_n_s:

    mmoodduullee__ccllaassss((_+_C_l_a_s_s_e_s))
         Process modules of the given _C_l_a_s_s_e_s.  The  default for classes
         is [user].    For example,  to include the  libraries into  the
         examination, use [user,library].


ttrriivviiaall__ffaaiill__ggooaall((_:_G_o_a_l))                                     _[_m_u_l_t_i_f_i_l_e_]
    Multifile  hook that  tells list_trivial_fails/0 to  accept _G_o_a_l  as
    valid.


lliisstt__ssttrriinnggss                                                       _[_d_e_t_]


lliisstt__ssttrriinnggss((_+_O_p_t_i_o_n_s))                                             _[_d_e_t_]
    List  strings that appear  in clauses.   This  predicate is used  to
    find  portability issues for changing the Prolog  flag double_quotes
    from codes to  string, creating packed string objects.  Warnings may
    be suppressed using the following multifile hooks:

      o  string_predicate/1 to stop checking certain predicates

      o  valid_string_goal/1to tell the checker that a goal is safe.

         SSeeee aallssoo Prolog flag double_quotes.


ssttrriinngg__pprreeddiiccaattee((_:_P_r_e_d_i_c_a_t_e_I_n_d_i_c_a_t_o_r))                        _[_m_u_l_t_i_f_i_l_e_]
    Multifile  hook to  disable list_strings/0 on  the given  predicate.
    This is typically used for facts that store strings.


vvaalliidd__ssttrriinngg__ggooaall((_+_G_o_a_l))                             _[_s_e_m_i_d_e_t_,_m_u_l_t_i_f_i_l_e_]
    Multifile  hook  that qualifies  _G_o_a_l as  valid for  list_strings/0.
    For  example, format("Hello world~n")  is considered  proper use  of
    string constants.


cchheecckkeerr((_:_G_o_a_l_, _+_M_e_s_s_a_g_e_:_t_e_x_t))                               _[_m_u_l_t_i_f_i_l_e_]
    Register  code validation  routines.    Each clause  defines a  _G_o_a_l
    which  performs a consistency  check executed by  check/0.   _M_e_s_s_a_g_e
    is  a short description  of the  check.   For example, assuming  the
    my_checks module defines a predicate list_format_mistakes/0:

    ____________________________________________________________________|                                                                    |
    | :- multifile check:checker/2.                                      |

    | check:checker(my_checks:list_format_mistakes,                      |
    ||______________"errors_with_format/2_arguments").__________________ ||

    The predicate is  dynamic, so you can disable checks with retract/1.
    For example, to stop reporting redefined predicates:

    ____________________________________________________________________|                                                                    |
    ||retract(check:checker(list_redefined,_))._________________________ ||


1122..77 lliibbrraarryy((ccllppbb))::     CCoonnssttrraaiinntt   LLooggiicc  PPrrooggrraammmmiinngg   oovveerr   BBoooolleeaann
     VVaarriiaabblleess

    aauutthhoorr  Markus Triska


1122..77..00..11 IInnttrroodduuccttiioonn

Constraint programming  is a declarative formalism  that lets you  state
relations  between terms.    This  library provides  CLP(B),  Constraint
Logic Programming  over Boolean  Variables.   It  can be  used to  model
and solve  combinatorial problems such  as verification, allocation  and
covering tasks.

The  implementation is  based  on reduced  and ordered  Binary  Decision
Diagrams (BDDs).


1122..77..00..22 BBoooolleeaann eexxpprreessssiioonnss

A _B_o_o_l_e_a_n _e_x_p_r_e_s_s_i_o_n is one of:

    ______________________________________________
    | 0              |false                       |
    | 1              |true                        |
    | _v_a_r_i_a_b_l_e       _|unknown truth value         |

    | ~ _E_x_p_r         _|logical NOT                 |
    | _E_x_p_r + _E_x_p_r    _|logical OR                  |
    | _E_x_p_r * _E_x_p_r    _|logical AND                 |
    | _E_x_p_r # _E_x_p_r    _|exclusive OR                |
    | _V_a_r ^ _E_x_p_r     _|existential quantification  |
    | _E_x_p_r =:= _E_x_p_r  _|equality                    |
    | _E_x_p_r =\= _E_x_p_r  _|disequality (same as #)     |

    | _E_x_p_r =<  _E_x_p_r  _|less or equal (implication) |
    | _E_x_p_r >= _E_x_p_r   _|greater or equal            |
    | _E_x_p_r < _E_x_p_r    _|less than                   |
    | _E_x_p_r > _E_x_p_r    _|greater than                |
    | card(Is,Exprs) |_s_e_e _b_e_l_o_w                   _|
    _| +(Exprs)       |_s_e_e _b_e_l_o_w                   _|
    _|__*(Exprs)______________|_s_e_e___b_e_l_o_w_______________________________________|

where _E_x_p_r again denotes a Boolean expression.

The Boolean  expression card(Is,Exprs) is  true iff  the number of  true
expressions in  the list _E_x_p_r_s is  a member of  the list _I_s of  integers
and integer ranges of the form From-To.

+(Exprs)  and  *(Exprs)  denote,   respectively,  the   disjunction  and
conjunction of all elements in the list _E_x_p_r_s of Boolean expressions.


1122..77..00..33 IInntteerrffaaccee pprreeddiiccaatteess

Important interface predicates of CLP(B) are:

ssaatt((_+_E_x_p_r))
    True iff the Boolean expression _E_x_p_r is satisfiable.

ttaauutt((_+_E_x_p_r_, _-_T))
    If  _E_x_p_r is  a  tautology with  respect to  the posted  constraints,
    succeeds  with _T == 11.  If _E_x_p_r cannot be satisfied,  succeeds with _T
    == 00.  Otherwise, it fails.

llaabbeelliinngg((_+_V_s))
    Assigns  truth values to the variables _V_s such that  all constraints
    are satisfied.

The unification of  a CLP(B) variable _X with  a term _T is equivalent  to
posting the constraint sat(X=:=T).


1122..77..00..44 EExxaammpplleess

Here is an example session with a few queries and their answers:

________________________________________________________________________|                                                                        |
|?- use_module(library(clpb)).                                           |

|true.                                                                   |
|                                                                        |
|?- sat(X*Y).                                                            |
|X = Y, Y = 1.                                                           |
|                                                                        |
|?- sat(X * ~X).                                                         |
|false.                                                                  |
|                                                                        |

|?- taut(X * ~X, T).                                                     |
|T = 0,                                                                  |
|sat(X=:=X).                                                             |
|                                                                        |
|?- sat(X^Y^(X+Y)).                                                      |
|sat(X=:=X),                                                             |
|sat(Y=:=Y).                                                             |

|                                                                        |
|?- sat(X*Y + X*Z), labeling([X,Y,Z]).                                   |
|X = Z, Z = 1, Y = 0 ;                                                   |
|X = Y, Y = 1, Z = 0 ;                                                   |
|X = Y, Y = Z, Z = 1.                                                    |
|                                                                        |
|?- sat(X =< Y), sat(Y =< Z), taut(X =< Z, T).                           |
|T = 1,                                                                  |

|sat(1#X#X*Y),                                                           |
|sat(1#Y#Y*Z).|_________________________________________________________ |             |

The  pending residual  goals constrain  remaining  variables to  Boolean
expressions and are declaratively equivalent to the original query.


ssaatt((_+_E_x_p_r))                                                    _[_s_e_m_i_d_e_t_]
    True iff _E_x_p_r is a satisfiable Boolean expression.


ttaauutt((_+_E_x_p_r_, _-_T))                                               _[_s_e_m_i_d_e_t_]
    Succeeds  with  _T =  0  if the  Boolean  expression _E_x_p_r  cannot  be
    satisfied,  and with _T =  1 if _E_x_p_r is  always true with respect  to
    the current constraints.  Fails otherwise.


llaabbeelliinngg((_+_V_s))                                                   _[_m_u_l_t_i_]
    Assigns  truth values  to  the Boolean  variables _V_s  such that  all
    stated constraints are satisfied.


ssaatt__ccoouunntt((_+_E_x_p_r_, _-_N))                                               _[_d_e_t_]
    _N  is the  number of different  assignments of  truth values to  the
    variables  in the Boolean  expression _E_x_p_r, such  that _E_x_p_r is  true
    and all posted constraints are satisfiable.

    Example:

    ____________________________________________________________________|                                                                    |
    | ?- length(Vs, 120), sat_count(+Vs, CountOr), sat_count(*(Vs), CountAnd).|

    | Vs = [...],                                                        |
    | CountOr = 1329227995784915872903807060280344575,                   |
    ||CountAnd_=_1._____________________________________________________ ||


1122..88 lliibbrraarryy((ccllppffdd))::  CCoonnssttrraaiinntt LLooggiicc PPrrooggrraammmmiinngg oovveerr FFiinniittee DDoommaaiinnss

    aauutthhoorr  Markus Triska


1122..88..00..55 IInnttrroodduuccttiioonn

Constraint programming  is a declarative formalism  that lets you  state
relations  between terms.    This library  provides CLP(FD),  Constraint
Logic Programming over Finite Domains.

There are two major use cases of this library:

 1. CLP(FD)  constraints provide _d_e_c_l_a_r_a_t_i_v_e  _i_n_t_e_g_e_r _a_r_i_t_h_m_e_t_i_c:   They
    implement  pure _r_e_l_a_t_i_o_n_s  between  integer expressions  and can  be
    used in all directions, also if parts of expressions are variables.

 2. In   connection  with  enumeration   predicates  and  more   complex
    constraints, CLP(FD) is  often used to model and solve combinatorial
    problems such as planning, scheduling and allocation tasks.

When teaching Prolog,  we _s_t_r_o_n_g_l_y _r_e_c_o_m_m_e_n_d that you  introduce CLP(FD)
constraints  _b_e_f_o_r_e  explaining lower-level  arithmetic  predicates  and
their procedural idiosyncrasies.   This is because constraints  are easy
to explain,  understand and use due  to their purely relational  nature.
In contrast,  the modedness and  directionality of low-level  arithmetic
primitives are non-declarative  limitations that are better deferred  to
more advanced lectures.

If  you are  used  to the  complicated operational  considerations  that
low-level  arithmetic primitives  necessitate,  then moving  to  CLP(FD)
constraints may,  due to their power and  convenience, at first feel  to
you excessive  and almost like  cheating.   It _i_s_n_'_t.   Constraints  are
an integral part  of many Prolog systems  and are available to help  you
eliminate and  avoid, as  far as  possible, the use  of lower-level  and
less general primitives  by providing declarative alternatives that  are
meant to be used instead.

For  satisfactory performance,  arithmetic  constraints  are  implicitly
rewritten at  compilation time so  that lower-level fallback  predicates
are automatically used whenever possible.

We recommend the following reference to cite this  library in scientific
publications:

________________________________________________________________________|                                                                        |

|@inproceedings{Triska12,                                                |
|  author    = {Markus Triska},                                          |
|  title     = {The Finite Domain Constraint Solver of {SWI-Prolog}},    |
|  booktitle = {FLOPS},                                                  |
|  series    = {LNCS},                                                   |

|  volume    = {7294},                                                   |
|  year      = {2012},                                                   |
|  pages     = {307-316}                                                 |
|}|_____________________________________________________________________ | |

and the following URL to link to its documentation:

________________________________________________________________________|                                                                        |
|http://www.swi-prolog.org/man/clpfd.html|______________________________ |                                        |


1122..88..00..66 AArriitthhmmeettiicc ccoonnssttrraaiinnttss

A finite domain _a_r_i_t_h_m_e_t_i_c _e_x_p_r_e_s_s_i_o_n is one of:

    _______________________________________________________
    | _i_n_t_e_g_e_r        _|Given value                          |
    | _v_a_r_i_a_b_l_e       _|Unknown integer                      |
    | ?(_v_a_r_i_a_b_l_e)    |Unknown integer                      |

    | -Expr          |Unary minus                          |
    | Expr + Expr    |Addition                             |
    | Expr * Expr    |Multiplication                       |
    | Expr - Expr    |Subtraction                          |
    | Expr ^ Expr    |Exponentiation                       |
    | min(Expr,Expr) |Minimum of two expressions           |
    | max(Expr,Expr) |Maximum of two expressions           |

    | Expr mod Expr  |Modulo induced by floored division   |
    | Expr rem Expr  |Modulo induced by truncated division |
    | abs(Expr)      |Absolute value                       |
    |_Expr_//_Expr___|Truncated_integer_division___________|

Arithmetic _c_o_n_s_t_r_a_i_n_t_s are relations between arithmetic expressions.

The most important arithmetic constraints are:

    ___________________________________________________________
    | Expr1 #>= Expr2 |Expr1 is greater than or equal to Expr2 |
    | Expr1 #=< Expr2 |Expr1 is less than or equal to Expr2    |
    | Expr1 #= Expr2  |Expr1 equals Expr2                      |
    | Expr1 #\= Expr2 |Expr1 is not equal to Expr2             |
    | Expr1 #> Expr2  |Expr1 is greater than Expr2             |
    |_Expr1_#<_Expr2__|Expr1_is_less_than_Expr2________________|


1122..88..00..77 DDeeccllaarraattiivvee iinntteeggeerr aarriitthhmmeettiicc

CLP(FD) constraints  let you  declaratively express integer  arithmetic.
The CLP(FD) constraints  #=/2, #>/2 etc.   are meant to be used  instead
of the corresponding primitives is/2, =:=/2, >/2 etc.  over integers.

An  important  advantage  of  arithmetic  constraints  is  their  purely
relational nature.    They are therefore  easy to explain  and use,  and
well suited for beginners and experienced Prolog programmers alike.

Consider for example the query:

________________________________________________________________________|                                                                        |
|?- X #> 3, X #= 5 + 2.                                                  |

|X|=_7._________________________________________________________________ | |

In contrast, when using low-level integer arithmetic, we get:

________________________________________________________________________|                                                                        |
|?- X > 3, X is 5 + 2.                                                   |
|ERROR:|>/2:_Arguments_are_not_sufficiently_instantiated________________ |      |

Due  to the  necessary  operational  considerations,  the use  of  these
low-level  arithmetic predicates  is considerably  harder to  understand
and should therefore be deferred to more advanced lectures.

For supported expressions, CLP(FD) constraints are  drop-in replacements
of these  low-level arithmetic predicates,  often yielding more  general
programs.

Here is an example:

________________________________________________________________________|                                                                        |
|:- use_module(library(clpfd)).                                          |

|                                                                        |
|n_factorial(0, 1).                                                      |
|n_factorial(N, F) :-                                                    |
|        N #> 0, N1 #= N - 1, F #= N * F1,                               |
||_______n_factorial(N1,_F1).___________________________________________ ||

This predicate can be used in all directions.  For example:

________________________________________________________________________|                                                                        |
|?- n_factorial(47, F).                                                  |

|F = 258623241511168180642964355153611979969197632389120000000000 ;      |
|false.                                                                  |
|                                                                        |
|?- n_factorial(N, 1).                                                   |
|N = 0 ;                                                                 |
|N = 1 ;                                                                 |
|false.                                                                  |

|                                                                        |
|?- n_factorial(N, 3).                                                   |
|false.|________________________________________________________________ |      |

To make  the predicate terminate  if any  argument is instantiated,  add
the (implied) constraint F #\= 0 before the recursive  call.  Otherwise,
the query  n_factorial(N, 0) is  the only non-terminating  case of  this
kind.

This library  uses goal_expansion/2 to automatically rewrite  arithmetic
constraints  at compilation  time.    The expansion's  aim is  to  bring
the performance of  arithmetic constraints close to that of  lower-level
arithmetic predicates whenever possible.  To disable  the expansion, set
the flag clpfd_goal_expansion to false.


1122..88..00..88 RReeiiffiiccaattiioonn

The constraints in/2, #=/2, #\=/2,  #</2, #>/2, #=</2, and #>=/2  can be
_r_e_i_f_i_e_d, which means  reflecting their truth values into  Boolean values
represented by  the integers  0 and 1.    Let P and  Q denote  reifiable
constraints or Boolean variables, then:

    __________________________________________________
    | #\ Q       |True iff Q is false                  |
    | P #\/ Q    |True iff either P or Q               |
    | P #/\ Q    |True iff both P and Q                |

    | P #\ Q     |True iff either P or Q, but not both |
    | P #<==>  Q |True iff P and Q are equivalent      |
    | P #==>  Q  |True iff P implies Q                 |
    |_P_#<==_Q___|True_iff_Q_implies_P________________ |

The constraints of this table are reifiable as well.

When   reasoning   over   Boolean   variables,   also   consider   using
library(clpb) and its dedicated CLP(B) constraints.


1122..88..00..99 DDoommaaiinnss

Each  CLP(FD) variable  has  an associated  set of  admissible  integers
which we  call the  variable's _d_o_m_a_i_n.   Initially,  the domain of  each
CLP(FD) variable is the  set of all integers.  The constraints  in/2 and
ins/2 are the primary means to specify tighter domains of variables.

Here  are example  queries  and  the system's  declaratively  equivalent
answers:

________________________________________________________________________|                                                                        |
|?- X in 100..sup.                                                       |
|X in 100..sup.                                                          |
|                                                                        |

|?- X in 1..5 \/ 3..12.                                                  |
|X in 1..12.                                                             |
|                                                                        |
|?- [X,Y,Z] ins 0..3.                                                    |
|X in 0..3,                                                              |
|Y in 0..3,                                                              |
|Z|in_0..3._____________________________________________________________ | |

Domains are taken into account when further constraints  are stated, and
by enumeration predicates like labeling/2.


1122..88..00..1100 EExxaammpplleess

Here is an example session with a few queries and their answers:

________________________________________________________________________|                                                                        |
|?- use_module(library(clpfd)).                                          |

|% library(clpfd) compiled into clpfd 0.06 sec, 633,732 bytes            |
|true.                                                                   |
|                                                                        |
|?- X #> 3.                                                              |
|X in 4..sup.                                                            |
|                                                                        |
|?- X #\= 20.                                                            |
|X in inf..19\/21..sup.                                                  |

|                                                                        |
|?- 2*X #= 10.                                                           |
|X = 5.                                                                  |
|                                                                        |
|?- X*X #= 144.                                                          |
|X in -12\/12.                                                           |
|                                                                        |

|?- 4*X + 2*Y #= 24, X + Y #= 9, [X,Y] ins 0..sup.                       |
|X = 3,                                                                  |
|Y = 6.                                                                  |
|                                                                        |
|?- X #= Y #<==> B, X in 0..3, Y in 4..5.                                |
|B = 0,                                                                  |
|X in 0..3,                                                              |
|Y|in_4..5._____________________________________________________________ | |

In each case, and as for all pure programs,  the answer is declaratively
equivalent  to the  original query,  and in  many  cases the  constraint
solver has deduced additional domain restrictions.


1122..88..00..1111 EEnnuummeerraattiioonn pprreeddiiccaatteess aanndd sseeaarrcchh

In addition to  being declarative replacements for low-level  arithmetic
predicates,   CLP(FD)  constraints   are  also  often   used  to   solve
combinatorial  problems  such as  planning,  scheduling  and  allocation
tasks.   To  let you conveniently  model and solve  such problems,  this
library provides several constraints beyond typical  integer arithmetic,
such as all_distinct/1, global_cardinality/2and cumulative/1.

Using  CLP(FD)  constraints  to  solve  combinatorial   tasks  typically
consists of two phases:

 1. First, all relevant constraints are stated.

 2. Second,   if  the  domain  of  each  involved  variable  is  _f_i_n_i_t_e,
    then  _e_n_u_m_e_r_a_t_i_o_n  _p_r_e_d_i_c_a_t_e_s can  be used  to  search for  concrete
    solutions.

It  is  good  practice to  keep  the  modeling  part,  via  a  dedicated
predicate  called the  ccoorree rreellaattiioonn,  separate from  the actual  search
for  solutions.    This lets  you  observe termination  and  determinism
properties of the core  relation in isolation from the search,  and more
easily try different search strategies.

As  an  example of  a  constraint  satisfaction  problem,  consider  the
cryptoarithmetic puzzle  SEND +  MORE = MONEY,  where different  letters
denote distinct integers between 0 and 9.  It can  be modeled in CLP(FD)
as follows:

________________________________________________________________________|                                                                        |

|:- use_module(library(clpfd)).                                          |
|                                                                        |
|puzzle([S,E,N,D] + [M,O,R,E] = [M,O,N,E,Y]) :-                          |
|        Vars = [S,E,N,D,M,O,R,Y],                                       |
|        Vars ins 0..9,                                                  |
|        all_different(Vars),                                            |
|                  S*1000 + E*100 + N*10 + D +                           |

|                  M*1000 + O*100 + R*10 + E #=                          |
|        M*10000 + O*1000 + N*100 + E*10 + Y,                            |
||_______M_#\=_0,_S_#\=_0.______________________________________________ ||

Notice that we  are _n_o_t using labeling/2  in this predicate, so that  we
can first execute  and observe the modeling  part in isolation.   Sample
query and its result (actual variables replaced for readability):

________________________________________________________________________|                                                                        |
|?- puzzle(As+Bs=Cs).                                                    |
|As = [9, A2, A3, A4],                                                   |

|Bs = [1, 0, B3, A2],                                                    |
|Cs = [1, 0, A3, A2, C5],                                                |
|A2 in 4..7,                                                             |
|all_different([9, A2, A3, A4, 1, 0, B3, C5]),                           |
|91*A2+A4+10*B3#=90*A3+C5,                                               |
|A3 in 5..8,                                                             |
|A4 in 2..8,                                                             |
|B3 in 2..8,                                                             |

|C5|in_2..8.____________________________________________________________ |  |

From this answer,  we see that this  core relation _t_e_r_m_i_n_a_t_e_s and is  in
fact _d_e_t_e_r_m_i_n_i_s_t_i_c.   Moreover, we see from the residual goals  that the
constraint solver has  deduced more stringent bounds for all  variables.
Such observations  are only possible  if modeling  and search parts  are
cleanly separated.

Labeling  can  then be  used  to  search  for solutions  in  a  separate
predicate or goal:

________________________________________________________________________|                                                                        |
|?- puzzle(As+Bs=Cs), label(As).                                         |
|As = [9, 5, 6, 7],                                                      |
|Bs = [1, 0, 8, 5],                                                      |
|Cs = [1, 0, 6, 5, 2] ;                                                  |
|false.|________________________________________________________________ |      |

In this  case, it suffices to  label a subset  of variables to find  the
puzzle's unique solution,  since the constraint solver is  strong enough
to reduce  the domains  of remaining variables  to singleton  sets.   In
general though, it is necessary to label all  variables to obtain ground
solutions.


1122..88..00..1122 OOppttiimmiissaattiioonn

You can use  labeling/2 to minimize or  maximize the value of a  CLP(FD)
expression,  and generate solutions  in increasing  or decreasing  order
of  the value.    See  the  labeling  options min(Expr)  and  max(Expr),
respectively.

Again,  to easily  try  different labeling  options in  connection  with
optimisation,  we  recommend  to introduce  a  dedicated  predicate  for
posting constraints,  and to use  labeling/2 in a separate  goal.   This
way, you can observe  properties of the core relation in  isolation, and
try different labeling options without recompiling your code.

If  necessary,  you  can use  once/1  to  commit to  the  first  optimal
solution.    However,  it  is often  very  valuable to  see  alternative
solutions that are  _a_l_s_o optimal, so that  you can choose among  optimal
solutions by other criteria.   For the sake of purity  and completeness,
we  recommend  to  avoid  once/1  and  other  constructs  that  lead  to
impurities in CLP(FD) programs.


1122..88..00..1133 AAddvvaanncceedd ttooppiiccss

If you set the flag clpfd_monotonic to true,  then CLP(FD) is monotonic:
Adding new constraints  cannot yield new solutions.   When this flag  is
true, you must wrap variables that occur in  arithmetic expressions with
the functor  (?)/1.  For  example, ?(X) #= ?(Y) + ?(Z). The wrapper  can
be omitted for variables that are already constrained to integers.

Use call_residue_vars/2 and  copy_term/3 to inspect  residual goals  and
the constraints  in which  a variable is  involved.   This library  also
provides _r_e_f_l_e_c_t_i_o_n  predicates (like  fd_dom/2, fd_size/2 etc.)    with
which you  can inspect a  variable's current domain.   These  predicates
can be useful if you want to implement your own labeling strategies.

You can  also define custom constraints.   The  mechanism to do this  is
not yet  finalised, and we welcome  suggestions and descriptions of  use
cases  that are  important to  you.   As  an example  of how  it can  be
done currently, let us define a new  custom constraint oneground(X,Y,Z),
where Z shall be 1 if at least one of X and Y is instantiated:

________________________________________________________________________|                                                                        |
|:- use_module(library(clpfd)).                                          |
|                                                                        |
|:- multifile clpfd:run_propagator/2.                                    |

|                                                                        |
|oneground(X, Y, Z) :-                                                   |
|        clpfd:make_propagator(oneground(X, Y, Z), Prop),                |
|        clpfd:init_propagator(X, Prop),                                 |
|        clpfd:init_propagator(Y, Prop),                                 |
|        clpfd:trigger_once(Prop).                                       |
|                                                                        |
|clpfd:run_propagator(oneground(X, Y, Z), MState) :-                     |

|        (   integer(X) -> clpfd:kill(MState), Z = 1                     |
|        ;   integer(Y) -> clpfd:kill(MState), Z = 1                     |
|        ;   true                                                        |
||_______)._____________________________________________________________ ||

First,  clpfd:make_propagator/2  is used  to  transform  a  user-defined
representation  of  the new  constraint  to  an  internal form.     With
clpfd:init_propagator/2, this internal  form is then  attached to X  and
Y. From now on,  the propagator will be invoked whenever the  domains of
X or  Y are changed.    Then, clpfd:trigger_once/1 is  used to give  the
propagator its first  chance for propagation even though the  variables'
domains  have  not yet  changed.    Finally,  clpfd:run_propagator/2  is
extended to define the actual propagator.  As  explained, this predicate
is automatically called  by the constraint solver.   The first  argument
is  the  user-defined  representation  of  the  constraint  as  used  in
clpfd:make_propagator/2, and  the  second argument  is a  mutable  state
that can be used  to prevent further invocations of the  propagator when
the constraint has become  entailed, by using clpfd:kill/1.   An example
of using the new constraint:

________________________________________________________________________|                                                                        |
|?- oneground(X, Y, Z), Y = 5.                                           |

|Y = 5,                                                                  |
|Z = 1,                                                                  |
|X|in_inf..sup._________________________________________________________ | |


_?_V_a_r iinn _+_D_o_m_a_i_n
    _V_a_r is an element of _D_o_m_a_i_n.  _D_o_m_a_i_n is one of:

    _I_n_t_e_g_e_r
         Singleton set consisting only of _I_n_t_e_g_e_r.

    _L_o_w_e_r ....  _U_p_p_e_r
         All integers _I such  that _L_o_w_e_r =< _I =<  _U_p_p_e_r.  _L_o_w_e_r must  be
         an integer or  the atom iinnff,  which denotes negative  infinity.
         _U_p_p_e_r  must be  an  integer  or the  atom  ssuupp,  which  denotes
         positive infinity.

    _D_o_m_a_i_n_1 \/ _D_o_m_a_i_n_2
         The union of _D_o_m_a_i_n_1 and _D_o_m_a_i_n_2.


_+_V_a_r_s iinnss _+_D_o_m_a_i_n
    The variables in the list _V_a_r_s are elements of _D_o_m_a_i_n.


iinnddoommaaiinn((_?_V_a_r))
    Bind _V_a_r to all  feasible values of its domain on backtracking.  The
    domain of _V_a_r must be finite.


llaabbeell((_+_V_a_r_s))
    Equivalent to labeling([], Vars).


llaabbeelliinngg((_+_O_p_t_i_o_n_s_, _+_V_a_r_s))
    Assign  a  value   to  each  variable  in  _V_a_r_s.     Labeling  means
    systematically  trying out  values for the  finite domain  variables
    _V_a_r_s  until all of them are ground.  The domain of  each variable in
    _V_a_r_s  must be finite.   _O_p_t_i_o_n_s  is a list of  options that let  you
    exhibit  some control over the  search process.  Several  categories
    of options exist:

    The  variable selection strategy lets you specify which  variable of
    _V_a_r_s is labeled next and is one of:

    lleeffttmmoosstt
         Label the variables in the  order they occur in _V_a_r_s.   This is
         the default.

    ffff
         _F_i_r_s_t _f_a_i_l.   Label the leftmost variable with  smallest domain
         next, in order to detect infeasibility early.  This  is often a
         good strategy.

    ffffcc
         Of  the  variables with  smallest  domains,  the  leftmost  one
         participating in most constraints is labeled next.

    mmiinn
         Label the  leftmost variable  whose lower bound  is the  lowest
         next.

    mmaaxx
         Label the leftmost  variable whose upper  bound is the  highest
         next.

    The value order is one of:

    uupp
         Try the elements of  the chosen variable's domain in  ascending
         order.  This is the default.

    ddoowwnn
         Try the domain elements in descending order.

    The branching strategy is one of:

    sstteepp
         For each variable X, a  choice is made between X = V and  X #\=
         V, where V is determined  by the value ordering options.   This
         is the default.

    eennuumm
         For each variable X, a  choice is made between X = V_1, X = V_2
         etc.,  for all  values V_i  of  the domain  of X.  The order  is
         determined by the value ordering options.

    bbiisseecctt
         For each variable X, a choice is made between X #=< M  and X #>
         M, where M is the midpoint of the domain of X.

    At most one option  of each category can be specified, and an option
    must not occur repeatedly.

    The order of solutions can be influenced with:

      o  min(Expr)

      o  max(Expr)

    This generates  solutions in ascending/descending order with respect
    to the evaluation  of the arithmetic expression Expr.  Labeling _V_a_r_s
    must make Expr ground.   If several such options are specified, they
    are interpreted from left to right, e.g.:

    ____________________________________________________________________|                                                                    |
    ||?-_[X,Y]_ins_10..20,_labeling([max(X),min(Y)],[X,Y])._____________ ||

    This  generates solutions  in descending  order of X,  and for  each
    binding  of X, solutions are generated  in ascending order of Y.  To
    obtain  the incomplete  behaviour  that other  systems exhibit  with
    "maximize(Expr)" and "minimize(Expr)", use once/1, e.g.:

    ____________________________________________________________________|                                                                    |

    ||once(labeling([max(Expr)],_Vars))_________________________________ ||

    Labeling  is  always  complete,  always terminates,  and  yields  no
    redundant solutions.


aallll__ddiiffffeerreenntt((_+_V_a_r_s))
    _V_a_r_s are pairwise distinct.


aallll__ddiissttiinncctt((_+_L_s))
    Like  all_different/1,  with stronger  propagation.    For  example,
    all_distinct/1  can  detect  that  not  all   variables  can  assume
    distinct values given the following domains:

    ____________________________________________________________________|                                                                    |
    | ?- maplist(in, Vs,                                                 |

    |            [1\/3..4, 1..2\/4, 1..2\/4, 1..3, 1..3, 1..6]),         |
    |    all_distinct(Vs).                                               |
    ||false.____________________________________________________________ ||


ssuumm((_+_V_a_r_s_, _+_R_e_l_, _?_E_x_p_r))
    The  sum of elements of  the list _V_a_r_s is  in relation _R_e_l to  _E_x_p_r.
    _R_e_l is one of #=, #\=, #<, #>, #=<  or #>=.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- [A,B,C] ins 0..sup, sum([A,B,C], #=, 100).                      |

    | A in 0..100,                                                       |
    | A+B+C#=100,                                                        |
    | B in 0..100,                                                       |
    ||C_in_0..100.______________________________________________________ ||


ssccaallaarr__pprroodduucctt((_+_C_s_, _+_V_s_, _+_R_e_l_, _?_E_x_p_r))
    True  iff the  scalar product of  _C_s and  _V_s is in  relation _R_e_l  to
    _E_x_p_r.   _C_s  is a list  of integers,  _V_s is a  list of variables  and
    integers.  _R_e_l is #=, #\=, #<, #>, #=<  or #>=.


_?_X #>= _?_Y
    _X is greater than or equal to _Y.


_?_X #=< _?_Y
    _X is less than or equal to _Y.


_?_X #= _?_Y
    _X equals _Y.


_?_X #\= _?_Y
    _X is not _Y.


_?_X #> _?_Y
    _X is greater than _Y.


_?_X #< _?_Y
    _X  is  less than  _Y. In  addition  to its  regular use  in  problems
    that  require it, this  constraint can also  be useful to  eliminate
    uninteresting symmetries from  a problem.  For example, all possible
    matches between pairs built from four players in total:

    ____________________________________________________________________|                                                                    |
    | ?- Vs = [A,B,C,D], Vs ins 1..4,                                    |

    |         all_different(Vs),                                         |
    |         A #< B, C #< D, A #< C,                                    |
    |    findall(pair(A,B)-pair(C,D), label(Vs), Ms).                    |
    | Ms = [ pair(1, 2)-pair(3, 4),                                      |
    |        pair(1, 3)-pair(2, 4),                                      |
    ||_______pair(1,_4)-pair(2,_3)].____________________________________ ||


#\ _+_Q
    The  reifiable constraint _Q does _n_o_t  hold.  For example,  to obtain
    the complement of a domain:

    ____________________________________________________________________|                                                                    |
    | ?- #\ X in -3..0\/10..80.                                          |

    ||X_in_inf.._-4\/1..9\/81..sup._____________________________________ ||


_?_P #<==> _?_Q
    _P and _Q are equivalent.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- X #= 4 #<==> B, X #\= 4.                                        |

    | B = 0,                                                             |
    ||X_in_inf..3\/5..sup.______________________________________________ ||

    The  following example uses reified constraints to relate a  list of
    finite  domain variables  to the  number of occurrences  of a  given
    value:

    ____________________________________________________________________|                                                                    |

    | :- use_module(library(clpfd)).                                     |
    |                                                                    |
    | vs_n_num(Vs, N, Num) :-                                            |
    |         maplist(eq_b(N), Vs, Bs),                                  |
    |         sum(Bs, #=, Num).                                          |
    |                                                                    |

    ||eq_b(X,_Y,_B)_:-_X_#=_Y_#<==>_B.__________________________________ ||

    Sample queries and their results:

    ____________________________________________________________________|                                                                    |
    | ?- Vs = [X,Y,Z], Vs ins 0..1, vs_n_num(Vs, 4, Num).                |
    | Vs = [X, Y, Z],                                                    |
    | Num = 0,                                                           |
    | X in 0..1,                                                         |

    | Y in 0..1,                                                         |
    | Z in 0..1.                                                         |
    |                                                                    |
    | ?- vs_n_num([X,Y,Z], 2, 3).                                        |
    | X = 2,                                                             |
    | Y = 2,                                                             |
    ||Z_=_2.____________________________________________________________ ||


_?_P #==> _?_Q
    _P implies _Q.


_?_P #<== _?_Q
    _Q implies _P.


_?_P #/\ _?_Q
    _P and _Q hold.


_?_P #\/ _?_Q
    _P  or _Q holds.  For  example, the sum of natural numbers  below 1000
    that are multiples of 3 or 5:

    ____________________________________________________________________|                                                                    |
    | ?- findall(N, (N mod 3 #= 0 #\/ N mod 5 #= 0, N in 0..999,         |

    |                indomain(N)),                                       |
    |            Ns),                                                    |
    |    sum(Ns, #=, Sum).                                               |
    | Ns = [0, 3, 5, 6, 9, 10, 12, 15, 18|...],                          |
    ||Sum_=_233168._____________________________________________________ ||


_?_P #\ _?_Q
    Either _P holds or _Q holds, but not both.


lleexx__cchhaaiinn((_+_L_i_s_t_s))
    _L_i_s_t_s are lexicographically non-decreasing.


ttuupplleess__iinn((_+_T_u_p_l_e_s_, _+_R_e_l_a_t_i_o_n))
    True  iff all  _T_u_p_l_e_s are  elements of _R_e_l_a_t_i_o_n.    Each element  of
    the  list _T_u_p_l_e_s is a list  of integers or finite domain  variables.
    _R_e_l_a_t_i_o_n  is  a  list  of  lists of  integers.     Arbitrary  finite
    relations,  such as  compatibility tables,  can be  modeled in  this
    way.    For example,  if 1  is compatible  with 2  and 5,  and 4  is
    compatible with 0 and 3:

    ____________________________________________________________________|                                                                    |
    | ?- tuples_in([[X,Y]], [[1,2],[1,5],[4,0],[4,3]]), X = 4.           |

    | X = 4,                                                             |
    ||Y_in_0\/3.________________________________________________________ ||

    As another example,  consider a train schedule represented as a list
    of  quadruples, denoting departure and arrival places and  times for
    each  train.   In the  following program, Ps  is a feasible  journey
    of  length 3  from A  to D  via trains that  are part  of the  given
    schedule.

    ____________________________________________________________________|                                                                    |

    | :- use_module(library(clpfd)).                                     |
    |                                                                    |
    | trains([[1,2,0,1],                                                 |
    |         [2,3,4,5],                                                 |
    |         [2,3,0,1],                                                 |
    |         [3,4,5,6],                                                 |

    |         [3,4,2,3],                                                 |
    |         [3,4,8,9]]).                                               |
    |                                                                    |
    | threepath(A, D, Ps) :-                                             |
    |         Ps = [[A,B,_T0,T1],[B,C,T2,T3],[C,D,T4,_T5]],              |
    |         T2 #> T1,                                                  |
    |         T4 #> T3,                                                  |

    |         trains(Ts),                                                |
    ||________tuples_in(Ps,_Ts).________________________________________ ||

    In this example, the unique solution is found without labeling:

    ____________________________________________________________________|                                                                    |
    | ?- threepath(1, 4, Ps).                                            |
    ||Ps_=_[[1,_2,_0,_1],_[2,_3,_4,_5],_[3,_4,_8,_9]].__________________ ||


sseerriiaalliizzeedd((_+_S_t_a_r_t_s_, _+_D_u_r_a_t_i_o_n_s))
    Describes  a set of non-overlapping  tasks.  _S_t_a_r_t_s  = [S_1,...,S_n],
    is  a list of variables  or integers, _D_u_r_a_t_i_o_n_s =  [D_1,...,D_n] is  a
    list  of non-negative integers.  Constrains _S_t_a_r_t_s and  _D_u_r_a_t_i_o_n_s to
    denote a  set of non-overlapping tasks, i.e.:  S_i + D_i =< S_j or S_j
    + D_j =< S_i for all 1 =< i < j =< n.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- length(Vs, 3),                                                  |

    |    Vs ins 0..3,                                                    |
    |    serialized(Vs, [1,2,3]),                                        |
    |    label(Vs).                                                      |
    | Vs = [0, 1, 3] ;                                                   |
    | Vs = [2, 0, 3] ;                                                   |
    ||false.____________________________________________________________ ||

         SSeeee aallssoo Dorndorf  et al.   2000,  "Constraint Propagation
             Techniques for the Disjunctive Scheduling Problem"


eelleemmeenntt((_?_N_, _+_V_s_, _?_V))
    The  _N-th element of  the list of finite  domain variables _V_s is  _V.
    Analogous to nth1/3.


gglloobbaall__ccaarrddiinnaalliittyy((_+_V_s_, _+_P_a_i_r_s))
    Global     Cardinality     constraint.             Equivalent     to
    global_cardinality(Vs, Pairs, []).  Example:

    ____________________________________________________________________|                                                                    |
    | ?- Vs = [_,_,_], global_cardinality(Vs, [1-2,3-_]), label(Vs).     |

    | Vs = [1, 1, 3] ;                                                   |
    | Vs = [1, 3, 1] ;                                                   |
    ||Vs_=_[3,_1,_1].___________________________________________________ ||


gglloobbaall__ccaarrddiinnaalliittyy((_+_V_s_, _+_P_a_i_r_s_, _+_O_p_t_i_o_n_s))
    Global  Cardinality  constraint.   _V_s  is a  list  of finite  domain
    variables,  _P_a_i_r_s  is a  list  of Key-Num  pairs,  where Key  is  an
    integer  and Num is a finite domain variable.  The  constraint holds
    iff each V in _V_s  is equal to some key, and for each Key-Num pair in
    _P_a_i_r_s, the number of  occurrences of Key in _V_s is Num.  _O_p_t_i_o_n_s is a
    list of options.  Supported options are:

    ccoonnssiisstteennccyy((_v_a_l_u_e))
         A weaker form of consistency is used.

    ccoosstt((_C_o_s_t_, _M_a_t_r_i_x))
         _M_a_t_r_i_x is a list of  rows, one for each variable, in  the order
         they occur in _V_s.   Each of these  rows is a list of  integers,
         one for  each key,  in  the order  these keys  occur in  _P_a_i_r_s.
         When variable  v_i is  assigned the value  of key  k_j, then  the
         associated cost is _M_a_t_r_i_x__{ij}.  _C_o_s_t is the sum of all costs.


cciirrccuuiitt((_+_V_s))
    True  iff  the   list  _V_s  of  finite  domain  variables  induces  a
    Hamiltonian  circuit.  The k-th element of _V_s denotes  the successor
    of node k.  Node indexing starts with 1.  Examples:

    ____________________________________________________________________|                                                                    |
    | ?- length(Vs, _), circuit(Vs), label(Vs).                          |

    | Vs = [] ;                                                          |
    | Vs = [1] ;                                                         |
    | Vs = [2, 1] ;                                                      |
    | Vs = [2, 3, 1] ;                                                   |
    | Vs = [3, 1, 2] ;                                                   |
    ||Vs_=_[2,_3,_4,_1]_._______________________________________________ ||


ccuummuullaattiivvee((_+_T_a_s_k_s))
    Equivalent to cumulative(Tasks, [limit(1)]).


ccuummuullaattiivvee((_+_T_a_s_k_s_, _+_O_p_t_i_o_n_s))
    Schedule  with  a limited  resource.    _T_a_s_k_s is  a list  of  tasks,
    each  of the  form task(S_i, D_i, E_i, C_i, T_i).   S_i denotes  the
    start  time, D_i the  positive duration,  E_i the  end time,  C_i  the
    non-negative  resource  consumption,  and T_i the  task  identifier.
    Each  of  these arguments  must  be a  finite domain  variable  with
    bounded  domain, or an  integer.  The  constraint holds iff at  each
    time slot during the  start and end of each task, the total resource
    consumption  of all tasks running at  that time does not exceed  the
    global  resource limit.  _O_p_t_i_o_n_s is  a list of options.   Currently,
    the only supported option is:

    lliimmiitt((_L))
         The integer _L is the global resource limit.  Default is 1.

    For example, given  the following predicate that relates three tasks
    of durations 2 and 3 to a list containing their starting times:

    ____________________________________________________________________|                                                                    |

    | tasks_starts(Tasks, [S1,S2,S3]) :-                                 |
    |         Tasks = [task(S1,3,_,1,_),                                 |
    |                  task(S2,2,_,1,_),                                 |
    ||_________________task(S3,2,_,1,_)]._______________________________ ||

    We can use cumulative/2 as follows, and obtain a schedule:

    ____________________________________________________________________|                                                                    |

    | ?- tasks_starts(Tasks, Starts), Starts ins 0..10,                  |
    |    cumulative(Tasks, [limit(2)]), label(Starts).                   |
    | Tasks = [task(0, 3, 3, 1, _G36), task(0, 2, 2, 1, _G45), ...],     |
    ||Starts_=_[0,_0,_2]_.______________________________________________ ||


ddiissjjooiinntt22((_+_R_e_c_t_a_n_g_l_e_s))
    True  iff _R_e_c_t_a_n_g_l_e_s are not overlapping.   _R_e_c_t_a_n_g_l_e_s is a list  of
    terms  of the form F(X_i, W_i, Y_i, H_i), where F is any  functor, and
    the  arguments are finite domain variables or integers  that denote,
    respectively,  the X coordinate, width,  Y coordinate and height  of
    each rectangle.


aauuttoommaattoonn((_+_S_i_g_n_a_t_u_r_e_, _+_N_o_d_e_s_, _+_A_r_c_s))
    Describes     a      list     of     finite     domain     variables
    with     a      finite     automaton.              Equivalent     to
    automaton(_, _, Signature, Nodes, Arcs, [], [], _),     a     common
    use  case of  automaton/8.   In  the  following example,  a list  of
    binary  finite domain variables is  constrained to contain at  least
    two consecutive ones:

    ____________________________________________________________________|                                                                    |
    | :- use_module(library(clpfd)).                                     |
    |                                                                    |
    | two_consecutive_ones(Vs) :-                                        |

    |         automaton(Vs, [source(a),sink(c)],                         |
    |                   [arc(a,0,a), arc(a,1,b),                         |
    |                    arc(b,0,a), arc(b,1,c),                         |
    ||___________________arc(c,0,c),_arc(c,1,c)]).______________________ ||

    Example query:

    ____________________________________________________________________|                                                                    |
    | ?- length(Vs, 3), two_consecutive_ones(Vs), label(Vs).             |
    | Vs = [0, 1, 1] ;                                                   |

    | Vs = [1, 1, 0] ;                                                   |
    ||Vs_=_[1,_1,_1].___________________________________________________ ||


aauuttoommaattoonn((_?_S_e_q_u_e_n_c_e_, _?_T_e_m_p_l_a_t_e_, _+_S_i_g_n_a_t_u_r_e_, _+_N_o_d_e_s_, _+_A_r_c_s_, _+_C_o_u_n_t_e_r_s_, _+_I_n_i_t_i_a_l_s_, _?_F_i_n_a_l_s))
    Describes   a  list  of  finite  domain  variables  with   a  finite
    automaton.    True iff  the finite  automaton induced  by _N_o_d_e_s  and
    _A_r_c_s  (extended with  _C_o_u_n_t_e_r_s) accepts  _S_i_g_n_a_t_u_r_e.   _S_e_q_u_e_n_c_e is  a
    list  of  terms, all  of the  same shape.    Additional  constraints
    must  link  _S_e_q_u_e_n_c_e  to  _S_i_g_n_a_t_u_r_e,  if  necessary.    _N_o_d_e_s  is  a
    list  of source(Node)  and  sink(Node) terms.    _A_r_c_s is  a list  of
    arc(Node,Integer,Node)  and arc(Node,Integer,Node,Exprs) terms  that
    denote  the  automaton's  transitions.    Each node  is  represented
    by  an  arbitrary term.    Transitions  that  are not  mentioned  go
    to  an  implicit failure  node.    _E_x_p_r_s  is  a list  of  arithmetic
    expressions,  of the same length as  _C_o_u_n_t_e_r_s.  In each  expression,
    variables  occurring in _C_o_u_n_t_e_r_s  correspond to old counter  values,
    and  variables  occurring  in  _T_e_m_p_l_a_t_e correspond  to  the  current
    element  of _S_e_q_u_e_n_c_e.   When a transition containing expressions  is
    taken,  each  counter is  updated as  stated by  the  result of  the
    corresponding  arithmetic expression.   By default, counters  remain
    unchanged.   _C_o_u_n_t_e_r_s  is a  list of variables  that must not  occur
    anywhere  outside of the  constraint goal.   _I_n_i_t_i_a_l_s  is a list  of
    the same length  as _C_o_u_n_t_e_r_s.  Counter arithmetic on the transitions
    relates the counter values in _I_n_i_t_i_a_l_s to _F_i_n_a_l_s.

    The  following example is taken from Beldiceanu,  Carlsson, Debruyne
    and   Petit:    "Reformulation   of  Global  Constraints  Based   on
    Constraints  Checkers", Constraints  10(4), pp 339-362  (2005).   It
    relates  a sequence of integers  and finite domain variables to  its
    number of inflexions,  which are switches between strictly ascending
    and strictly descending subsequences:

    ____________________________________________________________________|                                                                    |
    | :- use_module(library(clpfd)).                                     |

    |                                                                    |
    | sequence_inflexions(Vs, N) :-                                      |
    |         variables_signature(Vs, Sigs),                             |
    |         automaton(_, _, Sigs,                                      |
    |                   [source(s),sink(i),sink(j),sink(s)],             |
    |                   [arc(s,0,s), arc(s,1,j), arc(s,2,i),             |
    |                    arc(i,0,i), arc(i,1,j,[C+1]), arc(i,2,i),       |
    |                    arc(j,0,j), arc(j,1,j),                         |

    |                    arc(j,2,i,[C+1])],                              |
    |                   [C], [0], [N]).                                  |
    |                                                                    |
    | variables_signature([], []).                                       |
    | variables_signature([V|Vs], Sigs) :-                               |
    |         variables_signature_(Vs, V, Sigs).                         |
    |                                                                    |

    | variables_signature_([], _, []).                                   |
    | variables_signature_([V|Vs], Prev, [S|Sigs]) :-                    |
    |         V #= Prev #<==> S #= 0,                                    |
    |         Prev #< V #<==> S #= 1,                                    |
    |         Prev #> V #<==> S #= 2,                                    |
    ||________variables_signature_(Vs,_V,_Sigs).________________________ ||

    Example queries:

    ____________________________________________________________________|                                                                    |

    | ?- sequence_inflexions([1,2,3,3,2,1,3,0], N).                      |
    | N = 3.                                                             |
    |                                                                    |
    | ?- length(Ls, 5), Ls ins 0..1,                                     |
    |    sequence_inflexions(Ls, 3), label(Ls).                          |
    | Ls = [0, 1, 0, 1, 0] ;                                             |
    ||Ls_=_[1,_0,_1,_0,_1]._____________________________________________ ||


ttrraannssppoossee((_+_M_a_t_r_i_x_, _?_T_r_a_n_s_p_o_s_e))
    _T_r_a_n_s_p_o_s_e a list of lists of the same length.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- transpose([[1,2,3],[4,5,6],[7,8,9]], Ts).                       |

    ||Ts_=_[[1,_4,_7],_[2,_5,_8],_[3,_6,_9]].___________________________ ||

    This predicate is  useful in many constraint programs.  Consider for
    instance Sudoku:

    ____________________________________________________________________|                                                                    |

    | :- use_module(library(clpfd)).                                     |
    |                                                                    |
    | sudoku(Rows) :-                                                    |
    |         length(Rows, 9), maplist(same_length(Rows), Rows),         |
    |         append(Rows, Vs), Vs ins 1..9,                             |
    |         maplist(all_distinct, Rows),                               |
    |         transpose(Rows, Columns),                                  |

    |         maplist(all_distinct, Columns),                            |
    |         Rows = [A,B,C,D,E,F,G,H,I],                                |
    |         blocks(A, B, C), blocks(D, E, F), blocks(G, H, I).         |
    |                                                                    |
    | blocks([], [], []).                                                |
    | blocks([A,B,C|Bs1], [D,E,F|Bs2], [G,H,I|Bs3]) :-                   |
    |         all_distinct([A,B,C,D,E,F,G,H,I]),                         |

    |         blocks(Bs1, Bs2, Bs3).                                     |
    |                                                                    |
    | problem(1, [[_,_,_,_,_,_,_,_,_],                                   |
    |             [_,_,_,_,_,3,_,8,5],                                   |
    |             [_,_,1,_,2,_,_,_,_],                                   |
    |             [_,_,_,5,_,7,_,_,_],                                   |
    |             [_,_,4,_,_,_,1,_,_],                                   |
    |             [_,9,_,_,_,_,_,_,_],                                   |

    |             [5,_,_,_,_,_,_,7,3],                                   |
    |             [_,_,2,_,1,_,_,_,_],                                   |
    ||____________[_,_,_,_,4,_,_,_,9]]).________________________________ ||

    Sample query:

    ____________________________________________________________________|                                                                    |
    | ?- problem(1, Rows), sudoku(Rows), maplist(writeln, Rows).         |
    | [9,8,7,6,5,4,3,2,1]                                                |

    | [2,4,6,1,7,3,9,8,5]                                                |
    | [3,5,1,9,2,8,7,4,6]                                                |
    | [1,2,8,5,3,7,6,9,4]                                                |
    | [6,3,4,8,9,2,1,5,7]                                                |
    | [7,9,5,4,6,1,8,3,2]                                                |
    | [5,1,9,2,8,6,4,7,3]                                                |
    | [4,7,2,3,1,9,5,6,8]                                                |
    | [8,6,3,7,4,5,2,1,9]                                                |

    ||Rows_=_[[9,_8,_7,_6,_5,_4,_3,_2|...],_..._,_[...|...]].___________ ||


zzccoommppaarree((_?_O_r_d_e_r_, _?_A_, _?_B))
    Analogous  to  compare/3,  with finite  domain  variables _A  and  _B.
    Example:

    ____________________________________________________________________|                                                                    |
    | :- use_module(library(clpfd)).                                     |

    |                                                                    |
    | n_factorial(N, F) :-                                               |
    |         zcompare(C, N, 0),                                         |
    |         n_factorial_(C, N, F).                                     |
    |                                                                    |
    | n_factorial_(=, _, 1).                                             |
    | n_factorial_(>, N, F) :-                                           |
    |         F #= F0*N, N1 #= N - 1,                                    |

    ||________n_factorial(N1,_F0).______________________________________ ||

    This   version   is  deterministic   if   the  first   argument   is
    instantiated:

    ____________________________________________________________________|                                                                    |

    | ?- n_factorial(30, F).                                             |
    ||F_=_265252859812191058636308480000000.____________________________ ||


cchhaaiinn((_+_Z_s_, _+_R_e_l_a_t_i_o_n))
    _Z_s  form a chain with respect to _R_e_l_a_t_i_o_n.   _Z_s is a list  of finite
    domain variables that  are a chain with respect to the partial order
    _R_e_l_a_t_i_o_n,  in the order they appear in  the list.  _R_e_l_a_t_i_o_n  must be
    #=, #=<, #>=, #<  or #>.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- chain([X,Y,Z], #>=).                                            |

    | X#>=Y,                                                             |
    ||Y#>=Z.____________________________________________________________ ||


ffdd__vvaarr((_+_V_a_r))
    True iff _V_a_r is a CLP(FD) variable.


ffdd__iinnff((_+_V_a_r_, _-_I_n_f))
    _I_n_f is the infimum of the current domain of _V_a_r.


ffdd__ssuupp((_+_V_a_r_, _-_S_u_p))
    _S_u_p is the supremum of the current domain of _V_a_r.


ffdd__ssiizzee((_+_V_a_r_, _-_S_i_z_e))
    _S_i_z_e is the number  of elements of the current domain of _V_a_r, or the
    atom ssuupp if the domain is unbounded.


ffdd__ddoomm((_+_V_a_r_, _-_D_o_m))
    _D_o_m  is the current  domain (see in/2)  of _V_a_r.   This predicate  is
    useful  if you  want to  reason about  domains.   It  is _n_o_t  needed
    if  you only want  to display remaining  domains; instead,  separate
    your  model from the search part  and let the toplevel display  this
    information via residual goals.

    For  example, to implement a custom labeling strategy, you  may need
    to  inspect the current  domain of a finite  domain variable.   With
    the  following code, you  can convert a _f_i_n_i_t_e  domain to a list  of
    integers:

    ____________________________________________________________________|                                                                    |
    | dom_integers(D, Is) :- phrase(dom_integers_(D), Is).               |

    |                                                                    |
    | dom_integers_(I)      --> { integer(I) }, [I].                     |
    | dom_integers_(L..U)   --> { numlist(L, U, Is) }, Is.               |
    ||dom_integers_(D1\/D2)_-->_dom_integers_(D1),_dom_integers_(D2).___ ||

    Example:

    ____________________________________________________________________|                                                                    |
    | ?- X in 1..5, X #\= 4, fd_dom(X, D), dom_integers(D, Is).          |
    | D = 1..3\/5,                                                       |

    | Is = [1,2,3,5],                                                    |
    ||X_in_1..3\/5._____________________________________________________ ||


1122..99 lliibbrraarryy((ccllppqqrr))::   CCoonnssttrraaiinntt LLooggiicc  PPrrooggrraammmmiinngg oovveerr RRaattiioonnaallss  aanndd
     RReeaallss

    Author:   _C_h_r_i_s_t_i_a_n _H_o_l_z_b_a_u_r, ported to SWI-Prolog by _L_e_s_l_i_e _D_e
    _K_o_n_i_n_c_k, K.U. Leuven

This CLP(Q,R) system is a port of the CLP(Q,R)  system of Sicstus Prolog
by Christian  Holzbaur:   Holzbaur C.:   OFAI  clp(q,r) Manual,  Edition
1.3.3, Austrian Research Institute for Artificial  Intelligence, Vienna,
TR-95-09,  1995.   This manual  is roughly  based on the  manual of  the
above mentioned CLP(Q,R) implementation.

The CLP(Q,R) system consists of two components:  the  CLP(Q) library for
handling constraints  over the rational numbers  and the CLP(R)  library
for handling  constraints over  the real numbers  (using floating  point
numbers as  representation).  Both  libraries offer the same  predicates
(with exception  of bb_inf/4 in  CLP(Q) and bb_inf/5  in CLP(R)). It  is
allowed to use both libraries in one program, but  using both CLP(Q) and
CLP(R) constraints on the same variable will result in an exception.

Please  note that  the clpqr  library  is _n_o_t  an _a_u_t_o_l_o_a_d  library  and
therefore this library must be loaded explicitly before using it:

________________________________________________________________________|                                                                        |

|:-|use_module(library(clpq)).__________________________________________ |  |

or

________________________________________________________________________|                                                                        |

|:-|use_module(library(clpr)).__________________________________________ |  |


1122..99..11 SSoollvveerr pprreeddiiccaatteess

The following predicates are provided to work with constraints:


{}((_+_C_o_n_s_t_r_a_i_n_t_s))
    Adds the constraints given by _C_o_n_s_t_r_a_i_n_t_s to the constraint store.


eennttaaiilleedd((_+_C_o_n_s_t_r_a_i_n_t))
    Succeeds  if  _C_o_n_s_t_r_a_i_n_t  is  necessarily true  within  the  current
    constraint  store.    This means  that adding  the  negation of  the
    constraint to the store results in failure.


iinnff((_+_E_x_p_r_e_s_s_i_o_n_, _-_I_n_f))
    Computes  the infimum of _E_x_p_r_e_s_s_i_o_n within the current state  of the
    constraint  store and returns that infimum  in _I_n_f.  This  predicate
    does not change the constraint store.


ssuupp((_+_E_x_p_r_e_s_s_i_o_n_, _-_S_u_p))
    Computes the supremum  of _E_x_p_r_e_s_s_i_o_n within the current state of the
    constraint  store and returns that supremum in _S_u_p.   This predicate
    does not change the constraint store.


mmiinniimmiizzee((_+_E_x_p_r_e_s_s_i_o_n))
    Minimizes  _E_x_p_r_e_s_s_i_o_n within the current constraint store.   This is
    the  same as computing  the infimum and  equating the expression  to
    that infimum.


mmaaxxiimmiizzee((_+_E_x_p_r_e_s_s_i_o_n))
    Maximizes  _E_x_p_r_e_s_s_i_o_n within the current constraint store.   This is
    the  same as computing the  supremum and equating the expression  to
    that supremum.


bbbb__iinnff((_+_I_n_t_s_, _+_E_x_p_r_e_s_s_i_o_n_, _-_I_n_f_, _-_V_e_r_t_e_x_, _+_E_p_s))
    This  predicate  is  offered  in  CLP(R) only.     It  computes  the
    infimum of _E_x_p_r_e_s_s_i_o_n  within the current constraint store, with the
    additional  constraint that in that  infimum, all variables in  _I_n_t_s
    have  integral values.   _V_e_r_t_e_x will contain  the values of _I_n_t_s  in
    the  infimum.   _E_p_s  denotes how  much a  value may  differ from  an
    integer to be considered  an integer.  E.g. when _E_p_s = 0.001, then X
    =  4.999 will be  considered as an  integer (5 in this  case).   _E_p_s
    should be between 0 and 0.5.


bbbb__iinnff((_+_I_n_t_s_, _+_E_x_p_r_e_s_s_i_o_n_, _-_I_n_f_, _-_V_e_r_t_e_x))
    This  predicate is offered in CLP(Q) only.   It behaves the  same as
    bb_inf/5 but does not use an error margin.


bbbb__iinnff((_+_I_n_t_s_, _+_E_x_p_r_e_s_s_i_o_n_, _-_I_n_f))
    The  same as bb_inf/5 or  bb_inf/4 but without returning the  values
    of the integers.  In CLP(R), an error margin of 0.001 is used.


dduummpp((_+_T_a_r_g_e_t_, _+_N_e_w_v_a_r_s_, _-_C_o_d_e_d_A_n_s_w_e_r))
    Returns the constraints  on _T_a_r_g_e_t in the list _C_o_d_e_d_A_n_s_w_e_r where all
    variables  of _T_a_r_g_e_t have been replaced by _N_e_w_V_a_r_s.   This operation
    does not change the constraint store.  E.g. in

    ____________________________________________________________________|                                                                    |
    ||dump([X,Y,Z],[x,y,z],Cons)________________________________________ ||

    Cons  will  contain the  constraints  on X,  Y  and Z,  where  these
    variables have been replaced by atoms x, y and z.


1122..99..22 SSyynnttaaxx ooff tthhee pprreeddiiccaattee aarrgguummeennttss

The arguments  of the  predicates defined  in the  subsection above  are
defined in table 12.1.  Failing to meet the syntax  rules will result in
an exception.
 _______________________________________________________________________
 | <_C_o_n_s_t_r_a_i_n_t_s>::=  <_C_o_n_s_t_r_a_i_n_t>                   |single constraint |
 |                 | <_C_o_n_s_t_r_a_i_n_t> , <_C_o_n_s_t_r_a_i_n_t_s>    |conjunction       |
 |                 | <_C_o_n_s_t_r_a_i_n_t> ; <_C_o_n_s_t_r_a_i_n_t_s>    |disjunction       |
 | <_C_o_n_s_t_r_a_i_n_t> ::=  <_E_x_p_r_e_s_s_i_o_n> < <_E_x_p_r_e_s_s_i_o_n>     |less than         |
 |                 | <_E_x_p_r_e_s_s_i_o_n> > <_E_x_p_r_e_s_s_i_o_n>     |greater than      |

 |                 | <_E_x_p_r_e_s_s_i_o_n> =< <_E_x_p_r_e_s_s_i_o_n>    |less or equal     |
 |                 | <=(<_E_x_p_r_e_s_s_i_o_n>, <_E_x_p_r_e_s_s_i_o_n>)  |less or equal     |
 |                 | <_E_x_p_r_e_s_s_i_o_n> >= <_E_x_p_r_e_s_s_i_o_n>    |greater or equal  |
 |                 | <_E_x_p_r_e_s_s_i_o_n> =\= <_E_x_p_r_e_s_s_i_o_n>   |not equal         |
 |                 | <_E_x_p_r_e_s_s_i_o_n> =:= <_E_x_p_r_e_s_s_i_o_n>   |equal             |
 |                 | <_E_x_p_r_e_s_s_i_o_n> = <_E_x_p_r_e_s_s_i_o_n>     |equal             |
 | <_E_x_p_r_e_s_s_i_o_n> ::=  <_V_a_r_i_a_b_l_e>                     |Prolog variable   |
 |                 | <_N_u_m_b_e_r>                       |Prolog number     |

 |                 | +<_E_x_p_r_e_s_s_i_o_n>                  |unary plus        |
 |                 | -<_E_x_p_r_e_s_s_i_o_n>                  |unary minus       |
 |                 | <_E_x_p_r_e_s_s_i_o_n> + <_E_x_p_r_e_s_s_i_o_n>     |addition          |
 |                 | <_E_x_p_r_e_s_s_i_o_n> - <_E_x_p_r_e_s_s_i_o_n>     |substraction      |
 |                 | <_E_x_p_r_e_s_s_i_o_n> * <_E_x_p_r_e_s_s_i_o_n>     |multiplication    |
 |                 | <_E_x_p_r_e_s_s_i_o_n> / <_E_x_p_r_e_s_s_i_o_n>     |division          |
 |                 | abs(<_E_x_p_r_e_s_s_i_o_n>)              |absolute value    |

 |                 | sin(<_E_x_p_r_e_s_s_i_o_n>)              |sine              |
 |                 | cos(<_E_x_p_r_e_s_s_i_o_n>)              |cosine            |
 |                 | tan(<_E_x_p_r_e_s_s_i_o_n>)              |tangent           |
 |                 | exp(<_E_x_p_r_e_s_s_i_o_n>)              |exponent          |
 |                 | pow(<_E_x_p_r_e_s_s_i_o_n>)              |exponent          |
 |                 | <_E_x_p_r_e_s_s_i_o_n> ^ <_E_x_p_r_e_s_s_i_o_n>     |exponent          |
 |                 | min(<_E_x_p_r_e_s_s_i_o_n>, <_E_x_p_r_e_s_s_i_o_n>) |minimum           |
 |_________________|_max(<_E_x_p_r_e_s_s_i_o_n>,_<_E_x_p_r_e_s_s_i_o_n>)_|maximum___________|

                  Table 12.1:  CLP(Q,R) constraint BNF


1122..99..33 UUssee ooff uunniiffiiccaattiioonn

Instead  of using  the {}/1  predicate, you  can also  use the  standard
unification mechanism to store constraints.  The  following code samples
are equivalent:

    ____________________________________________________________________|                                                                    |
  o _U_n_i_f_i_c_a_t_i_o_n_|_w_i_t_h{_aX_v_a_r_i_a_b_l_e=:= Y}                                                          |

    | {X = Y}                                                            |
    ||X_=_Y_____________________________________________________________ ||

    ____________________________________________________________________|                                                                    |
  o _U_n_i_f_i_c_a_t_i_o_n_|_w_i_t_h{_aX_n_u_m_b_e_r=:= 5.0}                                                        |

    | {X = 5.0}                                                          |
    ||X_=_5.0___________________________________________________________ ||


1122..99..44 NNoonn--lliinneeaarr ccoonnssttrraaiinnttss

The CLP(Q,R)  system deals only  passively with non-linear  constraints.
They remain in  a passive state until certain conditions  are satisfied.
These conditions,  which are called the  isolation axioms, are given  in
table 12.2.
     ______________________________________________________________
     | A =B *C     |B or C is ground       |A = 5 *  C or A = B * |
     |             |                       |4                     |
     |              |A  and  (B or  C)  are|20 = 5  * C or 20 = B |
     |______________|ground________________|*_4___________________|_
     | A =B=C      |C is ground            |A = B / 3             |
     |______________|A_and_B_are_ground____|4_=_12_/_C____________|_

     | X =min(Y; Z) |Y and Z are ground    |X = min(4,3)          |
     | X =max(Y; Z) |Y and Z are ground    |X = max(4,3)          |
     |_X_=abs(Y_)___|Y_is_ground___________|X_=_abs(-7)___________|_
     | X =pow(Y; Z) |X and Y are ground    |8 = 2 ^ Z             |
     | X =exp(Y; Z) |X and Z are ground    |8 = Y ^ 3             |
     |_X_=Y__^_Z___|Y_and_Z_are_ground_____|X_=_2_^_3_____________|_
     | X =sin(Y )   X|is ground            |1 = sin(Y)            |

     | X =cos(Y )   Y|is ground            |X = sin(1.5707)       |
     |_X_=tan(Y_)___|______________________|______________________|_
                 Table 12.2:  CLP(Q,R) isolating axioms


1122..99..55 SSttaattuuss aanndd kknnoowwnn pprroobblleemmss

The clpq  and clpr libraries are  `orphaned', i.e., they currently  have
no maintainer.

  o _T_o_p_-_l_e_v_e_l _o_u_t_p_u_t
    The  top-level  output  may contain  variables  not present  in  the
    original query:

    ____________________________________________________________________|                                                                    |

    | ?- {X+Y>=1}.                                                       |
    | {Y=1-X+_G2160, _G2160>=0}.                                         |
    |                                                                    |
    ||?-________________________________________________________________ ||

    Nonetheless,  for  linear  constraints  this kind  of  answer  means
    unconditional satisfiability.

  o _D_u_m_p_i_n_g _c_o_n_s_t_r_a_i_n_t_s
    The  first argument of dump/3 has to be a list of free  variables at
    call-time:

    ____________________________________________________________________|                                                                    |
    | ?- {X=1},dump([X],[Y],L).                                          |
    | ERROR: Unhandled exception: Unknown message:                       |
    |        instantiation_error(dump([1],[_G11],_G6),1)                 |

    ||?-________________________________________________________________ ||


1122..1100 lliibbrraarryy((ccssvv))::  PPrroocceessss CCSSVV ((CCoommmmaa--SSeeppaarraatteedd VVaalluueess)) ddaattaa

    SSeeee aallssoo  RFC 4180

    TToo bbee ddoonnee
         - Implement immediate assert of the data to avoid possible
         stack overflows.
         -  Writing  creates an  intermediate  code-list,  possibly
         overflowing resources.  This waits for pure output!

This library parses and generates CSV data.  CSV  data is represented in
Prolog as a list of  rows.  Each row is a compound term, where  all rows
have the same name and arity.


ccssvv__rreeaadd__ffiillee((_+_F_i_l_e_, _-_R_o_w_s))                                        _[_d_e_t_]


ccssvv__rreeaadd__ffiillee((_+_F_i_l_e_, _-_R_o_w_s_, _+_O_p_t_i_o_n_s))                              _[_d_e_t_]
    Read  a CSV file into  a list of  rows.  Each  row is a Prolog  term
    with  the same  arity.   _O_p_t_i_o_n_s  is handed  to csv//2.    Remaining
    options  are processed by phrase_from_file/3.   The default separator
    depends  on the file name extension and  is \t for .tsv files  and ,
    otherwise.

    Suppose  we want to create a predicate table/6 from a CSV  file that
    we  know contains 6 fields per record.   This can be done  using the
    code  below.   Without the  option arity(6),  this would generate  a
    predicate  table/N, where N  is the number  of fields per record  in
    the data.

    ____________________________________________________________________|                                                                    |
    | ?- csv_read_file(File, Rows, [functor(table), arity(6)]),          |
    ||___maplist(assert,_Rows)._________________________________________ ||


ccssvv((_?_R_o_w_s)) //                                                     _[_d_e_t_]


ccssvv((_?_R_o_w_s_, _+_O_p_t_i_o_n_s)) //                                           _[_d_e_t_]
    Prolog DCG to `read/write' CSV data.  _O_p_t_i_o_n_s:

    sseeppaarraattoorr((_+_C_o_d_e))
         The comma-separator.   Must be  a character code.   Default  is
         (of course) the comma.  Character codes can  be specified using
         the 0' notion.   E.g., using separator(0';) parses  a semicolon
         separated file.

    iiggnnoorree__qquuootteess((_+_B_o_o_l_e_a_n))
         If true  (default  false),  threat double  quotes as  a  normal
         character.

    ssttrriipp((_+_B_o_o_l_e_a_n))
         If  true (default  false),  strip  leading and  trailing  blank
         space.  RFC4180 says that blank space is part of the data.

    ccoonnvveerrtt((_+_B_o_o_l_e_a_n))
         If  true (default),  use  name/2  on  the  field data.     This
         translates the field into a number if possible.

    ffuunnccttoorr((_+_A_t_o_m))
         Functor to use for creating row terms.  Default is row.

    aarriittyy((_?_A_r_i_t_y))
         Number  of fields  in  each  row.    This  predicate  raises  a
         domain_error(row_arity(Expected), Found)  if  a  row  is  found
         with different arity.

    mmaattcchh__aarriittyy((_+_B_o_o_l_e_a_n))
         If false (default  true), do not  reject CSV files where  lines
         provide a varying  number of fields (columns).   This can be  a
         work-around to use some incorrect CSV files.


ccssvv__rreeaadd__ffiillee__rrooww((_+_F_i_l_e_, _-_R_o_w_, _+_O_p_t_i_o_n_s))                         _[_n_o_n_d_e_t_]
    True  when _R_o_w is a row in _F_i_l_e.   First unifies _R_o_w with  the first
    row  in _F_i_l_e.   Backtracking  yields the  second, ...   row.    This
    interface  is an alternative to  csv_read_file/3that avoids  loading
    all  rows in memory.   Note that  this interface does not  guarantee
    that all rows in _F_i_l_e have the same arity.

    In  addition  to  the  options  of csv_read_file/3,  this  predicate
    processes the option:

    lliinnee((_-_L_i_n_e))
         _L_i_n_e is unified with the 1-based line-number from  which _R_o_w is
         read.  Note that _L_i_n_e is not the physical line,  but rather the
         _l_o_g_i_c_a_l record number.

         TToo bbee ddoonnee Input  is  read  line by  line.    If  a record
             separator  is embedded in a quoted  field, parsing the
             record  fails and another line is  added to the input.
             This  does  not  nicely deal  with  other  reasons why
             parsing the row may fail.


ccssvv__wwrriittee__ffiillee((_+_F_i_l_e_, _+_D_a_t_a))                                       _[_d_e_t_]


ccssvv__wwrriittee__ffiillee((_+_F_i_l_e_, _+_D_a_t_a_, _+_O_p_t_i_o_n_s))                             _[_d_e_t_]
    Write  a list  of Prolog terms  to a CSV  file.   _O_p_t_i_o_n_s are  given
    to  csv//2.   Remaining options are  given to open/4.   The  default
    separator  depends on  the file name  extension and  is \t for  .tsv
    files and , otherwise.


ccssvv__wwrriittee__ssttrreeaamm((_+_S_t_r_e_a_m_, _+_D_a_t_a_, _+_O_p_t_i_o_n_s))                         _[_d_e_t_]
    Write   the  rows  in  _D_a_t_a  to   _S_t_r_e_a_m.     This  is  similar   to
    csv_write_file/3,   but  can  deal  with   data  that  is   produced
    incrementally.     The example  below  saves  all answers  from  the
    predicate data/3 to File.

    ____________________________________________________________________|                                                                    |
    | save_data(File) :-                                                 |

    |    setup_call_cleanup(                                             |
    |        open(File, write, Out),                                     |
    |        forall(data(C1,C2,C3),                                      |
    |               csv_write_stream(Out, [row(C1,C2,C3)], [])),         |
    ||_______close(Out)),_______________________________________________ ||


1122..1111 lliibbrraarryy((ddeebbuugg))::  PPrriinntt ddeebbuugg mmeessssaaggeess aanndd tteesstt aasssseerrttiioonnss

    aauutthhoorr  Jan Wielemaker

This library is a replacement for format/3 for  printing debug messages.
Messages are  assigned a _t_o_p_i_c.   By  dynamically enabling or  disabling
topics  the user  can select  desired messages.    Debug statements  are
removed when the code is compiled for optimization.

See manual for details.  With XPCE, you can use  the call below to start
a graphical monitoring tool.

________________________________________________________________________|                                                                        |

|?-|prolog_ide(debug_monitor).__________________________________________ |  |

Using  the predicate  assertion/1 you  can make  assumptions about  your
program explicit, trapping the debugger if the condition does not hold.


ddeebbuuggggiinngg((_+_T_o_p_i_c))                                             _[_s_e_m_i_d_e_t_]


ddeebbuuggggiinngg((_-_T_o_p_i_c))                                              _[_n_o_n_d_e_t_]


ddeebbuuggggiinngg((_?_T_o_p_i_c_, _?_B_o_o_l))                                       _[_n_o_n_d_e_t_]
    Examine  debug topics.   The form  debugging(+Topic) may be used  to
    perform more complex debugging tasks.  A typical usage skeleton is:

    ____________________________________________________________________|                                                                    |
    |       (   debugging(mytopic)                                       |

    |       ->  <perform debugging actions>                              |
    |       ;   true                                                     |
    |       ),                                                           |
    ||______..._________________________________________________________ ||

    The  other two calls  are intended to  examine existing and  enabled
    debugging tokens and are typically not used in user programs.


ddeebbuugg((_+_T_o_p_i_c))                                                     _[_d_e_t_]


nnooddeebbuugg((_+_T_o_p_i_c))                                                   _[_d_e_t_]
    Add/remove  a topic  from  being printed.    nodebug(_) removes  all
    topics.   Gives a warning if  the topic is not defined unless  it is
    used  from a directive.   The latter allows placing debug topics  at
    the start of a (load-)file without warnings.

    For  debug/1, _T_o_p_i_c can be a term _T_o_p_i_c  > Out, where Out is either
    a  stream or  stream-alias or  a filename  (atom).   This  redirects
    debug information on this topic to the given output.


lliisstt__ddeebbuugg__ttooppiiccss                                                  _[_d_e_t_]
    List currently known debug topics and their setting.


ddeebbuugg__mmeessssaaggee__ccoonntteexxtt((_+_W_h_a_t))                                       _[_d_e_t_]
    Specify  additional  context  for  debug  messages.    _W_h_a_t  is  one
    of  +Context  or  -Context,  and  Context is  one  of  thread,  time
    or  time(Format),   where  Format  is  a  format  specification  for
    format_time/3 (default  is %T.%3f).   Initially, debug/3 shows  only
    thread information.


ddeebbuugg((_+_T_o_p_i_c_, _+_F_o_r_m_a_t_, _:_A_r_g_s))                                     _[_d_e_t_]
    _F_o_r_m_a_t a message if  debug topic is enabled.  Similar to format/3 to
    user_error,  but only prints if _T_o_p_i_c is activated  through debug/1.
    _A_r_g_s  is  a  meta-argument to  deal  with  goal for  the  @-command.
    Output  is first handed  to the hook prolog:debug_print_hook/3.   If
    this  fails, _F_o_r_m_a_t+_A_r_g_s  is translated to  text using the  message-
    translation  (see print_message/2) for the term  debug(Format, Args)
    and  then  printed  to  every matching  destination  (controlled  by
    debug/1) using print_message_lines/3.

    The message is preceded by '% ' and terminated with a newline.

         SSeeee aallssoo format/3.


pprroolloogg::ddeebbuugg__pprriinntt__hhooookk((_+_T_o_p_i_c_, _+_F_o_r_m_a_t_, _+_A_r_g_s))      _[_s_e_m_i_d_e_t_,_m_u_l_t_i_f_i_l_e_]
    Hook  called  by debug/3.     This hook  is  used by  the  graphical
    frontend that can be activated using prolog_ide/1:

    ____________________________________________________________________|                                                                    |
    ||?-_prolog_ide(debug_monitor)._____________________________________ ||


aasssseerrttiioonn((_:_G_o_a_l))                                                  _[_d_e_t_]
    Acts  similar  to C  assert()  macro.    It has  no effect  if  _G_o_a_l
    succeeds.    If _G_o_a_l  fails or  throws an  exception, the  following
    steps are taken:

      o  call prolog:assertion_failed/2.   If  prolog:assertion_failed/2
         fails, then:

           {{ If  this  is  an  interactive  toplevel  thread,   print  a
             message, the stack-trace, and finally trap the debugger.

           {{ Otherwise, throw  error(assertion_error(Reason, G),_) where
             Reason is one of fail or the exception raised.


pprroolloogg::aasssseerrttiioonn__ffaaiilleedd((_+_R_e_a_s_o_n_, _+_G_o_a_l))              _[_s_e_m_i_d_e_t_,_m_u_l_t_i_f_i_l_e_]
    This  hook is called if  the _G_o_a_l of assertion/1  fails.  _R_e_a_s_o_n  is
    unified with either  fail if _G_o_a_l simply failed or an exception call
    otherwise.   If this hook fails, the default behaviour is activated.
    If  the hooks  throws an exception  it will  be propagated into  the
    caller of assertion/1.


1122..1122 lliibbrraarryy((ggeennssyymm))::  GGeenneerraattee uunniiqquuee iiddeennttiiffiieerrss

Gensym  (GGeennerate SSyymmbols)  is  an  old library  for  generating  unique
symbols (atoms).    Such symbols are  generated from  a base atom  which
gets a sequence number  appended.  Of course there is no  guarantee that
`catch22'  is not  an already  defined atom  and therefore  one must  be
aware these atoms are only unique in an isolated context.

The SWI-Prolog gensym library is thread-safe.  The  sequence numbers are
global over  all threads and therefore  generated atoms are unique  over
all threads.


ggeennssyymm((_+_B_a_s_e_, _-_U_n_i_q_u_e))
    Generate  a unique  atom from base  _B_a_s_e and  unify it with  _U_n_i_q_u_e.
    _B_a_s_e  should be an  atom.  The  first call will  return <_b_a_s_e>1,  the
    next <_b_a_s_e>2, etc.  Note that this is no guarantee  that the atom is
    unique in the system.


rreesseett__ggeennssyymm((_+_B_a_s_e))
    Restart  generation of identifiers  from _B_a_s_e  at <_B_a_s_e>1.   Used to
    make  sure a program produces  the same results on subsequent  runs.
    Use with care.


rreesseett__ggeennssyymm
    Reset  gensym for all registered keys.  This predicate  is available
    for  compatibility only.  New code is strongly advised to  avoid the
    use  of reset_gensym or at least to reset only the keys  used by your
    program to avoid unexpected side effects on other components.


1122..1133 lliibbrraarryy((iioossttrreeaamm))::  UUttiilliittiieess ttoo ddeeaall wwiitthh ssttrreeaammss

    SSeeee aallssoo  library(archive),   library(process),  library(zlib),
         library(http/http_stream)

This  library  contains  utilities  that  deal  with  streams,   notably
originating from non-built-in  sources such as URLs, archives,  windows,
processes, etc.

The predicate open_any/5 acts as a _b_r_o_k_e_r between applications  that can
process data from  a stream and libraries  that can create streams  from
diverse sources.    Without this predicate,  processing data  inevitally
follows the pattern below.   As _c_a_l_l___s_o_m_e___o_p_e_n___v_a_r_i_a_t_i_o_n can  be anything,
this blocks us from writing predicates such  as load_xml(From, DOM) that
can operate on arbitrary input sources.

________________________________________________________________________|                                                                        |

|setup_call_cleanup(                                                     |
|    call_some_open_variation(Spec, In),                                 |
|    process(In),                                                        |
||___close(In)).________________________________________________________ ||

Libraries   that    can   open    streams   can    install   the    hook
iostream:open_hook/6  to  make  their  functionality  available  through
open_any/5.


ooppeenn__aannyy((_+_S_p_e_c_i_f_i_c_a_t_i_o_n_, _+_M_o_d_e_, _-_S_t_r_e_a_m_, _-_C_l_o_s_e_, _+_O_p_t_i_o_n_s))
    Establish  a stream from _S_p_e_c_i_f_i_c_a_t_i_o_n  that should be closed  using
    _C_l_o_s_e,   which  can either  be  called  or  passed  to  close_any/5.
    _O_p_t_i_o_n_s processed:

    eennccooddiinngg((_E_n_c))
         Set stream to encoding _E_n_c.

    Without  loaded  plugins,  the  open_any/5 processes  the  following
    values for  _S_p_e_c_i_f_i_c_a_t_i_o_n.  If no rule matches, open_any/5 processes
    _S_p_e_c_i_f_i_c_a_t_i_o_n as file(Specification).

    _S_t_r_e_a_m
         A plain  stream  handle.   Possisible  post-processing  options
         such  as encoding  are  applied.    _C_l_o_s_e  does _n_o_t  close  the
         stream, but resets other side-effects such as the encoding.

    ssttrreeaamm((_S_t_r_e_a_m))
         Same as a plain _S_t_r_e_a_m.

    _F_i_l_e_U_R_L
         If _S_p_e_c_i_f_i_c_a_t_i_o_n is  of the form  =file://...=, the pointed  to
         file is  opened  using open/4.    Requires  library(uri) to  be
         installed.

    ffiillee((_P_a_t_h))
         Explicitly open the file _P_a_t_h.  _P_a_t_h can be  an _P_a_t_h(File) term
         as accepted by absolute_file_name/3.

    ssttrriinngg((_S_t_r_i_n_g))
         Open a Prolog string,  atom, list of characters or codes  as an
         _i_n_p_u_t stream.

    The  typical  usage  scenario is  given  in the  code  below,  where
    <process> processes the input.

    ____________________________________________________________________|                                                                    |
    | setup_call_cleanup(                                                |

    |     open_any(Spec, read, In, Close, Options),                      |
    |     <process>(In),                                                 |
    ||____Close)._______________________________________________________ ||

    Currently, the following libraries extend this predicate:

    lliibbrraarryy((_h_t_t_p_/_h_t_t_p___o_p_e_n))
         Adds support for URLs using the http and https schemes.


cclloossee__aannyy((_+_G_o_a_l))
    Execute  the  _C_l_o_s_e closure  returned by  open_any/5.    The  closure
    can  also be called directly.   Using close_any/1 can be  considered
    better style and enhances tractability of the source code.


ooppeenn__hhooookk((_+_S_p_e_c_, _+_M_o_d_e_, _-_S_t_r_e_a_m_, _-_C_l_o_s_e_, _+_O_p_t_i_o_n_s_0_, _-_O_p_t_i_o_n_s))_[_s_e_m_i_d_e_t_,_m_u_l_t_i_f_i_l_e_]
    Open _S_p_e_c in _M_o_d_e, producing _S_t_r_e_a_m.

    ___________________________________________________________Arguments_
     _C_l_o_s_e     is  unified to  a goal  that must  be called  to
               undo  the  side-effects  of  the action,   e.g.,
               typically the term close(Stream)
     _O_p_t_i_o_n_s_0  are the options passed to open_any/5
     _O_p_t_i_o_n_s   are  passed to the post processing filters  that
               may be installed by open_any/5.


1122..1144 lliibbrraarryy((lliissttss))::  LLiisstt MMaanniippuullaattiioonn

    CCoommppaattiibbiilliittyy  Virtually     every     Prolog    system     has
         library(lists),   but  the  set   of  provided  predicates
         is diverse.   There is  a fair agreement  on the semantics
         of most of  these predicates, although  error handling may
         vary.

This  library  provides  commonly accepted  basic  predicates  for  list
manipulation  in   the  Prolog   community.      Some  additional   list
manipulations are built-in.  See e.g., memberchk/2, length/2.

The implementation of  this library is copied  from many places.   These
include:  "The Craft  of Prolog", the DEC-10 Prolog  library (LISTRO.PL)
and the YAP lists  library.  Some predicates are reimplemented  based on
their specification by Quintus and SICStus.


mmeemmbbeerr((_?_E_l_e_m_, _?_L_i_s_t))
    True  if  _E_l_e_m is  a member  of  _L_i_s_t.   The  SWI-Prolog  definition
    differs  from the classical  one.   Our definition avoids  unpacking
    each  list  element  twice  and provides  determinism  on  the  last
    element.  E.g.  this is deterministic:

    ____________________________________________________________________|                                                                    |
    ||____member(X,_[One])._____________________________________________ ||

         aauutthhoorr Gertjan van Noord


aappppeenndd((_?_L_i_s_t_1_, _?_L_i_s_t_2_, _?_L_i_s_t_1_A_n_d_L_i_s_t_2))
    _L_i_s_t_1_A_n_d_L_i_s_t_2 is the concatenation of _L_i_s_t_1 and _L_i_s_t_2


aappppeenndd((_+_L_i_s_t_O_f_L_i_s_t_s_, _?_L_i_s_t))
    Concatenate  a list of lists.   Is true if _L_i_s_t_O_f_L_i_s_t_s is a  list of
    lists, and _L_i_s_t is the concatenation of these lists.

    ___________________________________________________________Arguments_
     _L_i_s_t_O_f_L_i_s_t_s  must be a list of _p_o_s_s_i_b_l_y partial lists


pprreeffiixx((_?_P_a_r_t_, _?_W_h_o_l_e))
    True iff _P_a_r_t is  a leading substring of _W_h_o_l_e.  This is the same as
    append(Part, _, Whole).


sseelleecctt((_?_E_l_e_m_, _?_L_i_s_t_1_, _?_L_i_s_t_2))
    Is true when _L_i_s_t_1, with _E_l_e_m removed, results in _L_i_s_t_2.


sseelleeccttcchhkk((_+_E_l_e_m_, _+_L_i_s_t_, _-_R_e_s_t))                                _[_s_e_m_i_d_e_t_]
    Semi-deterministic  removal of  first element in  _L_i_s_t that  unifies
    with _E_l_e_m.


sseelleecctt((_?_X_, _?_X_L_i_s_t_, _?_Y_, _?_Y_L_i_s_t))                                 _[_n_o_n_d_e_t_]
    Select  from  two lists  at the  same positon.    True  if _X_L_i_s_t  is
    unifiable  with _Y_L_i_s_t apart  a single element  at the same  position
    that  is unified with  _X in _X_L_i_s_t and  with _Y in  _Y_L_i_s_t.  A  typical
    use  for  this predicate  is  to _r_e_p_l_a_c_e  an  element, as  shown  in
    the  example below.    All possible substitutions  are performed  on
    backtracking.

    ____________________________________________________________________|                                                                    |
    | ?- select(b, [a,b,c,b], 2, X).                                     |

    | X = [a, 2, c, b] ;                                                 |
    | X = [a, b, c, 2] ;                                                 |
    ||false.____________________________________________________________ ||

         SSeeee aallssoo selectchk/4 provides a semidet version.


sseelleeccttcchhkk((_?_X_, _?_X_L_i_s_t_, _?_Y_, _?_Y_L_i_s_t))                             _[_s_e_m_i_d_e_t_]
    Semi-deterministic version of select/4.


nneexxttttoo((_?_X_, _?_Y_, _?_L_i_s_t))
    True if _Y follows _X in _L_i_s_t.


ddeelleettee((_+_L_i_s_t_1_, _@_E_l_e_m_, _-_L_i_s_t_2))                                     _[_d_e_t_]
    Delete  matching elements from a  list.  True  when _L_i_s_t_2 is a  list
    with all elements  from _L_i_s_t_1 except for those that unify with _E_l_e_m.
    Matching  _E_l_e_m with  elements of _L_i_s_t_1  is uses \+ Elem \= H,  which
    implies that _E_l_e_m is not changed.

         SSeeee aallssoo select/3, subtract/3.

         ddeepprreeccaatteedd There  are  too many  ways in  which  one might
             want  to delete  elements from a  list to  justify the
             name.     Think  of  matching  (= vs.     ==),  delete
             first/all, be deterministic or not.


nntthh00((_?_I_n_d_e_x_, _?_L_i_s_t_, _?_E_l_e_m))
    True when _E_l_e_m is  the _I_n_d_e_x'th element of _L_i_s_t.  Counting starts at
    0.

         EErrrroorrss type_error(integer, Index)   if  _I_n_d_e_x  is  not  an
             integer or unbound.

         SSeeee aallssoo nth1/3.


nntthh11((_?_I_n_d_e_x_, _?_L_i_s_t_, _?_E_l_e_m))
    Is true when _E_l_e_m  is the _I_n_d_e_x'th element of _L_i_s_t.  Counting starts
    at 1.

         SSeeee aallssoo nth0/3.


nntthh00((_?_N_, _?_L_i_s_t_, _?_E_l_e_m_, _?_R_e_s_t))                                     _[_d_e_t_]
    Select/insert  element  at  index.    True  when _E_l_e_m  is  the  _N'th
    (0-based)  element  of _L_i_s_t  and _R_e_s_t  is the  remainder  (as in  by
    select/3) of _L_i_s_t.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- nth0(I, [a,b,c], E, R).                                         |

    | I = 0, E = a, R = [b, c] ;                                         |
    | I = 1, E = b, R = [a, c] ;                                         |
    | I = 2, E = c, R = [a, b] ;                                         |
    ||false.____________________________________________________________ ||

    ____________________________________________________________________|                                                                    |

    | ?- nth0(1, L, a1, [a,b]).                                          |
    ||L_=_[a,_a1,_b].___________________________________________________ ||


nntthh11((_?_N_, _?_L_i_s_t_, _?_E_l_e_m_, _?_R_e_s_t))                                     _[_d_e_t_]
    As nth0/4, but counting starts at 1.


llaasstt((_?_L_i_s_t_, _?_L_a_s_t))
    Succeeds  when _L_a_s_t is the last element of _L_i_s_t.  This  predicate is
    semidet if _L_i_s_t is a list and multi if _L_i_s_t is a partial list.

         CCoommppaattiibbiilliittyy There   is  no  de-facto  standard  for  the
             argument  order of  last/2.   Be careful  when porting
             code  or  use  append(_, [Last], List)  as a  portable
             alternative.


pprrooppeerr__lleennggtthh((_@_L_i_s_t_, _-_L_e_n_g_t_h))                                  _[_s_e_m_i_d_e_t_]
    True when _L_e_n_g_t_h is  the number of elements in the proper list _L_i_s_t.
    This is equivalent to

    ____________________________________________________________________|                                                                    |
    | proper_length(List, Length) :-                                     |

    |       is_list(List),                                               |
    ||______length(List,_Length)._______________________________________ ||


ssaammee__lleennggtthh((_?_L_i_s_t_1_, _?_L_i_s_t_2))
    Is  true when  _L_i_s_t_1 and  _L_i_s_t_2 are lists  with the  same number  of
    elements.   The  predicate is deterministic if  at least one of  the
    arguments  is  a proper  list.    It  is non-deterministic  if  both
    arguments are partial lists.

         SSeeee aallssoo length/2


rreevveerrssee((_?_L_i_s_t_1_, _?_L_i_s_t_2))
    Is true when the  elements of _L_i_s_t_2 are in reverse order compared to
    _L_i_s_t_1.


ppeerrmmuuttaattiioonn((_?_X_s_, _?_Y_s))                                          _[_n_o_n_d_e_t_]
    True  when  _X_s  is  a  permutation  of _Y_s.     This  can  solve  for
    _Y_s  given  _X_s  or  _X_s  given  _Y_s,   or  even  enumerate  _X_s  and  _Y_s
    together.     The  predicate  permutation/2  is  primarily  intended
    to  generate  permutations.    Note  that a  list  of length  N  has
    N!  permutations,   and  unbounded  permutation  generation  becomes
    prohibitively  expensive,  even  for rather  short  lists  (10!    =
    3,628,800).

    If both _X_s and  _Y_s are provided and both lists have equal length the
    order  is |_X_s|^2.  Simply testing whether _X_s is a permutation  of _Y_s
    can  be achieved  in order  log(|_X_s|) using  msort/2 as  illustrated
    below with the semidet predicate is_permutation/2:

    ____________________________________________________________________|                                                                    |
    | is_permutation(Xs, Ys) :-                                          |

    |   msort(Xs, Sorted),                                               |
    ||__msort(Ys,_Sorted).______________________________________________ ||

    The  example below illustrates that _X_s and _Y_s being proper  lists is
    not a sufficient condition to use the above replacement.

    ____________________________________________________________________|                                                                    |
    | ?- permutation([1,2], [X,Y]).                                      |
    | X = 1, Y = 2 ;                                                     |
    | X = 2, Y = 1 ;                                                     |
    ||false.____________________________________________________________ ||

         EErrrroorrss type_error(list, Arg)  if either argument  is not a
             proper or partial list.


ffllaatttteenn((_+_N_e_s_t_e_d_L_i_s_t_, _-_F_l_a_t_L_i_s_t))                                   _[_d_e_t_]
    Is  true if _F_l_a_t_L_i_s_t  is a non-nested version  of _N_e_s_t_e_d_L_i_s_t.   Note
    that  empty lists  are removed.   In standard  Prolog, this  implies
    that  the atom '[]' is  removed too.  In  SWI7, [] is distinct  from
    '[]'.

    Ending  up  needing flatten/3  often  indicates, like  append/3  for
    appending  two lists, a bad design.   Efficient code that  generates
    lists  from generated small lists  must use difference lists,  often
    possible through grammar rules for optimal readability.

         SSeeee aallssoo append/2


mmaaxx__mmeemmbbeerr((_-_M_a_x_, _+_L_i_s_t))                                        _[_s_e_m_i_d_e_t_]
    True when _M_a_x is  the largest member in the standard order of terms.
    Fails if _L_i_s_t is empty.

         SSeeee aallssoo
             - compare/3
             - max_list/2 for the maximum of a list of numbers.


mmiinn__mmeemmbbeerr((_-_M_i_n_, _+_L_i_s_t))                                        _[_s_e_m_i_d_e_t_]
    True  when  _M_i_n is  the smallest  member in  the  standard order  of
    terms.  Fails if _L_i_s_t is empty.

         SSeeee aallssoo
             - compare/3
             - min_list/2 for the minimum of a list of numbers.


ssuumm__lliisstt((_+_L_i_s_t_, _-_S_u_m))                                              _[_d_e_t_]
    _S_u_m is the result of adding all numbers in _L_i_s_t.


mmaaxx__lliisstt((_+_L_i_s_t_:_l_i_s_t_(_n_u_m_b_e_r_)_, _-_M_a_x_:_n_u_m_b_e_r))                      _[_s_e_m_i_d_e_t_]
    True if _M_a_x is the largest number in _L_i_s_t.  Fails if _L_i_s_t is empty.

         SSeeee aallssoo max_member/2.


mmiinn__lliisstt((_+_L_i_s_t_:_l_i_s_t_(_n_u_m_b_e_r_)_, _-_M_i_n_:_n_u_m_b_e_r))                      _[_s_e_m_i_d_e_t_]
    True  if _M_i_n  is the  smallest number  in _L_i_s_t.   Fails  if _L_i_s_t  is
    empty.

         SSeeee aallssoo min_member/2.


nnuummlliisstt((_+_L_o_w_, _+_H_i_g_h_, _-_L_i_s_t))                                   _[_s_e_m_i_d_e_t_]
    _L_i_s_t is a list [_L_o_w, _L_o_w+1, ...  _H_i_g_h].  Fails if _H_i_g_h < _L_o_w.

         EErrrroorrss
             - type_error(integer, Low)
             - type_error(integer, High)


iiss__sseett((_@_S_e_t))                                                       _[_d_e_t_]
    True  if _S_e_t is  a proper list without  duplicates.  Equivalence  is
    based  on  ==/2.   The  implementation  uses sort/2,  which  implies
    that  the  complexity is  N*log(N)  and the  predicate may  cause  a
    resource-error.  There are no other error conditions.


lliisstt__ttoo__sseett((_+_L_i_s_t_, _?_S_e_t))                                           _[_d_e_t_]
    True when _S_e_t has  the same elements as _L_i_s_t in the same order.  The
    left-most copy of  duplicate elements is retained.  _L_i_s_t may contain
    variables.   Elements _E_1 and _E_2 are considered duplicates iff  _E_1 ==
    _E_2 holds.  The complexity of the implementation is N*log(N).

         EErrrroorrss _L_i_s_t is type-checked.

         aauutthhoorr Ulrich Neumerkel

         SSeeee aallssoo sort/2  can  be used  to create  an  ordered set.
             Many  set  operations  on  ordered  sets  are order  N
             rather  than order N**2.   The list_to_set/2 predicate
             is more  expensive than sort/2 because it involves, in
             addition to a sort, three linear scans of the list.

         CCoommppaattiibbiilliittyy Up   to  version  6.3.11,  list_to_set/2 had
             complexity N**2 and equality was tested using =/2.


iinntteerrsseeccttiioonn((_+_S_e_t_1_, _+_S_e_t_2_, _-_S_e_t_3))                                 _[_d_e_t_]
    True  if _S_e_t_3 unifies with the intersection  of _S_e_t_1 and _S_e_t_2.   The
    complexity of this predicate is |_S_e_t_1|*|_S_e_t_2|

         SSeeee aallssoo ord_intersection/3.


uunniioonn((_+_S_e_t_1_, _+_S_e_t_2_, _-_S_e_t_3))                                        _[_d_e_t_]
    True  if  _S_e_t_3  unifies with  the  union of  _S_e_t_1  and  _S_e_t_2.    The
    complexity of this predicate is |_S_e_t_1|*|_S_e_t_2|

         SSeeee aallssoo ord_union/3.


ssuubbsseett((_+_S_u_b_S_e_t_, _+_S_e_t))                                         _[_s_e_m_i_d_e_t_]
    True  if all elements of _S_u_b_S_e_t belong  to _S_e_t as well.   Membership
    test is based on memberchk/2.  The complexity is |_S_u_b_S_e_t|*|_S_e_t|.

         SSeeee aallssoo ord_subset/2.


ssuubbttrraacctt((_+_S_e_t_, _+_D_e_l_e_t_e_, _-_R_e_s_u_l_t))                                  _[_d_e_t_]
    _D_e_l_e_t_e  all elements  in  _D_e_l_e_t_e from  _S_e_t.   Deletion  is based  on
    unification using memberchk/2.  The complexity is |_D_e_l_e_t_e|*|_S_e_t|.

         SSeeee aallssoo ord_subtract/3.


1122..1155 lliibbrraarryy((nnbb__sseett))::  NNoonn--bbaacckkttrraacckkaabbllee sseett

The  library  nb_set  defines  _n_o_n_-_b_a_c_k_t_r_a_c_k_a_b_l_e  _s_e_t_s,  implemented  as
binary  trees.     The  sets  are  represented  as  compound  terms  and
manipulated  using  nb_setarg/3.     Non-backtrackable  manipulation  of
datastructures  is   not  supported   by  a  large   number  of   Prolog
implementations, but it has several advantages over  using the database.
It  produces less  garbage,  is thread-safe,  reentrant and  deals  with
exceptions without leaking data.

Similar to  the assoc library, keys  can be any  Prolog term, but it  is
not allowed to instantiate or modify a term.

One of  the ways to  use this  library is to  generate unique values  on
backtracking  _w_i_t_h_o_u_t generating  _a_l_l solutions  first,  for example  to
act as  a filter between  a generator producing  many duplicates and  an
expensive test routine, as outlined below:

________________________________________________________________________|                                                                        |
|generate_and_test(Solution) :-                                          |

|        empty_nb_set(Set),                                              |
|        generate(Solution),                                             |
|        add_nb_set(Solution, Set, true),                                |
||_______test(Solution).________________________________________________ ||


eemmppttyy__nnbb__sseett((_?_S_e_t))
    True if _S_e_t is a non-backtrackable empty set.


aadddd__nnbb__sseett((_+_K_e_y_, _!_S_e_t))
    Add  _K_e_y to _S_e_t.   If _K_e_y  is already a member  of _S_e_t, add_nb_set/3
    succeeds without modifying _S_e_t.


aadddd__nnbb__sseett((_+_K_e_y_, _!_S_e_t_, _?_N_e_w))
    If  _K_e_y is not in _S_e_t  and _N_e_w is unified  to true, _K_e_y is added  to
    _S_e_t.   If _K_e_y is  in _S_e_t, _N_e_w is unified to  false.  It can  be used
    for many purposes:

             add_nb_set(+, +, false) Test membership
             add_nb_set(+, +, true)  Succeed only if new member
             add_nb_set(+, +, Var)   Succeed, binding _V_a_r


ggeenn__nnbb__sseett((_+_S_e_t_, _-_K_e_y))
    Generate  all members of _S_e_t  on backtracking in the standard  order
    of terms.  To test membership, use add_nb_set/3.


ssiizzee__nnbb__sseett((_+_S_e_t_, _-_S_i_z_e))
    Unify _S_i_z_e with the number of elements in _S_e_t.


nnbb__sseett__ttoo__lliisstt((_+_S_e_t_, _-_L_i_s_t))
    Unify _L_i_s_t with a  list of all elements in _S_e_t in the standard order
    of terms (i.e., an _o_r_d_e_r_e_d _l_i_s_t).


1122..1166 lliibbrraarryy((wwwwww__bbrroowwsseerr))::  AAccttiivvaattiinngg yyoouurr WWeebb--bbrroowwsseerr

This library deals with the very system-dependent task of  opening a web
page in a browser.  See also url and the HTTP package.


wwwwww__ooppeenn__uurrll((_+_U_R_L))
    Open  _U_R_L in  an external web  browser.   The reason  to place  this
    in  the library  is  to centralise  the maintenance  on this  highly
    platform-  and browser-specific task.  It distinguishes  between the
    following cases:

      o  _M_S_-_W_i_n_d_o_w_s
         If it detects MS-Windows  it uses win_shell/2 to open the  _U_R_L.
         The behaviour  and browser  started depends on  the version  of
         Windows  and Windows-shell  configuration,  but in  general  it
         should be the behaviour expected by the user.

      o  _O_t_h_e_r _p_l_a_t_f_o_r_m_s
         On  other platforms  it  tests  the environment  variable  (see
         getenv/2) named BROWSER  or uses netscape  if this variable  is
         not  set.    If the  browser  is  either mozilla  or  netscape,
         www_open_url/1 first tries to  open a new  window on a  running
         browser using the  -remote option of Netscape.   If this  fails
         or the  browser is not  mozilla or  netscape the system  simply
         passes the URL as first argument to the program.


1122..1177 lliibbrraarryy((ooppttiioonn))::  OOppttiioonn lliisstt pprroocceessssiinngg

    SSeeee aallssoo
         - library(record)
         - Option processing capabilities may be declared using the
         directive predicate_options/3.

    TToo bbee ddoonnee  We should consider putting many options in an assoc
         or record with appropriate preprocessing to achieve better
         performance.

The  library(option)  provides  some  utilities  for  processing  option
lists.     Option  lists  are  commonly  used  as   an  alternative  for
many  arguments.    Examples  of  built-in  predicates  are  open/4  and
write_term/3.  Naming the  arguments results in more readable code,  and
the list  nature makes it  easy to extend the  list of options  accepted
by a  predicate.   Option lists come  in two styles,  both of which  are
handled by this library.

NNaammee((VVaalluuee))  This is the preferred style.

NNaammee == VVaalluuee  This is often used, but deprecated.

Processing options inside  time-critical code (loops) can cause  serious
overhead.  One  possibility is to define a record  using library(record)
and initialise  this using  make_<record>/2.   In  addition to providing
good  performance,   this  also   provides  type-checking  and   central
declaration of defaults.

________________________________________________________________________|                                                                        |
|:- record atts(width:integer=100, shape:oneof([box,circle])=box).       |
|                                                                        |
|process(Data, Options) :-                                               |
|        make_atts(Options, Attributes),                                 |
|        action(Data, Attributes).                                       |

|                                                                        |
|action(Data, Attributes) :-                                             |
|        atts_shape(Attributes, Shape),                                  |
||_______...____________________________________________________________ ||

Options  typically  have  exactly  one  argument.     The  library  does
support options  with 0  or more  than one argument  with the  following
restrictions:

  o The  predicate   option/3  and  select_option/4,   involving  default
    are   meaningless.      They  perform  an   arg(1, Option, Default),
    causing  failure  without  arguments  and  filling  only  the  first
    option-argument otherwise.

  o meta_options/3 can only qualify options with exactly one argument.


ooppttiioonn((_?_O_p_t_i_o_n_, _+_O_p_t_i_o_n_L_i_s_t_, _+_D_e_f_a_u_l_t))                        _[_s_e_m_i_d_e_t_]
    Get  an _O_p_t_i_o_n Qfrom _O_p_t_i_o_n_L_i_s_t.  _O_p_t_i_o_n_L_i_s_t can use  the Name=Value
    as well as the Name(Value) convention.

    ___________________________________________________________Arguments_
     _O_p_t_i_o_n  Term of the form Name(?Value).


ooppttiioonn((_?_O_p_t_i_o_n_, _+_O_p_t_i_o_n_L_i_s_t))                                  _[_s_e_m_i_d_e_t_]
    Get  an _O_p_t_i_o_n from _O_p_t_i_o_n_L_i_s_t.   _O_p_t_i_o_n_L_i_s_t can use the  Name=Value
    as  well  as the  Name(Value) convention.    Fails  silently if  the
    option does not appear in _O_p_t_i_o_n_L_i_s_t.

    ___________________________________________________________Arguments_
     _O_p_t_i_o_n  Term of the form Name(?Value).


sseelleecctt__ooppttiioonn((_?_O_p_t_i_o_n_, _+_O_p_t_i_o_n_s_, _-_R_e_s_t_O_p_t_i_o_n_s))                 _[_s_e_m_i_d_e_t_]
    Get  and remove _O_p_t_i_o_n from an  option list.  As option/2,  removing
    the matching option  from _O_p_t_i_o_n_s and unifying the remaining options
    with _R_e_s_t_O_p_t_i_o_n_s.


sseelleecctt__ooppttiioonn((_?_O_p_t_i_o_n_, _+_O_p_t_i_o_n_s_, _-_R_e_s_t_O_p_t_i_o_n_s_, _+_D_e_f_a_u_l_t))           _[_d_e_t_]
    Get  and remove _O_p_t_i_o_n with default value.   As select_option/3, but
    if  _O_p_t_i_o_n is not in _O_p_t_i_o_n_s, its value is unified with  _D_e_f_a_u_l_t and
    _R_e_s_t_O_p_t_i_o_n_s with _O_p_t_i_o_n_s.


mmeerrggee__ooppttiioonnss((_+_N_e_w_, _+_O_l_d_, _-_M_e_r_g_e_d))                                 _[_d_e_t_]
    Merge  two option lists.  _M_e_r_g_e_d  is a sorted list of  options using
    the  canonical format Name(Value) holding  all options from _N_e_w  and
    _O_l_d, after removing conflicting options from _O_l_d.

    Multi-values  options (e.g.,  proxy(Host, Port)) are allowed,  where
    both option-name and arity define the identity of the option.


mmeettaa__ooppttiioonnss((_+_I_s_M_e_t_a_, _:_O_p_t_i_o_n_s_0_, _-_O_p_t_i_o_n_s))                         _[_d_e_t_]
    Perform   meta-expansion  on  options  that  are   module-sensitive.
    Whether an option  name is module-sensitive is determined by calling
    call(IsMeta, Name).  Here is an example:

    ____________________________________________________________________|                                                                    |
    |         meta_options(is_meta, OptionsIn, Options),                 |

    |         ...                                                        |
    |                                                                    |
    ||is_meta(callback).________________________________________________ ||

    Meta-options must have  exactly one argument.  This argument will be
    qualified.

         TToo bbee ddoonnee Should  be  integrated  with declarations  from
             predicate_options/3.


ddiicctt__ooppttiioonnss((_?_D_i_c_t_, _?_O_p_t_i_o_n_s))                                      _[_d_e_t_]
    Convert  between  an option  list and  a  dictionary.   One  of  the
    arguments  must be instantiated.  If the option list is  created, it
    is  created in canonical  form, i.e.,  using Option(Value) with  the
    _O_p_t_i_o_n_s  sorted in  the  standard order  of terms.    Note that  the
    conversion  is not always possible due to different  constraints and
    convertion may thus lead to (type) errors.

      o  _D_i_c_t keys can  be integers.   This is not allowed in  canonical
         option lists.

      o  _O_p_t_i_o_n_s can hold multiple options  with the same key.   This is
         not allowed in dicts.

      o  _O_p_t_i_o_n_s can have  more than one value  (name(V1,V2)).  This  is
         not allowed in dicts.

    Also  note that  most system  predicates and  predicates using  this
    library  for  processing  the option  argument  can both  work  with
    classical Prolog options and dicts objects.


1122..1188 lliibbrraarryy((ooppttppaarrssee))::  ccoommmmaanndd lliinnee ppaarrssiinngg

    aauutthhoorr  Marcus Uneson

    vveerrssiioonn  0.20 (2011-04-27)

    TToo bbee ddoonnee  :  validation?   e.g, numbers; file path existence;
         one-out-of-a-set-of-atoms

This  module   helps  in  building  a   command-line  interface  to   an
application.  In  particular, it provides functions that take  an option
specification and  a list  of atoms,  probably given to  the program  on
the command  line, and  return a  parsed representation (a  list of  the
customary Key(Val) by default;  or optionally, a list of Func(Key,  Val)
terms in the style of  current_prolog_flag/2).  It can also  synthesize a
simple help text from the options specification.

The  terminology  in  the following  is  partly  borrowed  from  python,
see  http://docs.python.org/library/optparse.html#terminology .     Very
briefly,   _a_r_g_u_m_e_n_t_s  is   what  you   provide  on   the  command   line
and  for   many  prologs   show  up  as   a  list   of  atoms  Args   in
current_prolog_flag(argv, Args).    For  a typical  prolog  incantation,
they can be divided into

  o _r_u_n_t_i_m_e  _a_r_g_u_m_e_n_t_s, which controls  the prolog runtime;  convention-
    ally, they are ended by '--';

  o _o_p_t_i_o_n_s,  which are key-value pairs  (with a boolean value  possibly
    implicit)  intended to control your  program in one way or  another;
    and

  o _p_o_s_i_t_i_o_n_a_l  _a_r_g_u_m_e_n_t_s,  which  is  what remains  after  all  runtime
    arguments and options  have been removed (with implicit arguments --
    true/false for booleans -- filled in).

Positional  arguments are  in particular  used  for mandatory  arguments
without  which your  program  won't work  and  for  which there  are  no
sensible  defaults (e.g,,  input file  names).   Options,  by  contrast,
offer flexibility  by letting  you change  a default setting.    Options
are optional  not only  by etymology:   this  library has  no notion  of
mandatory or required options (see the python docs  for other rationales
than laziness).

The command-line arguments  enter your program as  a list of atoms,  but
the programs perhaps  expects booleans, integers, floats or  even prolog
terms.   You tell the parser  so by providing an _o_p_t_i_o_n_s  _s_p_e_c_i_f_i_c_a_t_i_o_n.
This is just a list of individual option specifications.   One of those,
in turn, is a  list of ground prolog terms in the  customary Name(Value)
format.  The following terms are recognized (any others raise error).

oopptt((_K_e_y))
    _K_e_y  is what the  option later  will be accessed  by, just like  for
    current_prolog_flag(Key, Value).   This term is mandatory  (an error
    is thrown if missing).

sshhoorrttffllaaggss((_L_i_s_t_O_f_F_l_a_g_s))
    _L_i_s_t_O_f_F_l_a_g_s  denotes any single-dashed, single letter  args specify-
    ing  the current  option  (-s , -K, etc).    Uppercase letters  must
    be  quoted.    Usually _L_i_s_t_O_f_F_l_a_g_s  will be  a singleton  list,  but
    sometimes aliased flags may be convenient.

lloonnggffllaaggss((_L_i_s_t_O_f_F_l_a_g_s))
    _L_i_s_t_O_f_F_l_a_g_s  denotes  any  double-dashed  arguments  specifying  the
    current  option (--verbose, --no-debug, etc).  They are  basically a
    more readable alternative to short flags, except

 1. long  flags can  be specified as  --flag value or --flag=value  (but
    not  as  --flagvalue);  short  flags as  -f val  or -fval  (but  not
    -f=val)

 2. boolean   long   flags   can   be  specified   as   --bool-flag   or
    --bool-flag=true  or --bool-flag true;  and they  can be negated  as
    --no-bool-flag or --bool-flag=false or --bool-flag false.

    Except  that shortflags must  be single characters, the  distinction
    between long and  short is in calling convention, not in namespaces.
    Thus, if you have  shortflags([v]), you can use it as -v2 or -v 2 or
    --v=2 or --v 2 (but not -v=2 or --v2).

    Shortflags  and longflags both default to [].   It can be  useful to
    have flagless options -- see example below.

mmeettaa((_M_e_t_a))
    _M_e_t_a  is  optional  and  only relevant  for  the  synthesized  usage
    message  and is  the name  (an atom) of  the metasyntactic  variable
    (possibly)  appearing in  it together  with type  and default  value
    (e.g,  x:integer=3, interest:float=0.11).  It may be useful  to have
    named  variables (x,  interest)  in case  you wish  to mention  them
    again  in the help text.  If not given the Meta:  part is suppressed
    -- see example below.

ttyyppee((_T_y_p_e))
    _T_y_p_e  is one  of  boolean, atom, integer, float, term.   The  corre-
    sponding  argument  will be  parsed  appropriately.   This  term  is
    optional; if not given, defaults to term.

ddeeffaauulltt((_D_e_f_a_u_l_t))
    _D_e_f_a_u_l_t  value.  This  term is optional; if  not given, or if  given
    the  special value '_', an uninstantiated  variable is created  (and
    any type declaration is ignored).

hheellpp((_H_e_l_p))
    _H_e_l_p is (usually) an  atom of text describing the option in the help
    text.   This  term is optional  (but obviously strongly  recommended
    for all options which have flags).

    Long  lines are  subject to basic  word wrapping  -- split on  white
    space,  reindent,  rejoin.   However, you  can get  more control  by
    supplying  the line breaking  yourself:  rather  than a single  line
    of  text, you can provide  a list of lines (as  atoms).  If you  do,
    they  will be joined with the appropriate indent but  otherwise left
    untouched (see the option mode in the example below).

Absence of mandatory option  specs or the presence of more than  one for
a  particular option  throws an  error, as  do  unknown or  incompatible
types.

As a concrete  example from a fictive  application, suppose we want  the
following options to be read from the command line  (long flag(s), short
flag(s), meta:type=default, help)

________________________________________________________________________|                                                                        |
|--mode                  -m     atom=SCAN       data gathering mode,     |
|                                               one of                   |
|                                                SCAN: do this           |

|                                                READ: do that           |
|                                                MAKE: make numbers      |
|                                                WAIT: do nothing        |
|--rebuild-cache         -r     boolean=true    rebuild cache in         |
|                                               each iteration           |
|--heisenberg-threshold  -t,-h  float=0.1       heisenberg threshold     |
|--depths, --iters       -i,-d  K:integer=3     stop after K             |
|                                               iterations               |

|--distances                    term=[1,2,3,5]  initial prolog term      |
|--output-file           -o     FILE:atom=_     write output to FILE     |
|--label                 -l     atom=REPORT     report label             |
|--verbosity             -v     V:integer=2     verbosity level,         |
||______________________________________________1_<=_V_<=_3_____________ ||

We  may also  have  some  configuration parameters  which  we  currently
think  not  needs   to  be  controlled  from   the  command  line,   say
path('/some/file/path').

This  interface is  described  by  the following  options  specification
(order   between  the   specifications  of   a   particular  option   is
irrelevant).

________________________________________________________________________|                                                                        |
|ExampleOptsSpec =                                                       |

|    [ [opt(mode    ), type(atom), default('SCAN'),                      |
|        shortflags([m]),   longflags(['mode'] ),                        |
|        help([ 'data gathering mode, one of'                            |
|             , '  SCAN: do this'                                        |
|             , '  READ: do that'                                        |
|             , '  MAKE: fabricate some numbers'                         |
|             , '  WAIT: don''t do anything'])]                          |
|                                                                        |

|    , [opt(cache), type(boolean), default(true),                        |
|        shortflags([r]),   longflags(['rebuild-cache']),                |
|        help('rebuild cache in each iteration')]                        |
|                                                                        |
|    , [opt(threshold), type(float), default(0.1),                       |
|        shortflags([t,h]),  longflags(['heisenberg-threshold']),        |
|        help('heisenberg threshold')]                                   |

|                                                                        |
|    , [opt(depth), meta('K'), type(integer), default(3),                |
|        shortflags([i,d]),longflags([depths,iters]),                    |
|        help('stop after K iterations')]                                |
|                                                                        |
|    , [opt(distances), default([1,2,3,5]),                              |
|        longflags([distances]),                                         |
|        help('initial prolog term')]                                    |

|                                                                        |
|    , [opt(outfile), meta('FILE'), type(atom),                          |
|        shortflags([o]),  longflags(['output-file']),                   |
|        help('write output to FILE')]                                   |
|                                                                        |
|    , [opt(label), type(atom), default('REPORT'),                       |
|        shortflags([l]), longflags([label]),                            |

|        help('report label')]                                           |
|                                                                        |
|    , [opt(verbose),  meta('V'), type(integer), default(2),             |
|        shortflags([v]),  longflags([verbosity]),                       |
|        help('verbosity level, 1 <= V <= 3')]                           |
|                                                                        |
|    , [opt(path), default('/some/file/path/')]                          |
||___]._________________________________________________________________ ||

The       help       text       above       was        accessed       by
opt_help(ExamplesOptsSpec, HelpText).     The  options  appear   in  the
same order as in the OptsSpec.

Given   ExampleOptsSpec,   a   command  line   (somewhat   syntactically
inconsistent,  in order  to demonstrate  different calling  conventions)
may look as follows

________________________________________________________________________|                                                                        |

|ExampleArgs = [ '-d5'                                                   |
|              , '--heisenberg-threshold', '0.14'                        |
|              , '--distances=[1,1,2,3,5,8]'                             |
|              , '--iters', '7'                                          |
|              , '-ooutput.txt'                                          |
|              , '--rebuild-cache', 'true'                               |

|              , 'input.txt'                                             |
|              , '--verbosity=2'                                         |
||_____________]._______________________________________________________ ||

opt_parse(ExampleOptsSpec, ExampleArgs, Opts, PositionalArgs)      would
then succeed with

________________________________________________________________________|                                                                        |
|Opts =    [ mode('SCAN')                                                |
|          , label('REPORT')                                             |
|          , path('/some/file/path')                                     |
|          , threshold(0.14)                                             |

|          , distances([1,1,2,3,5,8])                                    |
|          , depth(7)                                                    |
|          , outfile('output.txt')                                       |
|          , cache(true)                                                 |
|          , verbose(2)                                                  |
|          ],                                                            |
|PositionalArgs|=_['input.txt'].________________________________________ |              |

Note  that path('/some/file/path')  showing  up in  Opts has  a  default
value  (of  the  implicit  type  'term'),  but  no  corresponding  flags
in  OptsSpec.      Thus  it  can't   be  set  from  the  command   line.
The  rest  of  your program  doesn't  need  to  know  that,  of  course.
This  provides  an  alternative to  the  common  practice  of  asserting
such  hard-coded  parameters  under a  single  predicate  (for  instance
setting(path, '/some/file/path')),  with  the  advantage  that  you  may
seamlessly  upgrade them  to command-line  options, should  you one  day
find this  a good  idea.   Just  add an appropriate  flag or  two and  a
line of  help text.   Similarly,  suppressing an  option in a  cluttered
interface amounts to commenting out the flags.

opt_parse/5 allows more control  through an additional argument list  as
shown in the example below.

________________________________________________________________________|                                                                        |

|?- opt_parse(ExampleOptsSpec, ExampleArgs,  Opts, PositionalArgs,       |
|             [ output_functor(appl_config)                              |
|             ]).                                                        |
|                                                                        |
|Opts =    [ appl_config(verbose, 2),                                    |
|          , appl_config(label, 'REPORT')                                |

|          ...                                                           |
||_________]____________________________________________________________ ||

This representation may be preferable with  the empty-flag configuration
parameter style above (perhaps with asserting appl_config/2).


1122..1188..11 NNootteess aanndd ttiippss

  o In  the example  we were  mostly explicit about  the types.    Since
    the  default is  term, which subsumes  integer, float, atom, it  may
    be  possible to get  away cheaper (e.g.,  by only giving  booleans).
    However,   it is  recommended  practice  to  always  specify  types:
    parsing  becomes more reliable and error messages will be  easier to
    interpret.

  o Note  that -sbar is taken to mean -s bar, not -s -b -a -r,  that is,
    there is no clustering of flags.

  o -s=foo  is  disallowed.     The  rationale  is  that  although  some
    command-line  parsers will silently interpret this as -s =foo,  this
    is  very seldom what  you want.   To have  an option argument  start
    with '=' (very un-recommended), say so explicitly.

  o The  example specifies  the option  depth twice:   once  as -d5  and
    once  as --iters 7.  The default when encountering  duplicated flags
    is  to keeplast (this  behaviour can  be controlled, by  ParseOption
    duplicated_flags).

  o The  order of the options returned  by the parsing functions is  the
    same  as given  on the  command line,  with non-overridden  defaults
    prepended  and duplicates removed as in  previous item.  You  should
    not rely on this, however.

  o Unknown  flags (not appearing in OptsSpec) will throw errors.   This
    is  usually a Good Thing.  Sometimes, however, you may wish  to pass
    along  flags to an  external program (say,  one called by  shell/2),
    and  it means duplicated effort  and a maintenance headache to  have
    to  specify all possible flags  for the external program  explicitly
    (if  it even can  be done).   On the other  hand, simply taking  all
    unknown  flags as  valid makes  error checking  much less  efficient
    and  identification of  positional arguments  uncertain.   A  better
    solution  is to collect all arguments intended for passing  along to
    an  indirectly called program as  a single argument, probably as  an
    atom  (if you don't need to inspect them first) or as a  prolog term
    (if you do).


oopptt__aarrgguummeennttss((_+_O_p_t_s_S_p_e_c_, _-_O_p_t_s_, _-_P_o_s_i_t_i_o_n_a_l_A_r_g_s))                   _[_d_e_t_]
    Extract  commandline options  according to  a specification.    Con-
    venience  predicate,  assuming that  command-line  arguments can  be
    accessed  by current_prolog_flag/2 (as  in swi-prolog).   For  other
    access  mechanisms and/or more control,  get the args and pass  them
    as a list of atoms to opt_parse/4 or opt_parse/5 instead.

    _O_p_t_s  is a list of  parsed options in the  form Key(Value).   Dashed
    args  not in _O_p_t_s_S_p_e_c  are not permitted  and will raise error  (see
    tip  on  how  to pass  unknown  flags  in the  module  description).
    _P_o_s_i_t_i_o_n_a_l_A_r_g_s  are the  remaining non-dashed args  after each  flag
    has  taken its  argument (filling  in true or  false for  booleans).
    There  are no restrictions on  non-dashed arguments and they may  go
    anywhere  (although it  is good  practice to put  them last).    Any
    leading  arguments for the  runtime (up to  and including '--')  are
    discarded.


oopptt__ppaarrssee((_+_O_p_t_s_S_p_e_c_, _+_A_p_p_l_A_r_g_s_, _-_O_p_t_s_, _-_P_o_s_i_t_i_o_n_a_l_A_r_g_s))            _[_d_e_t_]
    Equivalent to opt_parse(OptsSpec, ApplArgs, Opts, PositionalArgs, []).


oopptt__ppaarrssee((_+_O_p_t_s_S_p_e_c_, _+_A_p_p_l_A_r_g_s_, _-_O_p_t_s_, _-_P_o_s_i_t_i_o_n_a_l_A_r_g_s_, _+_P_a_r_s_e_O_p_t_i_o_n_s))_[_d_e_t_]
    Parse  the arguments Args (as list of atoms) according  to _O_p_t_s_S_p_e_c.
    Any runtime arguments  (typically terminated by '--') are assumed to
    be removed already.

    _O_p_t_s  is a list of parsed  options in the form Key(Value),  or (with
    the  option  functor(Func)  given) in  the  form  Func(Key,  Value).
    Dashed  args not in _O_p_t_s_S_p_e_c are not permitted and will  raise error
    (see  tip on how to pass  unknown flags in the module  description).
    _P_o_s_i_t_i_o_n_a_l_A_r_g_s  are the  remaining non-dashed args  after each  flag
    has  taken its  argument (filling  in true or  false for  booleans).
    There  are  no restrictions  on non-dashed  arguments  and they  may
    go  anywhere  (although  it is  good  practice  to put  them  last).
    _P_a_r_s_e_O_p_t_i_o_n_s are

    oouuttppuutt__ffuunnccttoorr((_F_u_n_c))
         Set the functor  _F_u_n_c of the returned options  _F_u_n_c(Key,Value).
         Default  is the  special  value  'OPTION'  (upper-case),  which
         makes the returned options have form Key(Value).

    dduupplliiccaatteedd__ffllaaggss((_K_e_e_p))
         Controls how  to handle  options given  more than  once on  the
         commad line.  _K_e_e_p is one  of keepfirst, keeplast, keepall with
         the obvious meaning.  Default is keeplast.

    aallllooww__eemmppttyy__ffllaagg__ssppeecc((_B_o_o_l))
         If true  (default), a  flag specification is  not required  (it
         is allowed  that both  shortflags  and longflags  be either  []
         or absent).   Flagless options  cannot be manipulated from  the
         command  line and  will  not show  up  in the  generated  help.
         This  is useful  when  you  have (also)  general  configuration
         parameters in your _O_p_t_s_S_p_e_c,  especially if you think they  one
         day might  need to be  controlled externally.   See example  in
         the module  overview.   allow_empty_flag_spec(false) gives  the
         more customary behaviour of raising error on empty flags.


oopptt__hheellpp((_+_O_p_t_s_S_p_e_c_, _-_H_e_l_p_:_a_t_o_m))                                    _[_d_e_t_]
    True when _H_e_l_p is a help string synthesized from _O_p_t_s_S_p_e_c.


ppaarrssee__ttyyppee((_+_T_y_p_e_, _+_C_o_d_e_s_:_l_i_s_t_(_c_o_d_e_)_, _-_R_e_s_u_l_t))        _[_s_e_m_i_d_e_t_,_m_u_l_t_i_f_i_l_e_]
    Hook to parse option text _C_o_d_e_s to an object of type _T_y_p_e.


1122..1199 lliibbrraarryy((oorrddsseettss))::  OOrrddeerreedd sseett mmaanniippuullaattiioonn

Ordered  sets are  lists with  unique elements  sorted  to the  standard
order of  terms (see  sort/2).   Exploiting  ordering, many  of the  set
operations can  be expressed  in order  N rather than  N^2 when  dealing
with unordered sets  that may contain duplicates.   The library(ordsets)
is available in a number of Prolog implementations.   Our predicates are
designed to be compatible with common practice in  the Prolog community.
The implementation  is incomplete  and relies  partly on  library(oset),
an  older  ordered  set  library  distributed  with  SWI-Prolog.     New
applications are advised to use library(ordsets).

Some  of   these  predicates  match   directly  to  corresponding   list
operations.    It  is advised  to use  the  versions from  this  library
to  make clear  you are  operating on  ordered sets.    An exception  is
member/2.  See ord_memberchk/2.

The ordsets  library is  based on  the standard order  of terms.    This
implies  it can  handle all  Prolog terms,  including variables.    Note
however, that  the ordering is not  stable if a  term inside the set  is
further  instantiated.   Also  note that  variable  ordering changes  if
variables in the  set are unified with each  other or a variable in  the
set is unified with a variable that is `older'  than the newest variable
in  the set.    In practice,  this implies  that  it is  allowed to  use
member(X, OrdSet) on an ordered set that holds variables only  if X is a
fresh variable.  In  other cases one should cease using it as  an ordset
because the order it relies on may have been changed.


iiss__oorrddsseett((_@_T_e_r_m))                                               _[_s_e_m_i_d_e_t_]
    True  if _T_e_r_m is  an ordered set.   All  predicates in this  library
    expect  ordered sets as  input arguments.   Failing to fullfil  this
    assumption results in  undefined behaviour.  Typically, ordered sets
    are created by predicates from this library, sort/2 or setof/3.


oorrdd__eemmppttyy((_?_L_i_s_t))                                               _[_s_e_m_i_d_e_t_]
    True  when _L_i_s_t is the empty ordered set.  Simply unifies  list with
    the empty list.  Not part of Quintus.


oorrdd__sseetteeqq((_+_S_e_t_1_, _+_S_e_t_2))                                        _[_s_e_m_i_d_e_t_]
    True  if  _S_e_t_1  and _S_e_t_2  have  the same  elements.    As  both  are
    canonical sorted lists, this is the same as ==/2.

         CCoommppaattiibbiilliittyy sicstus


lliisstt__ttoo__oorrdd__sseett((_+_L_i_s_t_, _-_O_r_d_S_e_t))                                     _[_d_e_t_]
    Transform  a list into an ordered set.  This is the  same as sorting
    the list.


oorrdd__iinntteerrsseecctt((_+_S_e_t_1_, _+_S_e_t_2))                                    _[_s_e_m_i_d_e_t_]
    True if both ordered sets have a non-empty intersection.


oorrdd__ddiissjjooiinntt((_+_S_e_t_1_, _+_S_e_t_2))                                     _[_s_e_m_i_d_e_t_]
    True  if  _S_e_t_1 and  _S_e_t_2  have no  common  elements.   This  is  the
    negation of ord_intersect/2.


oorrdd__iinntteerrsseecctt((_+_S_e_t_1_, _+_S_e_t_2_, _-_I_n_t_e_r_s_e_c_t_i_o_n))
    _I_n_t_e_r_s_e_c_t_i_o_n holds the common elements of _S_e_t_1 and _S_e_t_2.

         ddeepprreeccaatteedd Use ord_intersection/3


oorrdd__iinntteerrsseeccttiioonn((_+_P_o_w_e_r_S_e_t_, _-_I_n_t_e_r_s_e_c_t_i_o_n))
    _I_n_t_e_r_s_e_c_t_i_o_n  of a powerset.   True when _I_n_t_e_r_s_e_c_t_i_o_n is an  ordered
    set holding all elements common to all sets in _P_o_w_e_r_S_e_t.

         CCoommppaattiibbiilliittyy sicstus


oorrdd__iinntteerrsseeccttiioonn((_+_S_e_t_1_, _+_S_e_t_2_, _-_I_n_t_e_r_s_e_c_t_i_o_n))                      _[_d_e_t_]
    _I_n_t_e_r_s_e_c_t_i_o_n holds the common elements of _S_e_t_1 and _S_e_t_2.


oorrdd__iinntteerrsseeccttiioonn((_+_S_e_t_1_, _+_S_e_t_2_, _?_I_n_t_e_r_s_e_c_t_i_o_n_, _?_D_i_f_f_e_r_e_n_c_e))         _[_d_e_t_]
    _I_n_t_e_r_s_e_c_t_i_o_n and difference  between two ordered sets.  _I_n_t_e_r_s_e_c_t_i_o_n
    is  the  intersection between  _S_e_t_1 and  _S_e_t_2,  while _D_i_f_f_e_r_e_n_c_e  is
    defined by ord_subtract(Set2, Set1, Difference).

         SSeeee aallssoo ord_intersection/3 and ord_subtract/3.


oorrdd__aadddd__eelleemmeenntt((_+_S_e_t_1_, _+_E_l_e_m_e_n_t_, _?_S_e_t_2))                            _[_d_e_t_]
    Insert   an  element  into   the  set.      This  is  the  same   as
    ord_union(Set1, [Element], Set2).


oorrdd__ddeell__eelleemmeenntt((_+_S_e_t_, _+_E_l_e_m_e_n_t_, _-_N_e_w_S_e_t))                           _[_d_e_t_]
    Delete  an  element from  an  ordered set.    This  is the  same  as
    ord_subtract(Set, [Element], NewSet).


oorrdd__sseelleeccttcchhkk((_+_I_t_e_m_, _?_S_e_t_1_, _?_S_e_t_2))                             _[_s_e_m_i_d_e_t_]
    Selectchk/3,   specialised  for  ordered   sets.     Is  true   when
    select(Item, Set1, Set2)  and  _S_e_t_1,  _S_e_t_2  are  both  sorted  lists
    without  duplicates.  This  implementation is only expected to  work
    for  _I_t_e_m  ground  and  either _S_e_t_1  or  _S_e_t_2  ground.    The  "chk"
    suffix  is meant to  remind you of  memberchk/2, which also  expects
    its  first  argument  to  be  ground.    ord_selectchk(X, S, T)  =>
    ord_memberchk(X, S) & \+ ord_memberchk(X, T).

         aauutthhoorr Richard O'Keefe


oorrdd__mmeemmbbeerrcchhkk((_+_E_l_e_m_e_n_t_, _+_O_r_d_S_e_t))                               _[_s_e_m_i_d_e_t_]
    True  if _E_l_e_m_e_n_t is  a member of  _O_r_d_S_e_t, compared using  ==.   Note
    that  _e_n_u_m_e_r_a_t_i_n_g  elements of  an  ordered set  can be  done  using
    member/2.

    Some  Prolog  implementations also  provide  ord_member/2,  with  the
    same  semantics  as  ord_memberchk/2.     We believe  that  having  a
    semidet  ord_member/2 is  unacceptably  inconsistent with  the *_chk
    convention.  Portable code should use ord_memberchk/2 or member/2.

         aauutthhoorr Richard O'Keefe


oorrdd__ssuubbsseett((_+_S_u_b_, _+_S_u_p_e_r))                                       _[_s_e_m_i_d_e_t_]
    Is true if all elements of _S_u_b are in _S_u_p_e_r


oorrdd__ssuubbttrraacctt((_+_I_n_O_S_e_t_, _+_N_o_t_I_n_O_S_e_t_, _-_D_i_f_f))                           _[_d_e_t_]
    _D_i_f_f  is the  set holding  all elements of  _I_n_O_S_e_t that  are not  in
    _N_o_t_I_n_O_S_e_t.


oorrdd__uunniioonn((_+_S_e_t_O_f_S_e_t_s_, _-_U_n_i_o_n))                                      _[_d_e_t_]
    True  if  _U_n_i_o_n  is  the  union of  all  elements  in  the  superset
    _S_e_t_O_f_S_e_t_s.   Each member  of _S_e_t_O_f_S_e_t_s must  be an ordered set,  the
    sets need not be ordered in any way.

         aauutthhoorr Copied  from  YAP, probably  originally  by Richard
             O'Keefe.


oorrdd__uunniioonn((_+_S_e_t_1_, _+_S_e_t_2_, _?_U_n_i_o_n))                                    _[_d_e_t_]
    _U_n_i_o_n is the union of _S_e_t_1 and _S_e_t_2


oorrdd__uunniioonn((_+_S_e_t_1_, _+_S_e_t_2_, _-_U_n_i_o_n_, _-_N_e_w))                              _[_d_e_t_]
    True          iff          ord_union(Set1, Set2, Union)          and
    ord_subtract(Set2, Set1, New).


oorrdd__ssyymmddiiffff((_+_S_e_t_1_, _+_S_e_t_2_, _?_D_i_f_f_e_r_e_n_c_e))                             _[_d_e_t_]
    Is  true when  _D_i_f_f_e_r_e_n_c_e is  the symmetric difference  of _S_e_t_1  and
    _S_e_t_2.    I.e.,  _D_i_f_f_e_r_e_n_c_e contains  all elements  that  are not  in
    the  intersection of _S_e_t_1 and  _S_e_t_2.  The  semantics is the same  as
    the  sequence below (but the  actual implementation requires only  a
    single scan).

    ____________________________________________________________________|                                                                    |
    |       ord_union(Set1, Set2, Union),                                |

    |       ord_intersection(Set1, Set2, Intersection),                  |
    ||______ord_subtract(Union,_Intersection,_Difference).______________ ||

    For example:

    ____________________________________________________________________|                                                                    |
    | ?- ord_symdiff([1,2], [2,3], X).                                   |
    ||X_=_[1,3].________________________________________________________ ||


1122..2200 lliibbrraarryy((ppaaiirrss))::  OOppeerraattiioonnss oonn kkeeyy--vvaalluuee lliissttss

    aauutthhoorr  Jan Wielemaker

    SSeeee aallssoo  keysort/2, library(assoc)

This  module  implements common  operations  on  Key-Value  lists,  also
known as  _P_a_i_r_s.   Pairs have great practical  value, especially due  to
keysort/2 and the library assoc.pl.

This  library is  based  on  disussion in  the  SWI-Prolog  mailinglist,
including specifications from Quintus and a library  proposal by Richard
O'Keefe.


ppaaiirrss__kkeeyyss__vvaalluueess((_?_P_a_i_r_s_, _?_K_e_y_s_, _?_V_a_l_u_e_s))                          _[_d_e_t_]
    True if _K_e_y_s holds the keys of _P_a_i_r_s and _V_a_l_u_e_s the values.

    Deterministic  if any argument is instantiated to a finite  list and
    the others are either  free or finite lists.  All three lists are in
    the same order.

         SSeeee aallssoo pairs_values/2 and pairs_keys/2.


ppaaiirrss__vvaalluueess((_+_P_a_i_r_s_, _-_V_a_l_u_e_s))                                      _[_d_e_t_]
    Remove  the  keys  from  a  list  of  Key-Value  pairs.     Same  as
    pairs_keys_values(Pairs, _, Values)


ppaaiirrss__kkeeyyss((_+_P_a_i_r_s_, _-_K_e_y_s))                                          _[_d_e_t_]
    Remove  the  values  from  a list  of  Key-Value  pairs.    Same  as
    pairs_keys_values(Pairs, Keys, _)


ggrroouupp__ppaaiirrss__bbyy__kkeeyy((_+_P_a_i_r_s_, _-_J_o_i_n_e_d_:_l_i_s_t_(_K_e_y_-_V_a_l_u_e_s_)))                _[_d_e_t_]
    Group  values with the same key.   _P_a_i_r_s must be a  key-sorted list.
    For example:

    ____________________________________________________________________|                                                                    |
    | ?- group_pairs_by_key([a-2, a-1, b-4], X).                         |

    |                                                                    |
    ||X_=_[a-[2,1],_b-[4]]______________________________________________ ||

    ___________________________________________________________Arguments_
     _P_a_i_r_s   _K_e_y-Value list, sorted to the standard order  of
             terms (as keysort/2 does)

     _J_o_i_n_e_d  List  of _K_e_y-Group, where  Group is the list  of
             _V_a_l_u_e_s associated with _K_e_y.


ttrraannssppoossee__ppaaiirrss((_+_P_a_i_r_s_, _-_T_r_a_n_s_p_o_s_e_d))                               _[_d_e_t_]
    Swap  Key-Value to Value-Key.   The  resulting list is sorted  using
    keysort/2 on the new key.


mmaapp__lliisstt__ttoo__ppaaiirrss((_:_F_u_n_c_t_i_o_n_, _+_L_i_s_t_, _-_K_e_y_e_d))
    Create  a Key-Value  list  by mapping  each element  of _L_i_s_t.    For
    example,  if  we have  a  list of  lists  we can  create a  list  of
    Length-_L_i_s_t using

    ____________________________________________________________________|                                                                    |
    ||________map_list_to_pairs(length,_ListOfLists,_Pairs),____________ ||


1122..2211 lliibbrraarryy((ppeerrssiisstteennccyy))::  PPrroovviiddee ppeerrssiisstteenntt ddyynnaammiicc pprreeddiiccaatteess

    TToo bbee ddoonnee
         - Provide type safety while loading
         - Thread  safety must now  be provided at  the user-level.
         Can we  provide generic  thread safety?    Basically, this
         means that  we must  wrap all exported  predicates.   That
         might better be done outside this library.
         - Transaction management?
         - Should  assert_<name>  only assert if  the database  does
         not contain a variant?

This module provides  simple persistent storage for one or  more dynamic
predicates.   A database is always associated  with a module.  A  module
that wishes to  maintain a database must  declare the terms that can  be
placed in the database using the directive persistent/1.

The persistent/1 expands each declaration into four predicates:

  o name(Arg, ...)

  o assert_name(Arg, ...)

  o retract_name(Arg, ...)

  o retractall_name(Arg, ...)

As  mentioned, a  database can  only be  accessed from  within a  single
module.   This limitation is on purpose,  forcing the user to provide  a
proper API for accessing the shared persistent data.

Below is a simple example:

________________________________________________________________________|                                                                        |
|:- module(user_db,                                                      |
|          [ attach_user_db/1,                % +File                    |
|            current_user_role/2,        % ?User, ?Role                  |

|            add_user/2,                        % +User, +Role           |
|            set_user_role/2                % +User, +Role               |
|          ]).                                                           |
|:- use_module(library(persistency)).                                    |
|                                                                        |
|:- persistent                                                           |
|        user_role(name:atom, role:oneof([user,administrator])).         |
|                                                                        |

|attach_user_db(File) :-                                                 |
|        db_attach(File, []).                                            |
|                                                                        |
|%%        current_user_role(+Name, -Role) is semidet.                   |
|                                                                        |
|current_user_role(Name, Role) :-                                        |
|        with_mutex(user_db, user_role(Name, Role)).                     |

|                                                                        |
|add_user(Name, Role) :-                                                 |
|        assert_user_role(Name, Role).                                   |
|                                                                        |
|set_user_role(Name, Role) :-                                            |
|        user_role(Name, Role), !.                                       |
|set_user_role(Name, Role) :-                                            |
|        with_mutex(user_db,                                             |

|                   (  retractall_user_role(Name, _),                    |
||_____________________assert_user_role(Name,_Role))).__________________ ||


ppeerrssiisstteenntt _+_S_p_e_c
    Declare dynamic database  terms.  Declarations appear in a directive
    and have the following format:

    ____________________________________________________________________|                                                                    |
    | :- persistent                                                      |

    |         <callable>,                                                |
    |         <callable>,                                                |
    ||________..._______________________________________________________ ||

    Each specification is  a callable term, following the conventions of
    library(record), where each argument is of the form

    ____________________________________________________________________|                                                                    |
    ||name:type_________________________________________________________ ||

    Types are defined by library(error).


ccuurrrreenntt__ppeerrssiisstteenntt__pprreeddiiccaattee((_:_P_I))                               _[_n_o_n_d_e_t_]
    True  if _P_I is  a predicate that  provides access to the  persistent
    database DB.


ddbb__aattttaacchh((_:_F_i_l_e_, _+_O_p_t_i_o_n_s))
    Use  _F_i_l_e  as persistent  database  for the  calling  module.    The
    calling  module must  defined persistent/1 to  declare the  database
    terms.  Defined options:

    ssyynncc((_+_S_y_n_c))
         One  of close  (close  journal after  write),  flush  (default,
         flush journal after  write) or none  (handle as fully  buffered
         stream).


ddbb__ssyynncc((_:_W_h_a_t))
    Synchronise database with the associated file.  _W_h_a_t is one of:

    rreellooaadd
         Database is reloaded from file

    ggcc
         Database was  re-written, deleting  all retractall  statements.
         This is the same as gc(50).

    ggcc((_P_e_r_c_e_n_t_a_g_e))
         GC DB if  the number of deleted  terms is the given  percentage
         of the total number of terms.

    cclloossee
         Database stream was closed

    ddeettaacchh
         Remove all registered persistency for the calling module

    nnoopp
         No-operation performed

    With  unbound  _W_h_a_t,  db_sync/1  reloads  the  database  if  it  was
    modified  on disk,  gc  it if  it is  dirty and  close it  if it  is
    opened.


ddbb__ssyynncc__aallll((_+_W_h_a_t))
    Sync all registered databases.


1122..2222 lliibbrraarryy((ppiioo))::  PPuurree II//OO

This library provides  pure list-based I/O processing for Prolog,  where
the communication  to the actual I/O  device is performed  transparently
through coroutining.   This  module itself is just  an interface to  the
actual implementation modules.


1122..2222..11 lliibbrraarryy((ppuurree__iinnppuutt))::  PPuurree IInnppuutt ffrroomm ffiilleess

    aauutthhoorr
         - Ulrich Neumerkel
         - Jan Wielemaker

    TToo bbee ddoonnee
         -  Provide support  for  alternative  input readers,  e.g.
         reading terms, tokens, etc.
         - Support  non-repositioning streams, such  as sockets and
         pipes.

This module  is part  of pio.pl,  dealing with _p_u_r_e  _i_n_p_u_t:   processing
input  streams from  the outside  world using  pure predicates,  notably
grammar  rules  (DCG). Using  pure  predicates  makes  non-deterministic
processing of input much simpler.

Pure input uses  coroutining (freeze/2) to read input from  the external
source into  a list _o_n  _d_e_m_a_n_d.   The overhead of  lazy reading is  more
than compensated for by using block reads based on read_pending_input/3.


pphhrraassee__ffrroomm__ffiillee((_:_G_r_a_m_m_a_r_, _+_F_i_l_e))                               _[_n_o_n_d_e_t_]
    Process  the  content of  _F_i_l_e using  the  DCG rule  _G_r_a_m_m_a_r.    The
    space  usage of  this mechanism  depends on  the length  of the  not
    committed  part of _G_r_a_m_m_a_r.   Committed parts of the temporary  list
    are  reclaimed by the garbage collector, while the list  is extended
    on demand.   Here is a very simple definition for searching a string
    in a file:

    ____________________________________________________________________|                                                                    |
    | ... --> []|[_],... .                                               |
    |                                                                    |
    | file_contains(File, Pattern) :-                                    |

    |         phrase_from_file((..., Pattern, ...), File).               |
    |                                                                    |
    | match_count(File, Pattern, Count) :-                               |
    |         findall(x, file_contains(File, Pattern), Xs),              |
    ||________length(Xs,_Count).________________________________________ ||

    This can be called  as (note that the pattern must be a string (code
    list)):

    ____________________________________________________________________|                                                                    |
    ||?-_match_count('pure_input.pl',_"file",_Count).___________________ ||


pphhrraassee__ffrroomm__ffiillee((_:_G_r_a_m_m_a_r_, _+_F_i_l_e_, _+_O_p_t_i_o_n_s))                     _[_n_o_n_d_e_t_]
    As  phrase_from_file/2,  providing additional _O_p_t_i_o_n_s.   _O_p_t_i_o_n_s  are
    passed  to  open/4,  except  for buffer_size,  which  is  passed  to
    set_stream/2.   If  not specified,  the default buffer  size is  512
    bytes.   Of  particular importance are  the open/4 options type  and
    encoding.


pphhrraassee__ffrroomm__ssttrreeaamm((_:_G_r_a_m_m_e_r_, _+_S_t_r_e_a_m))
    Helper  for  phrase_from_file/3.     This predicate  cooperates  with
    syntax_error//1 to generate syntax error locations for grammars.


ssyynnttaaxx__eerrrroorr((_+_E_r_r_o_r)) //
    Throw  the syntax error _E_r_r_o_r at the current location of  the input.
    This  predicate  is  designed  to  be called  from  the  handler  of
    phrase_from_file/3.

         tthhrroowwss error(syntax_error(Error), Location)


llaazzyy__lliisstt__llooccaattiioonn((_-_L_o_c_a_t_i_o_n)) //                                   _[_d_e_t_]
    Determine  current  (error) location  in a  lazy list.    True  when
    _L_o_c_a_t_i_o_n  is an  (error) location term  that represents the  current
    location in the DCG list.

    ___________________________________________________________Arguments_
     _L_o_c_a_t_i_o_n  is   a  term   file(Name, Line, LinePos, CharNo)
               or  stream(Stream, Line, LinePos, CharNo) if  no
               file  is associated to the stream  RestLazyList.
               Finally, if the Lazy list is fully  materialized
               (ends   in  []),   _L_o_c_a_t_i_o_n   is  unified   with
               end_of_file-CharCount.

         SSeeee aallssoo lazy_list_character_count//1  only  provides  the
             character count.


llaazzyy__lliisstt__cchhaarraacctteerr__ccoouunntt((_-_C_h_a_r_C_o_u_n_t)) //
    True  when _C_h_a_r_C_o_u_n_t  is  the current  character count  in the  Lazy
    list.   The character count  is computed by finding the distance  to
    the next frozen tail of the lazy list.  _C_h_a_r_C_o_u_n_t is one of:

      o  An integer

      o  A term end_of_file-Count

         SSeeee aallssoo lazy_list_location//1  provides  full details  of
             the location for error reporting.


ssttrreeaamm__ttoo__llaazzyy__lliisstt((_+_S_t_r_e_a_m_, _-_L_i_s_t))                                 _[_d_e_t_]
    Create  a lazy list representing the character codes in _S_t_r_e_a_m.   It
    must be possible to  reposition _S_t_r_e_a_m.  _L_i_s_t is a list that ends in
    a  delayed goal.   _L_i_s_t can be  unified completely transparent to  a
    (partial)  list and processed  transparently using DCGs, but  please
    be aware that a  lazy list is not the same as a materialized list in
    all respects.

    Typically, this predicate  is used as a building block for more high
    level safe predicates such as phrase_from_file/2.

         TToo bbee ddoonnee Enhance of lazy list throughout the system.


1122..2233 lliibbrraarryy((pprreeddiiccaattee__ooppttiioonnss))::   DDeeccllaarree  ooppttiioonn--pprroocceessssiinngg ooff  pprreeddii--
      ccaatteess

               _D_i_s_c_u_s_s_i_o_n_s _w_i_t_h _J_e_f_f _S_c_h_u_l_t_z _h_e_l_p_e_d _s_h_a_p_i_n_g _t_h_i_s _l_i_b_r_a_r_y


1122..2233..11 TThhee ssttrreennggtthh aanndd wweeaakknneessss ooff pprreeddiiccaattee ooppttiioonnss

Many  ISO  predicates  accept   options,  e.g.,   open/4,  write_term/3.
Options  offer an  attractive  alternative  to proliferation  into  many
predicates and using high-arity predicates.  Properly  defined and used,
they also  form a  mechanism for extending  the API  of both system  and
application predicates without  breaking portability.  I.e.,  previously
fixed behaviour  can be replaced by  dynamic behaviour controlled by  an
option  where the  default is  the previously  defined fixed  behaviour.
The  alternative to  using  options is  to  add an  additional  argument
and maintain  the previous  definition.   While a  series of  predicates
with  increasing arity  is adequate  for a  small  number of  additional
parameters, the untyped  positional argument handling of Prolog  quickly
makes this unmanageable.

The ISO standard  uses the extensibility offered by options  by allowing
implementations to extend  the set of accepted  options.  While  options
form a  perfect solution to  maintain backward  portability in a  linear
development  model, it  is not  well equipped  to  deal with  concurrent
branches because

 1. There is no API  to find which options are supported in a particular
    implementation.

 2. While  the  portability problem  caused by  a  missing predicate  in
    Prolog _A can  easily be solved by implementing this predicate, it is
    much harder to  add processing of an additional option to an already
    existing predicate.

Different Prolog implementations  can be seen as concurrent  development
branches of the  Prolog language.   Different sets of supported  options
pose a serious  portability issue.   Using an option _O that  establishes
the desired behaviour  on system _A leads  (on most systems) to an  error
or system _B. Porting may require several actions:

  o Drop  _O (if the option is not  vital, such as the layout  options to
    write_term/3)

  o Replace _O by _O_2 (i.e., a differently named option doing the same)

  o Something  else  (cannot be  ported;  requires a  totally  different
    approach, etc.)

Predicates that process options are particularly a  problem when writing
a compatibility layer to  run programs developed for System _A  on System
_B  because  complete  emulation is  often  hard,  may  cause  a  serious
slowdown and  is often not  needed because the  application-to-be-ported
only uses options that are shared by all  target Prolog implementations.
Unfortunately,  the  consequences  of  a  partial  emulation  cannot  be
assessed by tools.


1122..2233..22 OOppttiioonnss aass aarrgguummeennttss oorr eennvviirroonnmmeenntt??

We distinguish two views on  options.  One is to see them  as additional
parameters that require  strict existence, type and domain-checking  and
the other  is to consider them  `locally scoped environment  variables'.
Most systems  adopt the  first option.   SWI-Prolog  adopts the  second:
it silently  ignores options that  are not supported  but does type  and
domain checking  of option-values.   The `environment' view is  commonly
used in applications to create predicates supporting  more options using
the skeleton  below.   This way of programming  requires that _p_r_e_d_1  and
_p_r_e_d_2 do  not interpret  the same option  differently.   In cases  where
this is  not true,  the options  must be distributed  by _s_o_m_e___p_r_e_d.    We
have been using  this programming style for  many years and in  practice
it  turns out  that  the need  for  active  distribution of  options  is
rare.  I.e.,  options either have distinct names or  multiple predicates
implement the same option  but this has the desired effect.   An example
of  the latter  is the  encoding  option, which  typically needs  to  be
applied consistently.

________________________________________________________________________|                                                                        |
|some_pred(..., Options) :-                                              |

|      pred1(..., Options),                                              |
||_____pred2(...,_Options)._____________________________________________ ||

As stated before,  options provide a readable alternative  to high-arity
predicates and offer  a robust mechanism to  evolve the API, but at  the
cost  of some  runtime overhead  and weaker  consistency checking,  both
at compiletime  and runtime.    From our  experience, the  `environment'
approach is  productive, but  the consequence is  that mistyped  options
are  silently ignored.    The option  infrastructure  described in  this
section tries to remedy these problems.


1122..2233..33 IImmpprroovviinngg oonn tthhee ccuurrrreenntt ssiittuuaattiioonn

Whether  we see  options  as  arguments or  locally  scoped  environment
variables, the most obvious  way to improve on the current  situation is
to provide  reflective support for options:   discover that an  argument
is  an option-list  and find  what options  are supported.    Reflective
access  to  options  can  be  used  by  the   compiler  and  development
environment as well as by the runtime system to warn or throw errors.


1122..2233..33..11 OOppttiioonnss aass ttyyppeess

An obvious  approach to  deal with  options is to  define the  different
possible option values  as a type and  type the argument that  processes
the option  as list(<option_type>),  as illustrated below.   Considering
options as  types fully  covers the  case where we  consider options  as
additional parameters.

________________________________________________________________________|                                                                        |
|:- type open_option ---> type(stream_type) |                            |

|                         alias(atom) | ... .                            |
|:-|pred_open(source_sink,_open_mode,_stream,_list(open_option))._______ |  |

There are three reasons for considering a different approach:

  o There  is no  consensus about  types  in the  Prolog world,  neither
    about  what types  should look  like, nor  whether or  not they  are
    desirable.    It is  not likely that  this debate  will be  resolved
    shortly.

  o Considering  options as  types  does not  support the  `environment'
    view, which we consider the most productive.

  o Even  when using types,  we need reflective  access to what  options
    are  provided  in order  to  be able  to  write compile  or  runtime
    conditional code.


1122..2233..33..22 RReefflleeccttiivvee aacccceessss ttoo ooppttiioonnss

From  the above,  we  conclude  that  we require  reflective  access  to
find  out whether  an option  is supported  and valid  for a  particular
predicate.  Possible option  values must be described by types.   Due to
lack of a type system, we use library(error)  to describe allowed option
values.  Predicate options are declared using predicate_options/3:


pprreeddiiccaattee__ooppttiioonnss((_:_P_I_, _+_A_r_g_, _+_O_p_t_i_o_n_s))                             _[_d_e_t_]
    Declare that the predicate  _P_I processes options on _A_r_g.  _O_p_t_i_o_n_s is
    a list of options processed.  Each element is one of:

      o  Option(ModeAndType)  _P_I processes  Option.    The  option-value
         must comply to ModeAndType.  Mode is one of + or  - and Type is
         a type as accepted by must_be/2.

      o  pass_to(:_P_I,_A_r_g)  The  option-list is  passed to  the  indicated
         predicate.

    Below  is an example that  processes the option header(boolean)  and
    passes all options to open/4:

    ____________________________________________________________________|                                                                    |

    | :- predicate_options(write_xml_file/3, 3,                          |
    |                      [ header(boolean),                            |
    |                        pass_to(open/4, 4)                          |
    |                      ]).                                           |
    |                                                                    |

    | write_xml_file(File, XMLTerm, Options) :-                          |
    |     open(File, write, Out, Options),                               |
    |     (   option(header(true), Option, true)                         |
    |     ->  write_xml_header(Out)                                      |
    |     ;   true                                                       |
    |     ),                                                             |
    ||____...___________________________________________________________ ||

    This  predicate may only be used as a _d_i_r_e_c_t_i_v_e and is  processed by
    expand_term/2.  Option processing can be  specified at runtime using
    assert_predicate_options/3,  which is  intended to  support  program
    analysis.


aasssseerrtt__pprreeddiiccaattee__ooppttiioonnss((_:_P_I_, _+_A_r_g_, _+_O_p_t_i_o_n_s_, _?_N_e_w))            _[_s_e_m_i_d_e_t_]
    As  predicate_options(:_P_I, +_A_r_g,   +_O_p_t_i_o_n_s).    _N_e_w  is  a  boolean
    indicating  whether  the  declarations have  changed.    If  _N_e_w  is
    provided and false,  the predicate becomes semidet and fails without
    modifications if modifications are required.

The  predicates  below  realise the  support  for  compile  and  runtime
checking for supported options.


ccuurrrreenntt__pprreeddiiccaattee__ooppttiioonn((_:_P_I_, _?_A_r_g_, _?_O_p_t_i_o_n))                    _[_n_o_n_d_e_t_]
    True  when _A_r_g of _P_I processes  _O_p_t_i_o_n.  For example,  the following
    is true:

    ____________________________________________________________________|                                                                    |
    | ?- current_predicate_option(open/4, 4, type(text)).                |
    ||true._____________________________________________________________ ||

    This predicate is  intended to support conditional compilation using
    if/1  ...   endif/0.  The  predicate current_predicate_options/3 can
    be used to access the full capabilities of a predicate.


cchheecckk__pprreeddiiccaattee__ooppttiioonn((_:_P_I_, _+_A_r_g_, _+_O_p_t_i_o_n))                         _[_d_e_t_]
    Verify    predicate   options    at   runtime.         Similar    to
    current_predicate_option/3,   but   intended  to   support   runtime
    checking.

         EErrrroorrss
             -  existence_error(option, OptionName)  if  the option
             is not supported by _P_I.
             -  type_error(Type, Value) if the  option is supported
             but  the value does  not match the  option type.   See
             must_be/2.

The predicates below can be used in a development  environment to inform
the user  about supported  options.   PceEmacs uses  this for  colouring
option names and values.


ccuurrrreenntt__ooppttiioonn__aarrgg((_:_P_I_, _?_A_r_g))                                   _[_n_o_n_d_e_t_]
    True when _A_r_g of  _P_I processes predicate options.  Which options are
    processed can be accessed using current_predicate_option/3.


ccuurrrreenntt__pprreeddiiccaattee__ooppttiioonnss((_:_P_I_, _?_A_r_g_, _?_O_p_t_i_o_n_s))                  _[_n_o_n_d_e_t_]
    True  when _O_p_t_i_o_n_s is the  current active option declaration for  _P_I
    on _A_r_g.   See predicate_options/3for the  argument descriptions.  If
    _P_I  is ground and refers  to an undefined predicate, the  autoloader
    is used to obtain a definition of the predicate.

The  library  can  execute  a  complete  check  of  your  program  using
check_predicate_options/0:


cchheecckk__pprreeddiiccaattee__ooppttiioonnss                                            _[_d_e_t_]
    Analyse  loaded  program  for erroneous  options.    This  predicate
    decompiles the current  program and searches for calls to predicates
    that  process options.  For  each option list, it validates  whether
    the  provided  options  are  supported and  validates  the  argument
    type.   This predicate  performs partial dataflow analysis to  track
    option-lists inside a clause.

         SSeeee aallssoo derive_predicate_options/0 can be  used to derive
             declarations   for  predicates   that   pass  options.
             This  predicate   should  normally  be  called  before
             check_predicate_options/0.

The library  offers predicates that may  be used to create  declarations
for your application.   These predicates are designed to  cooperate with
the module system.


ddeerriivvee__pprreeddiiccaattee__ooppttiioonnss                                           _[_d_e_t_]
    Derive  new predicate option declarations.  This  predicate analyses
    the  loaded program to find  clauses that process options using  one
    of  the predicates from library(option)  or passes options to  other
    predicates  that  are known  to process  options.    The process  is
    repeated until no new declarations are retrieved.

         SSeeee aallssoo autoload/0  may  be used  to complete  the loaded
             program.


rreettrraaccttaallll__pprreeddiiccaattee__ooppttiioonnss                                       _[_d_e_t_]
    Remove all dynamically (derived) predicate options.


ddeerriivveedd__pprreeddiiccaattee__ooppttiioonnss((_:_P_I_, _?_A_r_g_, _?_O_p_t_i_o_n_s))                  _[_n_o_n_d_e_t_]
    Derive  option arguments using static  analysis.  True when  _O_p_t_i_o_n_s
    is the current _d_e_r_i_v_e_d active option declaration for _P_I on _A_r_g.


ddeerriivveedd__pprreeddiiccaattee__ooppttiioonnss((_+_M_o_d_u_l_e))                                 _[_d_e_t_]
    Derive  predicate option  declarations for  a module.   The  derived
    options are printed to the current_output stream.


1122..2244 lliibbrraarryy((pprroolloogg__ppaacckk))::  AA ppaacckkaaggee mmaannaaggeerr ffoorr PPrroolloogg

    SSeeee aallssoo  Installed   packages    can   be    inspected   using
         ?- doc_browser.

    TToo bbee ddoonnee
         - Version logic
         - Find and resolve conflicts
         - Upgrade git packages
         - Validate git packages
         - Test packages:  run tests from directory `test'.

The library(prolog_pack) provides the SWI-Prolog package manager.   This
library lets  you inspect installed  packages, install packages,  remove
packages, etc.   It is complemented by the  built-in attach_packs/0 that
makes installed packages available as libaries.


ppaacckk__lliisstt__iinnssttaalllleedd                                                _[_d_e_t_]
    List  currently  installed  packages.     Unlike  pack_list/1,  only
    locally  installed packages are displayed and no connection  is made
    to the internet.

         SSeeee aallssoo Use pack_list/1 to find packages.


ppaacckk__iinnffoo((_+_P_a_c_k))
    Print more detailed information about _P_a_c_k.


ppaacckk__sseeaarrcchh((_+_Q_u_e_r_y))                                                _[_d_e_t_]


ppaacckk__lliisstt((_+_Q_u_e_r_y))                                                  _[_d_e_t_]
    _Q_u_e_r_y  package server  and installed packages  and display  results.
    _Q_u_e_r_y  is matches case-insensitively against  the name and title  of
    known  and installed packages.  For each matching package,  a single
    line is displayed that provides:

      o  Installation status

           {{ pp:  package, not installed

           {{ ii:  installed package; up-to-date with public version

           {{ UU: installed package; can be upgraded

           {{ AA: installed package; newer than publically available

           {{ ll:  installed package; not on server

      o  Name@Version

      o  Name@Version(ServerVersion)

      o  Title

    Hint:  ?- pack_list(''). lists all packages.

    The  predicates pack_list/1 and  pack_search/1 are synonyms.    Both
    contact  the  package server  at http://www.swi-prolog.org  to  find
    available packages.

         SSeeee aallssoo pack_list_installed/0 to  list installed packages
             without contacting the server.


ppaacckk__iinnssttaallll((_+_S_p_e_c_:_a_t_o_m))                                           _[_d_e_t_]
    Install a package.  _S_p_e_c is one of

      o  Archive file name

      o  HTTP URL of an archive file name.  This URL  may contain a star
         (*) for the  version.   In this case pack_install asks for  the
         deirectory content and selects the latest version.

      o  GIT URL (not well supported yet)

      o  A local directory name

      o  A  package name.     This  queries the  package  repository  at
         http://www.swi-prolog.org

    After  resolving the type of  package, pack_install/2 is used to  do
    the actual installation.


ppaacckk__iinnssttaallll((_+_N_a_m_e_, _+_O_p_t_i_o_n_s))                                      _[_d_e_t_]
    Install  package  _N_a_m_e.    Processes the  options  below.    Default
    options as  would be used by pack_install/1are  used to complete the
    provided _O_p_t_i_o_n_s.

    uurrll((_+_U_R_L))
         Source for downloading the package

    ppaacckkaaggee__ddiirreeccttoorryy((_+_D_i_r))
         Directory into which to install the package

    iinntteerraaccttiivvee((_+_B_o_o_l_e_a_n))
         Use  default answer  without  asking the  user  if there  is  a
         default action.

    ssiilleenntt((_+_B_o_o_l_e_a_n))
         If  true  (default  false),   suppress  informational  progress
         messages.

    uuppggrraaddee((_+_B_o_o_l_e_a_n))
         If true  (default  false),  upgrade package  if it  is  already
         installed.

    ggiitt((_+_B_o_o_l_e_a_n))
         If true  (default false  unless _U_R_L ends  with =.git=),  assume
         the URL is a GIT repository.

    Non-interactive  installation can  be established  using the  option
    interactive(false).    It is  adviced to install  from a  particular
    _t_r_u_s_t_e_d   URL  instead  of  the  plain  pack  name   for  unattented
    operation.


ppaacckk__uurrll__ffiillee((_+_U_R_L_, _-_F_i_l_e))                                         _[_d_e_t_]
    True  if _F_i_l_e is  a unique id for  the referenced pack and  version.
    Normally, that is  simply the base name, but GitHub archives destroy
    this picture.  Needed by the pack manager.


ppaacckk__rreebbuuiilldd((_+_P_a_c_k))                                                _[_d_e_t_]
    Rebuilt possible foreign components of _P_a_c_k.


ppaacckk__rreebbuuiilldd                                                       _[_d_e_t_]
    Rebuild foreign components of all packages.


eennvviirroonnmmeenntt((_-_N_a_m_e_, _-_V_a_l_u_e))                           _[_n_o_n_d_e_t_,_m_u_l_t_i_f_i_l_e_]
    Hook   to  define  the  environment  for  building  packs.      This
    Multifile hook extends  the process environment for building foreign
    extensions.    A  value  provided by  this hook  overrules  defaults
    provided  by  def_environment/2.     In  addition  to  changing  the
    environment,  this  may be  used to  pass additional  values to  the
    environment, as in:

    ____________________________________________________________________|                                                                    |
    | prolog_pack:environment('USER', User) :-                           |
    ||____getenv('USER',_User)._________________________________________ ||

    ___________________________________________________________Arguments_
     _N_a_m_e   is an atom denoting a valid variable name
     _V_a_l_u_e  is  either an  atom or  number representing  the
            value of the variable.


ppaacckk__uuppggrraaddee((_+_P_a_c_k))                                            _[_s_e_m_i_d_e_t_]
    Try to upgrade the package _P_a_c_k.

         TToo bbee ddoonnee Update  dependencies when updating  a pack from
             git?


ppaacckk__rreemmoovvee((_+_N_a_m_e))                                                 _[_d_e_t_]
    Remove the indicated package.


ppaacckk__pprrooppeerrttyy((_?_P_a_c_k_, _?_P_r_o_p_e_r_t_y))                                 _[_n_o_n_d_e_t_]
    True  when  _P_r_o_p_e_r_t_y is  a property  of  _P_a_c_k.   This  interface  is
    intended  for  programs  that  wish to  interact  with  the  package
    manager.  Defined properties are:

    ddiirreeccttoorryy((_D_i_r_e_c_t_o_r_y))
         _D_i_r_e_c_t_o_r_y into which the package is installed

    vveerrssiioonn((_V_e_r_s_i_o_n))
         Installed version

    ttiittllee((_T_i_t_l_e))
         Full title of the package

    aauutthhoorr((_A_u_t_h_o_r))
         Registered author

    ddoowwnnllooaadd((_U_R_L))
         Official download _U_R_L

    rreeaaddmmee((_F_i_l_e))
         Package README file (if present)

    ttooddoo((_F_i_l_e))
         Package TODO file (if present)


1122..2255 lliibbrraarryy((pprroolloogg__xxrreeff))::  CCrroossss--rreeffeerreennccee ddaattaa ccoolllleeccttiioonn lliibbrraarryy

This library collects information on defined and used  objects in Prolog
source  files.    Typically these  are  predicates,  but we  expect  the
library  to deal  with  other types  of  objects in  the  future.    The
library  is a  building block  for tools  doing  dependency tracking  in
applications.  Dependency tracking is useful to reveal  the structure of
an unknown  program or detect  missing components  at compile time,  but
also for program  transformation or minimising a program saved  state by
only saving the reachable objects.

This section gives  a partial description of the library  API, providing
some insight  in how you  can use it  for analysing your  program.   The
library should be  further modularized, moving its knowledge about,  for
example, XPCE  into a different file  and allowing for adding  knowledge
about other  libraries such  as Logtalk.   PPlleeaassee  ddoo nnoott ccoonnssiiddeerr  tthhiiss
iinntteerrffaaccee rroocckk--ssoolliidd..

The  library is  exploited  by two  graphical  tools in  the  SWI-Prolog
environment:   the XPCE front-end  started by  gxref/0 and described  in
section 3.7,  and PceEmacs  (section 3.4),  which exploits this  library
for its syntax colouring.

For  all predicates  described  below,  _S_o_u_r_c_e  is the  source  that  is
processed.    This is  normally a  filename in  any notation  acceptable
to the  file loading  predicates (see  load_files/2).    Using the  hooks
defined  in  section  12.25.1  it can  be  anything  else  that  can  be
translated into a  Prolog stream holding Prolog  source text.   _C_a_l_l_a_b_l_e
is a callable  term (see callable/1).   Callables do not carry a  module
qualifier unless  the referred predicate  is not  in the module  defined
_S_o_u_r_c_e.


xxrreeff__ssoouurrccee((_+_S_o_u_r_c_e))
    Gather information on  _S_o_u_r_c_e.  If _S_o_u_r_c_e has already been processed
    and  is still up-to-date according to the file timestamp,  no action
    is  taken.     This  predicate  must be  called  on  a  file  before
    information can be gathered.


xxrreeff__ccuurrrreenntt__ssoouurrccee((_?_S_o_u_r_c_e))
    _S_o_u_r_c_e has been processed.


xxrreeff__cclleeaann((_+_S_o_u_r_c_e))
    Remove the information gathered for _S_o_u_r_c_e


xxrreeff__ddeeffiinneedd((_?_S_o_u_r_c_e_, _?_C_a_l_l_a_b_l_e_, _-_H_o_w))
    _C_a_l_l_a_b_l_e is defined in _S_o_u_r_c_e.  _H_o_w is one of

             dynamic(_L_i_n_e)       Declared dynamic at _L_i_n_e

             thread_local(_L_i_n_e)  Declared thread local at _L_i_n_e
             multifile(_L_i_n_e)     Declared multifile at _L_i_n_e
             local(_L_i_n_e)         First clause at _L_i_n_e
             foreign(_L_i_n_e)       Foreign library loaded at _L_i_n_e
             constraint(_L_i_n_e)    CHR Constraint at _L_i_n_e
             imported(_F_i_l_e)      Imported from _F_i_l_e


xxrreeff__ccaalllleedd((_?_S_o_u_r_c_e_, _?_C_a_l_l_a_b_l_e_, _?_B_y))
    _C_a_l_l_a_b_l_e is called in _S_o_u_r_c_e by _B_y.


xxrreeff__eexxppoorrtteedd((_?_S_o_u_r_c_e_, _?_C_a_l_l_a_b_l_e))
    _C_a_l_l_a_b_l_e is public (exported from the module).


xxrreeff__mmoodduullee((_?_S_o_u_r_c_e_, _?_M_o_d_u_l_e))
    _S_o_u_r_c_e is a module file defining the given module.


xxrreeff__bbuuiilltt__iinn((_?_C_a_l_l_a_b_l_e))
    True  if  _C_a_l_l_a_b_l_e is  a  built-in predicate.    Currently  this  is
    assumed  for all predicates defined in the system module  and having
    the  property built_in.  Built-in  predicates are not registered  as
    `called'.


1122..2255..11 EExxtteennddiinngg tthhee lliibbrraarryy

The library provides hooks  for extending the rules it uses  for finding
predicates called by some programming construct.


pprroolloogg::ccaalllleedd__bbyy((_+_G_o_a_l_, _-_C_a_l_l_e_d))
    _G_o_a_l is a  non-var subgoal appearing in the called object (typically
    a  clause body).   If  it succeeds it  must return  a list of  goals
    called  by _G_o_a_l.    As a  special construct,  if a  term Callable +N
    is  returned,  N variable  arguments are  added to  _C_a_l_l_a_b_l_e before
    further  processing.  For simple meta-calls a single  fact suffices.
    Complex  rules as  used in  the html_write library  provided by  the
    HTTP  package examine  the  arguments and  create a  list of  called
    objects.

    The  current  system   cannot  deal  with  the  same  name/arity  in
    different  modules that  behave differently with  respect to  called
    arguments.


1122..2266 lliibbrraarryy((qquuaassii__qquuoottaattiioonnss))::  DDeeffiinnee QQuuaassii QQuuoottaattiioonn ssyynnttaaxx

    aauutthhoorr  Jan Wielemaker.    Introduction of Quasi  Quotation was
         suggested by Michael Hendricks.

    SSeeee aallssoo  Why it's nice to be quoted:  quasiquoting for haskell

Inspired  by  Haskell,  SWI-Prolog  support  _q_u_a_s_i  _q_u_o_t_a_t_i_o_n.     Quasi
quotation allows  for embedding (long)  strings using  the syntax of  an
external  language (e.g.,  HTML, SQL)  in Prolog  text and  syntax-aware
embedding of Prolog variables  in this syntax.  At the same  time, quasi
quotation provides  an alternative to represent  long strings and  atoms
in Prolog.

The basic  form of a  quasi quotation is  defined below.   Here,  _S_y_n_t_a_x
is an  arbitrary Prolog term  that must parse into  a _c_a_l_l_a_b_l_e (atom  or
compound) term  and Quotation  is an arbitrary  sequence of  characters,
not including the sequence  |}.  If this sequence needs to  be embedded,
it must be escaped according to the rules of the  target language or the
`quoter' must provide an escaping mechanism.

________________________________________________________________________|                                                                        |

|{|Syntax||Quotation|}|_________________________________________________ |                     |

While reading  a Prolog  term, and  if the Prolog  flag quasi_quotes  is
set to true  (which is the case if  this library is loaded), the  parser
collects  quasi quotations.    After reading  the final  full stop,  the
parser makes  the call  below.   Here,  _S_y_n_t_a_x_N_a_m_e is  the functor  name
of _S_y_n_t_a_x above  and _S_y_n_t_a_x_A_r_g_s is a  list holding the arguments,  i.e.,
Syntax =.. [SyntaxName|SyntaxArgs].  Splitting the syntax  into its name
and arguments  is done to  make the quasi  quotation parser a  predicate
with  a consistent  arity  4, regardless  of  the number  of  additional
arguments.

________________________________________________________________________|                                                                        |
|call(+SyntaxName,|+Content,_+SyntaxArgs,_+VariableNames,_-Result)______ |                 |

The arguments are defined as

  o _S_y_n_t_a_x_N_a_m_e  is the principal functor of the quasi  quotation syntax.
    This  must be declared using quasi_quotation_syntax/1and  there must
    be a predicate SyntaxName/4.

  o _C_o_n_t_e_n_t  is an  opaque term that  carries the  content of the  quasi
    quoted material and  position information about the source code.  It
    is passed to with_quasi_quote_input/3.

  o _S_y_n_t_a_x_A_r_g_s  carries the additional arguments  of the _S_y_n_t_a_x.   These
    are  commonly used to make the parameter passing between  the clause
    and the quasi quotation explicit.  For example:

    ____________________________________________________________________|                                                                    |

    |     ...,                                                           |
    |     {|html(Name, Address)||                                        |
    |      <tr><td>Name<td>Address</tr>                                  |
    ||_____|}___________________________________________________________ ||

  o _V_a_r_i_a_b_l_e_N_a_m_e_s  is the  complete  variable dictionary  of the  clause
    as  it   is  made  available  throug  read_term/3  with  the  option
    variable_names.  It is a list of terms Name = Var.

  o _R_e_s_u_l_t  is  a  variable that  must  be  unified to  resulting  term.
    Typically,  this  term  is structured  Prolog  tree that  carries  a
    (partial)  representation of the abstract syntax tree  with embedded
    variables  that pass the Prolog parameters.   This term is  normally
    either  passed to  a predicate that  serializes the abstract  syntax
    tree,  or a  predicate that  processes the  result in Prolog.    For
    example,  HTML  is  commonly  embedded for  writing  HTML  documents
    (see  library(http/html_write)).  Examples of languages that  may be
    embedded  for processing  in Prolog  are SPARQL,  RuleML or  regular
    expressions.

The  file library(http/html_quasiquotations)  provides the,  suprisingly
simple, quasi quotation parser for HTML.


wwiitthh__qquuaassii__qquuoottaattiioonn__iinnppuutt((_+_C_o_n_t_e_n_t_, _-_S_t_r_e_a_m_, _:_G_o_a_l))                _[_d_e_t_]
    Process  the  quasi-quoted  _C_o_n_t_e_n_t  using _S_t_r_e_a_m  parsed  by  _G_o_a_l.
    _S_t_r_e_a_m is a temporary stream with the following properties:

      o  Its initial _p_o_s_i_t_i_o_n  represents the position  of the start  of
         the quoted material.

      o  It is a text stream, using utf8 _e_n_c_o_d_i_n_g.

      o  It allows for repositioning

      o  It will be closed after _G_o_a_l completes.

    ___________________________________________________________Arguments_
     _G_o_a_l  is  executed as once(Goal).  _G_o_a_l must  succeed.
           Failure or exceptions from _G_o_a_l are  interpreted
           as syntax errors.

         SSeeee aallssoo phrase_from_quasi_quotation/2  can  be   used  to
             process a quotation using a grammar.


pphhrraassee__ffrroomm__qquuaassii__qquuoottaattiioonn((_:_G_r_a_m_m_a_r_, _+_C_o_n_t_e_n_t))                     _[_d_e_t_]
    Process  the quasi quotation using the DCG _G_r_a_m_m_a_r.  Failure  of the
    grammer is interpreted as a syntax error.

         SSeeee aallssoo with_quasi_quotation_input/3 for  processing quo-
             tations from stream.


qquuaassii__qquuoottaattiioonn__ssyynnttaaxx((_:_S_y_n_t_a_x_N_a_m_e))                                _[_d_e_t_]
    Declare the predicate  _S_y_n_t_a_x_N_a_m_e/4 to implement the the quasi quote
    syntax _S_y_n_t_a_x_N_a_m_e.  Normally used as a directive.


qquuaassii__qquuoottaattiioonn__ssyynnttaaxx__eerrrroorr((_+_E_r_r_o_r))
    Report  syntax_error(Error) using the current location in  the quasi
    quoted input parser.

         tthhrroowwss error(syntax_error(Error), Position)


1122..2277 lliibbrraarryy((rraannddoomm))::  RRaannddoomm nnuummbbeerrss

    aauutthhoorr  R.A. O'Keefe, V.S. Costa, L. Damas, Jan Wielemaker

    SSeeee aallssoo  Built-in function random/1:  A is random(10)

This  library  is  derived  from the  DEC10  library  random.     Later,
the  core random  generator was  moved to  C. The  current version  uses
the SWI-Prolog  arithmetic functions  to realise  this library.    These
functions are based on the GMP library.


rraannddoomm((_-_R_:_f_l_o_a_t))                                                  _[_d_e_t_]
    Binds _R to a new random float in the _o_p_e_n interval (0.0,1.0).

         SSeeee aallssoo
             -  setrand/1, getrand/1 may  be used  to fetch/set the
             state.
             -  In  SWI-Prolog,  random/1  is  implemented  by  the
             function random_float/0.


rraannddoomm__bbeettwweeeenn((_+_L_:_i_n_t_, _+_U_:_i_n_t_, _-_R_:_i_n_t))                         _[_s_e_m_i_d_e_t_]
    Binds  _R to a random  integer in [_L,_U]  (i.e., including both _L  and
    _U). Fails silently if _U<_L.


rraannddoomm((_+_L_:_i_n_t_, _+_U_:_i_n_t_, _-_R_:_i_n_t))                                    _[_d_e_t_]


rraannddoomm((_+_L_:_f_l_o_a_t_, _+_U_:_f_l_o_a_t_, _-_R_:_f_l_o_a_t))                              _[_d_e_t_]
    Generate a random integer or  float in a range.  If _L and _U are both
    integers, _R is a  random integer in the half open interval [_L,_U). If
    _L and _U are both floats, _R is a float in the open interval (_L,_U).

         ddeepprreeccaatteedd Please  use  random/1 for  generating  a random
             float  and  random_between/3 for  generating  a random
             integer.   Note that the random_between/3 includes the
             upper  bound, while this predicate  excludes the upper
             bound.


sseettrraanndd((_+_S_t_a_t_e))                                                   _[_d_e_t_]


ggeettrraanndd((_-_S_t_a_t_e))                                                   _[_d_e_t_]
    Query/set  the state of the random generator.  This is  intended for
    restarting  the generator  at a  known state  only.   The  predicate
    setrand/1  accepts an opaque term returned by getrand/1.   This term
    may  be asserted, written  and read.   The application may not  make
    other assumptions about this term.

    For  compatibility  reasons with  older  versions of  this  library,
    setrand/1  also accepts  a term rand(A,B,C),  where A,  B and C  are
    integers in the range  1..30,000.  This argument is used to seed the
    random generator.  Deprecated.

         EErrrroorrss existence_error(random_state, _)  is raised  if the
             underlying  infrastructure  cannot  fetch  the  random
             state.   This is  currently the case  if SWI-Prolog is
             not compiled with the GMP library.

         SSeeee aallssoo set_random/1  and  random_property/1 provide  the
             SWI-Prolog native implementation.


mmaayybbee                                                         _[_s_e_m_i_d_e_t_]
    Succeed/fail with equal probability (variant of maybe/1).


mmaayybbee((_+_P))                                                     _[_s_e_m_i_d_e_t_]
    Succeed with probability _P, fail with probability 1-_P


mmaayybbee((_+_K_, _+_N))                                                 _[_s_e_m_i_d_e_t_]
    Succeed with probability _K/_N (variant of maybe/1)


rraannddoomm__ppeerrmm22((_?_A_, _?_B_, _?_X_, _?_Y))                                   _[_s_e_m_i_d_e_t_]
    Does _X=_A,_Y=_B or _X=_B,_Y=_A with equal probability.


rraannddoomm__mmeemmbbeerr((_-_X_, _+_L_i_s_t_:_l_i_s_t))                                  _[_s_e_m_i_d_e_t_]
    _X  is  a random  member of  _L_i_s_t.   Equivalent  to random_between(1,
    |_L_i_s_t|), followed by nth1/3.  Fails of _L_i_s_t is the empty list.

         CCoommppaattiibbiilliittyy Quintus and SICStus libraries.


rraannddoomm__sseelleecctt((_-_X_, _+_L_i_s_t_, _-_R_e_s_t))                                _[_s_e_m_i_d_e_t_]


rraannddoomm__sseelleecctt((_+_X_, _-_L_i_s_t_, _+_R_e_s_t))                                    _[_d_e_t_]
    Randomly  select or insert an element.  Either _L_i_s_t or _R_e_s_t  must be
    a list.  Fails if _L_i_s_t is the empty list.

         CCoommppaattiibbiilliittyy Quintus and SICStus libraries.


rraannddsseett((_+_K_:_i_n_t_, _+_N_:_i_n_t_, _-_S_:_l_i_s_t_(_i_n_t_)))                             _[_d_e_t_]
    _S  is a sorted list of _K  unique random integers in the  range 1.._N.
    Implemented  by enumerating  1.._N and  deciding whether  or not  the
    number should be part of the set.  For example:

    ____________________________________________________________________|                                                                    |
    | ?- randset(5, 5, S).                                               |

    | S = [1, 2, 3, 4, 5].                (always)                       |
    | ?- randset(5, 20, S).                                              |
    ||S_=_[2,_7,_10,_19,_20].___________________________________________ ||

         SSeeee aallssoo randseq/3.

         bbuugg Slow if _N is large and _K is small.


rraannddsseeqq((_+_K_:_i_n_t_, _+_N_:_i_n_t_, _-_L_i_s_t_:_l_i_s_t_(_i_n_t_)))                          _[_d_e_t_]
    S  is a  list of _K  unique random  integers in the  range 1.._N.  The
    order is random.  Works as if defined by the following code.

    ____________________________________________________________________|                                                                    |
    | randseq(K, N, List) :-                                             |

    |       randset(K, N, Set),                                          |
    ||______random_permutation(Set,_List).______________________________ ||

         SSeeee aallssoo randset/3.


rraannddoomm__ppeerrmmuuttaattiioonn((_+_L_i_s_t_, _-_P_e_r_m_u_t_a_t_i_o_n))                            _[_d_e_t_]


rraannddoomm__ppeerrmmuuttaattiioonn((_-_L_i_s_t_, _+_P_e_r_m_u_t_a_t_i_o_n))                            _[_d_e_t_]
    _P_e_r_m_u_t_a_t_i_o_n  is a random permutation of  _L_i_s_t.  This is intended  to
    process  the elements of  _L_i_s_t in  random order.   The predicate  is
    symmetric.

         EErrrroorrss instantiation_error, type_error(list, _).


1122..2288 lliibbrraarryy((rreeaadduuttiill))::  RReeaaddiinngg lliinneess,, ssttrreeaammss aanndd ffiilleess

This library contains  primitives to read lines, files,  multiple terms,
etc.   The package clib provides  a shared object (DLL) named  readutil.
If the  library can locate  this shared object it  will use the  foreign
implementation for  reading character codes.   Otherwise  it will use  a
Prolog implementation.    Distributed applications should  make sure  to
deliver the  readutil shared object if  performance of these  predicates
is critical.


rreeaadd__lliinnee__ttoo__ccooddeess((_+_S_t_r_e_a_m_, _-_C_o_d_e_s))
    Read  the  next line  of  input from  _S_t_r_e_a_m  and unify  the  result
    with  _C_o_d_e_s _a_f_t_e_r the  line has  been read.   A line  is ended by  a
    newline character or end-of-file.  Unlike  read_line_to_codes/3, this
    predicate removes a trailing newline character.

    On  end-of-file  the  atom  end_of_file  is  returned.     See  also
    at_end_of_stream/[0,1].


rreeaadd__lliinnee__ttoo__ccooddeess((_+_S_t_r_e_a_m_, _-_C_o_d_e_s_, _?_T_a_i_l))
    Difference-list  version  to  read  an  input  line  to  a  list  of
    character  codes.    Reading  stops at  the newline  or  end-of-file
    character,  but unlike read_line_to_codes/2, the newline  is retained
    in  the output.  This  predicate is especially useful for reading  a
    block  of lines up to some  delimiter.  The following example  reads
    an HTTP header ended by a blank line:

    ____________________________________________________________________|                                                                    |
    | read_header_data(Stream, Header) :-                                |

    |         read_line_to_codes(Stream, Header, Tail),                  |
    |         read_header_data(Header, Stream, Tail).                    |
    |                                                                    |
    | read_header_data("\r\n", _, _) :- !.                               |
    | read_header_data("\n", _, _) :- !.                                 |
    | read_header_data("", _, _) :- !.                                   |
    | read_header_data(_, Stream, Tail) :-                               |
    |         read_line_to_codes(Stream, Tail, NewTail),                 |

    ||________read_header_data(Tail,_Stream,_NewTail).__________________ ||


rreeaadd__ssttrreeaamm__ttoo__ccooddeess((_+_S_t_r_e_a_m_, _-_C_o_d_e_s))
    Read all input until end-of-file and unify the result to _C_o_d_e_s.


rreeaadd__ssttrreeaamm__ttoo__ccooddeess((_+_S_t_r_e_a_m_, _-_C_o_d_e_s_, _?_T_a_i_l))
    Difference-list version of read_stream_to_codes/2.


rreeaadd__ffiillee__ttoo__ccooddeess((_+_S_p_e_c_, _-_C_o_d_e_s_, _+_O_p_t_i_o_n_s))
    Read  a  file  to a  list  of  character codes.    _S_p_e_c  is  a  file
    specification  for  absolute_file_name/3.    _C_o_d_e_s is  the  resulting
    code  list.  _O_p_t_i_o_n_s  is a list of  options for absolute_file_name/3
    and open/4.   In addition, the option tail(_T_a_i_l) is defined, forming
    a difference-list.


rreeaadd__ffiillee__ttoo__tteerrmmss((_+_S_p_e_c_, _-_T_e_r_m_s_, _+_O_p_t_i_o_n_s))
    Read  a  file  to  a list  of  Prolog  terms  (see read/1).     _S_p_e_c
    is  a file  specification for  absolute_file_name/3.    _T_e_r_m_s is  the
    resulting  list of  Prolog  terms.   _O_p_t_i_o_n_s  is a  list of  options
    for  absolute_file_name/3 and  open/4.    In  addition,  the  option
    tail(_T_a_i_l) is defined, forming a difference-list.


1122..2299 lliibbrraarryy((rreeccoorrdd))::  AAcccceessss nnaammeedd ffiieellddss iinn aa tteerrmm

The  library  record  provides  named  access  to  fields  in  a  record
represented as a  compound term such as  point(X, Y).  The Prolog  world
knows various  approaches to solve this  problem, unfortunately with  no
consensus.   The approach taken by  this library is proposed by  Richard
O'Keefe on the SWI-Prolog mailinglist.

The  approach  automates  a  technique  commonly   described  in  Prolog
text-books,  where access and  modification predicates  are defined  for
the record type.   Such predicates  are subject to normal  import/export
as well as  analysis by cross-referencers.   Given the simple nature  of
the access  predicates, an  optimizing compiler can  easily inline  them
for optimal preformance.

A record  is defined  using the directive  record/1.   We introduce  the
library with a short example:

________________________________________________________________________|                                                                        |
|:- record point(x:integer=0, y:integer=0).                              |

|                                                                        |
|        ...,                                                            |
|        default_point(Point),                                           |
|        point_x(Point, X),                                              |
|        set_x_of_point(10, Point, Point1),                              |
|                                                                        |
||_______make_point([y(20)],_YPoint),___________________________________ ||

The principal functor  and arity of the  term used defines the name  and
arity of  the compound  used as  records.   Each  argument is  described
using a term of the format below.

    <_n_a_m_e>[:<_t_y_p_e>][=<_d_e_f_a_u_l_t>]

In this definition, <_n_a_m_e> is an atom defining the name of the argument,
<_t_y_p_e> is  an optional type  specification as  defined by must_be/2 from
library error,  and <_d_e_f_a_u_l_t> is the default  initial value.   The <_t_y_p_e>
defaults to  any.  If  no default value is  specified the default is  an
unbound variable.

A  record  declaration  creates  a  set  of   predicates  through  _t_e_r_m_-
_e_x_p_a_n_s_i_o_n.   We describe these predicates  below.  In this  description,
<_c_o_n_s_t_r_u_c_t_o_r> refers to  the name of the record  (`point' in the example
above) and <_n_a_m_e> to the name of an argument (field).

  o _d_e_f_a_u_l_t__<_c_o_n_s_t_r_u_c_t_o_r>_(_-_R_e_c_o_r_d_)
    Create  a new  record where  all fields have  their default  values.
    This is the same as make_<_c_o_n_s_t_r_u_c_t_o_r>([], Record).

  o _m_a_k_e__<_c_o_n_s_t_r_u_c_t_o_r>_(_+_F_i_e_l_d_s_, _-_R_e_c_o_r_d_)
    Create  a  new  record where  specified  fields have  the  specified
    values  and  remaining  fields  have  their default  value.     Each
    field  is specified as  a term <_n_a_m_e>(<_v_a_l_u_e>).   See example  in the
    introduction.

  o _m_a_k_e__<_c_o_n_s_t_r_u_c_t_o_r>_(_+_F_i_e_l_d_s_, _-_R_e_c_o_r_d_, _-_R_e_s_t_F_i_e_l_d_s_)
    Same as  make_<_c_o_n_s_t_r_u_c_t_o_r>/2, but named fields that do not appear in
    _R_e_c_o_r_d  are returned in _R_e_s_t_F_i_e_l_d_s.  This predicate is  motivated by
    option-list processing.  See library option.

  o <_c_o_n_s_t_r_u_c_t_o_r>_<_n_a_m_e>_(_R_e_c_o_r_d_, _V_a_l_u_e_)
    Unify _V_a_l_u_e with argument in _R_e_c_o_r_d named <_n_a_m_e>.

  o <_c_o_n_s_t_r_u_c_t_o_r>__d_a_t_a_(_?_N_a_m_e_, _+_R_e_c_o_r_d_, _?_V_a_l_u_e_)
    True  when _V_a_l_u_e is  the value for the  field named _N_a_m_e in  _R_e_c_o_r_d.
    This predicate does not perform type-checking.

  o _s_e_t__<_n_a_m_e>__o_f__<_c_o_n_s_t_r_u_c_t_o_r>_(_+_V_a_l_u_e_, _+_O_l_d_R_e_c_o_r_d_, _-_N_e_w_R_e_c_o_r_d_)
    Replace  the value for  <_n_a_m_e> in  _O_l_d_R_e_c_o_r_d by _V_a_l_u_e  and unify the
    result with _N_e_w_R_e_c_o_r_d.

  o _s_e_t__<_n_a_m_e>__o_f__<_c_o_n_s_t_r_u_c_t_o_r>_(_+_V_a_l_u_e_, _!_R_e_c_o_r_d_)
    Destructively  replace the argument <_n_a_m_e> in  _R_e_c_o_r_d by _V_a_l_u_e based
    on setarg/3.  Use with care.

  o _n_b___s_e_t__<_n_a_m_e>__o_f__<_c_o_n_s_t_r_u_c_t_o_r>_(_+_V_a_l_u_e_, _!_R_e_c_o_r_d_)
    As   above,   but  using  non-backtrackable   assignment  based   on
    nb_setarg/3.  Use with _e_x_t_r_e_m_e care.

  o _s_e_t__<_c_o_n_s_t_r_u_c_t_o_r>__f_i_e_l_d_s_(_+_F_i_e_l_d_s_, _+_R_e_c_o_r_d_0_, _-_R_e_c_o_r_d_)
    Set  multiple fields using  the same syntax  as make_<_c_o_n_s_t_r_u_c_t_o_r>/2,
    but starting with _R_e_c_o_r_d_0 rather than the default record.

  o _s_e_t__<_c_o_n_s_t_r_u_c_t_o_r>__f_i_e_l_d_s_(_+_F_i_e_l_d_s_, _+_R_e_c_o_r_d_0_, _-_R_e_c_o_r_d_, _-_R_e_s_t_F_i_e_l_d_s_)
    Similar  to  set_<_c_o_n_s_t_r_u_c_t_o_r>_fields/4, but  fields  not  defined by
    <_c_o_n_s_t_r_u_c_t_o_r> are returned in _R_e_s_t_F_i_e_l_d_s.

  o _s_e_t__<_c_o_n_s_t_r_u_c_t_o_r>__f_i_e_l_d_(_+_F_i_e_l_d_, _+_R_e_c_o_r_d_0_, _-_R_e_c_o_r_d_)
    Set a single field specified as a term <_n_a_m_e>(<_v_a_l_u_e>).


rreeccoorrdd((_+_S_p_e_c))
    The  construct  :- record Spec, ...  is  used to  define  access  to
    named  fields  in a  compound.    It  is subject  to  term-expansion
    (see  expand_term/2) and  cannot  be called  as a  predicate.    See
    section 12.29 for details.


1122..3300 lliibbrraarryy((rreeggiissttrryy))::  MMaanniippuullaattiinngg tthhee WWiinnddoowwss rreeggiissttrryy

The registry is only available on the MS-Windows  version of SWI-Prolog.
It loads  the foreign extension  plregtry.dll, providing the  predicates
described below.   This  library only makes  the most common  operations
on the registry available  through the Prolog user.  The  underlying DLL
provides a  more complete coverage of  the Windows registry API.  Please
consult  the  sources  in  pl/src/win32/foreign/plregtry.c  for  further
details.

In  all these  predicates,  _P_a_t_h refers  to a  `/' separated  path  into
the registry.   This  is _n_o_t an atom  containing `/'-characters as  used
for  filenames, but  a term  using the  functor  //2.   Windows  defines
the  following  roots for  the  registry:   classes_root,  current_user,
local_machine and users.


rreeggiissttrryy__ggeett__kkeeyy((_+_P_a_t_h_, _-_V_a_l_u_e))
    Get  the principal (default)  value associated to  this key.   Fails
    silently if the key does not exist.


rreeggiissttrryy__ggeett__kkeeyy((_+_P_a_t_h_, _+_N_a_m_e_, _-_V_a_l_u_e))
    Get a named value associated to this key.


rreeggiissttrryy__sseett__kkeeyy((_+_P_a_t_h_, _+_V_a_l_u_e))
    Set the principal (default)  value of this key.  Creates (a path to)
    the key if it does not already exist.


rreeggiissttrryy__sseett__kkeeyy((_+_P_a_t_h_, _+_N_a_m_e_, _+_V_a_l_u_e))
    Associate  a named value to this key.   Creates (a path to)  the key
    if it does not already exist.


rreeggiissttrryy__ddeelleettee__kkeeyy((_+_P_a_t_h))
    Delete the indicated key.


sshheellll__rreeggiisstteerr__ffiillee__ttyyppee((_+_E_x_t_, _+_T_y_p_e_, _+_N_a_m_e_, _+_O_p_e_n_A_c_t_i_o_n))
    Register  a file-type.   _E_x_t is  the extension to  associate.   _T_y_p_e
    is  the type name,  often something like prolog.type.   _N_a_m_e is  the
    name visible in  the Windows file-type browser.  Finally, _O_p_e_n_A_c_t_i_o_n
    defines  the action to  execute when a  file with this extension  is
    opened in the Windows explorer.


sshheellll__rreeggiisstteerr__ddddee((_+_T_y_p_e_, _+_A_c_t_i_o_n_, _+_S_e_r_v_i_c_e_, _+_T_o_p_i_c_, _+_C_o_m_m_a_n_d_, _+_I_f_N_o_t_R_u_n_n_i_n_g))
    Associate DDE actions to  a type.  _T_y_p_e is the same type as used for
    the 2nd argument of shell_register_file_type/4, _A_c_t_i_o_n is the action
    to  perform, _S_e_r_v_i_c_e  and _T_o_p_i_c  specify the DDE  topic to  address,
    and  _C_o_m_m_a_n_d is  the command  to execute on  this topic.    Finally,
    _I_f_N_o_t_R_u_n_n_i_n_g  defines the  command to  execute if  the required  DDE
    server is not present.


sshheellll__rreeggiisstteerr__pprroolloogg((_+_E_x_t))
    Default registration of  SWI-Prolog, which is invoked as part of the
    initialisation  process on  Windows  systems.   As  the source  also
    includes the above predicates, it is given as an example:

    ____________________________________________________________________|                                                                    |
    | shell_register_prolog(Ext) :-                                      |

    |         current_prolog_flag(argv, [Me|_]),                         |
    |         atomic_list_concat(['"', Me, '" "%1"'], OpenCommand),      |
    |         shell_register_file_type(                                  |
    |             Ext, 'prolog.type', 'Prolog Source', OpenCommand),     |
    |         shell_register_dde(                                        |
    |             'prolog.type', consult,                                |
    |             prolog, control, 'consult(''%1'')', Me),               |
    |         shell_register_dde(                                        |

    |             'prolog.type', edit,                                   |
    ||____________prolog,_control,_'edit(''%1'')',_Me)._________________ ||


1122..3311 lliibbrraarryy((ssiimmpplleexx))::  SSoollvvee lliinneeaarr pprrooggrraammmmiinngg pprroobblleemmss

                                                  Author:  _M_a_r_k_u_s _T_r_i_s_k_a

A linear programming problem consists of a set  of (linear) constraints,
a number  of variables and  a linear  objective function.   The goal  is
to assign values  to the variables so  as to maximize (or minimize)  the
value of the objective function while satisfying all constraints.

Many optimization problems can be modeled in this way.   Consider having
a knapsack with fixed capacity C, and a number of  items with sizes s(i)
and values v(i).   The goal is to  put as many items as possible  in the
knapsack (not exceeding its capacity) while maximizing the  sum of their
values.

As another example,  suppose you are given  a set of coins with  certain
values, and you are to find the minimum number of  coins such that their
values  sum up  to a  fixed amount.    Instances of  these problems  are
solved below.

The simplex module provides the following predicates:


aassssiiggnnmmeenntt((_+_C_o_s_t_, _-_A_s_s_i_g_n_m_e_n_t))
    Solves an assignment problem.   _C_o_s_t is a list of lists representing
    the  quadratic cost matrix, where element (i,j) denotes  the integer
    cost of  assigning entity i to entity j.  An assignment with minimal
    cost  is computed and  unified with _A_s_s_i_g_n_m_e_n_t  as a list of  lists,
    representing an adjacency matrix.


ccoonnssttrraaiinntt((_+_C_o_n_s_t_r_a_i_n_t_, _+_S_0_, _-_S))
    Adds  a  linear  or integrality  constraint  to the  linear  program
    corresponding  to state  _S_0.   A linear  constraint is  of the  form
    "Left  Op C", where "Left"  is a list of Coefficient*Variable  terms
    (variables  in  the  context of  linear  programs  can be  atoms  or
    compound terms) and C  is a non-negative numeric constant.  The list
    represents  the sum of its elements.   _O_p can be  =, =< or >=.   The
    coefficient  "1" can be  omitted.   An integrality constraint is  of
    the  form integral(Variable) and constrains Variable to  an integral
    value.


ccoonnssttrraaiinntt((_+_N_a_m_e_, _+_C_o_n_s_t_r_a_i_n_t_, _+_S_0_, _-_S))
    Like  constraint/3, and attaches the name _N_a_m_e (an atom  or compound
    term) to the new constraint.


ccoonnssttrraaiinntt__aadddd((_+_N_a_m_e_, _+_L_e_f_t_, _+_S_0_, _-_S))
    _L_e_f_t  is a list of Coefficient*Variable terms.  The terms  are added
    to  the left-hand side of the constraint  named _N_a_m_e.  _S  is unified
    with the resulting state.


ggeenn__ssttaattee((_-_S_t_a_t_e))
    Generates  an  initial   state  corresponding  to  an  empty  linear
    program.


mmaaxxiimmiizzee((_+_O_b_j_e_c_t_i_v_e_, _+_S_0_, _-_S))
    Maximizes  the  objective function,  stated as  a  list of  "Coeffi-
    cient*Variable" terms that  represents the sum of its elements, with
    respect  to the  linear program  corresponding to state  _S_0.   _S  is
    unified with an internal representation of the solved instance.


mmiinniimmiizzee((_+_O_b_j_e_c_t_i_v_e_, _+_S_0_, _-_S))
    Analogous to maximize/3.


oobbjjeeccttiivvee((_+_S_t_a_t_e_, _-_O_b_j_e_c_t_i_v_e))
    Unifies  _O_b_j_e_c_t_i_v_e with the result of the objective function  at the
    obtained extremum.  _S_t_a_t_e must correspond to a solved instance.


sshhaaddooww__pprriiccee((_+_S_t_a_t_e_, _+_N_a_m_e_, _-_V_a_l_u_e))
    Unifies  _V_a_l_u_e with  the shadow  price corresponding  to the  linear
    constraint  whose name is _N_a_m_e.   _S_t_a_t_e must correspond to a  solved
    instance.


ttrraannssppoorrttaattiioonn((_+_S_u_p_p_l_i_e_s_, _+_D_e_m_a_n_d_s_, _+_C_o_s_t_s_, _-_T_r_a_n_s_p_o_r_t))
    Solves  a transportation  problem.    _S_u_p_p_l_i_e_s and  _D_e_m_a_n_d_s must  be
    lists  of non-negative  integers.    Their respective  sums must  be
    equal.    _C_o_s_t_s is  a list of  lists representing  the cost  matrix,
    where  an entry (i,j) denotes  the integer cost of transporting  one
    unit  from i  to j.   A transportation  plan having  minimum cost is
    computed  and unified with _T_r_a_n_s_p_o_r_t in the form of a list  of lists
    that  represents  the  transportation matrix,  where  element  (i,j)
    denotes how many units to ship from i to j.


vvaarriiaabbllee__vvaalluuee((_+_S_t_a_t_e_, _+_V_a_r_i_a_b_l_e_, _-_V_a_l_u_e))
    _V_a_l_u_e  is unified with the value obtained for _V_a_r_i_a_b_l_e.   _S_t_a_t_e must
    correspond to a solved instance.

All numeric  quantities are  converted to  rationals via  rationalize/1,
and rational arithmetic is used throughout solving linear programs.   In
the  current implementation,  all variables  are implicitly  constrained
to  be  non-negative.     This  may  change  in  future  versions,   and
non-negativity constraints should therefore be stated explicitly.


1122..3311..11 EExxaammppllee 11

This is  the "radiation  therapy" example, taken  from "Introduction  to
Operations Research" by Hillier and Lieberman.  DCG  notation is used to
implicitly thread the state through posting the constraints:

________________________________________________________________________|                                                                        |
|:- use_module(library(simplex)).                                        |

|                                                                        |
|post_constraints -->                                                    |
|        constraint([0.3*x1, 0.1*x2] =< 2.7),                            |
|        constraint([0.5*x1, 0.5*x2] = 6),                               |
|        constraint([0.6*x1, 0.4*x2] >= 6),                              |
|        constraint([x1] >= 0),                                          |
|        constraint([x2] >= 0).                                          |
|                                                                        |

|radiation(S) :-                                                         |
|        gen_state(S0),                                                  |
|        post_constraints(S0, S1),                                       |
||_______minimize([0.4*x1,_0.5*x2],_S1,_S)._____________________________ ||

An example query:

________________________________________________________________________|                                                                        |
|?- radiation(S), variable_value(S, x1, Val1),                           |
|                 variable_value(S, x2, Val2).                           |
|                                                                        |

|Val1 = 15 rdiv 2                                                        |
|Val2|=_9_rdiv_2_;______________________________________________________ |    |


1122..3311..22 EExxaammppllee 22

Here is  an instance of  the knapsack problem  described above, where  C
= 8,  and we have two types  of items:  One  item with value 7 and  size
6,  and 2  items each  having size  4 and  value 4.    We introduce  two
variables, x(1)  and x(2)  that denote how  many items  to take of  each
type.

________________________________________________________________________|                                                                        |
|knapsack_constrain(S) :-                                                |

|        gen_state(S0),                                                  |
|        constraint([6*x(1), 4*x(2)] =< 8, S0, S1),                      |
|        constraint([x(1)] =< 1, S1, S2),                                |
|        constraint([x(2)] =< 2, S2, S).                                 |
|                                                                        |
|knapsack(S) :-                                                          |
|        knapsack_constrain(S0),                                         |
||_______maximize([7*x(1),_4*x(2)],_S0,_S)._____________________________ ||

An example query yields:

________________________________________________________________________|                                                                        |

|?- knapsack(S), variable_value(S, x(1), X1),                            |
|                variable_value(S, x(2), X2).                            |
|                                                                        |
|X1 = 1                                                                  |
|X2|=_1_rdiv_2_;________________________________________________________ |  |

That is, we are to take the one item of the first  type, and half of one
of the items of the  other type to maximize the total value of  items in
the knapsack.

If items can not be split, integrality constraints have to be imposed:

________________________________________________________________________|                                                                        |
|knapsack_integral(S) :-                                                 |
|        knapsack_constrain(S0),                                         |

|        constraint(integral(x(1)), S0, S1),                             |
|        constraint(integral(x(2)), S1, S2),                             |
||_______maximize([7*x(1),_4*x(2)],_S2,_S)._____________________________ ||

Now the result is different:

________________________________________________________________________|                                                                        |
|?- knapsack_integral(S), variable_value(S, x(1), X1),                   |
|                         variable_value(S, x(2), X2).                   |
|                                                                        |
|X1 = 0                                                                  |
|X2|=_2_________________________________________________________________ |  |

That  is,  we are  to  take  only the  two  items of  the  second  type.
Notice in particular  that always choosing the remaining item  with best
performance (ratio  of value to  size) that still  fits in the  knapsack
does  not necessarily  yield  an optimal  solution  in the  presence  of
integrality constraints.


1122..3311..33 EExxaammppllee 33

We are given 3 coins  each worth 1, 20 coins each worth 5, and  10 coins
each worth 20 units of  money.  The task is to find a minimal  number of
these coins that amount  to 111 units of money.  We  introduce variables
c(1), c(5) and c(20)  denoting how many coins to take of  the respective
type:

________________________________________________________________________|                                                                        |
|coins -->                                                               |

|        constraint([c(1), 5*c(5), 20*c(20)] = 111),                     |
|        constraint([c(1)] =< 3),                                        |
|        constraint([c(5)] =< 20),                                       |
|        constraint([c(20)] =< 10),                                      |
|        constraint([c(1)] >= 0),                                        |
|        constraint([c(5)] >= 0),                                        |
|        constraint([c(20)] >= 0),                                       |
|        constraint(integral(c(1))),                                     |

|        constraint(integral(c(5))),                                     |
|        constraint(integral(c(20))),                                    |
|        minimize([c(1), c(5), c(20)]).                                  |
|                                                                        |
|coins(S) :-                                                             |
|        gen_state(S0),                                                  |
||_______coins(S0,_S).__________________________________________________ ||

An example query:

________________________________________________________________________|                                                                        |

|?- coins(S), variable_value(S, c(1), C1),                               |
|             variable_value(S, c(5), C5),                               |
|             variable_value(S, c(20), C20).                             |
|                                                                        |
|C1 = 1                                                                  |
|C5 = 2                                                                  |

|C20|=_5________________________________________________________________ |   |


1122..3322 lliibbrraarryy((ssoolluuttiioonn__sseeqquueenncceess))::  MMooddiiffyy ssoolluuttiioonn sseeqquueenncceess

    SSeeee aallssoo
         - all solution predicates findall/3, bagof/3 and setof/3.
         - library(aggregate)

The meta  predicates of this  library modify  the sequence of  solutions
of a  goal.   The  modifications and the  predicate names  are based  on
the classical database operations DISTINCT, LIMIT, OFFSET,  ORDER BY and
GROUP BY.

These predicates  were introduced  in the  context of  the SWISH  Prolog
browser-based shell,  which can represent  the solutions to a  predicate
as a table.  Notably wrapping a goal in  distinct/1 avoids duplicates in
the result table and using order_by/2 produces a nicely ordered table.

However,  the predicates  from this  library can  also be  used to  stay
longer  within the  clean  paradigm where  non-deterministic  predicates
are  composed from  simpler  non-deterministic  predicates by  means  of
conjunction and disjunction.   While evaluating a conjunction,  we might
want  to eliminate  duplicates of  the first  part  of the  conjunction.
Below we  give both  the classical  solution for  solving variations  of
(a(X), b(X)) and the ones using this library side-by-side.

    ____________________________________________________________________|                                                                    |
AAvvooiidd||dduupplliiccaatteesssooffeeeaarrlliieerrtsstteeppssof(X, a(X), Xs),                distinct(a(X)),               |

    |   member(X, Xs),                        b(X)                       |
    ||__b(X).___________________________________________________________ ||

    Note that the  distinct/1 based solution returns the first result of
    distinct(a(X))  immediately after a/1  produces a result, while  the
    setof/3 based solution will first compute all results of a/1.

    ____________________________________________________________________|                                                                    |
OOnnllyy|ttrryysb(X)eoonnllyytffoorrotthheefttoopp--1100(a(X)X, a(X), Xs),                limit(10, order_by([desc(X)], a(X))),|
    |   reverse(Xs, Desc),                b(X)                           |
    |   first_max_n(10, Desc, Limit),                                    |
    |   member(X, Limit),                                                |

    ||__b(X)____________________________________________________________ ||

    Here  we see  power of  composing primitives from  this library  and
    staying  within the  paradigm of  pure non-deterministic  relational
    predicates.


ddiissttiinncctt((_:_G_o_a_l))


ddiissttiinncctt((_?_W_i_t_n_e_s_s_, _:_G_o_a_l))
    True  if  _G_o_a_l  is true  and  no  previous solution  of  _G_o_a_l  bound
    _W_i_t_n_e_s_s  to the same  value.   The variant distinct/1 is  equivalent
    to  distinct(Goal,Goal).   Semantically, distinct/1  is the same  as
    the  code below,  but answers are  returned as  soon as they  become
    available rather than first computing the complete answer set.

    ____________________________________________________________________|                                                                    |
    | distinct(Goal) :-                                                  |

    |     findall(Goal, Goal, List),                                     |
    |     list_to_set(List, Set),                                        |
    ||____member(Goal,_Set).____________________________________________ ||


lliimmiitt((_+_C_o_u_n_t_, _:_G_o_a_l))
    Limit  the number of  solutions.   True if  _G_o_a_l is true,  returning
    at  most _C_o_u_n_t solutions.   Solutions are  returned as soon as  they
    become available.


ooffffsseett((_+_C_o_u_n_t_, _:_G_o_a_l))
    Ignore  the  first _C_o_u_n_t  solutions.    True  if  _G_o_a_l is  true  and
    produces  more than _C_o_u_n_t  solutions.   This predicate computes  and
    ignores the first _C_o_u_n_t solutions.


oorrddeerr__bbyy((_S_p_e_c_, _G_o_a_l))
    Order  solutions according to _S_p_e_c.  _S_p_e_c is a list of  terms, where
    each  element is one  of.   The ordering of  solutions of _G_o_a_l  that
    only  differ  in variables  that are  _n_o_t shared  with  _S_p_e_c is  not
    changed.

    aasscc((_T_e_r_m))
         Order solution according to ascending _T_e_r_m

    ddeesscc((_T_e_r_m))
         Order solution according to descending _T_e_r_m


ggrroouupp__bbyy((_+_B_y_, _+_T_e_m_p_l_a_t_e_, _:_G_o_a_l_, _-_B_a_g))                           _[_n_o_n_d_e_t_]
    Group  bindings of _T_e_m_p_l_a_t_e that have the  same value for _B_y.   This
    predicate  is almost the same as bagof/3, but instead  of specifying
    the  existential  variables  we specify  the  free  variables.    It
    is  provided for  consistency and  complete coverage  of the  common
    database vocabulary.


1122..3333 lliibbrraarryy((tthhrreeaadd__ppooooll))::  RReessoouurrccee bboouunnddeedd tthhrreeaadd mmaannaaggeemmeenntt

    SSeeee aallssoo  http_handler/3 and http_spawn/2.

The  module library(thread_pool)  manages  threads in  pools.    A  pool
defines  properties of  its member  threads and  the  maximum number  of
threads that can coexist  in the pool.  The call  thread_create_in_pool/4
allocates a thread in the pool, just  like thread_create/3.   If the pool
is fully allocated it can be asked to wait or raise an error.

The library  has been  designed to  deal with  server applications  that
receive a variety of requests, such as HTTP servers.   Simply starting a
thread for each request is a bit too simple minded for such servers:

  o Creating  many  CPU intensive  threads often  leads  to a  slow-down
    rather than a speedup.

  o Creating many memory intensive threads may exhaust resources

  o Tasks  that require little CPU and memory but take long  waiting for
    external resources can run many threads.

Using this  library, one can define  a pool for  each set of tasks  with
comparable characteristics and create threads in this pool.   Unlike the
worker-pool model,  threads are not started  immediately.  Depending  on
the design, both approaches can be attractive.

The  library is  implemented  by means  of  a  manager thread  with  the
fixed  thread id  __thread_pool_manager.   All  state  is maintained  in
this manager  thread, which  receives and processes  requests to  create
and destroy  pools, create threads  in a pool  and handle messages  from
terminated threads.   Thread pools  are _n_o_t saved  in a saved state  and
must  therefore be  recreated using  the  initialization/1 directive  or
otherwise during startup of the application.


tthhrreeaadd__ppooooll__ccrreeaattee((_+_P_o_o_l_, _+_S_i_z_e_, _+_O_p_t_i_o_n_s))                         _[_d_e_t_]
    Create  a pool  of threads.    A pool  of threads  is a  declaration
    for  creating  threads  with  shared properties  (stack  sizes)  and
    a   limited  number  of  threads.      Threads  are  created   using
    thread_create_in_pool/4.   If all threads  in the  pool are in  use,
    the  behaviour depends on the wait option of  thread_create_in_pool/4
    and  the backlog  option described  below.   _O_p_t_i_o_n_s  are passed  to
    thread_create/3, except for

    bbaacckklloogg((_+_M_a_x_B_a_c_k_L_o_g))
         Maximum number of requests  that can be suspended.   Default is
         infinite.  Otherwise it must be a non-negative integer.   Using
         backlog(0) will never delay thread creation for this pool.

    The  pooling mechanism does _n_o_t interact with the detached  state of
    a thread.   Threads can be created both detached and normal and must
    be joined using thread_join/2 if they are not detached.


tthhrreeaadd__ppooooll__ddeessttrrooyy((_+_N_a_m_e))                                         _[_d_e_t_]
    Destroy the thread pool named _N_a_m_e.

         EErrrroorrss existence_error(thread_pool, Name).


ccuurrrreenntt__tthhrreeaadd__ppooooll((_?_N_a_m_e))                                      _[_n_o_n_d_e_t_]
    True if _N_a_m_e refers to a defined thread pool.


tthhrreeaadd__ppooooll__pprrooppeerrttyy((_?_N_a_m_e_, _?_P_r_o_p_e_r_t_y))                          _[_n_o_n_d_e_t_]
    True  if  _P_r_o_p_e_r_t_y is  a property  of  thread pool  _N_a_m_e.    Defined
    properties are:

    ooppttiioonnss((_O_p_t_i_o_n_s))
         Thread creation options for this pool

    ffrreeee((_S_i_z_e))
         Number of free slots on this pool

    ssiizzee((_S_i_z_e))
         Total number of slots on this pool

    mmeemmbbeerrss((_L_i_s_t_O_f_I_D_s))
         _L_i_s_t_O_f_I_D_s is the list or threads running in this pool

    rruunnnniinngg((_R_u_n_n_i_n_g))
         Number of running threads in this pool

    bbaacckklloogg((_S_i_z_e))
         Number of delayed thread creations on this pool


tthhrreeaadd__ccrreeaattee__iinn__ppooooll((_+_P_o_o_l_, _:_G_o_a_l_, _-_I_d_, _+_O_p_t_i_o_n_s))                  _[_d_e_t_]
    Create  a thread in _P_o_o_l.  _O_p_t_i_o_n_s overrule default  thread creation
    options  associated to the pool.  In addition, the  following option
    is defined:

    wwaaiitt((_+_B_o_o_l_e_a_n))
         If true (default) and the pool is full, wait until  a member of
         the pool completes.  If false, throw a resource_error.

         EErrrroorrss
             -  resource_error(threads_in_pool(Pool)) is  raised if
             wait is false or the backlog limit has been reached.
             - existence_error(thread_pool, Pool)  if _P_o_o_l does not
             exist.


ccrreeaattee__ppooooll((_+_P_o_o_l_N_a_m_e))                               _[_s_e_m_i_d_e_t_,_m_u_l_t_i_f_i_l_e_]
    Hook  to  create a  thread  pool lazily.    The  hook is  called  if
    thread_create_in_pool/4 discovers  that  the  thread pool  does  not
    exist.     If  the  hook  succeeds,  thread_create_in_pool/4 retries
    creating  the  thread.    For  example,  we can  use  the  following
    declaration  to create  threads in  the  pool media,  which holds  a
    maximum of 20 threads.

    ____________________________________________________________________|                                                                    |
    | :- multifile thread_pool:create_pool/1.                            |
    |                                                                    |
    | thread_pool:create_pool(media) :-                                  |

    ||____thread_pool_create(media,_20,_[]).____________________________ ||


1122..3344 lliibbrraarryy((uuggrraapphhss))::  UUnnwweeiigghhtteedd GGrraapphhss

                          Authors:  _R_i_c_h_a_r_d _O_'_K_e_e_f_e _& _V_i_t_o_r _S_a_n_t_o_s _C_o_s_t_a

    _I_m_p_l_e_m_e_n_t_a_t_i_o_n  _a_n_d  _d_o_c_u_m_e_n_t_a_t_i_o_n _a_r_e  _c_o_p_i_e_d _f_r_o_m  _Y_A_P _5_._0_._1_.
    _T_h_e   ugraph  _l_i_b_r_a_r_y  _i_s  _b_a_s_e_d  _o_n  _c_o_d_e  _o_r_i_g_i_n_a_l_l_y  _w_r_i_t_t_e_n
    _b_y  _R_i_c_h_a_r_d  _O_'_K_e_e_f_e_.     _T_h_e  _c_o_d_e  _w_a_s  _t_h_e_n _e_x_t_e_n_d_e_d  _t_o  _b_e
    _c_o_m_p_a_t_i_b_l_e  _w_i_t_h _t_h_e _S_I_C_S_t_u_s _P_r_o_l_o_g _u_g_r_a_p_h_s  _l_i_b_r_a_r_y_.  _C_o_d_e _a_n_d
    _d_o_c_u_m_e_n_t_a_t_i_o_n  _h_a_v_e _b_e_e_n _c_l_e_a_n_e_d _a_n_d _s_t_y_l_e  _h_a_s _b_e_e_n _c_h_a_n_g_e_d _t_o
    _b_e _m_o_r_e _i_n _l_i_n_e _w_i_t_h _t_h_e _r_e_s_t _o_f _S_W_I_-_P_r_o_l_o_g_.

    _T_h_e  _u_g_r_a_p_h_s  _l_i_b_r_a_r_y  _w_a_s _o_r_i_g_i_n_a_l_l_y  _r_e_l_e_a_s_e_d  _i_n  _t_h_e _p_u_b_l_i_c
    _d_o_m_a_i_n_.    _T_h_e  _Y_A_P  _v_e_r_s_i_o_n _i_s  _c_o_v_e_r_e_d _b_y  _t_h_e  _P_e_r_l _A_r_t_i_s_t_i_c
    _l_i_c_e_n_s_e_,  _v_e_r_s_i_o_n _2_._0_.   _T_h_i_s  _c_o_d_e _i_s  _d_u_a_l_-_l_i_c_e_n_s_e_d _u_n_d_e_r _t_h_e
    _m_o_d_i_f_i_e_d  _G_P_L _a_s _u_s_e_d _f_o_r _a_l_l  _S_W_I_-_P_r_o_l_o_g _l_i_b_r_a_r_i_e_s _o_r _t_h_e _P_e_r_l
    _A_r_t_i_s_t_i_c _l_i_c_e_n_s_e_, _v_e_r_s_i_o_n _2_._0_.

The  routines   assume  directed  graphs;   undirected  graphs  may   be
implemented by using two edges.

Originally graphs were represented in two formats.   The SICStus library
and  this version  of ugraphs.pl  only use  the _S_-_r_e_p_r_e_s_e_n_t_a_t_i_o_n.    The
S-representation  of a  graph  is a  list of  (vertex-neighbors)  pairs,
where the pairs are  in standard order (as produced by keysort)  and the
neighbors of  each vertex  are also  in standard order  (as produced  by
sort).   This form  is convenient  for many calculations.   Each  vertex
appears in the S-representation, even if it has no neighbors.


vveerrttiicceess__eeddggeess__ttoo__uuggrraapphh((_+_V_e_r_t_i_c_e_s_, _+_E_d_g_e_s_, _-_G_r_a_p_h))
    Given a graph with  a set of _V_e_r_t_i_c_e_s and a set of _E_d_g_e_s, _G_r_a_p_h must
    unify  with the corresponding S-representation.  Note  that vertices
    without  edges will appear in _V_e_r_t_i_c_e_s but not in _E_d_g_e_s.   Moreover,
    it is sufficient for a vertex to appear in _E_d_g_e_s.

    ____________________________________________________________________|                                                                    |
    | ?- vertices_edges_to_ugraph([],[1-3,2-4,4-5,1-5], L).              |

    ||L_=_[1-[3,5],_2-[4],_3-[],_4-[5],_5-[]]___________________________ ||

    In this case all  vertices are defined implicitly.  The next example
    shows three unconnected vertices:

    ____________________________________________________________________|                                                                    |

    | ?- vertices_edges_to_ugraph([6,7,8],[1-3,2-4,4-5,1-5], L).         |
    ||L_=_[1-[3,5],_2-[4],_3-[],_4-[5],_5-[],_6-[],_7-[],_8-[]]_?_______ ||


vveerrttiicceess((_+_G_r_a_p_h_, _-_V_e_r_t_i_c_e_s))
    Unify _V_e_r_t_i_c_e_s with all vertices appearing in _G_r_a_p_h.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- vertices([1-[3,5],2-[4],3-[],4-[5],5-[]], L).                   |
    ||L_=_[1,_2,_3,_4,_5]_______________________________________________ ||


eeddggeess((_+_G_r_a_p_h_, _-_E_d_g_e_s))
    Unify _E_d_g_e_s with all edges appearing in _G_r_a_p_h.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- edges([1-[3,5],2-[4],3-[],4-[5],5-[]], L).                      |

    ||L_=_[1-3,_1-5,_2-4,_4-5]__________________________________________ ||


aadddd__vveerrttiicceess((_+_G_r_a_p_h_, _+_V_e_r_t_i_c_e_s_, _-_N_e_w_G_r_a_p_h))
    Unify  _N_e_w_G_r_a_p_h with  a new  graph obtained  by adding  the list  of
    _V_e_r_t_i_c_e_s to _G_r_a_p_h.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- add_vertices([1-[3,5],2-[]], [0,1,2,9], NG).                    |

    ||NG_=_[0-[],_1-[3,5],_2-[],_9-[]]__________________________________ ||


ddeell__vveerrttiicceess((_+_G_r_a_p_h_, _+_V_e_r_t_i_c_e_s_, _-_N_e_w_G_r_a_p_h))
    Unify  _N_e_w_G_r_a_p_h  with a  new  graph obtained  by deleting  the  list
    of  _V_e_r_t_i_c_e_s and  all edges that  start from  or go to  a vertex  in
    _V_e_r_t_i_c_e_s from _G_r_a_p_h.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- del_vertices([2,1],                                             |

    |                 [1-[3,5],2-[4],3-[],4-[5],                         |
    |                  5-[],6-[],7-[2,6],8-[]],                          |
    |                 NL).                                               |
    ||NL_=_[3-[],4-[5],5-[],6-[],7-[6],8-[]]____________________________ ||


aadddd__eeddggeess((_+_G_r_a_p_h_, _+_E_d_g_e_s_, _-_N_e_w_G_r_a_p_h))
    Unify  _N_e_w_G_r_a_p_h with  a new  graph obtained  by adding  the list  of
    _E_d_g_e_s to _G_r_a_p_h.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- add_edges([1-[3,5],2-[4],3-[],4-[5],                            |

    |               5-[],6-[],7-[],8-[]],                                |
    |              [1-6,2-3,3-2,5-7,3-2,4-5],                            |
    |              NL).                                                  |
    | NL = [1-[3,5,6], 2-[3,4], 3-[2], 4-[5],                            |
    ||______5-[7],_6-[],_7-[],_8-[]]____________________________________ ||


ddeell__eeddggeess((_+_G_r_a_p_h_, _+_E_d_g_e_s_, _-_N_e_w_G_r_a_p_h))
    Unify  _N_e_w_G_r_a_p_h with a  new graph obtained  by removing the list  of
    _E_d_g_e_s from _G_r_a_p_h.  Notice that no vertices are deleted.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- del_edges([1-[3,5],2-[4],3-[],4-[5],5-[],6-[],7-[],8-[]],       |

    |              [1-6,2-3,3-2,5-7,3-2,4-5,1-3],                        |
    |              NL).                                                  |
    ||NL_=_[1-[5],2-[4],3-[],4-[],5-[],6-[],7-[],8-[]]__________________ ||


ttrraannssppoossee((_+_G_r_a_p_h_, _-_N_e_w_G_r_a_p_h))
    Unify  _N_e_w_G_r_a_p_h with a  new graph obtained  from _G_r_a_p_h by  replacing
    all  edges of the form V1-V2 by edges  of the form V2-V1.   The cost
    is  O(|V|2).  Notice  that an undirected graph is  its own transpose.
    Example:

    ____________________________________________________________________|                                                                    |
    | ?- transpose([1-[3,5],2-[4],3-[],4-[5],                            |

    |               5-[],6-[],7-[],8-[]], NL).                           |
    ||NL_=_[1-[],2-[],3-[1],4-[2],5-[1,4],6-[],7-[],8-[]]_______________ ||


nneeiigghhbboouurrss((_+_V_e_r_t_e_x_, _+_G_r_a_p_h_, _-_V_e_r_t_i_c_e_s))
    Unify  _V_e_r_t_i_c_e_s with  the  list of  neighbours of  vertex _V_e_r_t_e_x  in
    _G_r_a_p_h.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- neighbours(4,[1-[3,5],2-[4],3-[],                               |

    |                  4-[1,2,7,5],5-[],6-[],7-[],8-[]], NL).            |
    ||NL_=_[1,2,7,5]____________________________________________________ ||


nneeiigghhbboorrss((_+_V_e_r_t_e_x_, _+_G_r_a_p_h_, _-_V_e_r_t_i_c_e_s))
    American version of neighbours/3.


ccoommpplleemmeenntt((_+_G_r_a_p_h_, _-_N_e_w_G_r_a_p_h))
    Unify _N_e_w_G_r_a_p_h with the graph complementary to _G_r_a_p_h.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- complement([1-[3,5],2-[4],3-[],                                 |

    |                4-[1,2,7,5],5-[],6-[],7-[],8-[]], NL).              |
    | NL = [1-[2,4,6,7,8],2-[1,3,5,6,7,8],3-[1,2,4,5,6,7,8],             |
    |       4-[3,5,6,8],5-[1,2,3,4,6,7,8],6-[1,2,3,4,5,7,8],             |
    ||______7-[1,2,3,4,5,6,8],8-[1,2,3,4,5,6,7]]________________________ ||


ccoommppoossee((_+_L_e_f_t_G_r_a_p_h_, _+_R_i_g_h_t_G_r_a_p_h_, _-_N_e_w_G_r_a_p_h))
    Compose  _N_e_w_G_r_a_p_h  by  connecting the  _d_r_a_i_n_s  of _L_e_f_t_G_r_a_p_h  to  the
    _s_o_u_r_c_e_s of _R_i_g_h_t_G_r_a_p_h.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- compose([1-[2],2-[3]],[2-[4],3-[1,2,4]],L).                     |

    ||L_=_[1-[4],_2-[1,2,4],_3-[]]______________________________________ ||


uuggrraapphh__uunniioonn((_+_G_r_a_p_h_1_, _+_G_r_a_p_h_2_, _-_N_e_w_G_r_a_p_h))
    _N_e_w_G_r_a_p_h is the union of _G_r_a_p_h_1 and _G_r_a_p_h_2.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- ugraph_union([1-[2],2-[3]],[2-[4],3-[1,2,4]],L).                |

    ||L_=_[1-[2],_2-[3,4],_3-[1,2,4]]___________________________________ ||


ttoopp__ssoorrtt((_+_G_r_a_p_h_, _-_S_o_r_t))
    Generate  the set of nodes _S_o_r_t  as a topological sorting of  _G_r_a_p_h,
    if  one is possible.   A  toplogical sort is  possible if the  graph
    is  connected and acyclic.   In the example we show how  topological
    sorting works for a linear graph:

    ____________________________________________________________________|                                                                    |
    | ?- top_sort([1-[2], 2-[3], 3-[]], L).                              |

    ||L_=_[1,_2,_3]_____________________________________________________ ||


ttoopp__ssoorrtt((_+_G_r_a_p_h_, _-_S_o_r_t_0_, _-_S_o_r_t))
    Generate the difference  list Sort-Sort0 as a topological sorting of
    _G_r_a_p_h, if one is possible.


ttrraannssiittiivvee__cclloossuurree((_+_G_r_a_p_h_, _-_C_l_o_s_u_r_e))
    Generate  the  graph Closure  as the  transitive  closure of  _G_r_a_p_h.
    Example:

    ____________________________________________________________________|                                                                    |
    |  ?- transitive_closure([1-[2,3],2-[4,5],4-[6]],L).                 |

    ||L_=_[1-[2,3,4,5,6],_2-[4,5,6],_4-[6]]_____________________________ ||


rreeaacchhaabbllee((_+_V_e_r_t_e_x_, _+_G_r_a_p_h_, _-_V_e_r_t_i_c_e_s))
    Unify  _V_e_r_t_i_c_e_s  with the  set of  all vertices  in  _G_r_a_p_h that  are
    reachable from _V_e_r_t_e_x.  Example:

    ____________________________________________________________________|                                                                    |
    | ?- reachable(1,[1-[3,5],2-[4],3-[],4-[5],5-[]],V).                 |

    ||V_=_[1,_3,_5]_____________________________________________________ ||


1122..3355 lliibbrraarryy((uurrll))::  AAnnaallyyssiinngg aanndd ccoonnssttrruuccttiinngg UURRLL

    aauutthhoorr
         - Jan Wielemaker
         - Lukas Faulstich

    ddeepprreeccaatteedd  New code  should use library(uri),  provided by the
         clib package.

This  library  deals  with the  analysis  and  construction  of  a  URL,
Universal  Resource  Locator.    URL  is  the  basis  for  communicating
locations of resources (data) on the web.  A URL  consists of a protocol
identifier (e.g.    HTTP, FTP,  and a  protocol-specific syntax  further
defining the location.  URLs are standardized in RFC-1738.

The implementation in  this library covers only  a small portion of  the
defined protocols.  Though the initial  implementation followed RFC-1738
strictly, the current  is more relaxed to deal with  frequent violations
of the standard encountered in practical use.


gglloobbaall__uurrll((_+_U_R_L_, _+_B_a_s_e_, _-_G_l_o_b_a_l))                                   _[_d_e_t_]
    Translate a possibly relative _U_R_L into an absolute one.

         EErrrroorrss syntax_error(illegal_url) if _U_R_L is not legal.


iiss__aabbssoolluuttee__uurrll((_+_U_R_L))
    True  if _U_R_L is an absolute _U_R_L.  That is, a _U_R_L that starts  with a
    protocol identifier.


hhttttpp__llooccaattiioonn((_?_P_a_r_t_s_, _?_L_o_c_a_t_i_o_n))
    Construct  or  analyze  an  HTTP  location.    This  is  similar  to
    parse_url/2, but only  deals with the location part of an  HTTP URL.
    That  is, the  path, search and  fragment specifiers.   In the  HTTP
    protocol, the first line of a message is

    ____________________________________________________________________|                                                                    |
    ||<Action>_<Location>_HTTP/<version>________________________________ ||

    ___________________________________________________________Arguments_
     _L_o_c_a_t_i_o_n  Atom or list of character codes.


ppaarrssee__uurrll((_?_U_R_L_, _?_A_t_t_r_i_b_u_t_e_s))                                       _[_d_e_t_]
    Construct  or analyse  a _U_R_L.  _U_R_L is  an atom  holding a  _U_R_L or  a
    variable.   _A_t_t_r_i_b_u_t_e_s is a list  of components.  Each  component is
    of the format Name(Value).  Defined components are:

    pprroottooccooll((_P_r_o_t_o_c_o_l))
         The used  protocol.    This is,  after  the optional  url:,  an
         identifier  separated  from the  remainder  of  the  _U_R_L  using
         :.   parse_url/2 assumes the  http protocol  if no protocol  is
         specified and  the  _U_R_L can  be  parsed as  a valid  HTTP  url.
         In  addition to  the  RFC-1738 specified  protocols,  the  file
         protocol is supported as well.

    hhoosstt((_H_o_s_t))
         _H_o_s_t-name  or IP-address  on  which  the resource  is  located.
         Supported by all network-based protocols.

    ppoorrtt((_P_o_r_t))
         Integer port-number  to access on  the \arg{Host}.    This only
         appears  if  the port  is  explicitly  specified  in  the  _U_R_L.
         Implicit default  ports (e.g., 80  for HTTP)  do _n_o_t appear  in
         the part-list.

    ppaatthh((_P_a_t_h))
         (File-) path addressed  by the _U_R_L.  This is supported for  the
         ftp, http and file protocols.  If no path  appears, the library
         generates the path /.

    sseeaarrcchh((_L_i_s_t_O_f_N_a_m_e_V_a_l_u_e))
         Search-specification of HTTP  _U_R_L. This is  the part after  the
         ?, normally used to transfer data from HTML forms  that use the
         GET protocol.   In  the _U_R_L it  consists of a  www-form-encoded
         list of Name=Value pairs.   This is mapped to a list  of Prolog
         Name=Value terms with decoded names and values.

    ffrraaggmmeenntt((_F_r_a_g_m_e_n_t))
         _F_r_a_g_m_e_n_t specification of HTTP _U_R_L. This is the  part after the
         # character.

    The example below illustrates all of this for an HTTP _U_R_L.

    ____________________________________________________________________|                                                                    |

    | ?- parse_url('http://www.xyz.org/hello?msg=Hello+World%21#x',      |
    |        P).                                                         |
    |                                                                    |
    | P = [ protocol(http),                                              |
    |       host('www.xyz.org'),                                         |

    |       fragment(x),                                                 |
    |       search([ msg = 'Hello World!'                                |
    |              ]),                                                   |
    |       path('/hello')                                               |
    ||____]_____________________________________________________________ ||

    By  instantiating  the  parts-list this  predicate  can be  used  to
    create a _U_R_L.


ppaarrssee__uurrll((_+_U_R_L_, _+_B_a_s_e_U_R_L_, _-_A_t_t_r_i_b_u_t_e_s))                             _[_d_e_t_]
    Similar  to parse_url/2 for relative URLs.   If _U_R_L is relative,  it
    is resolved using the absolute _U_R_L _B_a_s_e_U_R_L.


wwwwww__ffoorrmm__eennccooddee((_+_V_a_l_u_e_, _-_X_W_W_W_F_o_r_m_E_n_c_o_d_e_d))                          _[_d_e_t_]


wwwwww__ffoorrmm__eennccooddee((_-_V_a_l_u_e_, _+_X_W_W_W_F_o_r_m_E_n_c_o_d_e_d))                          _[_d_e_t_]
    En/decode to/from  application/x-www-form-encoded.  Encoding encodes
    all  characters  except   RFC  3986  _u_n_r_e_s_e_r_v_e_d  (ASCII  alnum  (see
    code_type/2)),  and one of "-._~" using percent  encoding.   Newline
    is  mapped to  %OD%OA. When  decoding, newlines appear  as a  single
    newline (10) character.

    Note that a space  is encoded as %20 instead of +.  Decoding decodes
    both to a space.

         ddeepprreeccaatteedd Use uri_encoded/3 for new code.


sseett__uurrll__eennccooddiinngg((_?_O_l_d_, _+_N_e_w))                                   _[_s_e_m_i_d_e_t_]
    Query  and set the  encoding for URLs.   The default  is utf8.   The
    only other defined value is iso_latin_1.

         TToo bbee ddoonnee Having  a global  flag is  highly inconvenient,
             but  a work-around  for  old sites  using ISO  Latin 1
             encoding.


uurrll__iirrii((_+_E_n_c_o_d_e_d_, _-_D_e_c_o_d_e_d))                                        _[_d_e_t_]


uurrll__iirrii((_-_E_n_c_o_d_e_d_, _+_D_e_c_o_d_e_d))                                        _[_d_e_t_]
    Convert between a URL,  encoding in US-ASCII and an IRI. An IRI is a
    fully  expanded Unicode string.   Unicode strings are first  encoded
    into UTF-8, after which %-encoding takes place.


ppaarrssee__uurrll__sseeaarrcchh((_?_S_p_e_c_, _?_F_i_e_l_d_s_:_l_i_s_t_(_N_a_m_e_=_V_a_l_u_e_)))                  _[_d_e_t_]
    Construct or analyze  an HTTP search specification.  This deals with
    form  data using the MIME-type application/x-www-form-urlencoded  as
    used in HTTP GET requests.


ffiillee__nnaammee__ttoo__uurrll((_+_F_i_l_e_, _-_U_R_L))                                       _[_d_e_t_]


ffiillee__nnaammee__ttoo__uurrll((_-_F_i_l_e_, _+_U_R_L))                                   _[_s_e_m_i_d_e_t_]
    Translate between a filename and a file:// _U_R_L.

         TToo bbee ddoonnee Current   implementation  does  not  deal  with
             paths that need special encoding.


1122..3366 lliibbrraarryy((vvaarrnnuummbbeerrss))::  UUttiilliittiieess ffoorr nnuummbbeerreedd tteerrmmss

    SSeeee aallssoo  numbervars/4, =@=/2 (variant/2).

    CCoommppaattiibbiilliittyy  This  library  was  introduced  by  Quintus  and
         available in  many related  implementations,  although not
         with exactly the same set of predicates.

This  library  provides  the  inverse  functionality   of  the  built-in
numbervars/3.   Note  that this  library suffers from  the known  issues
that  '$VAR'(X) is  a  normal  Prolog term  and,  -unlike  the  built-in
numbervars-, the  inverse predicates do _n_o_t process  cyclic terms.   The
following  predicate is  true  for any  acyclic  term that  contains  no
'$VAR'(X), integer(X) terms and no constraint variables:

________________________________________________________________________|                                                                        |

|always_true(X) :-                                                       |
|      copy_term(X, X2),                                                 |
|      numbervars(X),                                                    |
|      varnumbers(X, Copy),                                              |
||_____Copy_=@=_X2._____________________________________________________ ||


nnuummbbeerrvvaarrss((_+_T_e_r_m))                                                 _[_d_e_t_]
    Number   variables    in   _T_e_r_m   using   $VAR(N).   Equivalent   to
    numbervars(Term, 0, _).

         SSeeee aallssoo numbervars/3, numbervars/4


vvaarrnnuummbbeerrss((_+_T_e_r_m_, _-_C_o_p_y))                                          _[_d_e_t_]
    Inverse of numbervars/1.  Equivalent to varnumbers(Term, 0, Copy).


vvaarrnnuummbbeerrss((_+_T_e_r_m_, _+_S_t_a_r_t_, _-_C_o_p_y))                                  _[_d_e_t_]
    Inverse  of numbervars/3.   True when  _C_o_p_y is a  copy of _T_e_r_m  with
    all  variables  numbered >=  _S_t_a_r_t  consistently replaced  by  fresh
    variables.    Variables in  _T_e_r_m are  _s_h_a_r_e_d with  _C_o_p_y rather  than
    replaced by fresh variables.

         EErrrroorrss domain_error(acyclic_term, Term)    if    _T_e_r_m   is
             cyclic.

         CCoommppaattiibbiilliittyy Quintus,  SICStus.   Not  in YAP  version of
             this library


mmaaxx__vvaarr__nnuummbbeerr((_+_T_e_r_m_, _+_S_t_a_r_t_, _-_M_a_x))                                _[_d_e_t_]
    True  when _M_a_x is the max of _S_t_a_r_t and the highest  numbered $VAR(N)
    term.

         aauutthhoorr Vitor Santos Costa

         CCoommppaattiibbiilliittyy YAP


CChhaapptteerr 1133..  HHAACCKKEERRSS CCOORRNNEERR

This  appendix  describes  a  number  of  predicates  which  enable  the
Prolog  user  to  inspect the  Prolog  environment  and  manipulate  (or
even redefine)  the debugger.    They can be  used as  entry points  for
experiments with debugging  tools for Prolog.  The  predicates described
here should  be handled  with some  care as it  is easy  to corrupt  the
consistency of the Prolog system by misusing them.


1133..11 EExxaammiinniinngg tthhee EEnnvviirroonnmmeenntt SSttaacckk


pprroolloogg__ccuurrrreenntt__ffrraammee((_-_F_r_a_m_e))                                       _[_d_e_t_]
    Unify  _F_r_a_m_e with  an integer  providing a reference  to the  parent
    of  the  current local  stack  frame.    A  pointer to  the  current
    local   frame  cannot   be  provided  as   the  predicate   succeeds
    deterministically  and therefore its frame is  destroyed immediately
    after succeeding.


pprroolloogg__ccuurrrreenntt__cchhooiiccee((_-_C_h_o_i_c_e))                                 _[_s_e_m_i_d_e_t_]
    Unify  _C_h_o_i_c_e  with an  integer  provided a  reference to  the  last
    choice  point.    Fails if  the current  environment  has no  choice
    points.  See also prolog_choice_attribute/3.


pprroolloogg__ffrraammee__aattttrriibbuuttee((_+_F_r_a_m_e_, _+_K_e_y_, _:_V_a_l_u_e))
    Obtain  information  about  the local  stack  frame  _F_r_a_m_e.    _F_r_a_m_e
    is  a  frame reference  as obtained  through prolog_current_frame/1,
    prolog_trace_interception/4 or this predicate.   The key values  are
    described below.

    aalltteerrnnaattiivvee
         _V_a_l_u_e is unified with  an integer reference to the  local stack
         frame in  which execution  is  resumed if  the goal  associated
         with _F_r_a_m_e  fails.    Fails  if the  frame has  no  alternative
         frame.

    hhaass__aalltteerrnnaattiivveess
         _V_a_l_u_e is unified  with true if _F_r_a_m_e  still is a candidate  for
         backtracking; false otherwise.

    ggooaall
         _V_a_l_u_e is  unified with  the  goal associated  with _F_r_a_m_e.    If
         the  definition module  of  the  active predicate  is  not  the
         calling context,  the  goal is  represented as  <_m_o_d_u_l_e>:<_g_o_a_l>.
         Do  not instantiate  variables in  this  goal unless  you  kknnooww
         what you are  doing!  Note  that the returned term may  contain
         references to  the frame  and  should be  discarded before  the
         frame terminates.

    ppaarreenntt__ggooaall
         If _V_a_l_u_e  is  instantiated to  a callable  term,  find a  frame
         executing  the  predicate described  by  _V_a_l_u_e  and  unify  the
         arguments of _V_a_l_u_e  to the goal  arguments associated with  the
         frame.    This  is  intended  to check  the  current  execution
         context.  The user  must ensure the checked parent goal  is not
         removed from  the stack  due to last-call  optimisation and  be
         aware of the slow operation on deeply nested calls.

    pprreeddiiccaattee__iinnddiiccaattoorr
         Similar     to    goal,      but     only     returning     the
         [<_m_o_d_u_l_e>:]<_n_a_m_e>/<_a_r_i_t_y>   term   describing  the   term,    not
         the actual arguments.   It avoids  creating an illegal term  as
         goal and is used by the library prolog_stack.

    ccllaauussee
         _V_a_l_u_e is  unified with  a  reference to  the currently  running
         clause.    Fails  if the  current  goal  is associated  with  a
         foreign  (C) defined  predicate.    See  also nth_clause/3  and
         clause_property/2.

    lleevveell
         _V_a_l_u_e is unified  with the recursion level  of _F_r_a_m_e.  The  top
         level frame is at level `0'.

    ppaarreenntt
         _V_a_l_u_e is unified with an integer reference to  the parent local
         stack frame of _F_r_a_m_e.  Fails if _F_r_a_m_e is the top frame.

    ccoonntteexxtt__mmoodduullee
         _V_a_l_u_e is  unified with the  name of the  context module of  the
         environment.

    ttoopp
         _V_a_l_u_e is  unified with  true if _F_r_a_m_e  is the  top Prolog  goal
         from a  recursive call back  from the  foreign language;  false
         otherwise.

    hhiiddddeenn
         _V_a_l_u_e is  unified with  true if the  frame is  hidden from  the
         user, either  because a  parent has  the hide-childs  attribute
         (all  system  predicates),  or  the  system   has  no  trace-me
         attribute.

    sskkiippppeedd
         _V_a_l_u_e is true if this frame was skipped in the debugger.

    ppcc
         _V_a_l_u_e  is unified  with the  program  pointer saved  on  behalf
         of  the parent  goal if  the  parent goal  is  not owned  by  a
         foreign predicate  or belongs  to a  compound meta-call  (e.g.,
         call((a,b))).

    aarrgguummeenntt((_N))
         _V_a_l_u_e is  unified with the _N-th  slot of the  frame.   Argument
         1 is  the first  argument of  the goal.    Arguments above  the
         arity refer to local variables.  Fails silently if _N  is out of
         range.


pprroolloogg__cchhooiiccee__aattttrriibbuuttee((_+_C_h_o_i_c_e_P_o_i_n_t_, _+_K_e_y_, _-_V_a_l_u_e))
    Extract  attributes of a choice point.   _C_h_o_i_c_e_P_o_i_n_t is a  reference
    to  a  choice  point  as  passed  to prolog_trace_interception/4  on
    the  3rd argument  or obtained  using prolog_current_choice/1.    _K_e_y
    specifies the requested information:

    ppaarreenntt
         Requests a reference to the first older choice point.

    ffrraammee
         Requests a  reference to the  frame to  which the choice  point
         refers.

    ttyyppee
         Requests  the type.     Defined  values are  clause  (the  goal
         has alternative  clauses),  foreign (non-deterministic  foreign
         predicate),  jump (clause  internal choice  point), top  (first
         dummy choice point), catch  (catch/3 to allow for undo),  debug
         (help the debugger), or none (has been deleted).

    This  predicate  is used  for  the graphical  debugger to  show  the
    choice point stack.


ddeetteerrmmiinniissttiicc((_-_B_o_o_l_e_a_n))
    Unifies  its argument with  true if no  choice point exists that  is
    more  recent  than the  entry of  the clause  in  which it  appears.
    There  are few realistic  situations for using  this predicate.   It
    is  used by the  prolog/0 top level  to check whether Prolog  should
    prompt  the user for alternatives.  Similar results can  be achieved
    in a more portable fashion using call_cleanup/2.


1133..22 AAnncceessttrraall ccuuttss


pprroolloogg__ccuutt__ttoo((_+_C_h_o_i_c_e))
    Prunes  all  choice  points created  since  _C_h_o_i_c_e.    Can  be  used
    together  with prolog_current_choice/1 to implement _a_n_c_e_s_t_r_a_l  cuts.
    This  predicate is in  the hackers corner  because it should not  be
    used  in normal  Prolog code.   It may  be used  to create new  high
    level control structures, particularly for compatibility purposes.


1133..33 IInntteerrcceeppttiinngg tthhee TTrraacceerr


pprroolloogg__ttrraaccee__iinntteerrcceeppttiioonn((_+_P_o_r_t_, _+_F_r_a_m_e_, _+_C_h_o_i_c_e_, _-_A_c_t_i_o_n))
    Dynamic  predicate, normally not defined.  This predicate  is called
    from  the SWI-Prolog  debugger  just before  it would  show a  port.
    If  this predicate  succeeds, the  debugger assumes  that the  trace
    action  has been taken care of and continues execution  as described
    by  _A_c_t_i_o_n.    Otherwise  the  normal  Prolog debugger  actions  are
    performed.

    _P_o_r_t  denotes  the reason  to  activate the  tracer (`port'  in  the
    4/5-port, but with some additions):

    ccaallll
         Normal entry through the call port of the 4-port debugger.

    rreeddoo((_P_C))
         Normal entry  through the  redo  port of  the 4-port  debugger.
         The  redo  port  signals  resuming  a  predicate   to  generate
         alternative solutions.  If _P_C is 0 (zero),  clause indexing has
         found another clause  that will be tried  next.  Otherwise,  _P_C
         is the program  counter in the  current clause where  execution
         continues.    This implies  we are  dealing  with an  in-clause
         choice point left by, e.g., ;/2.  Note  that non-determinism in
         foreign predicates are  also handled using an in-clause  choice
         point.

    uunniiffyy
         The  unify port  represents  the _n_e_c_k  instruction,  signalling
         the end of  the head-matching process.   This port is  normally
         invisible.  See leash/1 and visible/1.

    eexxiitt
         The exit port signals the  goal is proved.  It is  possible for
         the goal to have alternatives.  See prolog_frame_attribute/3 to
         examine the goal stack.

    ffaaiill
         The fail port signals final failure of the goal.

    eexxcceeppttiioonn((_E_x_c_e_p_t))
         An  exception is  raised  and still  pending.    This  port  is
         activated on  each parent  frame  of the  frame generating  the
         exception until the  exception is caught  or the user  restarts
         normal  computation  using  retry.     _E_x_c_e_p_t  is  the  pending
         exception term.

    bbrreeaakk((_P_C))
         A break instruction is executed.  _P_C is program counter.   This
         port is used by the graphical debugger.

    ccuutt__ccaallll((_P_C))
         A cut is encountered at _P_C. This port is used  by the graphical
         debugger to visualise the effect of the cut.

    ccuutt__eexxiitt((_P_C))
         A cut has  been executed.   See cut_call(_P_C) for more  informa-
         tion.

    _F_r_a_m_e  is  a  reference to  the  current local  stack  frame,  which
    can  be  examined  using  prolog_frame_attribute/3.     _C_h_o_i_c_e  is  a
    reference  to  the  last choice  point  and  can be  examined  using
    prolog_choice_attribute/3.  _A_c_t_i_o_n must be unified with  a term that
    specifies  how execution must continue.   The following actions  are
    defined:

    aabboorrtt
         Abort execution.  See abort/0.

    ccoonnttiinnuuee
         Continue (i.e., _c_r_e_e_p in the command line debugger).

    ffaaiill
         Make the current goal fail.

    iiggnnoorree
         Step over the current goal without executing it.

    nnooddeebbuugg
         Continue execution in normal nodebugging mode.  See nodebug/0.

    rreettrryy
         Retry the current frame.

    rreettrryy((_F_r_a_m_e))
         Retry the given  frame.  This must  be a parent of the  current
         frame.

    sskkiipp
         Skip over  the current  goal (i.e.,  _s_k_i_p in  the command  line
         debugger).

    uupp
         Skip  to  the  parent  goal  (i.e.,  _u_p  in  the  command  line
         debugger).

    Together  with  the predicates  described in  section  4.37 and  the
    other predicates of  this chapter, this predicate enables the Prolog
    user  to define a  complete new debugger in  Prolog.  Besides  this,
    it  enables the  Prolog  programmer to  monitor the  execution of  a
    program.  The  example below records all goals trapped by the tracer
    in the database.

    ____________________________________________________________________|                                                                    |
    | prolog_trace_interception(Port, Frame, _PC, continue) :-           |
    |         prolog_frame_attribute(Frame, goal, Goal),                 |
    |         prolog_frame_attribute(Frame, level, Level),               |

    ||________recordz(trace,_trace(Port,_Level,_Goal))._________________ ||

    To  trace the execution of `go' this way the following  query should
    be given:

    ____________________________________________________________________|                                                                    |
    ||?-_trace,_go,_notrace.____________________________________________ ||


pprroolloogg__sskkiipp__ffrraammee((_-_F_r_a_m_e))
    Indicate  _F_r_a_m_e as  a skipped frame  and set  the `skip level'  (see
    prolog_skip_level/2 to the recursion depth of _F_r_a_m_e.   The effect of
    the skipped flag is  that a redo on a child of this frame is handled
    differently.   First,  a redo trace is  called for the child,  where
    the skip  level is set to redo_in_skip.  Next, the  skip level is set
    to skip level of the skipped frame.


pprroolloogg__sskkiipp__lleevveell((_-_O_l_d_, _+_N_e_w))
    Unify  _O_l_d  with  the  old  value  of  `skip  level'  and  then  set
    this  level  according  to  _N_e_w.    _N_e_w  is  an  integer,  the  atom
    very_deep  (meaning  don't  skip)  or  the  atom  skip_in_redo  (see
    prolog_skip_frame/1).  The `skip level' is a setting  of each Prolog
    thread  that disables  the debugger on  all recursion levels  deeper
    than the level of the variable.  See also prolog_skip_frame/1.


1133..44 BBrreeaakkppooiinntt aanndd wwaattcchhppooiinntt hhaannddlliinngg

SWI-Prolog support  _b_r_e_a_k_p_o_i_n_t_s.   Breakpoints can  be manipulated  with
the  library  prolog_breakpoints.     Setting  a  breakpoint  replaces  a
virtual  machine instruction  with  the D_BREAK  instruction.    If  the
virtual machine executes a D_BREAK, it performs a callback  to decide on
the action  to perform.   This section  describes this callback,  called
prolog:break_hook/6.


pprroolloogg::bbrreeaakk__hhooookk((_+_C_l_a_u_s_e_, _+_P_C_, _+_F_R_, _+_B_F_R_, _+_E_x_p_r_e_s_s_i_o_n_, _-_A_c_t_i_o_n))_[_h_o_o_k_,_s_e_m_i_d_e_t_]
    _E_x_p_e_r_i_m_e_n_t_a_l  This hook is called if the virtual machine  executes a
    D_BREAK,  set using set_breakpoint/4.   _C_l_a_u_s_e  and _P_C identify  the
    breakpoint.   _F_R and _B_F_R  provide the environment frame and  current
    choicepoint.   _E_x_p_r_e_s_s_i_o_n identifies the action that is interrupted,
    and is one of the following:

    ccaallll((_G_o_a_l))
         The instruction will call  _G_o_a_l.  This is generated  for nearly
         all instructions.   Note that  _G_o_a_l is semantically  equivalent
         to the  compiled  body term,  but  might differ  syntactically.
         This  is  notably the  case  when  arithmetic  expressions  are
         compiled in  optimized mode  (see  optimise).   In  particular,
         the  arguments  of arithmetic  expressions  have  already  been
         evaluated.   Thus,  _A is  3*_B, where _B  equals 3  results in  a
         term call(A is 9) if the clause was compiled  with optimization
         enabled.

    !
         The instruction will  call the cut.   Because the semantics  of
         metacalling  the cut  differs from  executing  the cut  in  its
         original context we do not wrap the cut in call/1.

    :-
         The  breakpoint  is  on  the  _n_e_c_k  instruction,  i.e.,   after
         performing the head unifications.

    eexxiitt
         The breakpoint is on the _e_x_i_t instruction, i.e., at  the end of
         the clause.  Note that the exit instruction may  not be reached
         due to last-call optimisation.

    uunniiffyy__eexxiitt
         The breakpoint is on the completion of  an in-lined unification
         while the system  is not in  debug mode.   If the system is  in
         debug mode, inlined unification is returned as call(Var=Term).

    If  prolog:break_hook/6 succeeds, it  must unify _A_c_t_i_o_n with a  value
    that  describes how execution  must continue.   Possible values  for
    _A_c_t_i_o_n are:

    ccoonnttiinnuuee
         Just continue as if no breakpoint was present.

    ddeebbuugg
         Continue in _d_e_b_u_g _m_o_d_e.  See debug/0.

    ttrraaccee
         Continue in _t_r_a_c_e _m_o_d_e.  See trace/0.

    ccaallll((_G_o_a_l))
         Execute  _G_o_a_l instead  of  the  goal that  would  be  executed.
         _G_o_a_l is  executed as call/1,  preserving (non-)determinism  and
         exceptions.

    If  this  hook throws  an  exception,  the exception  is  propagated
    normally.  If  this hook is not defined or fails, the default action
    is  executed.  This  implies that, if the  thread is in debug  mode,
    the  tracer will be enabled (trace) and otherwise the  breakpoint is
    ignored (continue).

    This hook allows  for injecting various debugging scenarios into the
    executable  without recompiling.   The hook can access variables  of
    the  calling context using  the frame inspection  predicates.   Here
    are some examples.

      o  Create _c_o_n_d_i_t_i_o_n_a_l  breakpoints by  imposing conditions  before
         deciding the return trace.

      o  Watch variables  at a specific  point in the  execution.   Note
         that  binding  of  these  variables  can  be   monitored  using
         _a_t_t_r_i_b_u_t_e_d _v_a_r_i_a_b_l_e_s, see section 7.1.

      o  Dynamically add _a_s_s_e_r_t_i_o_n_s on variables using assertion/1.

      o  Wrap the  _G_o_a_l into  a meta-call  that traces  progress of  the
         _G_o_a_l.


1133..55 AAddddiinngg ccoonntteexxtt ttoo eerrrroorrss::  pprroolloogg__eexxcceeppttiioonn__hhooookk

The hook prolog_exception_hook/4 has been introduced in SWI-Prolog 5.6.5
to  provide  dedicated exception  handling  facilities  for  application
frameworks, for  example non-interactive  server applications that  wish
to provide extensive context for exceptions for offline debugging.


pprroolloogg__eexxcceeppttiioonn__hhooookk((_+_E_x_c_e_p_t_i_o_n_I_n_, _-_E_x_c_e_p_t_i_o_n_O_u_t_, _+_F_r_a_m_e_, _+_C_a_t_c_h_e_r_F_r_a_m_e))
    This  hook predicate,  if  defined in  the module  user, is  between
    raising  an  exception   and  handling  it.     It  is  intended  to
    allow  a  program  adding  additional context  to  an  exception  to
    simplify  diagnosing  the problem.    _E_x_c_e_p_t_i_o_n_I_n  is the  exception
    term  as  raised  by throw/1  or  one  of the  built-in  predicates.
    The  output  argument  _E_x_c_e_p_t_i_o_n_O_u_t  describes  the  exception  that
    is  actually  raised.      _F_r_a_m_e  is  the  innermost  frame.     See
    prolog_frame_attribute/3 and  the library  prolog_stack for  getting
    information  from this.   _C_a_t_c_h_e_r_F_r_a_m_e is  a reference to the  frame
    calling  the  matching  catch/3 or  none  if  the exception  is  not
    caught.

    The hook is run  in `nodebug' mode.  If it succeeds, _E_x_c_e_p_t_i_o_n_O_u_t is
    considered the current  exception.  If it fails, _E_x_c_e_p_t_i_o_n_I_n is used
    for further processing.   The hook is _n_e_v_e_r called recursively.  The
    hook is _n_o_t allowed  to modify _E_x_c_e_p_t_i_o_n_O_u_t in such a way that it no
    longer unifies with the catching frame.

    Typically,   prolog_exception_hook/4 is  used  to  fill  the  second
    argument  of error(_F_o_r_m_a_l_, _C_o_n_t_e_x_t) exceptions.   _F_o_r_m_a_l is  defined
    by  the  ISO  standard,   while  SWI-Prolog  defines  _C_o_n_t_e_x_t  as  a
    term  context(_L_o_c_a_t_i_o_n_,  _M_e_s_s_a_g_e).    _L_o_c_a_t_i_o_n is  bound to  a  term
    <_n_a_m_e>/<_a_r_i_t_y>  by the kernel.    This hook can  be used to  add more
    information on the calling context, such as a full stack trace.

    Applications  that use exceptions as part of normal  processing must
    do  a  quick  test  of the  environment  before  starting  expensive
    gathering information on the state of the program.

    The  hook can call  trace/0 to  enter trace mode  immediately.   For
    example,  imagine an application performing an unwanted  division by
    zero while all other  errors are expected and handled.  We can force
    the  debugger using the hook definition  below.  Run the program  in
    debug  mode (see  debug/0) to preserve  as much  as possible of  the
    error context.

    ____________________________________________________________________|                                                                    |
    | user:prolog_exception_hook(                                        |
    |          error(evaluation_error(zero_divisor), _),                 |
    |          _, _, _) :-                                               |

    ||________trace,_fail.______________________________________________ ||


1133..66 HHooookkss uussiinngg tthhee eexxcceeppttiioonn pprreeddiiccaattee

This section describes  the predicate exception/3, which can  be defined
by the  user in the module  user as a multifile  predicate.  Unlike  the
name suggests,  this is actually a _h_o_o_k  predicate that has no  relation
to  Prolog exceptions  as  defined by  the  ISO predicates  catch/3  and
throw/1.

The  predicate exception/3  is  called by  the  kernel  on a  couple  of
events, allowing the user  to `fix' errors just-in-time.   The mechanism
allows for _l_a_z_y creation of objects such as predicates.


eexxcceeppttiioonn((_+_E_x_c_e_p_t_i_o_n_, _+_C_o_n_t_e_x_t_, _-_A_c_t_i_o_n))
    Dynamic  predicate,  normally not  defined.   Called  by the  Prolog
    system  on run-time exceptions that can be  repaired `just-in-time'.
    The values for _E_x_c_e_p_t_i_o_n  are described below.  See also catch/3 and
    throw/1.

    If  this  hook predicate  succeeds it  must  instantiate the  _A_c_t_i_o_n
    argument  to the  atom  fail to  make the  operation fail  silently,
    retry  to tell Prolog  to retry the operation  or error to make  the
    system generate an exception.   The action retry only makes sense if
    this  hook modified the environment such that the operation  can now
    succeed without error.

    uunnddeeffiinneedd__pprreeddiiccaattee
         _C_o_n_t_e_x_t   is    instantiated   to    a   predicate    indicator
         ([module]:<_n_a_m_e>/<_a_r_i_t_y>).  If the  predicate fails, Prolog will
         generate an  existence_error exception.   The hook is  intended
         to implement alternatives  to the built-in autoloader, such  as
         autoloading code  from a database.    Do _n_o_t use  this hook  to
         suppress existence errors on predicates.  See  also unknown and
         section 2.13.

    uunnddeeffiinneedd__gglloobbaall__vvaarriiaabbllee
         _C_o_n_t_e_x_t  is instantiated  to the  name  of the  missing  global
         variable.  The hook  must call nb_setval/2 or b_setval/2 before
         returning with the action retry.


1133..77 HHooookkss ffoorr iinntteeggrraattiinngg lliibbrraarriieess

Some libraries  realise an entirely new  programming paradigm on top  of
Prolog.   An example is  XPCE which adds an  object system to Prolog  as
well as an extensive  set of graphical primitives.   SWI-Prolog provides
several hooks to  improve the integration of  such libraries.  See  also
section 4.5 for  editing hooks and section  4.10.3 for hooking into  the
message system.


pprroolloogg__lliisstt__ggooaall((_:_G_o_a_l))
    Hook, normally not defined.   This hook is called by the 'L' command
    of  the  tracer in  the module  user to  list  the currently  called
    predicate.   This hook may be defined to list only  relevant clauses
    of  the indicated  _G_o_a_l and/or  show the  actual source  code in  an
    editor.  See also portray/1 and multifile/1.


pprroolloogg::ddeebbuugg__ccoonnttrrooll__hhooookk((_:_A_c_t_i_o_n))
    Hook for the  debugger control predicates that allows the creator of
    more  high-level programming languages  to use the common  front-end
    predicates  to control the debugger.   For example, XPCE uses  these
    hooks  to allow for spying methods  rather than predicates.   _A_c_t_i_o_n
    is one of:

    ssppyy((_S_p_e_c))
         Hook in  spy/1.  If  the hook succeeds  spy/1 takes no  further
         action.

    nnoossppyy((_S_p_e_c))
         Hook  in nospy/1.    If  the  hook  succeeds nospy/1  takes  no
         further action.  If  spy/1 is hooked, it is advised to  place a
         complementary hook for nospy/1.

    nnoossppyyaallll
         Hook in nospyall/0.   Should remove all spy points.   This hook
         is called in a failure-driven loop.

    ddeebbuuggggiinngg
         Hook in  debugging/0.   It can  be used in  two ways.   It  can
         report the  status of  the additional  debug points  controlled
         by the  above  hooks and  fail  to let  the system  report  the
         others,  or it  succeeds, overruling  the  entire behaviour  of
         debugging/0.


pprroolloogg::hheellpp__hhooookk((_+_A_c_t_i_o_n))
    Hook  into help/0 and help/1.   If  the hook succeeds, the  built-in
    actions are not  executed.  For example, ?- help(picture). is caught
    by  the XPCE help hook to give  help on the class _p_i_c_t_u_r_e.   Defined
    actions are:

    hheellpp
         User entered plain  help/0 to give default  help.  The  default
         performs help(help/1), giving help on help.

    hheellpp((_W_h_a_t))
         Hook in help/1 on the topic _W_h_a_t.

    aapprrooppooss((_W_h_a_t))
         Hook in apropos/1 on the topic _W_h_a_t.


1133..88 HHooookkss ffoorr llooaaddiinngg ffiilleess

All loading  of source  files is  achieved by  load_files/2.   The  hook
prolog_load_file/2 can be  used to  load Prolog code  from non-files  or
even load entirely different information, such as foreign files.


pprroolloogg__llooaadd__ffiillee((_+_S_p_e_c_, _+_O_p_t_i_o_n_s))
    Load  a single object.  If this  call succeeds, load_files/2 assumes
    the  action has been  taken care of.   This hook  is only called  if
    _O_p_t_i_o_n_s  does not contain the stream(_I_n_p_u_t)  option.  The hook  must
    be defined in the module user.

    This  can  be used  to  load  from unusual  places.    For  example,
    library  http/http_load  loads Prolog directly  from an HTTP  server.
    It  can  also be  used to  load  source in  unusual forms,  such  as
    loading  compressed files without decompressing  them first.   There
    is currently no example of that.


pprroolloogg::ccoommmmeenntt__hhooookk((_+_C_o_m_m_e_n_t_s_, _+_P_o_s_, _+_T_e_r_m))
    This  hook  allows   for  processing  comments  encountered  by  the
    compiler.   If this hook is defined,  the compiler calls read_term/2
    with  the  option  comments(_C_o_m_m_e_n_t_s).    If  the list  of  comments
    returned  by read_term/2  is not empty  it calls  this comment  hook
    with the following arguments.

      o  _C_o_m_m_e_n_t_s is the  non-empty list of comments.   Each comment  is
         a pair _P_o_s_i_t_i_o_n-_S_t_r_i_n_g,  where _S_t_r_i_n_g is  a string object  (see
         section 5.2)  that contains the  comment _i_n_c_l_u_d_i_n_g  delimiters.
         Consecutive line comments are returned as a single comment.

      o  _P_o_s  is a  stream-position  term  that describes  the  starting
         position of _T_e_r_m

      o  _T_e_r_m is the term read.

    This   hook  is  exploited  by  the  documentation  system.      See
    stream_position_data/3.  See also read_term/3.


1133..99 RReeaaddlliinnee IInntteerraaccttiioonn

The following  predicates are available if  SWI-Prolog is linked to  the
GNU  readline library.    This is  by default  the  case on  non-Windows
installations  and indicated  by the  Prolog flag  readline.   See  also
readline(3).


rrll__rreeaadd__iinniitt__ffiillee((_+_F_i_l_e))
    Read  a readline  initialisation file.   Readline  by default  reads
    ~/.inputrc.     This  predicate  may be  used  to  read  alternative
    readline initialisation files.


rrll__aadddd__hhiissttoorryy((_+_L_i_n_e))
    Add  a  line  to  the  Control-P/Control-N  history  system  of  the
    readline library.


rrll__wwrriittee__hhiissttoorryy((_+_F_i_l_e_N_a_m_e))
    Write  current history to _F_i_l_e_N_a_m_e.   Can be used  from at_halt/1 to
    save the history.


rrll__rreeaadd__hhiissttoorryy((_+_F_i_l_e_N_a_m_e))
    Read history from _F_i_l_e_N_a_m_e, appending to the current history.


CChhaapptteerr 1144..  CCOOMMPPAATTIIBBIILLIITTYY WWIITTHH OOTTHHEERR PPRROOLLOOGG DDIIAALLEECCTTSS

This  chapter explains  issues  for  writing portable  Prolog  programs.
It was  started after discussion  with Vitor  Santos Costa, the  leading
developer  of  YAP   Prolog  YAP  and  SWI-Prolog  have  expressed   the
ambition to enhance the portability beyond the  trivial Prolog examples,
including complex libraries involving foreign code.

Although it  is our  aim to enhance  compatibility, we  are still  faced
with many incompatibilities between the dialects.  As  a first step both
YAP and SWI will provide some instruments that  help developing portable
code.   A first  release of these tools  appeared in SWI-Prolog  5.6.43.
Some of  the facilities are  implemented in the  base system, others  in
the library dialect.pl.

  o The  Prolog flag dialect is an unambiguous and fast way to  find out
    which  Prolog dialect executes your program.   It has the value  swi
    for SWI-Prolog and yap on YAP.

  o The  Prolog flag version_data is bound  to a term swi(_M_a_j_o_r_,  _M_i_n_o_r_,
    _P_a_t_c_h_, _E_x_t_r_a)

  o Conditional   compilation  using  :- if(Condition)  ...:- endif   is
    supported.  See section 4.3.1.2.

  o The  predicate  expects_dialect/1 allows  for specifying  for  which
    Prolog system the code was written.

  o The  predicates exists_source/1 and source_exports/2 can be used  to
    query  the library content.  The require/1 directive can be  used to
    get access to predicates without knowing their location.

  o The  module predicates use_module/1,  use_module/2have  been extended
    with  a  notion  for  `import-except'  and `import-as'.     This  is
    particularly  useful  together  with reexport/1  and  reexport/2  to
    compose modules from other modules and mapping names.

  o Foreign  code can expect __SWI_PROLOG__ when compiled for  SWI-Prolog
    and  __YAP_PROLOG__when compiled on YAP.


::-- eexxppeeccttss__ddiiaalleecctt((_+_D_i_a_l_e_c_t))
    This  directive  states that  the code  following  the directive  is
    written  for the  given Prolog  _D_i_a_l_e_c_t.   See  also dialect.    The
    declaration  holds until the  end of the  file in which it  appears.
    The current dialect is available using prolog_load_context/2.

    The   exact  behaviour  of  this  predicate  is  still   subject  to
    discussion.   Of course, if _D_i_a_l_e_c_t matches the running  dialect the
    directive  has no  effect.   Otherwise  we check  for the  existence
    of  library(_d_i_a_l_e_c_t_/_D_i_a_l_e_c_t)  and  load it  if  the file  is  found.
    Currently, this file has this functionality:

      o  Define system  predicates of  the requested dialect  we do  not
         have.

      o  Apply goal_expansion/2  rules that  map conflicting  predicates
         to versions emulating the  requested dialect.  These  expansion
         rules  reside in  the  dialect compatibility  module,  but  are
         applied if prolog_load_context(dialect, Dialect) is active.

      o  Modify  the  search  path  for  library  directories,   putting
         libraries compatible with the target dialect before  the native
         libraries.

      o  Setup  support  for  the  default  filename  extension  of  the
         dialect.


eexxiissttss__ssoouurrccee((_+_S_p_e_c))
    Is  true if  _S_p_e_c exists as  a Prolog source.    _S_p_e_c uses the  same
    conventions as  load_files/2.  Fails without error  if _S_p_e_c cannot be
    found.


ssoouurrccee__eexxppoorrttss((_+_S_p_e_c_, _+_E_x_p_o_r_t))
    Is  true  if source  _S_p_e_c  exports _E_x_p_o_r_t,  a  predicate  indicator.
    Fails without error otherwise.


1144..11 SSoommee ccoonnssiiddeerraattiioonnss ffoorr wwrriittiinngg ppoorrttaabbllee ccooddee

The  traditional  way  to  write  portable  code  is  to  define  custom
predicates  for  all  potentially non-portable  code  and  define  these
separately for  all Prolog  dialects one wishes  to support.   Here  are
some considerations.

  o Probably  the  best reason  for this  is that  it  allows to  define
    minimal  semantics required by  the application for the  portability
    predicates.   Such functionality can often be mapped  efficiently to
    the  target dialect.    Contrary, if  code was  written for  dialect
    X,  the defined semantics are  those of dialect X.   Emulating all
    extreme  cases and full error handling compatibility may  be tedious
    and  result in a much slower  implementation that needed.  Take  for
    example  call_cleanup/2.   The SICStus  definition is  fundamentally
    different from the  SWI definition, but 99% of the applications just
    want to make  calls like below to guarantee _S_t_r_e_a_m_I_n is closed, even
    if process/1 misbehaves.

    ____________________________________________________________________|                                                                    |

    ||________call_cleanup(process(StreamIn),_close(In))________________ ||

  o As  a drawback,  the code becomes  full of _m_y___c_a_l_l___c_l_e_a_n_u_p, etc.  and
    every  potential portability conflict  needs to be  abstracted.   It
    is  hard for people  who have to maintain  such code later to  grasp
    the  exact semantics  of the  _m_y___* predicates  and applications  that
    combine  multiple libraries  using this  compatibility approach  are
    likely  to encounter conflicts  between the portability  layers.   A
    good  start  is not  to  use _m_y___*, but  a  prefix derived  from  the
    library  or  application name  or names  that  explain the  intended
    semantics more precisely.

  o Another  problem is  that most  code is initially  not written  with
    portability  in mind.    Instead, ports  are requested  by users  or
    arise from the desire  to switch Prolog dialect.  Typically, we want
    to  achieve compatibility with the  new Prolog dialect with  minimal
    changes,  often keeping compatibility with the  original dialect(s).
    This  problem is  well known  from the  C/Unix world  and we  advise
    anyone  to study the philosophy of GNU autoconf, from which  we will
    illustrate some highlights below.

The  GNU autoconf  suite, known  to  most people  as configure,  was  an
answer to the frustrating life of Unix/C programmers  when Unix dialects
were  about as  abundant  and  poorly standardised  as  Prolog  dialects
today.   Writing a portable  C program can  only be achieved using  cpp,
the C  preprocessor.   The  C preprocessor  performs two  tasks:   macro
expansion and conditional compilation.  Prolog  realises macro expansion
through term_expansion/2 and goal_expansion/2.   Conditional compilation
is  achieved using  :- if(Condition) as  explained  in section  4.3.1.2.
The situation appears similar.

The important lesson learned  from GNU autoconf is that the  _l_a_s_t resort
for conditional compilation  to achieve portability is to switch  on the
platform or dialect.   Instead, GNU  autoconf allows you to write  tests
for specific  properties of  the platform.   Most  of these are  whether
or  not some  function  or file  is  available.    Then there  are  some
standard tests  for difficult-to-write-portable  situations and  finally
there  is a  framework that  allows you  to write  arbitrary C  programs
and check  whether they  can be  compiled and/or whether  they show  the
intended behaviour.   Using  a separate configure  program is needed  in
C, as  you cannot  perform C  compilation step  or run  C programs  from
the C  preprocessor.  In  most Prolog environments  we do not need  this
distinction as the  compiler is integrated into the runtime  environment
and Prolog has excellent reflexion capabilities.

We  must learn  from the  distinction to  test for  features instead  of
platform (dialect), as this makes the platform-specific  code robust for
future changes of the dialect.  Suppose we need  compare/3 as defined in
this manual.   The compare/3 predicate is not part of the  ISO standard,
but  many systems  support it  and it  is not  unlikely  it will  become
ISO standard  or the  intended dialect will  start supporting  it.   GNU
autoconf strongly advises to test for the availability:

________________________________________________________________________|                                                                        |
|:- if(\+current_predicate(_, compare(_,_,_))).                          |
|compare(<, Term1, Term2) :-                                             |

|        Term1 @< Term2, !.                                              |
|compare(>, Term1, Term2) :-                                             |
|        Term1 @> Term2, !.                                              |
|compare(=, Term1, Term2) :-                                             |
|        Term1 == Term2.                                                 |
|:-|endif.______________________________________________________________ |  |

This code is  mmuucchh more robust against  changes to the intended  dialect
and, possibly  at least  as important,  will provide compatibility  with
dialects you didn't even consider porting to right now.

In a  more challenging case,  the target Prolog  has compare/3, but  the
semantics  are different.    What to  do?    One option  is  to write  a
my_compare/3 and change all occurrences in the code.   Alternatively you
can rename  calls using  goal_expansion/2 like  below.   This  construct
will not  only deal with  Prolog dialects lacking  compare/3 as well  as
those that  only implement  it for  numeric comparison  or have  changed
the argument order.   Of course,  writing rock-solid code would  require
a  complete  test-suite,  but  this  example  will  probably  cover  all
Prolog dialects  that allow for conditional  compilation, have core  ISO
facilities and  provide goal_expansion/2, the things  we claim a  Prolog
dialect should have to start writing portable code for it.

________________________________________________________________________|                                                                        |

|:- if(\+catch(compare(<,a,b), _, fail)).                                |
|compare_standard_order(<, Term1, Term2) :-                              |
|        Term1 @< Term2, !.                                              |
|compare_standard_order(>, Term1, Term2) :-                              |
|        Term1 @> Term2, !.                                              |
|compare_standard_order(=, Term1, Term2) :-                              |
|        Term1 == Term2.                                                 |

|                                                                        |
|goal_expansion(compare(Order, Term1, Term2),                            |
|               compare_standard_order(Order, Term1, Term2)).            |
|:-|endif.______________________________________________________________ |  |


CChhaapptteerr 1155..  GGLLOOSSSSAARRYY OOFF TTEERRMMSS

aannoonnyymmoouuss [[vvaarriiaabbllee]]
    The  variable  _  is  called  the  _a_n_o_n_y_m_o_u_s  variable.     Multiple
    occurrences of _ in a single _t_e_r_m are not _s_h_a_r_e_d.

aarrgguummeennttss
    Arguments  are _t_e_r_m_s that appear in a _c_o_m_p_o_u_n_d _t_e_r_m.  _A_1  and _a_2 are
    the first and second argument of the term myterm(_A_1_, _a_2).

aarriittyy
    Argument count (= number of arguments) of a _c_o_m_p_o_u_n_d _t_e_r_m.

aasssseerrtt
    Add a _c_l_a_u_s_e to  a _p_r_e_d_i_c_a_t_e.  Clauses can be added at either end of
    the clause-list of a _p_r_e_d_i_c_a_t_e.  See asserta/1 and assertz/1.

aattoomm
    Textual  constant.   Used as name for  _c_o_m_p_o_u_n_d terms, to  represent
    constants or text.

bbaacckkttrraacckkiinngg
    Search  process used  by Prolog.    If a  predicate offers  multiple
    _c_l_a_u_s_e_s  to  solve  a _g_o_a_l,  they  are  tried one-by-one  until  one
    _s_u_c_c_e_e_d_s.    If  a subsequent  part of  the proof  is not  satisfied
    with  the resulting _v_a_r_i_a_b_l_e _b_i_n_d_i_n_g, it may ask for  an alternative
    _s_o_l_u_t_i_o_n (= _b_i_n_d_i_n_g  of the _v_a_r_i_a_b_l_e_s), causing Prolog to reject the
    previously chosen _c_l_a_u_s_e and try the next one.

bbiinnddiinngg [[ooff aa vvaarriiaabbllee]]
    Current value of the _v_a_r_i_a_b_l_e.  See also _b_a_c_k_t_r_a_c_k_i_n_g and _q_u_e_r_y.

bbuuiilltt--iinn [[pprreeddiiccaattee]]
    Predicate  that is part of the  Prolog system.  Built-in  predicates
    cannot  be redefined  by the  user, unless this  is overruled  using
    redefine_system_predicate/1.

bbooddyy
    Part of a _c_l_a_u_s_e behind the _n_e_c_k operator (:-).

cchhooiiccee ppooiinntt
    A  _c_h_o_i_c_e _p_o_i_n_t represents  a choice in  the search for a  _s_o_l_u_t_i_o_n.
    Choice  points are  created  if multiple  clauses match  a _q_u_e_r_y  or
    using  disjunction (;/2).   On _b_a_c_k_t_r_a_c_k_i_n_g, the execution state  of
    the  most recent _c_h_o_i_c_e _p_o_i_n_t is restored and search  continues with
    the next alternative (i.e., next clause or second branch of ;/2).

ccllaauussee
    `Sentence'  of a Prolog program.   A _c_l_a_u_s_e  consists of a _h_e_a_d  and
    _b_o_d_y  separated by  the _n_e_c_k operator  (:-) or it  is a _f_a_c_t.    For
    example:

    ____________________________________________________________________|                                                                    |
    | parent(X) :-                                                       |

    ||________father(X,__)._____________________________________________ ||

    Expressed  as ``X is a  parent if X is a  father of someone''.   See
    also _v_a_r_i_a_b_l_e and _p_r_e_d_i_c_a_t_e.

ccoommppiillee
    Process  where  a Prolog  _p_r_o_g_r_a_m  is translated  to a  sequence  of
    instructions.   See  also _i_n_t_e_r_p_r_e_t_e_d.   SWI-Prolog always  compiles
    your program before executing it.

ccoommppoouunndd [[tteerrmm]]
    Also  called  _s_t_r_u_c_t_u_r_e.    It  consists of  a  name followed  by  _N
    _a_r_g_u_m_e_n_t_s,  each of which are _t_e_r_m_s.   _N is called the _a_r_i_t_y  of the
    term.

ccoonntteexxtt mmoodduullee
    If  a _t_e_r_m  is referring  to a _p_r_e_d_i_c_a_t_e  in a  _m_o_d_u_l_e, the  _c_o_n_t_e_x_t
    _m_o_d_u_l_e  is used to find the target module.  The context  module of a
    _g_o_a_l  is the module in which  the _p_r_e_d_i_c_a_t_e is defined, unless  this
    _p_r_e_d_i_c_a_t_e  is _m_o_d_u_l_e _t_r_a_n_s_p_a_r_e_n_t, in  which case the _c_o_n_t_e_x_t  _m_o_d_u_l_e
    is  inherited from the parent  _g_o_a_l.  See  also module_transparent/1
    and _m_e_t_a_-_p_r_e_d_i_c_a_t_e.

ddeett [[ddeetteerrmmiinniissmm]]
    Short for _d_e_t_e_r_m_i_n_i_s_t_i_c.

ddeetteerrmmiinniissmm
    How  many solutions a _g_o_a_l can  provide.  Values are `nondet'  (zero
    to  infinite), `multi'  (one to infinite),  `det' (exactly one)  and
    `semidet' (zero or one).

ddeetteerrmmiinniissttiicc
    A  _p_r_e_d_i_c_a_t_e  is  _d_e_t_e_r_m_i_n_i_s_t_i_c  if it  succeeds  exactly  one  time
    without leaving a _c_h_o_i_c_e _p_o_i_n_t.

ddyynnaammiicc [[pprreeddiiccaattee]]
    A _d_y_n_a_m_i_c predicate  is a predicate to which _c_l_a_u_s_e_s may be _a_s_s_e_r_ted
    and  from  which  _c_l_a_u_s_e_s may  be  _r_e_t_r_a_c_ted  while the  program  is
    running.  See also _u_p_d_a_t_e _v_i_e_w.

eexxppoorrtteedd [[pprreeddiiccaattee]]
    A  _p_r_e_d_i_c_a_t_e is  said to  be _e_x_p_o_r_t_e_d from  a _m_o_d_u_l_e  if it  appears
    in  the  _p_u_b_l_i_c _l_i_s_t.     This implies  that  the predicate  can  be
    _i_m_p_o_r_t_e_d  into another module  to make it visible  there.  See  also
    use_module/[1,2].

ffaacctt
    _C_l_a_u_s_e  without a _b_o_d_y.  This is called a fact  because, interpreted
    as logic, there is  no condition to be satisfied.  The example below
    states john is a person.

    ____________________________________________________________________|                                                                    |
    ||person(john)._____________________________________________________ ||

ffaaiill
    A _g_o_a_l is said to haved failed if it could not be _p_r_o_v_e_n.

ffllooaatt
    Computer's  crippled representation of a  real number.   Represented
    as `IEEE double'.

ffoorreeiiggnn
    Computer code expressed  in languages other than Prolog.  SWI-Prolog
    can only cooperate directly with the C and C++ computer languages.

ffuunnccttoorr
    Combination  of name and _a_r_i_t_y of a _c_o_m_p_o_u_n_d term.  The  term foo(_a_,
    _b_,  _c) is said to be a  term belonging to the functor foo/3.   foo/0
    is used to refer to the _a_t_o_m foo.

ggooaall
    Question  stated to the  Prolog engine.   A _g_o_a_l  is either an  _a_t_o_m
    or  a _c_o_m_p_o_u_n_d  term.   A _g_o_a_l  either succeeds, in  which case  the
    _v_a_r_i_a_b_l_e_s  in the  _c_o_m_p_o_u_n_d terms  have a  _b_i_n_d_i_n_g, or  it _f_a_i_l_s  if
    Prolog fails to prove it.

hhaasshhiinngg
    _I_n_d_e_x_i_n_g technique used for quick lookup.

hheeaadd
    Part of a _c_l_a_u_s_e before the  _n_e_c_k operator (:-).  This is an _a_t_o_m or
    _c_o_m_p_o_u_n_d term.

iimmppoorrtteedd [[pprreeddiiccaattee]]
    A  _p_r_e_d_i_c_a_t_e is said to be _i_m_p_o_r_t_e_d  into a _m_o_d_u_l_e if it  is defined
    in  another _m_o_d_u_l_e  and made  available in this  _m_o_d_u_l_e.   See  also
    chapter 6.

iinnddeexxiinngg
    Indexing is a  technique used to quickly select candidate _c_l_a_u_s_e_s of
    a  _p_r_e_d_i_c_a_t_e for a specific _g_o_a_l.  In most Prolog  systems, indexing
    is done (only) on  the first _a_r_g_u_m_e_n_t of the _h_e_a_d.  If this argument
    is  instantiated to an  _a_t_o_m, _i_n_t_e_g_e_r, _f_l_o_a_t  or _c_o_m_p_o_u_n_d term  with
    _f_u_n_c_t_o_r,  _h_a_s_h_i_n_g is used  to quickly select  all _c_l_a_u_s_e_s where  the
    first  argument  may _u_n_i_f_y  with  the first  argument of  the  _g_o_a_l.
    SWI-Prolog  supports just-in-time and multi-argument indexing.   See
    section 2.17.

iinntteeggeerr
    Whole number.   On all implementations of SWI-Prolog integers are at
    least  64-bit signed values.   When linked  to the GNU GMP  library,
    integer  arithmetic is unbounded.    See also current_prolog_flag/2,
    flags bounded, max_integer and min_integer.

iinntteerrpprreetteedd
    As  opposed  to  _c_o_m_p_i_l_e_d,   interpreted  means  the  Prolog  system
    attempts  to prove  a _g_o_a_l  by directly reading  the _c_l_a_u_s_e_s  rather
    than executing instructions  from an (abstract) instruction set that
    is not or only indirectly related to Prolog.

iinnssttaannttiiaattiioonn [[ooff aann aarrgguummeenntt]]
    To  what  extend  a term  is  bound to  a  value.    Typical  levels
    are  `unbound' (a  _v_a_r_i_a_b_l_e), `ground'  (term without variables)  or
    `partially bound' (term with embedded variables).

mmeettaa--pprreeddiiccaattee
    A  _p_r_e_d_i_c_a_t_e that reasons about other _p_r_e_d_i_c_a_t_e_s, either  by calling
    them, (re)defining them or querying _p_r_o_p_e_r_t_i_e_s.

mmooddee [[ddeeccllaarraattiioonn]]
    Declaration  of an argument  _i_n_s_t_a_n_t_i_a_t_i_o_n pattern for a  _p_r_e_d_i_c_a_t_e,
    often accompanied with a _d_e_t_e_r_m_i_n_i_s_m.

mmoodduullee
    Collection  of predicates.    Each module defines  a name-space  for
    predicates.   _b_u_i_l_t_-_i_n predicates  are accessible from all  modules.
    Predicates  can be published (_e_x_p_o_r_t_e_d)  and _i_m_p_o_r_t_e_d to make  their
    definition available to other modules.

mmoodduullee ttrraannssppaarreenntt [[pprreeddiiccaattee]]
    A  _p_r_e_d_i_c_a_t_e that  does not change  the _c_o_n_t_e_x_t  _m_o_d_u_l_e.   Sometimes
    also called a _m_e_t_a_-_p_r_e_d_i_c_a_t_e.

mmuullttii [[ddeetteerrmmiinniissmm]]
    A  _p_r_e_d_i_c_a_t_e is said  to have _d_e_t_e_r_m_i_n_i_s_m  multi if it generates  at
    _l_e_a_s_t one answer.

mmuullttiiffiillee [[pprreeddiiccaattee]]
    Predicate  for which  the  definition is  distributed over  multiple
    source files.  See multifile/1.

nneecckk
    Operator (:-) separating _h_e_a_d from _b_o_d_y in a _c_l_a_u_s_e.

nnoonnddeett
    Short for _n_o_n _d_e_t_e_r_m_i_n_i_s_t_i_c.

nnoonn ddeetteerrmmiinniissttiicc
    A  _n_o_n _d_e_t_e_r_m_i_n_i_s_t_i_c  predicate  is a  predicate that  mail fail  or
    succeed any number of times.

ooppeerraattoorr
    Symbol (_a_t_o_m) that  may be placed before its _o_p_e_r_a_n_d (prefix), after
    its _o_p_e_r_a_n_d (postfix) or between its two _o_p_e_r_a_n_d_s (infix).

    In  Prolog, the expression a+b is exactly the same as  the canonical
    term +(a,b).

ooppeerraanndd
    _A_r_g_u_m_e_n_t of an _o_p_e_r_a_t_o_r.

pprreecceeddeennccee
    The  _p_r_i_o_r_i_t_y  of an  _o_p_e_r_a_t_o_r.    Operator  precedence is  used  to
    interpret a+b*c as +(a, *(b,c)).

pprreeddiiccaattee
    Collection  of _c_l_a_u_s_e_s  with the same  _f_u_n_c_t_o_r (name/_a_r_i_t_y).   If  a
    _g_o_a_l  is proved,  the system  looks for  a _p_r_e_d_i_c_a_t_e  with the  same
    functor,  then uses  _i_n_d_e_x_i_n_g to select  candidate _c_l_a_u_s_e_s and  then
    tries these _c_l_a_u_s_e_s one-by-one.  See also _b_a_c_k_t_r_a_c_k_i_n_g.

pprreeddiiccaattee iinnddiiccaattoorr
    Term  of the form Name/Arity  (traditional) or Name//Arity (ISO  DCG
    proposal),  where Name is an atom and Arity a  non-negative integer.
    It acts as an _i_n_d_i_c_a_t_o_r (or reference) to a predicate or _D_C_G rule.

pprriioorriittyy
    In the context of _o_p_e_r_a_t_o_r_s a synonym for _p_r_e_c_e_d_e_n_c_e.

pprrooggrraamm
    Collection of _p_r_e_d_i_c_a_t_e_s.

pprrooppeerrttyy
    Attribute  of  an object.    SWI-Prolog  defines  various _*___p_r_o_p_e_r_t_y
    predicates to query the status of predicates, clauses.  etc.

pprroovvee
    Process  where Prolog attempts to prove a _q_u_e_r_y using  the available
    _p_r_e_d_i_c_a_t_e_s.

ppuubblliicc lliisstt
    List of _p_r_e_d_i_c_a_t_e_s exported from a _m_o_d_u_l_e.

qquueerryy
    See _g_o_a_l.

rreettrraacctt
    Remove  a _c_l_a_u_s_e from a  _p_r_e_d_i_c_a_t_e.   See also _d_y_n_a_m_i_c, _u_p_d_a_t_e  _v_i_e_w
    and _a_s_s_e_r_t.

sseemmiiddeett
    Shorthand for

sseemmii ddeetteerrmmiinniissttiicc
    .

sseemmii ddeetteerrmmiinniissttiicc
    A  _p_r_e_d_i_c_a_t_e that  is _s_e_m_i  _d_e_t_e_r_m_i_n_i_s_t_i_c either  fails or  succeeds
    exactly once without a _c_h_o_i_c_e _p_o_i_n_t.  See also _d_e_t_e_r_m_i_n_i_s_t_i_c.

sshhaarreedd
    Two  _v_a_r_i_a_b_l_e_s  are called  _s_h_a_r_e_d after  they are  _u_n_i_f_i_e_d.    This
    implies  if either of them is _b_o_u_n_d, the other is bound to  the same
    value:

    ____________________________________________________________________|                                                                    |
    | ?- A = B, A = a.                                                   |
    ||A_=_B,_B_=_a._____________________________________________________ ||

ssiinngglleettoonn [[vvaarriiaabbllee]]
    _V_a_r_i_a_b_l_e  appearing only one time in a _c_l_a_u_s_e.   SWI-Prolog normally
    warns  for  this to  avoid  you  making spelling  mistakes.    If  a
    variable  appears on  purpose only  once in  a clause,  write it  as
    _  (see _a_n_o_n_y_m_o_u_s).    Rules for naming  a variable  and avoiding  a
    warning are given in section 2.15.2.5.

ssoolluuttiioonn
    _B_i_n_d_i_n_g_s resulting from a successfully _p_r_o_v_en _g_o_a_l.

ssttrruuccttuurree
    Synonym for _c_o_m_p_o_u_n_d term.

ssttrriinngg
    Used  for the  following representations  of text:   a packed  array
    (see  section 5.2, SWI-Prolog specific),  a list of character  codes
    or a list of one-character _a_t_o_m_s.

ssuucccceeeedd
    A _g_o_a_l is said to have _s_u_c_c_e_e_d_e_d if it has been _p_r_o_v_e_n.

tteerrmm
    Value in Prolog.   A _t_e_r_m is either a _v_a_r_i_a_b_l_e, _a_t_o_m, _i_n_t_e_g_e_r, _f_l_o_a_t
    or  _c_o_m_p_o_u_n_d term.   In addition,  SWI-Prolog also defines the  type
    _s_t_r_i_n_g.

ttrraannssppaarreenntt
    See _m_o_d_u_l_e _t_r_a_n_s_p_a_r_e_n_t.

uunniiffyy
    Prolog  process to make  two terms equal  by assigning variables  in
    one term to  values at the corresponding location of the other term.
    For example:

    ____________________________________________________________________|                                                                    |

    | ?- foo(a, B) = foo(A, b).                                          |
    | A = a,                                                             |
    ||B_=_b.____________________________________________________________ ||

    Unlike  assignment (which does not exist in Prolog),  unification is
    not directed.

uuppddaattee vviieeww
    How  Prolog behaves when a _d_y_n_a_m_i_c _p_r_e_d_i_c_a_t_e is changed while  it is
    running.   There are two models.   In most older Prolog  systems the
    change  becomes immediately visible to  the _g_o_a_l, in modern  systems
    including  SWI-Prolog, the running _g_o_a_l is  not affected.  Only  new
    _g_o_a_l_s `see' the new definition.

vvaarriiaabbllee
    A  Prolog  variable is  a value  that `is  not yet  bound'.    After
    _b_i_n_d_i_n_g a variable, it  cannot be modified.  _B_a_c_k_t_r_a_c_k_i_n_g to a point
    in  the execution before  the variable was  bound will turn it  back
    into a variable:

    ____________________________________________________________________|                                                                    |
    | ?- A = b, A = c.                                                   |
    | false.                                                             |
    |                                                                    |
    | ?- (A = b; true; A = c).                                           |

    | A = b ;                                                            |
    | true ;                                                             |
    ||A_=_c_.___________________________________________________________ ||

    See also _u_n_i_f_y.


CChhaapptteerr 1166..  SSWWII--PPRROOLLOOGG LLIICCEENNSSEE CCOONNDDIITTIIOONNSS AANNDD TTOOOOLLSS

SWI-Prolog licensing aims at a large audience, combining  ideas from the
Free Software Foundation and the less principal  Open Source Initiative.
The license aims at the following:

  o Make SWI-Prolog and its libraries `as free as possible'.

  o Allow for easy integration of contributions.  See section 16.2.

  o Free software can build on SWI-Prolog without limitations.

  o Non-free  (open  or  proprietary)  software can  be  produced  using
    SWI-Prolog,  although contributed pure  GPL-ed components cannot  be
    used.

To achieve this, different parts of the system  have different licenses.
SWI-Prolog  programs consist  of  a  mixture of  `native'  code  (source
compiled to  machine instructions)  and `virtual  machine' code  (Prolog
source  compiled to  SWI-Prolog virtual  machine instructions,  covering
both compiled SWI-Prolog libraries and your compiled application).

For  maximal coherence  between free  licenses, we  start  with the  two
prime  licenses from  the  Free  Software Foundation,  the  GNU  General
Public License (GPL)  and the Lesser GNU General Public  License (LGPL),
after which we add a proven (used by the GNU  C compiler runtime library
as  well as  the  GNU _C_l_a_s_s_P_a_t_h  project)  exception  to deal  with  the
specific nature of compiled virtual machine code in a saved state.


1166..11 TThhee SSWWII--PPrroolloogg kkeerrnneell aanndd ffoorreeiiggnn lliibbrraarriieess

The SWI-Prolog  kernel and our foreign  libraries are distributed  under
the  LLGGPPLL. A  Prolog executable  consists of  the  combination of  these
`native'  code  components  and  Prolog  virtual  machine  code.     The
SWI-Prolog swipl-rc utility  allows for disassembling and  re-assembling
these parts, a process satisfying article 66bb of the LGPL.

Under  the LGPL,  SWI-Prolog can  be linked  to  code distributed  under
arbitrary licenses,  provided a  number of  requirements are  fulfilled.
The  most important  requirement is  that if  an  application relies  on
a _m_o_d_i_f_i_e_d  version of  SWI-Prolog, the  modified sources  must be  made
available.


1166..11..11 TThhee SSWWII--PPrroolloogg PPrroolloogg lliibbrraarriieess

Lacking a  satisfactory technical solution  to handle  article 66 of  the
LGPL, this  license cannot be  used for the Prolog  source code that  is
part of the  SWI-Prolog system (both libraries  and kernel code).   This
situation is  comparable to libgcc,  the runtime  library used with  the
GNU C  compiler.   Therefore, we  use the same  proven license terms  as
this library.    The libgcc  license is  the with  a special  exception.
Below we rephrase this exception adjusted to our needs:

    _A_s  _a _s_p_e_c_i_a_l  _e_x_c_e_p_t_i_o_n_, _i_f _y_o_u  _l_i_n_k _t_h_i_s  _l_i_b_r_a_r_y _w_i_t_h _o_t_h_e_r
    _f_i_l_e_s_,  _c_o_m_p_i_l_e_d  _w_i_t_h  _a _F_r_e_e  _S_o_f_t_w_a_r_e  _c_o_m_p_i_l_e_r_,  _t_o _p_r_o_d_u_c_e
    _a_n  _e_x_e_c_u_t_a_b_l_e_,  _t_h_i_s  _l_i_b_r_a_r_y  _d_o_e_s _n_o_t  _b_y  _i_t_s_e_l_f  _c_a_u_s_e _t_h_e
    _r_e_s_u_l_t_i_n_g  _e_x_e_c_u_t_a_b_l_e _t_o _b_e  _c_o_v_e_r_e_d _b_y _t_h_e  _G_N_U _G_e_n_e_r_a_l _P_u_b_l_i_c
    _L_i_c_e_n_s_e_.    _T_h_i_s _e_x_c_e_p_t_i_o_n  _d_o_e_s _n_o_t_,  _h_o_w_e_v_e_r_,  _i_n_v_a_l_i_d_a_t_e _a_n_y
    _o_t_h_e_r  _r_e_a_s_o_n_s _w_h_y _t_h_e _e_x_e_c_u_t_a_b_l_e _f_i_l_e  _m_i_g_h_t _b_e _c_o_v_e_r_e_d _b_y _t_h_e
    _G_N_U _G_e_n_e_r_a_l _P_u_b_l_i_c _L_i_c_e_n_s_e_.


1166..22 CCoonnttrriibbuuttiinngg ttoo tthhee SSWWII--PPrroolloogg pprroojjeecctt

To  achieve maximal  coherence using  SWI-Prolog for  Free and  Non-Free
software we  advise using LGPL  for contributed  foreign code and  using
GPL  with the  SWI-Prolog  exception  for Prolog  code  for  contributed
modules.

As a  rule of thumb  it is  advised to use  the above licenses  whenever
possible,  and use a  strict GPL  compliant license only  if the  module
contains other code under strict GPL compliant licenses.


1166..33 SSooffttwwaarree ssuuppppoorrtt ttoo kkeeeepp ttrraacckk ooff lliicceennssee ccoonnddiittiioonnss

Given the above, it is possible that SWI-Prolog  packages and extensions
will  rely  on the  GPL.  The  predicates below  allow  for  registering
license  requirements  for  Prolog files  and  foreign  modules.     The
predicate  eval_license/0 reports which  components  from the  currently
configured  system  are  distributed under  copy-left  and  open  source
enforcing  licenses (the  GPL)  and therefore  must be  replaced  before
distributing linked applications under non-free license conditions.


eevvaall__lliicceennssee
    Evaluate  the license conditions of all  loaded components.  If  the
    system  contains  one or  more components  that  are licenced  under
    GPL-like  restrictions the  system indicates this  program may  only
    be  distributed under the  GPL license as  well as which  components
    prohibit the use of other license conditions.


lliicceennssee((_+_L_i_c_e_n_s_e_I_d_, _+_C_o_m_p_o_n_e_n_t))
    Register  the fact  that _C_o_m_p_o_n_e_n_t  is distributed  under a  license
    identified by _L_i_c_e_n_s_e_I_d.  The most important _L_i_c_e_n_s_e_I_d's are:

    sswwiippll
         Indicates this  module  is distributed  under the  GNU  General
         Public License (GPL) with the SWI-Prolog exception:

             _A_s _a  _s_p_e_c_i_a_l _e_x_c_e_p_t_i_o_n_, _i_f _y_o_u _l_i_n_k _t_h_i_s _l_i_b_r_a_r_y _w_i_t_h
             _o_t_h_e_r  _f_i_l_e_s_, _c_o_m_p_i_l_e_d _w_i_t_h _S_W_I_-_P_r_o_l_o_g_,  _t_o _p_r_o_d_u_c_e _a_n
             _e_x_e_c_u_t_a_b_l_e_, _t_h_i_s  _l_i_b_r_a_r_y _d_o_e_s _n_o_t _b_y _i_t_s_e_l_f _c_a_u_s_e _t_h_e
             _r_e_s_u_l_t_i_n_g _e_x_e_c_u_t_a_b_l_e  _t_o _b_e _c_o_v_e_r_e_d _b_y _t_h_e _G_N_U _G_e_n_e_r_a_l
             _P_u_b_l_i_c  _L_i_c_e_n_s_e_.   _T_h_i_s  _e_x_c_e_p_t_i_o_n _d_o_e_s  _n_o_t_, _h_o_w_e_v_e_r_,
             _i_n_v_a_l_i_d_a_t_e  _a_n_y _o_t_h_e_r _r_e_a_s_o_n_s _w_h_y  _t_h_e _e_x_e_c_u_t_a_b_l_e _f_i_l_e
             _m_i_g_h_t _b_e _c_o_v_e_r_e_d _b_y _t_h_e _G_N_U _G_e_n_e_r_a_l _P_u_b_l_i_c _L_i_c_e_n_s_e_.

         This should  be the  default  for software  contributed to  the
         SWI-Prolog  project  as it  allows  the  community  to  prosper
         both in  the free  and non-free  world.    Still, people  using
         SWI-Prolog  to create  non-free  applications  must  contribute
         sources to improvements they make to the community.

    llggppll
         This is the default  license for foreign libraries linked  with
         SWI-Prolog.   Use PL_license() to  register the condition  from
         foreign code.

    ggppll
         Indicates this module is strictly Free Software,  which implies
         it  cannot   be  used   together  with  any   module  that   is
         incompatible with  the GPL.  Please only  use these  conditions
         when forced by other code used in the component.

    Other  licenses  known  to  the  system  are  guile,  gnu_ada,  x11,
    expat,  sml, public_domain, cryptix, bsd, zlib,  lgpl_compatible  and
    gpl_compatible.   New licenses can be defined by adding  clauses for
    the  multifile predicate  license:license/3.   Below is an  example.
    The second argument  is either gpl or lgpl to indicate compatibility
    with  these  licenses.     Other values  cause  the  license  to  be
    interpreted  as _p_r_o_p_r_i_e_t_a_r_y.   Proprietary licenses are reported  by
    eval_license/0.  See the file boot/license.pl for details.

    ____________________________________________________________________|                                                                    |
    | :- multifile license:license/3.                                    |

    |                                                                    |
    | license:license(mylicense, lgpl,                                   |
    |                 [ comment('My personal license'),                  |
    |                   url('http://www.mine.org/license.html')          |
    |                 ]).                                                |
    |                                                                    |
    ||:-_license(mylicense).____________________________________________ ||


lliicceennssee((_+_L_i_c_e_n_s_e_I_d))
    Intended  as a  directive  in Prolog  source files.    It takes  the
    current filename and calls license/2.


void PPLL__lliicceennssee(_c_o_n_s_t _c_h_a_r _*_L_i_c_e_n_s_e_I_d_, _c_o_n_s_t _c_h_a_r _*_C_o_m_p_o_n_e_n_t)
    Intended  for the install()  procedure of foreign  libraries.   This
    call can be made _b_e_f_o_r_e PL_initialise().


1166..44 LLiicceennssee ccoonnddiittiioonnss iinnhheerriitteedd ffrroomm uusseedd ccooddee


1166..44..11 CCrryyppttooggrraapphhiicc rroouuttiinneess

Cryptographic routines  are used  in variant_sha1/2  and crypt.    These
routines are provided under the following conditions:

Copyright (c) 2002, Dr Brian Gladman, Worcester, UK.   All rights reserved.

LICENSE TERMS

The free distribution and use of this software in both source and binary
form is allowed (with or without changes) provided that:

   1. distributions of this source code include the above copyright
      notice, this list of conditions and the following disclaimer;

   2. distributions in binary form include the above copyright
      notice, this list of conditions and the following disclaimer
      in the documentation and/or other associated materials;

   3. the copyright holder's name is not used to endorse products
      built using this software without specific written permission.

ALTERNATIVELY, provided that this notice is retained in full, this product
may be distributed under the terms of the GNU General Public License (GPL),
in which case the provisions of the GPL apply INSTEAD OF those given above.

DISCLAIMER

This software is provided 'as is' with no explicit or implied warranties
in respect of its properties, including, but not limited to, correctness
and/or fitness for purpose.


CChhaapptteerr 1177..  SSUUMMMMAARRYY


1177..11 PPrreeddiiccaatteess

The  predicate summary  is used  by the  Prolog  predicate apropos/1  to
suggest predicates from a keyword.

 @/2                            Call using calling context
 !/0                            Cut (discard choicepoints)
 ,/2                            Conjunction of goals
 ->/2                           If-then-else
 *->/2                          Soft-cut
 ./2                            Consult.  Also functional notation
 :</2                           Select keys from a dict
 ;/2                            Disjunction of two goals

 </2                            Arithmetic smaller
 =/2                            True when arguments are unified
 =../2                          ``Univ.''  Term to list conversion
 =:=/2                          Arithmetic equality
 =</2                           Arithmetic smaller or equal
 ==/2                           Test for strict equality
 =@=/2                          Test for structural equality (variant)

 =\=/2                          Arithmetic not equal
 >/2                            Arithmetic larger
 >=/2                           Arithmetic larger or equal
 >:</2                          Partial dict unification
 ?=/2                           Test of terms can be compared now
 @</2                           Standard order smaller
 @=</2                          Standard order smaller or equal
 @>/2                           Standard order larger

 @>=/2                          Standard order larger or equal
 \+/1                           Negation by failure.  Same as not/1
 \=/2                           True if arguments cannot be unified
 \==/2                          True if arguments are not strictly equal
 \=@=/2                         Not structural identical
 ^/2                            Existential quantification (bagof/3, setof/3)
 |/2                            Disjunction in DCGs.  Same as ;/2

 {}/1                           DCG escape; constraints
 abolish/1                      Remove predicate definition from the database
 abolish/2                      Remove predicate definition from the database
 abort/0                        Abort execution, return to top level
 absolute_file_name/2           Get absolute path name
 absolute_file_name/3           Get absolute path name with options
 access_file/2                  Check access permissions of a file
 acyclic_term/1                 Test term for cycles

 add_import_module/3            Add module to the auto-import list
 add_nb_set/2                   Add term to a non-backtrackable set
 add_nb_set/3                   Add term to a non-backtrackable set
 append/1                       Append to a file
 apply/2                        Call goal with additional arguments
 apropos/1                      online_help Search manual
 arg/3                          Access argument of a term

 assoc_to_list/2                Convert association tree to list
 assert/1                       Add a clause to the database
 assert/2                       Add a clause to the database, give reference
 asserta/1                      Add a clause to the database (first)
 asserta/2                      Add a clause to the database (first)
 assertion/1                    Make assertions about your program
 assertz/1                      Add a clause to the database (last)
 assertz/2                      Add a clause to the database (last)

 attach_console/0               Attach I/O console to thread
 attribute_goals/3              Project attributes to goals
 attr_unify_hook/2              Attributed variable unification hook
 attr_portray_hook/2            Attributed variable print hook
 attvar/1                       Type test for attributed variable
 at_end_of_stream/0             Test for end of file on input
 at_end_of_stream/1             Test for end of file on stream

 at_halt/1                      Register goal to run at halt/1
 atom/1                         Type check for an atom
 atom_chars/2                   Convert between atom and list of characters
 atom_codes/2                   Convert between atom and list of characters codes
 atom_concat/3                  Contatenate two atoms
 atom_length/2                  Determine length of an atom
 atom_number/2                  Convert between atom and number
 atom_prefix/2                  Test for start of atom

 atom_string/2                  Conversion between atom and string
 atom_to_term/3                 Convert between atom and term
 atomic/1                       Type check for primitive
 atomic_concat/3                Concatenate two atomic values to an atom
 atomic_list_concat/2           Append a list of atomics
 atomic_list_concat/3           Append a list of atomics with separator
 atomics_to_string/2            Concatenate list of inputs to a string

 atomics_to_string/3            Concatenate list of inputs to a string
 autoload/0                     Autoload all predicates now
 autoload_path/1                Add directories for autoloading
 b_getval/2                     Fetch backtrackable global variable
 b_set_dict/3                   Destructive assignment on a dict
 b_setval/2                     Assign backtrackable global variable
 bagof/3                        Find all solutions to a goal
 between/3                      Integer range checking/generating

 blob/2                         Type check for a blob
 break/0                        Start interactive top level
 break_hook/6                   (hook) Debugger hook
 byte_count/2                   Byte-position in a stream
 call/1                         Call a goal
 call/[2..]                     Call with additional arguments
 call_cleanup/3                 Guard a goal with a cleaup-handler

 call_cleanup/2                 Guard a goal with a cleaup-handler
 call_dcg/3                     As phrase/3 without type checking
 call_residue_vars/2            Find residual attributed variables
 call_shared_object_function/2  UNIX: Call C-function in shared (.so) file
 call_with_depth_limit/3        Prove goal with bounded depth
 call_with_inference_limit/3    Prove goal in limited inferences
 callable/1                     Test for atom or compound term
 cancel_halt/1                  Cancel halt/0 from an at_halt/1 hook

 catch/3                        Call goal, watching for exceptions
 char_code/2                    Convert between character and character code
 char_conversion/2              Provide mapping of input characters
 char_type/2                    Classify characters
 character_count/2              Get character index on a stream
 chdir/1                        Compatibility:  change working directory
 chr_constraint/1               CHR Constraint declaration

 chr_show_store/1               List suspended CHR constraints
 chr_trace/0                    Start CHR tracer
 chr_type/1                     CHR Type declaration
 chr_notrace/0                  Stop CHR tracer
 chr_leash/1                    Define CHR leashed ports
 chr_option/2                   Specify CHR compilation options
 clause/2                       Get clauses of a predicate
 clause/3                       Get clauses of a predicate

 clause_property/2              Get properties of a clause
 close/1                        Close stream
 close/2                        Close stream (forced)
 close_dde_conversation/1       Win32:  Close DDE channel
 close_shared_object/1          UNIX: Close shared library (.so file)
 collation_key/2                Sort key for locale dependent ordering
 comment_hook/3                 (hook) handle comments in sources

 compare/3                      Compare, using a predicate to determine the order
 compile_aux_clauses/1          Compile predicates for goal_expansion/2
 compile_predicates/1           Compile dynamic code to static
 compiling/0                    Is this a compilation run?
 compound/1                     Test for compound term
 compound_name_arity/3          Name and arity of a compound term
 compound_name_arguments/3      Name and arguments of a compound term
 code_type/2                    Classify a character-code

 consult/1                      Read (compile) a Prolog source file
 context_module/1               Get context module of current goal
 convert_time/8                 Break time stamp into fields
 convert_time/2                 Convert time stamp to string
 copy_stream_data/2             Copy all data from stream to stream
 copy_stream_data/3             Copy n bytes from stream to stream
 copy_predicate_clauses/2       Copy clauses between predicates

 copy_term/2                    Make a copy of a term
 copy_term/3                    Copy a term and obtain attribute-goals
 copy_term_nat/2                Make a copy of a term without attributes
 create_prolog_flag/3           Create a new Prolog flag
 current_arithmetic_function/1  Examine evaluable functions
 current_atom/1                 Examine existing atoms
 current_blob/2                 Examine typed blobs
 current_char_conversion/2      Query input character mapping

 current_flag/1                 Examine existing flags
 current_foreign_library/2      shlib Examine loaded shared libraries (.so files)
 current_format_predicate/2     Enumerate user-defined format codes
 current_functor/2              Examine existing name/arity pairs
 current_input/1                Get current input stream
 current_key/1                  Examine existing database keys
 current_locale/1               Get the current locale

 current_module/1               Examine existing modules
 current_op/3                   Examine current operator declarations
 current_output/1               Get the current output stream
 current_predicate/1            Examine existing predicates (ISO)
 current_predicate/2            Examine existing predicates
 current_signal/3               Current software signal mapping
 current_stream/3               Examine open streams
 cyclic_term/1                  Test term for cycles

 day_of_the_week/2              Determine ordinal-day from date
 date_time_stamp/2              Convert date structure to time-stamp
 date_time_value/3              Extract info from a date structure
 dcg_translate_rule/2           Source translation of DCG rules
 dcg_translate_rule/4           Source translation of DCG rules
 dde_current_connection/2       Win32:  Examine open DDE connections
 dde_current_service/2          Win32:  Examine DDE services provided

 dde_execute/2                  Win32:  Execute command on DDE server
 dde_register_service/2         Win32:  Become a DDE server
 dde_request/3                  Win32:  Make a DDE request
 dde_poke/3                     Win32:  POKE operation on DDE server
 dde_unregister_service/1       Win32:  Terminate a DDE service
 debug/0                        Test for debugging mode
 debug/1                        Select topic for debugging
 debug/3                        Print debugging message on topic

 debug_control_hook/1           (hook) Extend spy/1, etc.
 debugging/0                    Show debugger status
 debugging/1                    Test where we are debugging topic
 default_module/2               Query module inheritance
 del_attr/2                     Delete attribute from variable
 del_attrs/1                    Delete all attributes from variable
 del_dict/4                     Delete Key-Value pair from a dict

 delete_directory/1             Remove a folder from the file system
 delete_file/1                  Remove a file from the file system
 delete_import_module/2         Remove module from import list
 deterministic/1                Test deterministicy of current clause
 dif/2                          Constrain two terms to be different
 directory_files/2              Get entries of a directory/folder
 discontiguous/1                Indicate distributed definition of a predicate
 divmod/4                       Compute quotient and remainder of two integers

 downcase_atom/2                Convert atom to lower-case
 duplicate_term/2               Create a copy of a term
 dwim_match/2                   Atoms match in ``Do What I Mean'' sense
 dwim_match/3                   Atoms match in ``Do What I Mean'' sense
 dwim_predicate/2               Find predicate in ``Do What I Mean'' sense
 dynamic/1                      Indicate predicate definition may change
 edit/0                         Edit current script- or associated file

 edit/1                         Edit a file, predicate, module (extensible)
 elif/1                         Part of conditional compilation (directive)
 else/0                         Part of conditional compilation (directive)
 empty_assoc/1                  Create/test empty association tree
 empty_nb_set/1                 Test/create an empty non-backtrackable set
 encoding/1                     Define encoding inside a source file
 endif/0                        End of conditional compilation (directive)
 ensure_loaded/1                Consult a file if that has not yet been done

 erase/1                        Erase a database record or clause
 eval_license/0                 Evaluate licenses of loaded modules
 exception/3                    (hook) Handle runtime exceptions
 exists_directory/1             Check existence of directory
 exists_file/1                  Check existence of file
 exists_source/1                Check existence of a Prolog source
 expand_answer/2                Expand answer of query

 expand_file_name/2             Wildcard expansion of file names
 expand_file_search_path/2      Wildcard expansion of file paths
 expand_goal/2                  Compiler:  expand goal in clause-body
 expand_goal/4                  Compiler:  expand goal in clause-body
 expand_query/4                 Expanded entered query
 expand_term/2                  Compiler:  expand read term into clause(s)
 expand_term/4                  Compiler:  expand read term into clause(s)
 expects_dialect/1              For which Prolog dialect is this code written?

 explain/1                      explain Explain argument
 explain/2                      explain 2nd argument is explanation of first
 export/1                       Export a predicate from a module
 fail/0                         Always false
 false/0                        Always false
 current_prolog_flag/2          Get system configuration parameters
 file_base_name/2               Get file part of path

 file_directory_name/2          Get directory part of path
 file_name_extension/3          Add, remove or test file extensions
 file_search_path/2             Define path-aliases for locating files
 find_chr_constraint/1          Returns a constraint from the store
 findall/3                      Find all solutions to a goal
 findall/4                      Difference list version of findall/3
 findnsols/4                    Find first _N solutions
 findnsols/5                    Difference list version of findsols/4

 flag/3                         Simple global variable system
 float/1                        Type check for a floating point number
 flush_output/0                 Output pending characters on current stream
 flush_output/1                 Output pending characters on specified stream
 forall/2                       Prove goal for all solutions of another goal
 format/1                       Formatted output
 format/2                       Formatted output with arguments

 format/3                       Formatted output on a stream
 format_time/3                  C strftime() like date/time formatter
 format_time/4                  date/time formatter with explicit locale
 format_predicate/2             Program format/[1,2]
 term_attvars/2                 Find attributed variables in a term
 term_variables/2               Find unbound variables in a term
 term_variables/3               Find unbound variables in a term
 text_to_string/2               Convert arbitrary text to a string

 freeze/2                       Delay execution until variable is bound
 frozen/2                       Query delayed goals on var
 functor/3                      Get name and arity of a term or construct a term
 garbage_collect/0              Invoke the garbage collector
 garbage_collect_atoms/0        Invoke the atom garbage collector
 garbage_collect_clauses/0      Invoke clause garbage collector
 gen_assoc/3                    Enumerate members of association tree

 gen_nb_set/2                   Generate members of non-backtrackable set
 gensym/2                       Generate unique atoms from a base
 get/1                          Read first non-blank character
 get/2                          Read first non-blank character from a stream
 get_assoc/3                    Fetch key from association tree
 get_assoc/5                    Fetch key from association tree
 get0/1                         Read next character
 get0/2                         Read next character from a stream

 get_attr/3                     Fetch named attribute from a variable
 get_attrs/2                    Fetch all attributes of a variable
 get_byte/1                     Read next byte (ISO)
 get_byte/2                     Read next byte from a stream (ISO)
 get_char/1                     Read next character as an atom (ISO)
 get_char/2                     Read next character from a stream (ISO)
 get_code/1                     Read next character (ISO)

 get_code/2                     Read next character from a stream (ISO)
 get_dict/3                     Get the value associated to a key from a dict
 get_dict/5                     Replace existing value in a dict
 get_single_char/1              Read next character from the terminal
 get_string_code/3              Get character code at index in string
 get_time/1                     Get current time
 getenv/2                       Get shell environment variable
 goal_expansion/2               Hook for macro-expanding goals

 goal_expansion/4               Hook for macro-expanding goals
 ground/1                       Verify term holds no unbound variables
 gdebug/0                       Debug using graphical tracer
 gspy/1                         Spy using graphical tracer
 gtrace/0                       Trace using graphical tracer
 guitracer/0                    Install hooks for the graphical debugger
 gxref/0                        Cross-reference loaded program

 halt/0                         Exit from Prolog
 halt/1                         Exit from Prolog with status
 term_hash/2                    Hash-value of ground term
 term_hash/4                    Hash-value of term with depth limit
 help/0                         Give help on help
 help/1                         Give help on predicates and show parts of manual
 help_hook/1                    (hook) User-hook in the help-system
 if/1                           Start conditional compilation (directive)

 ignore/1                       Call the argument, but always succeed
 import/1                       Import a predicate from a module
 import_module/2                Query import modules
 in_pce_thread/1                Run goal in XPCE thread
 in_pce_thread_sync/1           Run goal in XPCE thread
 include/1                      Include a file with declarations
 initialization/1               Initialization directive

 initialization/2               Initialization directive
 instance/2                     Fetch clause or record from reference
 integer/1                      Type check for integer
 interactor/0                   Start new thread with console and top level
 is/2                           Evaluate arithmetic expression
 is_absolute_file_name/1        True if arg defines an absolute path
 is_assoc/1                     Verify association list
 is_list/1                      Type check for a list

 is_dict/1                      Type check for a dict
 is_dict/2                      Type check for a dict in a class
 is_stream/1                    Type check for a stream handle
 join_threads/0                 Join all terminated threads interactively
 keysort/2                      Sort, using a key
 last/2                         Last element of a list
 leash/1                        Change ports visited by the tracer

 length/2                       Length of a list
 library_directory/1            (hook) Directories holding Prolog libraries
 license/1                      Define license for current file
 license/2                      Define license for named module
 line_count/2                   Line number on stream
 line_position/2                Character position in line on stream
 list_debug_topics/0            List registered topics for debugging
 list_to_assoc/2                Create association tree from list

 list_to_set/2                  Remove duplicates from a list
 list_strings/0                 Help porting to version 7
 listing/0                      List program in current module
 listing/1                      List predicate
 load_files/1                   Load source files
 load_files/2                   Load source files with options
 load_foreign_library/1         shlib Load shared library (.so file)

 load_foreign_library/2         shlib Load shared library (.so file)
 locale_create/3                Create a new locale object
 locale_destroy/1               Destroy a locale object
 locale_property/2              Query properties of locale objects
 locale_sort/2                  Language dependent sort of atoms
 make/0                         Reconsult all changed source files
 make_directory/1               Create a folder on the file system
 make_library_index/1           Create autoload file INDEX.pl

 make_library_index/2           Create selective autoload file INDEX.pl
 map_assoc/2                    Map association tree
 map_assoc/3                    Map association tree
 dict_create/3                  Create a dict from data
 dict_pairs/3                   Convert between dict and list of pairs
 max_assoc/3                    Highest key in association tree
 memberchk/2                    Deterministic member/2

 message_hook/3                 Intercept print_message/2
 message_line_element/2         (hook) Intercept print_message_lines/3
 message_property/2             (hook) Define display of a message
 message_queue_create/1         Create queue for thread communication
 message_queue_create/2         Create queue for thread communication
 message_queue_destroy/1        Destroy queue for thread communication
 message_queue_property/2       Query message queue properties
 message_to_string/2            Translate message-term to string

 meta_predicate/1               Declare access to other predicates
 min_assoc/3                    Lowest key in association tree
 module/1                       Query/set current type-in module
 module/2                       Declare a module
 module/3                       Declare a module with language options
 module_property/2              Find properties of a module
 module_transparent/1           Indicate module based meta-predicate

 msort/2                        Sort, do not remove duplicates
 multifile/1                    Indicate distributed definition of predicate
 mutex_create/1                 Create a thread-synchronisation device
 mutex_create/2                 Create a thread-synchronisation device
 mutex_destroy/1                Destroy a mutex
 mutex_lock/1                   Become owner of a mutex
 mutex_property/2               Query mutex properties
 mutex_statistics/0             Print statistics on mutex usage

 mutex_trylock/1                Become owner of a mutex (non-blocking)
 mutex_unlock/1                 Release ownership of mutex
 mutex_unlock_all/0             Release ownership of all mutexes
 name/2                         Convert between atom and list of character codes
 nb_current/2                   Enumerate non-backtrackable global variables
 nb_delete/1                    Delete a non-backtrackable global variable
 nb_getval/2                    Fetch non-backtrackable global variable

 nb_link_dict/3                 Non-backtrackable assignment to dict
 nb_linkarg/3                   Non-backtrackable assignment to term
 nb_linkval/2                   Assign non-backtrackable global variable
 nb_set_to_list/2               Convert non-backtrackable set to list
 nb_set_dict/3                  Non-backtrackable assignment to dict
 nb_setarg/3                    Non-backtrackable assignment to term
 nb_setval/2                    Assign non-backtrackable global variable
 nl/0                           Generate a newline

 nl/1                           Generate a newline on a stream
 nodebug/0                      Disable debugging
 nodebug/1                      Disable debug-topic
 noguitracer/0                  Disable the graphical debugger
 nonvar/1                       Type check for bound term
 noprofile/1                    Hide (meta-) predicate for the profiler
 noprotocol/0                   Disable logging of user interaction

 normalize_space/2              Normalize white space
 nospy/1                        Remove spy point
 nospyall/0                     Remove all spy points
 not/1                          Negation by failure (argument not provable).  Same as \+/1
 notrace/0                      Stop tracing
 notrace/1                      Do not debug argument goal
 nth_clause/3                   N-th clause of a predicate
 nth_integer_root_and_remainder/4Integer root and remainder

 number/1                       Type check for integer or float
 number_chars/2                 Convert between number and one-char atoms
 number_codes/2                 Convert between number and character codes
 number_string/2                Convert between number and string
 numbervars/3                   Number unbound variables of a term
 numbervars/4                   Number unbound variables of a term
 on_signal/3                    Handle a software signal

 once/1                         Call a goal deterministically
 op/3                           Declare an operator
 open/3                         Open a file (creating a stream)
 open/4                         Open a file (creating a stream)
 open_dde_conversation/3        Win32:  Open DDE channel
 open_null_stream/1             Open a stream to discard output
 open_resource/3                Open a program resource as a stream
 open_shared_object/2           UNIX: Open shared library (.so file)

 open_shared_object/3           UNIX: Open shared library (.so file)
 open_string/2                  Open a string as a stream
 ord_list_to_assoc/2            Convert ordered list to assoc
 parse_time/2                   Parse text to a time-stamp
 parse_time/3                   Parse text to a time-stamp
 pce_dispatch/1                 Run XPCE GUI in separate thread
 pce_call/1                     Run goal in XPCE GUI thread

 peek_byte/1                    Read byte without removing
 peek_byte/2                    Read byte without removing
 peek_char/1                    Read character without removing
 peek_char/2                    Read character without removing
 peek_code/1                    Read character-code without removing
 peek_code/2                    Read character-code without removing
 peek_string/3                  Read a string without removing
 phrase/2                       Activate grammar-rule set

 phrase/3                       Activate grammar-rule set (returning rest)
 phrase_from_quasi_quotation/2  Parse quasi quotation with DCG
 please/3                       Query/change environment parameters
 plus/3                         Logical integer addition
 portray/1                      (hook) Modify behaviour of print/1
 portray_clause/1               Pretty print a clause
 portray_clause/2               Pretty print a clause to a stream

 predicate_property/2           Query predicate attributes
 predsort/3                     Sort, using a predicate to determine the order
 print/1                        Print a term
 print/2                        Print a term on a stream
 print_message/2                Print message from (exception) term
 print_message_lines/3          Print message to stream
 profile/1                      Obtain execution statistics
 profile/2                      Obtain execution statistics

 profile_count/3                Obtain profile results on a predicate
 profiler/2                     Obtain/change status of the profiler
 prolog/0                       Run interactive top level
 prolog_choice_attribute/3      Examine the choice point stack
 prolog_current_choice/1        Reference to most recent choice point
 prolog_current_frame/1         Reference to goal's environment stack
 prolog_cut_to/1                Realise global cuts

 prolog_edit:locate/2           Locate targets for edit/1
 prolog_edit:locate/3           Locate targets for edit/1
 prolog_edit:edit_source/1      Call editor for edit/1
 prolog_edit:edit_command/2     Specify editor activation
 prolog_edit:load/0             Load edit/1 extensions
 prolog_exception_hook/4        Rewrite exceptions
 prolog_file_type/2             Define meaning of file extension
 prolog_frame_attribute/3       Obtain information on a goal environment

 prolog_ide/1                   Program access to the development environment
 prolog_list_goal/1             (hook) Intercept tracer 'L' command
 prolog_load_context/2          Context information for directives
 prolog_load_file/2             (hook) Program load_files/2
 prolog_skip_level/2            Indicate deepest recursion to trace
 prolog_skip_frame/1            Perform `skip' on a frame
 prolog_stack_property/2        Query properties of the stacks

 prolog_to_os_filename/2        Convert between Prolog and OS filenames
 prolog_trace_interception/4    user Intercept the Prolog tracer
 project_attributes/2           Project constraints to query variables
 prompt1/1                      Change prompt for 1 line
 prompt/2                       Change the prompt used by read/1
 protocol/1                     Make a log of the user interaction
 protocola/1                    Append log of the user interaction to file
 protocolling/1                 On what file is user interaction logged

 public/1                       Declaration that a predicate may be called
 put/1                          Write a character
 put/2                          Write a character on a stream
 put_assoc/4                    Add Key-Value to association tree
 put_attr/3                     Put attribute on a variable
 put_attrs/2                    Set/replace all attributes on a variable
 put_byte/1                     Write a byte

 put_byte/2                     Write a byte on a stream
 put_char/1                     Write a character
 put_char/2                     Write a character on a stream
 put_code/1                     Write a character-code
 put_code/2                     Write a character-code on a stream
 put_dict/3                     Add/replace multiple keys in a dict
 put_dict/4                     Add/replace a single key in a dict
 qcompile/1                     Compile source to Quick Load File

 qcompile/2                     Compile source to Quick Load File
 qsave_program/1                Create runtime application
 qsave_program/2                Create runtime application
 quasi_quotation_syntax/1       Declare quasi quotation syntax
 quasi_quotation_syntax_error/1 Raise syntax error
 random_property/1              Query properties of random generation
 rational/1                     Type check for a rational number

 rational/3                     Decompose a rational
 read/1                         Read Prolog term
 read/2                         Read Prolog term from stream
 read_clause/3                  Read clause from stream
 read_history/6                 Read using history substitution
 read_link/3                    Read a symbolic link
 read_pending_input/3           Fetch buffered input from a stream
 read_string/3                  Read a number of characters into a string

 read_string/5                  Read string upto a delimiter
 read_term/2                    Read term with options
 read_term/3                    Read term with options from stream
 read_term_from_atom/3          Read term with options from atom
 recorda/2                      Record term in the database (first)
 recorda/3                      Record term in the database (first)
 recorded/2                     Obtain term from the database

 recorded/3                     Obtain term from the database
 recordz/2                      Record term in the database (last)
 recordz/3                      Record term in the database (last)
 redefine_system_predicate/1    Abolish system definition
 reexport/1                     Load files and re-export the imported predicates
 reexport/2                     Load predicates from a file and re-export it
 reload_foreign_libraries/0     Reload DLLs/shared objects
 reload_library_index/0         Force reloading the autoload index

 rename_file/2                  Change name of file
 repeat/0                       Succeed, leaving infinite backtrack points
 require/1                      This file requires these predicates
 reset_gensym/1                 Reset a gensym key
 reset_gensym/0                 Reset all gensym keys
 reset_profiler/0               Clear statistics obtained by the profiler
 resource/3                     Declare a program resource

 retract/1                      Remove clause from the database
 retractall/1                   Remove unifying clauses from the database
 same_file/2                    Succeeds if arguments refer to same file
 same_term/2                    Test terms to be at the same address
 see/1                          Change the current input stream
 seeing/1                       Query the current input stream
 seek/4                         Modify the current position in a stream
 seen/0                         Close the current input stream

 select_dict/2                  Select matching attributes from a dict
 select_dict/3                  Select matching attributes from a dict
 set_end_of_stream/1            Set physical end of an open file
 set_input/1                    Set current input stream from a stream
 set_locale/1                   Set the default local
 set_module/1                   Set properties of a module
 set_output/1                   Set current output stream from a stream

 set_prolog_IO/3                Prepare streams for interactive session
 set_prolog_flag/2              Define a system feature
 set_prolog_stack/2             Modify stack characteristics
 set_random/1                   Control random number generation
 set_stream/2                   Set stream attribute
 set_stream_position/2          Seek stream to position
 setup_call_cleanup/3           Undo side-effects safely
 setup_call_catcher_cleanup/4   Undo side-effects safely

 setarg/3                       Destructive assignment on term
 setenv/2                       Set shell environment variable
 setlocale/3                    Set/query C-library regional information
 setof/3                        Find all unique solutions to a goal
 shell/0                        Execute interactive subshell
 shell/1                        Execute OS command
 shell/2                        Execute OS command

 show_profile/1                 Show results of the profiler
 size_file/2                    Get size of a file in characters
 size_nb_set/2                  Determine size of non-backtrackable set
 skip/1                         Skip to character in current input
 skip/2                         Skip to character on stream
 rl_add_history/1               Add line to readline(3) history
 rl_read_history/1              Read readline(3) history
 rl_read_init_file/1            Read readline(3) init file

 rl_write_history/1             Write readline(3) history
 sleep/1                        Suspend execution for specified time
 sort/2                         Sort elements in a list
 sort/4                         Sort elements in a list
 source_exports/2               Check whether source exports a predicate
 source_file/1                  Examine currently loaded source files
 source_file/2                  Obtain source file of predicate

 source_file_property/2         Information about loaded files
 source_location/2              Location of last read term
 split_string/4                 Break a string into substrings
 spy/1                          Force tracer on specified predicate
 stamp_date_time/3              Convert time-stamp to date structure
 statistics/0                   Show execution statistics
 statistics/2                   Obtain collected statistics
 stream_pair/3                  Create/examine a bi-directional stream

 stream_position_data/3         Access fields from stream position
 stream_property/2              Get stream properties
 string/1                       Type check for string
 string_concat/3                atom_concat/3 for strings
 string_length/2                Determine length of a string
 string_chars/2                 Conversion between string and list of characters
 string_codes/2                 Conversion between string and list of character codes

 string_code/3                  Get or find a character code in a string
 string_lower/2                 Case conversion to lower case
 string_upper/2                 Case conversion to upper case
 string_predicate/1             (hook) Predicate contains strings
 strip_module/3                 Extract context module and term
 style_check/1                  Change level of warnings
 sub_atom/5                     Take a substring from an atom
 sub_atom_icasechk/3            Case insensitive substring match

 sub_string/5                   Take a substring from a string
 subsumes_term/2                One-sided unification test
 succ/2                         Logical integer successor relation
 swritef/2                      Formatted write on a string
 swritef/3                      Formatted write on a string
 tab/1                          Output number of spaces
 tab/2                          Output number of spaces on a stream

 tdebug/0                       Switch all threads into debug mode
 tdebug/1                       Switch a thread into debug mode
 tell/1                         Change current output stream
 telling/1                      Query current output stream
 term_expansion/2               (hook) Convert term before compilation
 term_expansion/4               (hook) Convert term before compilation
 term_string/2                  Read/write a term from/to a string
 term_string/3                  Read/write a term from/to a string

 term_subsumer/3                Most specific generalization of two terms
 term_to_atom/2                 Convert between term and atom
 thread_at_exit/1               Register goal to be called at exit
 thread_create/3                Create a new Prolog task
 thread_detach/1                Make thread cleanup after completion
 thread_exit/1                  Terminate Prolog task with value
 thread_get_message/1           Wait for message

 thread_get_message/2           Wait for message in a queue
 thread_get_message/3           Wait for message in a queue
 thread_initialization/1        Run action at start of thread
 thread_join/2                  Wait for Prolog task-completion
 thread_local/1                 Declare thread-specific clauses for a predicate
 thread_message_hook/3          Thread local message_hook/3
 thread_peek_message/1          Test for message
 thread_peek_message/2          Test for message in a queue

 thread_property/2              Examine Prolog threads
 thread_self/1                  Get identifier of current thread
 thread_send_message/2          Send message to another thread
 thread_send_message/3          Send message to another thread
 thread_setconcurrency/2        Number of active threads
 thread_signal/2                Execute goal in another thread
 thread_statistics/3            Get statistics of another thread

 threads/0                      List running threads
 throw/1                        Raise an exception (see catch/3)
 time/1                         Determine time needed to execute goal
 time_file/2                    Get last modification time of file
 tmp_file/2                     Create a temporary filename
 tmp_file_stream/3              Create a temporary file and open it
 tnodebug/0                     Switch off debug mode in all threads
 tnodebug/1                     Switch off debug mode in a thread

 told/0                         Close current output
 tprofile/1                     Profile a thread for some period
 trace/0                        Start the tracer
 trace/1                        Set trace point on predicate
 trace/2                        Set/Clear trace point on ports
 tracing/0                      Query status of the tracer
 trim_stacks/0                  Release unused memory resources

 true/0                         Succeed
 tspy/1                         Set spy point and enable debugging in all threads
 tspy/2                         Set spy point and enable debugging in a thread
 tty_get_capability/3           Get terminal parameter
 tty_goto/2                     Goto position on screen
 tty_put/2                      Write control string to terminal
 tty_size/2                     Get row/column size of the terminal
 ttyflush/0                     Flush output on terminal

 unify_with_occurs_check/2      Logically sound unification
 unifiable/3                    Determining binding required for unification
 unix/1                         OS interaction
 unknown/2                      Trap undefined predicates
 unload_file/1                  Unload a source file
 unload_foreign_library/1       shlib Detach shared library (.so file)
 unload_foreign_library/2       shlib Detach shared library (.so file)

 unsetenv/1                     Delete shell environment variable
 upcase_atom/2                  Convert atom to upper-case
 use_foreign_library/1          Load DLL/shared object (directive)
 use_foreign_library/2          Load DLL/shared object (directive)
 use_module/1                   Import a module
 use_module/2                   Import predicates from a module
 valid_string_goal/1            (hook) Goal handles strings
 var/1                          Type check for unbound variable

 var_number/2                   Check that var is numbered by numbervars
 var_property/2                 Variable properties during macro expansion
 variant_sha1/2                 Term-hash for term-variants
 version/0                      Print system banner message
 version/1                      Add messages to the system banner
 visible/1                      Ports that are visible in the tracer
 volatile/1                     Predicates that are not saved

 wait_for_input/3               Wait for input with optional timeout
 when/2                         Execute goal when condition becomes true
 wildcard_match/2               Csh(1) style wildcard match
 win_add_dll_directory/1        Add directory to DLL search path
 win_add_dll_directory/2        Add directory to DLL search path
 win_remove_dll_directory/1     Remove directory from DLL search path
 win_exec/2                     Win32:  spawn Windows task
 win_has_menu/0                 Win32:  true if console menu is available

 win_folder/2                   Win32:  get special folder by CSIDL
 win_insert_menu/2              swipl-win.exe:  add menu
 win_insert_menu_item/4         swipl-win.exe:  add item to menu
 win_shell/2                    Win32:  open document through Shell
 win_shell/3                    Win32:  open document through Shell
 win_registry_get_value/3       Win32:  get registry value
 win_window_pos/1               Win32:  change size and position of window

 window_title/2                 Win32:  change title of window
 with_mutex/2                   Run goal while holding mutex
 with_output_to/2               Write to strings and more
 with_quasi_quotation_input/3   Parse quasi quotation from stream
 working_directory/2            Query/change CWD
 write/1                        Write term
 write/2                        Write term to stream
 writeln/1                      Write term, followed by a newline

 writeln/2                      Write term, followed by a newline to a stream
 write_canonical/1              Write a term with quotes, ignore operators
 write_canonical/2              Write a term with quotes, ignore operators on a stream
 write_length/3                 Dermine #characters to output a term
 write_term/2                   Write term with options
 write_term/3                   Write term with options to stream
 writef/1                       Formatted write

 writef/2                       Formatted write on stream
 writeq/1                       Write term, insert quotes
 writeq/2                       Write term, insert quotes on stream


1177..22 LLiibbrraarryy pprreeddiiccaatteess


1177..22..11 lliibbrraarryy((aaggggrreeggaattee))

 aggregate/3      Aggregate bindings in Goal according to Template.
 aggregate/4      Aggregate bindings in Goal according to Template.
 aggregate_all/3  Aggregate bindings in Goal according to Template.
 aggregate_all/4  Aggregate bindings in Goal according to Template.
 foreach/2        True if conjunction of results is true.
 free_variables/4 Find free variables in bagof/setof template.
 safe_meta/2      Declare the aggregate meta-calls safe.


1177..22..22 lliibbrraarryy((aappppllyy))

 exclude/3    Filter elements for which Goal fails.
 foldl/4      Fold a list, using arguments of the list as left argument.
 foldl/5      Fold a list, using arguments of the list as left argument.
 foldl/6      Fold a list, using arguments of the list as left argument.
 foldl/7      Fold a list, using arguments of the list as left argument.
 include/3    Filter elements for which Goal succeeds.
 maplist/2    True if Goal can successfully be applied on all elements of List.
 maplist/3    As maplist/2, operating on pairs of elements from two lists.

 maplist/4    As maplist/2, operating on triples of elements from three lists.
 maplist/5    As maplist/2, operating on quadruples of elements from four lists.
 partition/4  Filter elements of List according to Pred.
 partition/5  Filter List according to Pred in three sets.
 scanl/4      Left scan of list.
 scanl/5      Left scan of list.
 scanl/6      Left scan of list.

 scanl/7      Left scan of list.


1177..22..33 lliibbrraarryy((aassssoocc))

 assoc_to_list/2    Translate assoc into a pairs list
 assoc_to_keys/2    Translate assoc into a key list
 assoc_to_values/2  Translate assoc into a value list
 empty_assoc/1      Test/create an empty assoc
 gen_assoc/3        Non-deterministic enumeration of assoc
 get_assoc/3        Get associated value
 get_assoc/5        Get and replace associated value
 list_to_assoc/2    Translate pair list to assoc

 map_assoc/2        Test assoc values
 map_assoc/3        Map assoc values
 max_assoc/3        Max key-value of an assoc
 min_assoc/3        Min key-value of an assoc
 ord_list_to_assoc/3Translate ordered list into an assoc
 put_assoc/4        Add association to an assoc


1177..22..44 lliibbrraarryy((bbrrooaaddccaasstt))

 broadcast/1         Send event notification
 broadcast_request/1 Request all agents
 listen/2            Listen to event notifications
 listen/3            Listen to event notifications
 unlisten/1          Stop listening to event notifications
 unlisten/2          Stop listening to event notifications
 unlisten/3          Stop listening to event notifications
 listening/3         Who is listening to event notifications?


1177..22..55 lliibbrraarryy((cchhaarrssiioo))

 atom_to_chars/2       Convert Atom into a list of character codes.
 atom_to_chars/3       Convert Atom into a difference list of character codes.
 format_to_chars/3     Use format/2 to write to a list of character codes.
 format_to_chars/4     Use format/2 to write to a difference list of character codes.
 number_to_chars/2     Convert Atom into a list of character codes.
 number_to_chars/3     Convert Number into a difference list of character codes.
 open_chars_stream/2   Open Codes as an input stream.
 read_from_chars/2     Read Codes into Term.

 read_term_from_chars/3Read Codes into Term.
 with_output_to_chars/2Run Goal as with once/1.
 with_output_to_chars/3Run Goal as with once/1.
 with_output_to_chars/4Same as with_output_to_chars/3 using an explicit stream.
 write_to_chars/2      Write a term to a code list.
 write_to_chars/3      Write a term to a code list.


1177..22..66 lliibbrraarryy((cchheecckk))

 check/0                  Run all consistency checks defined by checker/2.
 checker/2                Register code validation routines.
 list_autoload/0          Report predicates that may be auto-loaded.
 list_redefined/0         Lists predicates that are defined in the global module =user= as well as in a normal module; that is, predicates for which the@
 list_strings/0           List strings that appear in clauses.
 list_strings/1           List strings that appear in clauses.
 list_trivial_fails/0     List goals that trivially fail because there is no matching clause.
 list_trivial_fails/1     List goals that trivially fail because there is no matching clause.

 list_undefined/0         Report undefined predicates.
 list_undefined/1         Report undefined predicates.
 list_void_declarations/0 List predicates that have declared attributes, but no clauses.
 string_predicate/1       Multifile hook to disable list_strings/0 on the given predicate.
 trivial_fail_goal/1      Multifile hook that tells list_trivial_fails/0 to accept Goal as valid.
 valid_string_goal/1      Multifile hook that qualifies Goal as valid for list_strings/0.


1177..22..77 lliibbrraarryy((ccssvv))

 csv_read_file/2    Read a CSV file into a list of rows.
 csv_read_file/3    Read a CSV file into a list of rows.
 csv_read_file_row/3True when Row is a row in File.
 csv_write_file/2   Write a list of Prolog terms to a CSV file.
 csv_write_file/3   Write a list of Prolog terms to a CSV file.
 csv_write_stream/3 Write the rows in Data to Stream.
 csv/3              Prolog DCG to `read/write' CSV data.
 csv/4              Prolog DCG to `read/write' CSV data.


1177..22..88 lliibbrraarryy((lliissttss))

 append/2        Concatenate a list of lists.
 append/3        List1AndList2 is the concatenation of List1 and List2.
 delete/3        Delete matching elements from a list.
 flatten/2       Is true if FlatList is a non-nested version of NestedList.
 intersection/3  True if Set3 unifies with the intersection of Set1 and Set2.
 is_set/1        True if Set is a proper list without duplicates.
 last/2          Succeeds when Last is the last element of List.
 list_to_set/2   True when Set has the same elements as List in the same order.

 max_list/2      True if Max is the largest number in List.
 max_member/2    True when Max is the largest member in the standard order of terms.
 member/2        True if Elem is a member of List.
 min_list/2      True if Min is the smallest number in List.
 min_member/2    True when Min is the smallest member in the standard order of terms.
 nextto/3        True if Y follows X in List.
 nth0/3          True when Elem is the Index'th element of List.

 nth0/4          Select/insert element at index.
 nth1/3          Is true when Elem is the Index'th element of List.
 nth1/4          As nth0/4, but counting starts at 1.
 numlist/3       List is a list [Low, Low+1, ...  High].
 permutation/2   True when Xs is a permutation of Ys.
 prefix/2        True iff Part is a leading substring of Whole.
 proper_length/2 True when Length is the number of elements in the proper list List.
 reverse/2       Is true when the elements of List2 are in reverse order compared to List1.

 same_length/2   Is true when List1 and List2 are lists with the same number of elements.
 select/3        Is true when List1, with Elem removed, results in List2.
 select/4        Select from two lists at the same positon.
 selectchk/3     Semi-deterministic removal of first element in List that unifies with Elem.
 selectchk/4     Semi-deterministic version of select/4.
 subset/2        True if all elements of SubSet belong to Set as well.
 subtract/3      Delete all elements in Delete from Set.

 sum_list/2      Sum is the result of adding all numbers in List.
 union/3         True if Set3 unifies with the union of Set1 and Set2.


1177..22..99 lliibbrraarryy((ddeebbuugg))

 assertion/1             Acts similar to C assert() macro.
 assertion_failed/2      This hook is called if the Goal of assertion/1 fails.
 debug/1                 Add/remove a topic from being printed.
 debug/3                 Format a message if debug topic is enabled.
 debug_message_context/1 Specify additional context for debug messages.
 debug_print_hook/3      Hook called by debug/3.
 debugging/1             Examine debug topics.
 debugging/2             Examine debug topics.

 list_debug_topics/0     List currently known debug topics and their setting.
 nodebug/1               Add/remove a topic from being printed.


1177..22..1100 lliibbrraarryy((iioossttrreeaamm))


1177..22..1111 lliibbrraarryy((ssuummmmaarriieess..dd//iioossttrreeaamm//tteexx))


1177..22..1122 lliibbrraarryy((ooppttiioonn))

 dict_options/2  Convert between an option list and a dictionary.
 merge_options/3 Merge two option lists.
 meta_options/3  Perform meta-expansion on options that are module-sensitive.
 option/2        Get an Option from OptionList.
 option/3        Get an Option Qfrom OptionList.
 select_option/3 Get and remove Option from an option list.
 select_option/4 Get and remove Option with default value.


1177..22..1133 lliibbrraarryy((ooppttppaarrssee))

 opt_arguments/3 Extract commandline options according to a specification.
 opt_help/2      True when Help is a help string synthesized from OptsSpec.
 opt_parse/4     Equivalent to opt_parse(OptsSpec, ApplArgs, Opts, PositionalArgs, []).
 opt_parse/5     Parse the arguments Args (as list of atoms) according to OptsSpec.
 parse_type/3    Hook to parse option text Codes to an object of type Type.


1177..22..1144 lliibbrraarryy((oorrddsseettss))

 is_ordset/1        True if Term is an ordered set.
 list_to_ord_set/2  Transform a list into an ordered set.
 ord_add_element/3  Insert an element into the set.
 ord_del_element/3  Delete an element from an ordered set.
 ord_disjoint/2     True if Set1 and Set2 have no common elements.
 ord_empty/1        True when List is the empty ordered set.
 ord_intersect/2    True if both ordered sets have a non-empty intersection.
 ord_intersect/3    Intersection holds the common elements of Set1 and Set2.

 ord_intersection/2 Intersection of a powerset.
 ord_intersection/3 Intersection holds the common elements of Set1 and Set2.
 ord_intersection/4 Intersection and difference between two ordered sets.
 ord_memberchk/2    True if Element is a member of OrdSet, compared using ==.
 ord_selectchk/3    Selectchk/3, specialised for ordered sets.
 ord_seteq/2        True if Set1 and Set2 have the same elements.
 ord_subset/2       Is true if all elements of Sub are in Super.

 ord_subtract/3     Diff is the set holding all elements of InOSet that are not in NotInOSet.
 ord_symdiff/3      Is true when Difference is the symmetric difference of Set1 and Set2.
 ord_union/2        True if Union is the union of all elements in the superset SetOfSets.
 ord_union/3        Union is the union of Set1 and Set2.
 ord_union/4        True iff ord_union(Set1, Set2, Union) and ord_subtract(Set2, Set1, New).


1177..22..1155 lliibbrraarryy((ppeerrssiisstteennccyy))

 current_persistent_predicate/1 True if PI is a predicate that provides access to the persistent database DB.
 db_attach/2                    Use File as persistent database for the calling module.
 db_sync/1                      Synchronise database with the associated file.
 db_sync_all/1                  Sync all registered databases.
 persistent/1                   Declare dynamic database terms.


1177..22..1166 lliibbrraarryy((pprreeddiiccaattee__ooppttiioonnss))

 assert_predicate_options/4     As predicate_options(:PI, +Arg, +Options).
 check_predicate_option/3       Verify predicate options at runtime.
 check_predicate_options/0      Analyse loaded program for erroneous options.
 current_option_arg/2           True when Arg of PI processes predicate options.
 current_predicate_option/3     True when Arg of PI processes Option.
 current_predicate_options/3    True when Options is the current active option declaration for PI on Arg.
 derive_predicate_options/0     Derive new predicate option declarations.
 derived_predicate_options/1    Derive predicate option declarations for a module.

 derived_predicate_options/3    Derive option arguments using static analysis.
 predicate_options/3            Declare that the predicate PI processes options on Arg.
 retractall_predicate_options/0 Remove all dynamically (derived) predicate options.


1177..22..1177 lliibbrraarryy((pprroollooggppaacckk))

 environment/2         Hook to define the environment for building packs.
 pack_info/1           Print more detailed information about Pack.
 pack_install/1        Install a package.
 pack_install/2        Install package Name.
 pack_list/1           Query package server and installed packages and display results.
 pack_list_installed/0 List currently installed packages.
 pack_property/2       True when Property is a property of Pack.
 pack_rebuild/0        Rebuild foreign components of all packages.

 pack_rebuild/1        Rebuilt possible foreign components of Pack.
 pack_remove/1         Remove the indicated package.
 pack_search/1         Query package server and installed packages and display results.
 pack_upgrade/1        Try to upgrade the package Pack.
 pack_url_file/2       True if File is a unique id for the referenced pack and version.


1177..22..1188 lliibbrraarryy((pprroollooggxxrreeff))

 prolog:called_by/2    (hook) Extend cross-referencer
 xref_built_in/1       Examine defined built-ins
 xref_called/3         Examine called predicates
 xref_clean/1          Remove analysis of source
 xref_current_source/1 Examine cross-referenced sources
 xref_defined/3        Examine defined predicates
 xref_exported/2       Examine exported predicates
 xref_module/2         Module defined by source

 xref_source/1         Cross-reference analysis of source


1177..22..1199 lliibbrraarryy((ppaaiirrss))

 group_pairs_by_key/2Group values with the same key.
 map_list_to_pairs/3 Create a Key-Value list by mapping each element of List.
 pairs_keys/2        Remove the values from a list of Key-Value pairs.
 pairs_keys_values/3 True if Keys holds the keys of Pairs and Values the values.
 pairs_values/2      Remove the keys from a list of Key-Value pairs.
 transpose_pairs/2   Swap Key-Value to Value-Key.


1177..22..2200 lliibbrraarryy((ppiioo))


1177..22..2200..11 lliibbrraarryy((ppuurree__iinnppuutt))

 phrase_from_file/2         Process the content of File using the DCG rule Grammar.
 phrase_from_file/3         As phrase_from_file/2, providing additional Options.
 phrase_from_stream/2       Helper for phrase_from_file/3.
 stream_to_lazy_list/2      Create a lazy list representing the character codes in Stream.
 lazy_list_character_count/3True when CharCount is the current character count in the Lazy list.
 lazy_list_location/3       Determine current (error) location in a lazy list.
 syntax_error/3             Throw the syntax error Error at the current location of the input.


1177..22..2211 lliibbrraarryy((rraannddoomm))

 getrand/1            Query/set the state of the random generator.
 maybe/0              Succeed/fail with equal probability (variant of maybe/1).
 maybe/1              Succeed with probability P, fail with probability 1-P.
 maybe/2              Succeed with probability K/N (variant of maybe/1).
 random/1             Binds R to a new random float in the _open_interval (0.0,1.0).
 random/3             Generate a random integer or float in a range.
 random_between/3     Binds R to a random integer in [L,U] (i.e., including both L and U).
 random_member/2      X is a random member of List.

 random_perm2/4       Does X=A,Y=B or X=B,Y=A with equal probability.
 random_permutation/2 Permutation is a random permutation of List.
 random_select/3      Randomly select or insert an element.
 randseq/3            S is a list of K unique random integers in the range 1..N.
 randset/3            S is a sorted list of K unique random integers in the range 1..N.
 setrand/1            Query/set the state of the random generator.


1177..22..2222 lliibbrraarryy((rreeaadduuttiill))

 read_line_to_codes/2  Read line from a stream
 read_line_to_codes/3  Read line from a stream
 read_stream_to_codes/2Read contents of stream
 read_stream_to_codes/3Read contents of stream
 read_file_to_codes/3  Read contents of file
 read_file_to_terms/3  Read contents of file to Prolog terms


1177..22..2233 lliibbrraarryy((rreeccoorrdd))

 record/1  Define named fields in a term


1177..22..2244 lliibbrraarryy((rreeggiissttrryy))

This library is only available on Windows systems.

 registry_get_key/2        Get principal value of key
 registry_get_key/3        Get associated value of key
 registry_set_key/2        Set principal value of key
 registry_set_key/3        Set associated value of key
 registry_delete_key/1     Remove a key
 shell_register_file_type/4Register a file-type
 shell_register_dde/6      Register DDE action
 shell_register_prolog/1   Register Prolog


1177..22..2255 lliibbrraarryy((uuggrraapphhss))

 vertices_edges_to_ugraph/3Create unweighted graph
 vertices/2                Find vertices in graph
 edges/2                   Find edges in graph
 add_vertices/3            Add vertices to graph
 del_vertices/3            Delete vertices from graph
 add_edges/3               Add edges to graph
 del_edges/3               Delete edges from graph
 transpose/2               Invert the direction of all edges

 neighbors/3               Find neighbors of vertice
 neighbours/3              Find neighbors of vertice
 complement/2              Inverse presense of edges
 compose/3
 top_sort/2                Sort graph topologically
 top_sort/3                Sort graph topologically
 transitive_closure/2      Create transitive closure of graph

 reachable/3               Find all reachable vertices
 ugraph_union/3            Union of two graphs


1177..22..2266 lliibbrraarryy((uurrll))

 file_name_to_url/2 Translate between a filename and a file:// URL.
 global_url/3       Translate a possibly relative URL into an absolute one.
 http_location/2    Construct or analyze an HTTP location.
 is_absolute_url/1  True if URL is an absolute URL.
 parse_url/2        Construct or analyse a URL.
 parse_url/3        Similar to parse_url/2 for relative URLs.
 parse_url_search/2 Construct or analyze an HTTP search specification.
 set_url_encoding/2 Query and set the encoding for URLs.

 url_iri/2          Convert between a URL, encoding in US-ASCII and an IRI.
 www_form_encode/2  En/decode to/from application/x-www-form-encoded.


1177..22..2277 lliibbrraarryy((wwwwww__bbrroowwsseerr))

 www_open_url/1 Open a web-page in a browser


1177..22..2288 lliibbrraarryy((ccllpp//ccllppbb))

 labeling/1  Assigns truth values to the Boolean variables Vs such that all stated constraints are satisfied.
 sat/1       True iff Expr is a satisfiable Boolean expression.
 sat_count/2 N is the number of different assignments of truth values to the variables in the Boolean expression Expr, such that Expr is true and all po@
 taut/2      Succeeds with T = 0 if the Boolean expression Expr cannot be satisfied, and with T = 1 if Expr is always true with respect to the current c@


1177..22..2299 lliibbrraarryy((ccllpp//ccllppffdd))

 #/\/2                P and Q hold.
 #</2                 X is less than Y.
 #<==/2               Q implies P.
 #<==>/2              P and Q are equivalent.
 #=/2                 X equals Y.
 #=</2                X is less than or equal to Y.
 #==>/2               P implies Q.
 #>/2                 X is greater than Y.

 #>=/2                X is greater than or equal to Y.
 #\/1                 The reifiable constraint Q does _not_hold.
 #\/2                 Either P holds or Q holds, but not both.
 #\//2                P or Q holds.
 #\=/2                X is not Y.
 all_different/1      Vars are pairwise distinct.
 all_distinct/1       Like all_different/1, with stronger propagation.

 automaton/3          Describes a list of finite domain variables with a finite automaton.
 automaton/8          Describes a list of finite domain variables with a finite automaton.
 chain/2              Zs form a chain with respect to Relation.
 circuit/1            True iff the list Vs of finite domain variables induces a Hamiltonian circuit.
 cumulative/1         Equivalent to cumulative(Tasks, [limit(1)]).
 cumulative/2         Schedule with a limited resource.
 disjoint2/1          True iff Rectangles are not overlapping.
 element/3            The N-th element of the list of finite domain variables Vs is V.

 fd_dom/2             Dom is the current domain (see in/2) of Var.
 fd_inf/2             Inf is the infimum of the current domain of Var.
 fd_size/2            Size is the number of elements of the current domain of Var, or the atom *sup* if the domain is unbounded.
 fd_sup/2             Sup is the supremum of the current domain of Var.
 fd_var/1             True iff Var is a CLP(FD) variable.
 global_cardinality/2 Global Cardinality constraint.
 global_cardinality/3 Global Cardinality constraint.

 in/2                 Var is an element of Domain.
 indomain/1           Bind Var to all feasible values of its domain on backtracking.
 ins/2                The variables in the list Vars are elements of Domain.
 label/1              Equivalent to labeling([], Vars).
 labeling/2           Assign a value to each variable in Vars.
 lex_chain/1          Lists are lexicographically non-decreasing.
 scalar_product/4     True iff the scalar product of Cs and Vs is in relation Rel to Expr.
 serialized/2         Describes a set of non-overlapping tasks.

 sum/3                The sum of elements of the list Vars is in relation Rel to Expr.
 transpose/2          Transpose a list of lists of the same length.
 tuples_in/2          True iff all Tuples are elements of Relation.
 zcompare/3           Analogous to compare/3, with finite domain variables A and B.


1177..22..3300 lliibbrraarryy((ccllppqqrr))

 entailed/1  Check if constraint is entailed
 inf/2       Find the infimum of an expression
 sup/2       Find the supremum of an expression
 minimize/1  Minimizes an expression
 maximize/1  Maximizes an expression
 bb_inf/3    Infimum of expression for mixed-integer problems
 bb_inf/4    Infimum of expression for mixed-integer problems
 bb_inf/5    Infimum of expression for mixed-integer problems

 dump/3      Dump constraints on variables


1177..22..3311 lliibbrraarryy((ccllpp//ssiimmpplleexx))

 assignment/2      Solve assignment problem
 constraint/3      Add linear constraint to state
 constraint/4      Add named linear constraint to state
 constraint_add/4  Extend a named constraint
 gen_state/1       Create empty linear program
 maximize/3        Maximize objective function in to linear constraints
 minimize/3        Minimize objective function in to linear constraints
 objective/2       Fetch value of objective function

 shadow_price/3    Fetch shadow price in solved state
 transportation/4  Solve transportation problem
 variable_value/3  Fetch value of variable in solved state


1177..22..3322 lliibbrraarryy((ssoolluuttiioonn__sseeqquueenncceess))

 distinct/1  True if Goal is true and no previous solution of Goal bound Witness to the same value.
 distinct/2  True if Goal is true and no previous solution of Goal bound Witness to the same value.
 group_by/4  Group bindings of Template that have the same value for By.
 limit/2     Limit the number of solutions.
 offset/2    Ignore the first Count solutions.
 order_by/2  Order solutions according to Spec.


1177..22..3333 lliibbrraarryy((tthhrreeaadd__ppooooll))

 create_pool/1          Hook to create a thread pool lazily.
 current_thread_pool/1  True if Name refers to a defined thread pool.
 thread_create_in_pool/4Create a thread in Pool.
 thread_pool_create/3   Create a pool of threads.
 thread_pool_destroy/1  Destroy the thread pool named Name.
 thread_pool_property/2 True if Property is a property of thread pool Name.


1177..22..3344 lliibbrraarryy((vvaarrnnuummbbeerrss))

 max_var_number/3 True when Max is the max of Start and the highest numbered $VAR(N) term.
 numbervars/1     Number variables in Term using $VAR(N).
 varnumbers/2     Inverse of numbervars/1.
 varnumbers/3     Inverse of numbervars/3.


1177..33 AArriitthhmmeettiicc FFuunnccttiioonnss

 */2                     Multiplication
 **/2                    Power function

 +/1                     Unary plus (No-op)
 +/2                     Addition
 -/1                     Unary minus
 -/2                     Subtraction
 //2                     Division
 ///2                    Integer division
 /\/2                    Bitwise and
 <</2                    Bitwise left shift

 >>/2                    Bitwise right shift
 ./2                     List of one character:  character code
 \/1                     Bitwise negation
 \//2                    Bitwise or
 ^/2                     Power function
 abs/1                   Absolute value
 acos/1                  Inverse (arc) cosine

 acosh/1                 Inverse hyperbolic cosine
 asin/1                  Inverse (arc) sine
 asinh/1                 Inverse (arc) sine
 atan/1                  Inverse hyperbolic sine
 atan/2                  Rectangular to polar conversion
 atanh/1                 Inverse hyperbolic tangent
 atan2/2                 Rectangular to polar conversion
 ceil/1                  Smallest integer larger than arg

 ceiling/1               Smallest integer larger than arg
 cos/1                   Cosine
 cosh/1                  Hyperbolic cosine
 copysign/2              Apply sign of N2 to N1
 cputime/0               Get CPU time
 div/2                   Integer division
 e/0                     Mathematical constant

 erf/1                   Gauss error function
 erfc/1                  Complementary error function
 epsilon/0               Floating point precision
 eval/1                  Evaluate term as expression
 exp/1                   Exponent (base e)
 float/1                 Explicitly convert to float
 float_fractional_part/1 Fractional part of a float
 float_integer_part/1    Integer part of a float

 floor/1                 Largest integer below argument
 gcd/2                   Greatest common divisor
 getbit/2                Get bit at index from large integer
 integer/1               Round to nearest integer
 lgamma/1                Log of gamma function
 log/1                   Natural logarithm
 log10/1                 10 base logarithm

 lsb/1                   Least significant bit
 max/2                   Maximum of two numbers
 min/2                   Minimum of two numbers
 msb/1                   Most significant bit
 mod/2                   Remainder of division
 powm/3                  Integer exponent and modulo
 random/1                Generate random number
 random_float/0          Generate random number

 rational/1              Convert to rational number
 rationalize/1           Convert to rational number
 rdiv/2                  Ration number division
 rem/2                   Remainder of division
 round/1                 Round to nearest integer
 truncate/1              Truncate float to integer
 pi/0                    Mathematical constant

 popcount/1              Count 1s in a bitvector
 sign/1                  Extract sign of value
 sin/1                   Sine
 sinh/1                  Hyperbolic sine
 sqrt/1                  Square root
 tan/1                   Tangent
 tanh/1                  Hyperbolic tangent
 xor/2                   Bitwise exclusive or


1177..44 OOppeerraattoorrss

 $                     1    fx   Bind top-level variable
 ^                   200   xfy   Existential qualification
 ^                   200   xfy   Arithmetic function
 mod                 300   xfx   Arithmetic function
 *                   400   yfx   Arithmetic function
 /                   400   yfx   Arithmetic function
 //                  400   yfx   Arithmetic function
 <<                  400   yfx   Arithmetic function

 >>                  400   yfx   Arithmetic function
 xor                 400   yfx   Arithmetic function
 +                   500    fx   Arithmetic function
 -                   500    fx   Arithmetic function
 ?                   500    fx   XPCE: obtainer
 \                   500    fx   Arithmetic function
 +                   500   yfx   Arithmetic function

 -                   500   yfx   Arithmetic function
 /\                  500   yfx   Arithmetic function
 \/                  500   yfx   Arithmetic function
 :                   600   xfy   module:term separator
 <                   700   xfx   Predicate
 =                   700   xfx   Predicate
 =..                 700   xfx   Predicate
 =:=                 700   xfx   Predicate

 <                   700   xfx   Predicate
 ==                  700   xfx   Predicate
 =@=                 700   xfx   Predicate
 =\=                 700   xfx   Predicate
 >                   700   xfx   Predicate
 >=                  700   xfx   Predicate
 @<                  700   xfx   Predicate

 @=<                 700   xfx   Predicate
 @>                  700   xfx   Predicate
 @>=                 700   xfx   Predicate
 is                  700   xfx   Predicate
 \=                  700   xfx   Predicate
 \==                 700   xfx   Predicate
 =@=                 700   xfx   Predicate
 not                 900    fy   Predicate

 \+                  900    fy   Predicate
 ,                  1000   xfy   Predicate
 ->                 1050   xfy   Predicate
 *->                1050   xfy   Predicate
 ;                  1100   xfy   Predicate
 |                  1105   xfy   DCG disjunction
 discontiguous      1150    fx   Directive

 dynamic            1150    fx   Directive
 module_transparent 1150    fx   Directive
 meta_predicate     1150    fx   Head
 multifile          1150    fx   Directive
 thread_local       1150    fx   Directive
 volatile           1150    fx   Directive
 initialization     1150    fx   Directive
 :-                 1200    fx   Introduces a directive

 ?-                 1200    fx   Introduces a directive
 -->                1200   xfx   DCGrammar:  rewrite
 :-                 1200   xfx   head :- body.  separator


Bibliography

[Bowen _e_t _a_l_., 1983]         D.  L.   Bowen,  L.   M.  Byrd,   and   WF.
                             Clocksin.  A   portable  Prolog   compiler.
                             In  L.  M.  Pereira,  editor,   _P_r_o_c_e_e_d_i_n_g_s
                             _o_f _t_h_e  _L_o_g_i_c  _P_r_o_g_r_a_m_m_i_n_g  _W_o_r_k_s_h_o_p  _1_9_8_3,
                             Lisabon, Portugal, 1983. Universidade  nova
                             de Lisboa.

[Bratko, 1986]               I. Bratko.  _P_r_o_l_o_g _P_r_o_g_r_a_m_m_i_n_g _f_o_r  _A_r_t_i_f_i_-
                             _c_i_a_l _I_n_t_e_l_l_i_g_e_n_c_e. Addison-Wesley, Reading,
                             Massachusetts, 1986.

[Butenhof, 1997]             David R. Butenhof.  _P_r_o_g_r_a_m_m_i_n_g _w_i_t_h  _P_O_S_I_X
                             _t_h_r_e_a_d_s. Addison-Wesley, Reading, MA,  USA,
                             1997.

[Byrd, 1980]                 L. Byrd.  Understanding  the  control  flow
                             of  Prolog  programs.   _L_o_g_i_c   _P_r_o_g_r_a_m_m_i_n_g
                             _W_o_r_k_s_h_o_p, 1980.

[Clocksin & Melish, 1987]    W.  F.   Clocksin   and   C.   S.   Melish.
                             _P_r_o_g_r_a_m_m_i_n_g  _i_n  _P_r_o_l_o_g.   Springer-Verlag,
                             New  York,  Third,  Revised   and  Extended
                             edition, 1987.

[Demoen, 2002]               Bart  Demoen.  Dynamic  attributes,   their
                             hProlog   implementation,   and   a   first
                             evaluation.   Report   CW   350,    Depart-
                             ment  of  Computer   Science,   K.U.Leuven,
                             Leuven,   Belgium,   oct   2002.    URL   =
                             http://www.cs.kuleuven.ac.be/publicaties/rapporten/cw/CW350.abs.html.

[Freire _e_t _a_l_., 1997]        Juliana  Freire,  David  S.  Warren,   Kon-
                             stantinos Sagonas, Prasad Rao, and Terrance
                             Swift.  XSB:   A  system  for   efficiently
                             computing well-founded  semantics. In  _P_r_o_-
                             _c_e_e_d_i_n_g_s  _o_f  _L_P_N_M_R  _9_7,   pages  430--440,
                             Berlin, Germany, jan 1997. Springer Verlag.
                             LNCS 1265.

[Fr"uhwirth, ]               T.    Fr"uhwirth.      Thom     Fruehwirth's
                             constraint    handling    rules    website.
                             http://www.constraint-handling-rules.org.

[Fr"uhwirth, 2009]           T. Fr"uhwirth.  _C_o_n_s_t_r_a_i_n_t  _H_a_n_d_l_i_n_g  _R_u_l_e_s.
                             Cambridge University Press, 2009.

[Graham _e_t _a_l_., 1982]        Susan L.  Graham,  Peter  B.  Kessler,  and
                             Marshall K. McKusick. gprof:  a  call graph
                             execution profiler.  In  _S_I_G_P_L_A_N  _S_y_m_p_o_s_i_u_m
                             _o_n _C_o_m_p_i_l_e_r  _C_o_n_s_t_r_u_c_t_i_o_n, pages  120--126,
                             1982.

[Hodgson, 1998]              Jonathan Hodgson. validation suite for con-
                             formance with part 1 of the standard, 1998,
                             http://www.sju.edu/~jhodgson/pub/suite.tar.gz.

[Holzbaur, 1992]             Christian Holzbaur.  Metastructures  versus
                             attributed  variables  in  the  context  of
                             extensible unification.  In  _P_L_I_L_P,  volume
                             631, pages 260--268. Springer-Verlag, 1992.
                             LNCS 631.

[Kernighan & Ritchie, 1978]  B.  W.   Kernighan  and   D.  M.   Ritchie.
                             _T_h_e _C _P_r_o_g_r_a_m_m_i_n_g _L_a_n_g_u_a_g_e.  Prentice-Hall,
                             Englewood Cliffs, New Jersey, 1978.

[Neumerkel, 1993]            Ulrich  Neumerkel.   The   binary  WAM,   a
                             simplified  Prolog  engine.  Technical  re-
                             port, Technische  Universit"at  Wien,  1993.
                             http://www.complang.tuwien.ac.at/ulrich/papers/PDF/binwam-
                             nov93.pdf.

[O'Keefe, 1990]              R. A.  O'Keefe. _T_h_e  _C_r_a_f_t _o_f  _P_r_o_l_o_g.  MIT
                             Press, Massachussetts, 1990.

[Pereira, 1986]              F.   Pereira.   _C_-_P_r_o_l_o_g   _U_s_e_r_'_s   _M_a_n_u_a_l.
                             EdCaad, University of Edinburgh, 1986.

[Qui, 1997]                  AI  International ltd.,   Berkhamsted,  UK.
                             _Q_u_i_n_t_u_s _P_r_o_l_o_g_,  _U_s_e_r  _G_u_i_d_e _a_n_d  _R_e_f_e_r_e_n_c_e
                             _M_a_n_u_a_l, 1997.

[Schimpf, 2002]              Joachim Schimpf. Logical loops.  In PeterJ.
                             Stuckey, editor, _L_o_g_i_c _P_r_o_g_r_a_m_m_i_n_g,  volume
                             2401 of _L_e_c_t_u_r_e _N_o_t_e_s _i_n  _C_o_m_p_u_t_e_r _S_c_i_e_n_c_e,
                             pages 224--238. Springer Berlin Heidelberg,
                             2002.

[Sterling & Shapiro, 1986]   L. Sterling and E. Shapiro. _T_h_e _A_r_t _o_f _P_r_o_-
                             _l_o_g. MIT  Press, Cambridge,  Massachusetts,
                             1986.

                                  1804


Index

( _l_i_b_r_a_r_y, 968                       PL_get_string_chars(), 1042
-lswipl _l_i_b_r_a_r_y, 1247                PL_get_tail(), 1081
.pl, 79                              PL_get_wchars(), 1075
.pro, 79                             PL_halt(), 1245
?=/2, 211                            PL_handle_signals(), 1199
@/2, 813                             PL_initialise(), 1239
=:=/2, 485                           PL_install_readline(), 1241
/\/2, 524                            PL_instantiation_error(), 1142
=\=/2, 484                           PL_is_acyclic(), 1038
|/2, 220                             PL_is_atom(), 1027
#/\/2, 1399                          PL_is_atomic(), 1036
#=/2, 1391                           PL_is_blob(), 1159
#<==>/2, 1396                        PL_is_callable(), 1031
#>=/2, 1389                          PL_is_compound(), 1032
#>/2, 1393                           PL_is_float(), 1030
#=</2, 1390                          PL_is_functor(), 1033
#</2, 1394                           PL_is_ground(), 1026
#\=/2, 1392                          PL_is_initialised(), 1240
#\/1, 1395                           PL_is_integer(), 1029
#\/2, 1401                           PL_is_list(), 1034
,/2, 218                             PL_is_number(), 1037
#\//2, 1400                          PL_is_pair(), 1035
{}/1, 1424                           PL_is_string(), 1028
!/0, 217                             PL_is_variable(), 1025
/, 80                                PL_license(), 1761
//2, 495                             PL_LIST, 1083
./2, 507                             PL_malloc(), 1253
./3, 768                             PL_malloc_atomic(), 1257
=/2, 194                             PL_malloc_atomic_uncollectable(),
==/2, 197                                  1259
>=/2, 483                            PL_malloc_stubborn(), 1260
>/2, 480                             PL_malloc_uncollectable(), 1258
^/2, 546                             PL_module_name(), 1189
///2, 498                            PL_new_atom(), 1012
->/2, 221                            PL_new_atom_nchars(), 1070
=</2, 482                            PL_new_atom_wchars(), 1073
#<==/2, 1398                         PL_new_functor(), 1016
<</2, 522                            PL_new_module(), 1190
</2, 481                             PL_new_term_ref(), 994
>:</2, 786                           PL_new_term_refs(), 995
:</2, 784                            PL_next_solution(), 1176
-/1, 490                             PL_NOT_A_LIST, 1083
-/2, 493                             PL_on_halt(), 1233
\=/2, 195                            PL_open_foreign_frame(), 1182
\/1, 526                             PL_open_query(), 1175
\==/2, 198                           PL_PARTIAL_LIST, 1083
\+/1, 223                            PL_permission_error(), 1148
\//2, 523                            PL_pred(), 1171
+/1, 491                             PL_predicate(), 1172
+/2, 492                             PL_predicate_info(), 1173
**/2, 545                            PL_put_atom(), 1087
#==>/2, 1397                         PL_put_atom_chars(), 1089
>>/2, 521                            PL_put_atom_nchars(), 1062
;/2, 219                             PL_put_blob(), 1161
*->/2, 222                           PL_put_bool(), 1088
=@=/2, 206                           PL_put_float(), 1096
\=@=/2, 207                          PL_put_functor(), 1097
@>=/2, 202                           PL_put_int64(), 1094
@>/2, 201                            PL_put_integer(), 1093
*/2, 494                             PL_put_list(), 1098
@=</2, 200                           PL_put_list_chars(), 1092
@</2, 199                            PL_put_list_nchars(), 1065
=../2, 416                           PL_put_list_ncodes(), 1064
\, 80                                PL_put_nil(), 1099
_PL_get_arg(), 1057                  PL_put_pointer(), 1095
64-bits                              PL_put_string_chars(), 1090
   platforms, 73                     PL_put_string_nchars(), 1063, 1091

abolish/1, 262, 263                  PL_put_term(),P1100L_put_variable(), 1086
abolish/2, 263                       PL_query(), 1223
abolish/[1                           PL_quote(), 1125
   2], 41                            PL_raise(), 1198
abort/0,  20,  32, 239,  311,  316,  PL_raise_exception(), 1192
      323,  663,  888, 1220,  1231,  PL_realloc(), 1254
      1726                           PL_record(), 1206
abs/1, 502                           PL_record_external(), 1209
absolute_file_name/2, 7,  113,  125, PL_recorded(), 1207
      647, 649, 659, 1275            PL_recorded_external(), 1210
absolute_file_name/3, 41,  44,  104, PL_register_atom(), 1020
      111,   122,  128,  615,  647,  PL_register_extensions(), 1228
      648, 1212, 1213, 1637, 1638    PL_register_extensions_in_module(),
absolute_file_name/[2                      1227
   3], 41, 121, 648                  PL_register_foreign(), 1226
access_file/2, 41, 637, 648          PL_register_foreign_in_module(), 1225
acos/1, 532                          PL_representation_error(), 1144
acosh/1, 540                         PL_reset_term_refs(), 997
acquire(), 1153                      PL_resource_error(), 1149
acyclic_term/1, 60, 191, 192, 205    PL_retry(), 1005
add_edges/3, 1685                    PL_retry_address(), 1006
add_import_module/3, 821, 823, 838   PL_rewind_foreign_frame(), 1185
add_nb_set/2, 1502                   PL_same_compound(), 1204
add_nb_set/3, 1502--1504             PL_set_engine(), 967
add_vertices/3, 1683                 PL_set_prolog_flag(), 1216
agent, 1322                          PL_signal(), 1197
aggregate/3, 810, 1282               PL_skip_list(), 1083
aggregate/4, 810, 1283               PL_strip_module(), 1188
aggregate_all/3, 1284                PL_succeed(), 1002
aggregate_all/4, 1285                PL_syntax_error(), 1150
all_different/1, 1385                PL_term_type(), 1024
all_distinct/1, 1386                 PL_thread_at_exit(), 963
AMD64, 74                            PL_thread_attach_engine(), 961
anonymous                            PL_thread_destroy_engine(), 962
   variable, 59                      PL_thread_self(), 959
anonymous variable, 1752             PL_throw(), 1193
ansi_format/3, 247                   PL_toplevel(), 1242
ansi_term _l_i_b_r_a_r_y, 41, 244, 248      PL_type_error(), 1145
append/1, 325, 329                   PL_unify(), 1105
append/2, 808, 1470                  PL_unify_arg(), 1121
append/3, 306, 441, 1469             PL_unify_atom(), 1106
apply/2, 227                         PL_unify_atom_chars(), 1109
apply_macros _l_i_b_r_a_r_y, 259            PL_unify_atom_nchars(), 1066
apropos/1, 26, 27, 44, 1738, 1765    PL_unify_blob(), 1160
arg/3, 415                           PL_unify_bool(), 1107
arithmetic_function/1, 1191          PL_unify_bool_ex(), 1141
arity, 1752                          PL_unify_chars(), 1108
asin/1, 531                          PL_unify_compound(), 1118
asinh/1, 539                         PL_unify_float(), 1115
assert, 1752                         PL_unify_functor(), 1117
assert/1, 111, 261,  268, 270, 283,  PL_unify_int64(), 1114
      289,   290,  302,  801,  809,  PL_unify_integer(), 1113
      839, 865, 932                  PL_unify_list(), 1119
assert/2, 41, 273, 280, 305          PL_unify_list_chars(), 1110
assert_predicate_options/4, 1574     PL_unify_list_ex(), 1139
asserta/1,  18, 60,  61, 120,  206,  PL_unify_list_nchars(), 1069
      268,   269,  271,  272,  811,  PL_unify_list_ncodes(), 1068
      813, 1752                      PL_unify_mpq(), 1168
asserta/2, 271, 280                  PL_unify_mpz(), 1167
assertion/1, 1457, 1730              PL_unify_nil(), 1120
assertz/1, 120, 264, 269, 270, 302,  PL_unify_nil_ex(), 1140
      307, 837, 1752                 PL_unify_pointer(), 1116
assertz/2, 272, 273, 280             PL_unify_string_chars(), 1111
assignment/2, 1651                   PL_unify_string_nchars(), 1067, 1112
assoc _l_i_b_r_a_r_y, 774, 791, 792, 1306,  PL_unify_term(), 1122
      1500                           PL_unify_thread_id(), 960
assoc_to_keys/2, 1308                PL_unify_wchars(), 1076
assoc_to_list/2, 1307                PL_unify_wchars_diff(), 1077
assoc_to_values/2, 1309              PL_uninstantiation_error(), 1143
at_end_of_stream/0, 383              PL_unregister_atom(), 1021
at_end_of_stream/1, 384, 388         PL_unregister_blob_type(), 1157
at_end_of_stream/[0                  PL_warning(), 1218
   1], 316, 1633                     PL_wchars_to_term(), 1124
at_halt/1,  41, 130, 131,  665, 910, plus/3, 476
      1233, 1243, 1745, 1765         PLVERSION, 1262
atan/1, 533                          popcount/1, 558
atan/2, 535                          portable
atan2/2, 534                            prolog code, 1747
atanh/1, 541                         portray/1, 32, 82,  390, 401,  403,
atom, 1752                                 1175, 1236, 1736
atom/1, 184, 187, 1022               portray_clause/1, 172, 174, 175
atom_chars/2,  110,  340, 367,  431, portray_clause/2, 174, 175, 420
      433, 435, 457, 800             portray_text _l_i_b_r_a_r_y, 401
atom_codes/2,  110,  340,  431--433, portray_text/1, 259, 761
      437, 438, 457, 800             powm/3, 547
atom_concat/3, 441, 746              precedence, 1752
ATOM_dot(), 1014                     pred/1, 816
atom_length/2, 41, 445, 743          predicate, 1752
ATOM_nil(), 1013                        dynamic, 1752
atom_number/2, 340, 437, 438            exported, 1752
atom_prefix/2, 446                      imported, 1752
atom_result/2, 830                   predicate indicator, 109, 1752
atom_string/2, 736                   predicate_options/3, 1573
atom_to_chars/2, 1336                predicate_property/2,   116,    226,
atom_to_chars/3, 1337                      293, 300, 302, 810, 836
atom_to_term/3, 409, 440             predsort/3, 569, 572
atomic/1, 187                        prefix/2, 1471
atomic_concat/3, 441, 442            print/1, 41,  390, 401,  403,  585,
atomic_list_concat/2, 437, 443, 444        590, 1175, 1765
atomic_list_concat/3, 444            print/2, 41, 402
atomics_to_string/2, 749, 750        print_message/2, 41,  44, 113,  130,
atomics_to_string/3, 750                   242--245,   252,  401,   407,
attach_console/0, 946--948, 1220           712, 904, 906, 1765
attr_portray_hook/2, 390, 848        print_message_lines/3,      243--245,
attr_unify_hook/2, 840, 847                248, 252, 1765
attribute_goals//1, 848, 852         priority, 1752
attribute_goals/1, 849               process _l_i_b_r_a_r_y, 311, 601
attribute_goals/3, 840               process_create/3, 311, 601, 609
attvar/1, 842                        profile file, 14
autoload/0, 49, 117, 1267, 1269      profile/1, 699, 955, 1244
autoload_path/1, 46                  profile/3, 700
automaton/3, 1412                    profiler/2, 702
automaton/8, 1413                    profiling

b_getval/2, 867, 869                 proforeigngcode,r1263am, 1752
b_linkarg/3, 790                     project_attributes/+QueryVars
b_set_dict/3, 788                       +ResidualVars, 850
b_setval/2, 788, 865, 866, 1734      project_attributes/2, 850
backtracking, 1752                   prolog/0, 20, 324,  662, 666,  667,
bagof/3,  60, 574,  578, 579,  810,        815, 1242, 1722
      1765                           prolog/assertion_failed, 1458
bb_inf/3, 1432                       prolog/debug_print_hook, 1456
bb_inf/4, 1431                       prolog:break_hook/6, 1730
bb_inf/5, 1430                       prolog:called_by/2, 1608
between/3, 474                       prolog:comment_hook/3, 1741
binding, 1752                        prolog:debug_control_hook/1, 1737
bits                                 prolog:help_hook/1, 1738
   64, 72                            prolog:message_line_element/2, 248
blackboard, 1322                     prolog_breakpoints _l_i_b_r_a_r_y, 1729
blob/2, 185, 187, 310                prolog_choice_attribute/3,      1719,
body, 1752                                 1721, 1726
Boehm GC, 1256                       prolog_codewalk _l_i_b_r_a_r_y, 302
BOM, 66                              prolog_current_choice/1,  1719, 1721,
break/0, 20, 32, 41, 662, 888, 1220        1724
broadcast, 1322                      prolog_current_frame/1, 1718, 1720
broadcast _l_i_b_r_a_r_y, 1322              prolog_cut_to/1, 1724
broadcast/1, 1323, 1324              prolog_edit:edit_command/2, 169
broadcast_request/1, 1324            prolog_edit:edit_source/1, 168
built-in predicate, 1752             prolog_edit:load/0, 170
Byte Order Mark, 66                  prolog_edit:locate/2, 167
byte_count/2, 321, 343               prolog_edit:locate/3, 166
call/1,  103, 189,  217, 225,  238,  prolog_exception_hook/4,   240,  712,
      682,   696,  704,  706,  801,        1731, 1732
      860, 1169, 1730                prolog_file_type/2, 111, 123, 648
call/2, 189, 226                     prolog_frame_attribute/3,  307, 1720,
call/3, 390                                1726, 1732
call/[2-8], 226                      prolog_ide _c_l_a_s_s, 106
call_cleanup/2,  233, 235, 236, 340, prolog_ide/1, 105, 106
      1722, 1751                     prolog_list_goal/1, 1736
call_cleanup/3, 236                  prolog_load_context/2,    128,   129,
call_dcg/3, 259, 260                       406, 1748
call_residue_vars/2, 864             prolog_load_file/2, 113, 1739, 1740
call_shared_object_function/2, 990   prolog_server _l_i_b_r_a_r_y, 309, 324
call_with_depth_limit/3, 231, 232    prolog_skip_frame/1, 1727, 1728
call_with_inference_limit/3,     231,prolog_skip_level/2, 1727, 1728
      232                            prolog_stack _l_i_b_r_a_r_y, 1720, 1732
call_with_time_limit/2, 232, 233     prolog_stack_property/2, 712, 713
callable/1, 189, 1031, 1598          prolog_to_os_filename/2,   80,   615,
cancel_halt/1, 130, 131, 665, 1243         639, 649, 653
catch/3,  237--240, 407,  663, 704,  prolog_trace_interception/4,      95,
      904,  912, 913,  1721, 1732--        678, 712, 1720, 1721, 1726
      1734, 1765                     prolog_xref _l_i_b_r_a_r_y, 103, 802
ceil/1, 520                          prompt
ceiling/1, 519                          alternatives, 41
chain/2, 1416                        prompt/2, 410--412, 904
char_code/2, 110, 434                prompt1/1, 412
char_conversion/2, 41, 470, 471      proper_length/2, 1483
char_type/2, 58, 449, 456--459       property, 1752
character set, 53                    protocol/1, 670, 671, 673
character_count/2, 321, 343, 344     protocola/1, 671, 673
chdir/1, 659, 660                    protocolling/1, 673
check _l_i_b_r_a_r_y, 119, 302              prove, 1752
check/0, 117, 1347                   public list, 1752
check:string_predicate/1, 759        public/1, 288, 293, 302, 1269
check:valid_string_goal/1, 760       put/1, 350, 351, 772
check_predicate_option/3, 1576       put/2, 351, 773
check_predicate_options/0, 1579      put_assoc/4, 1320
checker/2, 1360                      put_attr/3, 842, 843, 847, 855
choice point, 1752                   put_attrs/2, 857
chr _l_i_b_r_a_r_y, 885, 889                put_byte/1, 352
chr_constraint/1, 883, 897           put_byte/2, 353
chr_leash/1, 892                     put_byte/[1
chr_notrace/0, 888, 891                 2], 110
chr_option/2, 879, 897               put_char/1, 350, 354, 356
chr_show_store/1, 893                put_char/2, 355
chr_trace/0, 888, 890                put_char/[1
chr_type/1, 884                         2], 110
circuit/1, 1408                      put_code/1, 350, 356, 357
clause, 1752                         put_code/2, 65, 357, 386, 388
clause/2, 172, 304, 305, 1269        put_code/[1
clause/3, 271, 280, 305, 307, 1271      2], 110
clause/[2                            put_dict/3, 772, 781
   3], 41                            put_dict/4, 773, 782
clause_property/2,  116,  125,  302, qcompile/1, 4, 113, 134,  159--161,
      307, 1720                            899
close/1, 308, 314, 319               qcompile/2, 161
close/2, 315                         qsave_program/1, 41, 132, 1268
close_any/1, 1465                    qsave_program/2, 4, 39, 41,  49, 82,
close_dde_conversation/1, 717              105, 1266, 1267, 1273
close_shared_object/1, 989           qsave_program/[1
clpfd _l_i_b_r_a_r_y, 819                      2], 18, 38, 41, 302,  976, 1239,
clpqr _l_i_b_r_a_r_y, 1422                        1249, 1269, 1271
code_type/2, 449, 455, 457, 458      quasi_quotation_syntax/1, 302, 1612
collate, 463                         quasi_quotation_syntax_error/1, 1613
collation_key/2, 449, 464, 465, 607  query, 1752
COM, 1151                            quiet, 18
command line
   arguments, 18                     random _l_i_b_r_a_r_y, 561
compare                              random/1, 508, 1615
   language-specific, 463            random/3, 1617, 1618
compare(), 1155                      random_between/3, 1616
compare/3, 60, 203, 572, 1203, 1751  random_float/0, 509
compile_aux_clauses/1, 111, 140      random_member/2, 1625
compile_predicates/1, 289, 290       random_perm2/4, 1624
compiling/0, 134, 160                random_permutation/2, 1630, 1631
complement/2, 1690                   random_property/1, 561, 562
completion                           random_select/3, 1626, 1627
   TAB, 86                           randseq/3, 1629
compose/3, 1691                      randset/3, 1628
compound, 1752                       rational
compound/1, 188                         number, 487
compound_name_arguments/3, 188, 416- rational trees, 60
      -418, 764, 767                 rational/1, 181, 513
compound_name_arity/3,   188,   414, rational/3, 182, 487
      417, 418, 764, 767             rationalize/1, 514
concat_atom/3, 444                   rb_new/1, 41
constraint/3, 1652, 1653             rbtrees _l_i_b_r_a_r_y, 41
constraint/4, 1653                   RDF
constraint_add/4, 1654                  memory usage, 75
consult/1,  11,  14, 44,  94,  111-  rdiv/2, 500
      -116,  119,  156,  159,  160,  reachable/3, 1696
      291                            read/1, 41, 70, 309--311, 360, 397,
context module, 1752                       404,  407,  411,   692,  873,
context_module/1, 810, 832, 1175           1638, 1765
convert_time/2, 41                   read/2, 342, 405
convert_time/[2                      read_clause/3, 59, 406, 692
   8], 646                           read_file_to_codes/3, 1637
copy_file/2, 601                     read_file_to_terms/3, 1638
copy_predicate_clauses/2, 264        read_from_chars/2, 1340
copy_stream_data/2, 387, 388         read_history/6, 410
copy_stream_data/3, 322, 386         read_line_to_codes/2,   756,    1633,
copy_term/2,   60,  206,  424,  426,       1634
      429, 787, 839, 853, 867        read_line_to_codes/3, 1633, 1634
copy_term/3, 390, 848, 849, 852      read_link/3, 654
copy_term_nat/2, 853                 read_pending_input/3, 388
copysign/1, 504                      read_stream_to_codes/2, 1635, 1636
cos/1, 529                           read_stream_to_codes/3, 1636
cosh/1, 537                          read_string/3, 753
count_atom_results/3, 830            read_string/5, 747, 754
cputime/0, 554                       read_term/2,  41,  128,   148,  390,
create_pool/1, 1678                        407,  408,  410,   440,  732,
create_prolog_flag/3, 41--43, 1215         739, 1741
crypt _l_i_b_r_a_r_y, 1763                  read_term/3,   59,  390,   406--409,
csv//1, 1441                               470, 667, 791, 1741
csv//2, 1442                         read_term/[2
csv_read_file/2, 569, 1439              3], 407
csv_read_file/3, 1440                read_term_from_atom/3, 409, 440
csv_read_file_row/3, 1443            read_term_from_chars/3, 1341
csv_write_file/2, 1444               readutil _l_i_b_r_a_r_y, 84
csv_write_file/3, 1445               reconsult, 111
csv_write_stream/3, 1446             record _l_i_b_r_a_r_y, 791, 792, 1639
ctype _l_i_b_r_a_r_y, 455                   record/1, 1639, 1640
cumulative/1, 1409                   recorda/2, 275
cumulative/2, 1410                   recorda/3, 60, 274, 276, 280,  299,
current_arithmetic_function/1, 563         865, 1205, 1206, 1209
current_atom/1, 295                  recorded/2, 279
current_blob/2, 296, 1152            recorded/3, 278, 280, 1271
current_char_conversion/2, 470, 471  recordz/2, 277
current_flag/1, 298                  recordz/3, 60, 276, 280
current_foreign_library/2, 984, 1267 redefine_system_predicate/1,     265,
current_format_predicate/2, 594            1752
current_functor/2, 297               reexport/1, 111, 113, 817, 1747
current_input/1, 128, 309, 330, 337  reexport/2, 111, 113, 818, 1747
current_key/1, 278, 299              registry, 68
current_locale/1, 454                registry _l_i_b_r_a_r_y, 1641
current_module/1, 300, 835           registry_delete_key/1, 1646
current_op/3, 468                    registry_get_key/2, 1642
current_option_arg/2, 1577           registry_get_key/3, 1643
current_output/1, 309, 331, 338      registry_set_key/2, 1644
current_persistent_predicate/1, 1554 registry_set_key/3, 1645
current_predicate/1, 226, 300--302   release(), 1154
current_predicate/2, 300, 301        reload_foreign_libraries/0, 985
current_predicate_option/3, 1575     reload_library_index/0, 45, 46, 49
current_predicate_options/3, 1578    rem/2, 497
current_prolog_flag/2, 18,  40,  41, rename_file/2, 601, 644
      45,  50, 55,  113,  407, 722,  repeat/0, 212, 216, 231, 233
      975, 1280, 1752                representation_error/1, 1144
current_signal/3, 254, 255           require/1, 117, 1747
current_stream/3, 317                reset_gensym/0, 1462
current_thread_pool/1, 1675          reset_gensym/1, 1461
cyclic terms, 60                     reset_profiler/0, 703
cyclic_term/1, 60, 191, 192          resource/3, 41,  1266, 1267,  1273,

daemon, 1322                         resour1275,c1276e_error/1, 1149
date_time_stamp/2, 623               retract, 1752
date_time_value/3, 619, 624          retract/1, 111, 120, 261, 262, 266,
day_of_the_week/2, 629                     283, 289, 290, 302, 932
db_attach/2, 1555                    retract/2, 839
db_sync/1, 1556                      retractall/1, 261, 262, 267
db_sync_all/1, 1557                  retractall_predicate_options/0, 1581
DCG, 111, 257                        rev/3, 803
dcg_translate_rule/2, 137, 141       reverse/2, 260, 803, 1485
dcg_translate_rule/4, 148            rl_add_history/1, 1744
dde_current_connection/2, 725        rl_read_history/1, 1746
dde_current_service/2, 724           rl_read_init_file/1, 1743
dde_execute/2, 719                   rl_write_history/1, 1745
dde_poke/4, 720                      round/1, 510
dde_register_service/2, 722
dde_request/3, 718                   same_file/2, 639, 641
dde_unregister_service/1, 723        same_length/2, 1484
debug _l_i_b_r_a_r_y, 106                   same_term/2, 430
debug/0,  32,  41, 240,  681,  683,  sandbox/safe_meta, 1288
      684,  712,  949, 1220,  1730,  sat/1, 1366
      1732                           sat_count/2, 1369
debug/1, 1451                        scalar_product/4, 1388
debug/3, 243, 1455                   scanl/4, 1302
debug_message_context/1, 1454        scanl/5, 1303
debugging                            scanl/6, 1304
   exceptions, 240                   scanl/7, 1305
debugging/0, 44, 681, 685, 1737      see/1, 308, 309, 325--327
debugging/1, 1448, 1449              seeing/1, 325, 326, 330
debugging/2, 1450                    seek/4, 316, 320, 322
default_module/2, 302, 821, 822      seen/0, 332
del_attr/2, 845, 855                 select(), 342
del_attrs/1, 858                     select/3, 1472
del_dict/4, 783                      select/4, 1474
del_edges/3, 1686                    select_dict/2, 785
del_vertices/3, 1684                 select_dict/3, 785, 786
delete/3, 1477                       select_option/3, 1512
delete_directory/1, 658              select_option/4, 1513
delete_file/1, 601, 643, 656         selectchk/3, 1473
delete_import_module/2,  821,   823, selectchk/4, 1475
      824, 838                       semi deterministic, 1752
derive_predicate_options/0, 1580     semidet, 1752
derived_predicate_options/1, 1583    serialize, 257
derived_predicate_options/3, 1582    serialized/2, 1404
deserialize, 257                     set_breakpoint/4, 1730
det, 1752                            set_end_of_stream/1, 385
determinism, 1752                    set_input/1, 309, 323, 327, 335
deterministic, 1752                  set_locale/1, 453
deterministic/1, 233, 1722           set_module/1, 268, 820, 836, 837
Development environment, 76          set_output/1, 309, 328, 336
dialect.pl _l_i_b_r_a_r_y, 1747             set_prolog_flag/2,  30, 40--43,  111,
dict_create/3, 779, 781                    479, 1215
dict_options/2, 1516                 set_prolog_IO/3, 309, 324
dict_pairs/2, 791                    set_prolog_stack/2,   19,  68,   683,
dict_pairs/3, 780                          712, 713, 734, 904
dif _l_i_b_r_a_r_y, 863                     set_random/1, 508, 561, 562
dif/2, 60, 195, 862, 863             set_stream/2,  65,  309,  311,  316,
directory_file_path/3, 639                 323, 324, 342, 378, 453
directory_files/2, 651               set_stream_position/2, 316, 320, 322
discontiguous/1,  116,   243,  288,  set_url_encoding/2, 1705
      292, 692                       setarg/3, 109, 424, 426, 427,  429,
disjoint2/1, 1411                          430, 788, 843, 873, 1639
display/1, 585, 1084                 setenv/2, 605
distinct/1, 1666                     setlocale/1, 904
distinct/2, 1667                     setlocale/3, 465, 607
div/2, 499                           setof/3, 60, 579, 810, 1765
divmod/4, 477                        setrand/1, 1619
do_not_use/1, 816                    setup_call_catcher_cleanup/4, 234
domain/2, 840                        setup_call_cleanup/2, 933
domain_error/2, 1146                 setup_call_cleanup/3, 233,  235, 908,
downcase_atom/2, 456, 459, 460             937, 938, 941
dump/3, 1433, 1437                   shadow_price/3, 1659
duplicate_term/2,   60,  424,   427, shared, 1752
      429, 868                       shell/0, 603, 608
dwim_match/2, 303, 727, 728          shell/1, 80, 169, 602, 608
dwim_match/3, 728                    shell/2, 601, 609
dwim_predicate/2, 303                shell/[0-2], 605
dynamic predicate, 1752              shell/[1
dynamic/1, 41, 109,  116, 261, 267,     2], 601
      288--290,   302,   831,  931,  shell_register_dde/6, 1648
      932, 1269                      shell_register_file_type/4,     1647,

e/0, 552                             shell_1648register_prolog/1, 1649
edges/2, 1682                        shlib _l_i_b_r_a_r_y, 1765
edit/0, 41, 164                      show_profile/1, 700, 701
edit/1,  41, 44,  86, 89,  94, 107,  sign/1, 503
      116,   119,   162--166,  168,  simplex _l_i_b_r_a_r_y, 1650
      814, 1765                      sin/1, 528
edit_source/1, 169                   singleton, 1752
editor _c_l_a_s_s, 85, 90                    variable, 59
element/3, 1405                      sinh/1, 536
elif/1, 151                          size_file/2, 645
else/0, 152                          size_nb_set/2, 1505
Emacs, 23                            skip/1, 380, 381
emacs/[0                             skip/2, 381
   1], 89                            sleep/1, 730
emacs/prolog_colour _l_i_b_r_a_r_y, 93      socket _l_i_b_r_a_r_y, 342
empty_assoc/1, 1310                  Solaris, 911
empty_nb_set/1, 1501                 solution, 1752
encoding/1, 65, 118                  sort/2, 232, 568--570, 572, 579
endif/0, 153                         sort/4, 569
ensure_loaded/1, 34, 111, 115, 807   source_exports/2, 1747, 1750
entailed/1, 1425                     source_file/1, 124
environment/2, 1594                  source_file/2, 116, 125, 160, 302
epsilon/0, 553                       source_file_property/2,   113,   116,
erase/1, 271, 274, 280, 305                126
erf/1, 549                           source_location/2, 128, 129
erfc/1, 550                          split_string/4, 444, 747, 754
error _l_i_b_r_a_r_y, 176, 1639             spy/1, 32,  41,  44, 96,  97,  107,
eval/1, 555                                109,  686,  814,   953,  954,
eval_license/0, 1757--1759                 1737, 1765
exception/3, 865, 1733, 1734         sqrt/1, 527
exceptions                           stack
   debugging, 240                       memory management, 69
exclude/3, 1291                      stamp_date_time/3, 619, 622, 623
exists_directory/1, 642              startup file, 14
exists_file/1, 41, 638               statistics _l_i_b_r_a_r_y, 697
exists_source/1, 1747, 1749          statistics/0, 243, 695
exp/1, 544                           statistics/2, 554, 694, 914
expand_answer/2, 667, 668            stream_pair/3, 310, 314, 319, 323
expand_file_name/2,  41,  113,  605, stream_position_data/3,   128,   316,
      608, 647, 648, 651, 652              321, 407, 1741
expand_file_search_path/2, 122       stream_property/2,  66,  128,   311,
expand_goal/2, 41, 135--139, 150           316, 320--323, 407
expand_goal/4, 144                   stream_to_lazy_list/2, 1566
expand_query/4, 667                  string/1, 186, 187, 590, 735
expand_term/2,  135--138, 141,  257, string_chars/2, 740
      1640                           string_code/3, 744, 745, 761
expand_term/4, 146                   string_codes/2, 741, 756
expects_dialect/1,  113, 128,  1747, string_concat/3, 746, 756
      1748                           string_length/2, 743
explain _l_i_b_r_a_r_y, 1765                string_lower/2, 752
explain/1, 28                        string_predicate/1, 1358
explain/2, 29                        string_upper/2, 751
export/1, 293, 827--829              strip_module/3, 810, 830, 833, 838
export_list/2, 828                   structure, 1752
exported predicate, 1752             style_check/1,  59,  70,  113,  292,

fact, 1752                                 692
fail/0, 139, 213                     sub_atom/5, 447, 748
false/0, 214                         sub_atom_icasechk/3, 448
fd_dom/2, 1421                       sub_string/5, 744, 748, 756
fd_inf/2, 1418                       subset/2, 1498
fd_size/2, 1420                      subsumes_chk/2, 287
fd_sup/2, 1419                       subsumes_term/2, 60, 204, 208
fd_var/1, 1417                       subtract/3, 1499
file_base_name/2, 640                succ/2, 475
file_directory_name/2, 639, 640      succeed, 1752
file_name_extension/3, 650           sum/3, 1387
file_name_to_url/2, 1709, 1710       sum_list/2, 1490
file_of_label/2, 815                 sup/2, 1427
file_search_path/2, 14, 18,  41, 45, swi/pce_profile _l_i_b_r_a_r_y, 697
      49,  81, 104, 113,  120, 121,  swi_edit _l_i_b_r_a_r_y, 170
      123,  128, 1213,  1249, 1272,  swritef/2, 587
      1275, 1278                     swritef/3, 340, 582, 586
fileerrors/2, 41                     syntax_error/1, 1563
filesex _l_i_b_r_a_r_y, 601, 639            TAB
find_chr_constraint/1, 894              completion, 86
findall/3, 60, 206,  212, 574, 575,  tab/1, 358
      577, 581, 791, 839, 1765       tab/2, 359
findall/4, 575, 577                  tan/1, 530
findnsols/4, 576                     tanh/1, 538
findnsols/5, 577                     taut/2, 1367
findsols/4, 1765                     tdebug/0, 904, 950, 954
flag/3, 282, 298, 427                tdebug/1, 949, 950, 953
flag:access_level, 41                tell/1, 308,  309, 325,  326,  328,
flag:address_bits, 41                      329
flag:agc_margin, 41                  telling/1, 325, 326, 331
flag:allow_dot_in_atom, 41           term, 1752
flag:allow_variable_name_as_functor, term//1, 340
      41                             term_attvars/2, 854
flag:answer_write_options, 41        term_expansion/2,  44,  111,   134--
flag:apple, 41                             138,  149,  160,   667,  885,
flag:arch, 41                              1751
flag:argv, 41                        term_expansion/4, 111, 147
flag:associated_file, 41             term_hash/2, 60, 63, 284--287
flag:autoload, 41                    term_hash/4, 63, 284, 286
flag:back_quotes, 41                 term_string/2, 439, 738, 739
flag:bounded, 41                     term_string/3, 739
flag:break_level, 41                 term_subsumer/3, 209
flag:c_cc, 41                        term_to_atom/2, 340, 439, 1123
flag:c_cflags, 41                    term_variables/2, 60, 407, 422, 423
flag:c_ldflags, 41                   term_variables/3, 422, 423
flag:c_libplso, 41                   terms
flag:c_libs, 41                         cyclic, 60
flag:char_conversion, 41             text_to_string/2, 742
flag:character_escapes, 41           thread _l_i_b_r_a_r_y, 41
flag:colon_sets_calling_context, 41  thread_at_exit/1, 665, 904, 910, 963
flag:color_term, 41                  thread_create/3, 904, 907, 910, 971
flag:compile_meta_arguments, 41      thread_create_in_pool/4, 904, 1677
flag:compiled_at, 41                 thread_detach/1, 904, 907
flag:console_menu, 41                thread_exit/1, 906, 908, 913
flag:cpu_count, 41                   thread_get_message/1, 920, 925
flag:dde, 41                         thread_get_message/2, 924--926
flag:debug, 41                       thread_get_message/3, 919, 921, 926
flag:debug_on_error, 41              thread_initialization/1, 865, 909
flag:debugger_show_context, 41       thread_join/2, 904, 906, 908, 913
flag:debugger_write_options, 41      thread_local/1, 246, 289,  302, 931,
flag:dialect, 41                           932
flag:double_quotes, 41               thread_message_hook/3, 246
flag:editor, 41                      thread_peek_message/1, 920, 921, 927
flag:emacs_inferior_process, 41      thread_peek_message/2, 926, 927
flag:encoding, 41                    thread_pool_create/3, 1673
flag:executable, 41                  thread_pool_destroy/1, 1674
flag:exit_status, 41                 thread_pool_property/2, 1676
flag:file_name_variables, 41         thread_property/2,  906,  907,  910,
flag:gc, 41                                913
flag:generate_debug_info, 41         thread_self/1,  41, 905,  907,  910,
flag:gmp_version, 41                       918
flag:gui, 41                         thread_send_message/2, 918, 919, 923
flag:history, 41                     thread_send_message/3, 919
flag:home, 41                        thread_setconcurrency/2, 41, 911
flag:hwnd, 41                        thread_signal/2,   233,  930,   949,
flag:integer_rounding_function, 41         1198, 1246
flag:iso, 41                         thread_statistics/3, 913, 914
flag:large_files, 41                 threads/0, 944
flag:last_call_optimisation, 41      throw/1,  32,  60,  237--239,  252,
flag:max_arity, 41                         256,  908,  913,   929,  930,
flag:max_integer, 41                       1192, 1194, 1732--1734
flag:max_tagged_integer, 41          time/1, 554, 696
flag:min_integer, 41                 time_file/2, 646
flag:min_tagged_integer, 41          tmp_file/2, 655, 656
flag:occurs_check, 41                tmp_file_stream/3, 655, 656
flag:open_shared_object, 41          tnodebug/0, 952
flag:optimise, 41                    tnodebug/1, 951, 954
flag:os_argv, 41                     told/0, 333
flag:pid, 41                         top_sort/2, 1693
flag:pipe, 41                        top_sort/3, 1694
flag:print_write_options, 41         tprofile/1, 955, 956
flag:prompt_alternatives_on, 41      trace/0, 32, 41, 96, 97,  107, 675,
flag:qcompile, 41                          681,  890,  891,  930,  1220,
flag:readline, 41                          1730, 1732
flag:report_error, 41                trace/1, 41, 680
flag:resource_database, 41           trace/2, 681
flag:runtime, 41                     tracing/0, 676
flag:sandboxed_load, 41              transformation
flag:saved_program, 41                  of program, 135
flag:shared_object_extension, 41     transitive_closure/2, 1695
flag:shared_object_search_path, 41   transparent, 1752
flag:signals, 41                     transportation/4, 1660
flag:stream_type_check, 41           transpose/2, 1414, 1687
flag:system_thread_id, 41            transpose_pairs/2, 1550
flag:timezone, 41                    trim_stacks/0, 709, 711, 712
flag:toplevel_print_anon, 41         trivial_fail_goal/1, 1355
flag:toplevel_print_factorized, 41   true/0, 41, 139, 215, 231
flag:toplevel_prompt, 41             truncate/1, 517
flag:toplevel_var_size, 41           tspy/1, 904, 947, 954
flag:trace_gc, 41                    tspy/2, 953
flag:traditional, 41                 tty_get_capability/3, 596, 598, 599
flag:tty_control, 41                 tty_goto/2, 597
flag:unix, 41                        tty_put/2, 598
flag:unknown, 41                     tty_size/2, 599
flag:unload_foreign_libraries, 41    ttyflush/0, 362, 585
flag:user_flags, 41                  tuples_in/2, 1403
flag:verbose, 41                     type_error/2, 252, 1145, 1147
flag:verbose_autoload, 41
flag:verbose_file_search, 41         UCS, 64
flag:verbose_load, 41                ugraph _l_i_b_r_a_r_y, 1679
flag:version, 41                     ugraph_union/3, 1692
flag:version_data, 41                ugraphs.pl _l_i_b_r_a_r_y, 1679
flag:version_git, 41                 Unicode, 64
flag:warn_override_implicit_import,  unifiable/3, 60, 204, 210
      41                             unify, 1752
flag:windows, 41                     unify_with_occurs_check/2,  41,   60,
flag:write_attributes, 41                  204, 205
flag:write_help_with_overstrike, 41  union/3, 1497
flag:xpce, 41                        unix, 41
flag:xpce_version, 41                unix/1, 608
flatten/2, 807, 1487                 unknown/2, 691, 1280
float/1, 180, 187, 512               unlisten/1, 1327
float_fractional_part/1, 515         unlisten/2, 1328
float_integer_part/1, 516            unlisten/3, 1329
floor/1, 518                         unload_file/1, 113, 127
flush_output/0, 360                  unload_foreign_library/1, 982
flush_output/1, 244, 361, 388        unload_foreign_library/2, 983
flush_output/[0                      unsetenv/1, 605, 606
   1], 311, 362                      upcase_atom/2, 456, 460
foldl/4, 1298                        update view, 283, 1752
foldl/5, 1299                        URL, 611
foldl/6, 1300                        url _l_i_b_r_a_r_y, 1507
foldl/7, 1301                        url_iri/2, 1706, 1707
forall/2, 581                        use_foreign_library/1,    121,   132,
foreach/2, 581, 1286                       615, 980, 1267
format/1, 244, 582, 589              use_foreign_library/2, 981
format/2, 57,  311, 401,  449, 582,  use_module/1, 41, 44, 81,  111, 113,
      589--591                             116,   156,  805--808,   817,
format/3, 243, 244,  247, 252, 309,        825, 826, 1269, 1747
      340,   389,  439,  449,  462,  use_module/2,  45, 111,  113,  806--
      487,   488,  582,  590,  591,        808, 818, 1747
      593, 756, 760                  use_module/[1
format/[1                               2], 34, 94, 111, 113,  115, 827,
   2], 389, 1765                           828, 1752
format/[2                            user _l_i_b_r_a_r_y, 1765
   3], 55                            user profile file, 14
format_predicate/2, 593              UTF-8, 64
format_time/3, 449, 593, 607, 625    utf-8, 110
format_time/4, 625, 626
format_to_chars/3, 1332              valgrind, 1263
format_to_chars/4, 1333              valid_string_goal/1, 1359
free_variables/4, 1287               var/1, 177, 842, 1022
freeze/2, 859, 860, 862              var_number/2, 421
frozen/2, 861                        var_property/2, 142
functor, 1752                        variable, 1752
functor/3, 188, 301, 414, 416, 417,     anonymous, 1752
      764, 767, 873                  variable_value/3, 1661

garbage_collect/0, 709               variant,v206ariant_sha1/2, 287, 1763
garbage_collect_atoms/0, 710, 1235   varnumbers/2, 1713
garbage_collect_clauses/0, 61,  154, varnumbers/3, 1714
      155, 158                       verbose, 18
garbage_collect_heap/0, 694          version/0, 250, 251
gcd/2, 501                           version/1, 250, 251
gdebug/0, 100                        vertices/2, 1681
gen_assoc/3, 1311                    vertices_edges_to_ugraph/3, 1680
gen_nb_set/2, 1504                   view
gen_state/1, 1655                       update, 1752
gensym/2, 1460                       visible/1, 690, 1726
get/1, 371, 372, 771                 vm_list/1, 1221
get/2, 372                           volatile/1, 302, 932, 1270
get0/1, 311, 369--372
get0/2, 370, 372                     wait_for_input/3, 323, 342
get_assoc/2, 791                     when _l_i_b_r_a_r_y, 862
get_assoc/3, 1312                    when/2, 60, 862
get_assoc/5, 1313                    wildcard_match/2, 729
get_attr/3, 844, 855                 win_add_dll_directory/1, 615
get_attrs/2, 856, 857                win_add_dll_directory/2, 615--617
get_byte/1, 363, 369                 win_exec/2, 601, 609--611
get_byte/2, 364, 368                 win_folder/2, 14, 18, 614
get_byte/[1                          win_has_menu/0, 633
   2], 110                           win_insert_menu/2, 633--635
get_char/1, 365, 367                 win_insert_menu_item/4, 633, 635
get_char/2, 368                      win_registry_get_value/3, 613
get_char/[1                          win_remove_dll_directory/1, 616, 617
   2], 110                           win_shell/2,  601,  609,  611,  612,
get_code/1,   110,  309,  365,  369,       1508
      380, 382                       win_window_pos/1, 632
get_code/2, 65,  322, 366, 368, 370, window_title/2, 631
      386, 388                       windows, 41
get_code/[1                          with_mutex/2,  929, 933,  937,  938,
   2], 110                                 941, 957
get_dict/3, 771, 777                 with_output_to/2,   309,  310,   336,
get_dict/5, 778                            340, 389, 439, 462, 591, 625
get_dict_ex/3, 768, 771              with_output_to_chars/2, 1343
get_single_char/1, 18, 41, 382       with_output_to_chars/3, 1344
get_string_code/3, 745               with_output_to_chars/4, 1345
get_time/1, 621, 646, 694, 919, 926  with_quasi_quotation_input/3, 1610
getbit/2, 559                        working_directory/2,  16, 608,  648,
getenv/2, 604, 605, 1508                   659, 660
getrand/1, 1620                      write(), 1156
global_cardinality/2, 1406           write/1, 41, 60, 70, 309, 395, 585,
global_cardinality/3, 1407                 590, 1043, 1084, 1156
global_url/3, 1698                   write/2, 396
GMP, 487                             write_canonical/1,  390,  393,  407,
GNU-Emacs, 23                              590, 732
go/0, 764                            write_canonical/2, 394, 420, 1043
goal, 1752                           write_length/3, 392, 445
goal_expansion/2,   111,  135,  136, write_term/2,   32,  41,   390--393,
      138--140,   142,  149,  1748,        401,  407,  420,   439,  585,
      1751, 1765                           590, 732, 739, 848
goal_expansion/4, 111, 145           write_term/3,  41,  44,   390,  391,
ground/1, 60, 190, 285, 1026               419, 445
group_by/4, 1671                     write_to_chars/2, 1334
group_pairs_by_key/2, 1549           write_to_chars/3, 1335
gspy/1, 101                          writef/1, 582, 584
gtrace/0, 99, 947                    writef/2, 7, 55, 389, 582, 584--586
guitracer/0, 96--98, 107, 674, 678   writeln/1, 399
gxref/0, 28, 104, 808, 1269, 1598    writeln/2, 400

halt/0, 32, 130, 664, 1765           writeq/1,w397,r585,i590teq/2, 398, 1043
halt/1, 41, 664, 665, 1220, 1765     www_form_encode/2, 1703, 1704
halt/[0                              www_open_url/1, 1508
   1], 130
hashing, 1752                        xor/2, 525
head, 1752                           xref_built_in/1, 1606
help/0, 25, 44, 1273, 1738           xref_called/3, 1603
help/1, 25, 26, 41, 44, 1738         xref_clean/1, 1601
hooks, 44                            xref_current_source/1, 1600
html_write _l_i_b_r_a_r_y, 1608             xref_defined/3, 1602
http/http_error _l_i_b_r_a_r_y, 240         xref_exported/2, 1604
http/http_header _l_i_b_r_a_r_y, 625        xref_module/2, 1605
http/http_load _l_i_b_r_a_r_y, 113, 1740    xref_source/1, 1599
http_location/2, 1700
http_open/3, 252                     YAP
http_timestamp/2, 625                   prolog, 1747
IA32, 74                             zcompare/3, 1415
IDE, 76
if
   directive, 149
if/1, 128, 150
ignore/1, 230, 704, 904
immediate
   update view, 283
import/1, 828, 829
import_module/2, 300, 821--823
imported predicate, 1752
in/2, 1380
in_pce_thread/1, 969, 970
in_pce_thread_sync/1, 970
include/1, 111, 113, 116, 125, 126,
      307
include/3, 1290
indexing, 1752
   term-hashes, 284
indomain/1, 1382
inf/2, 1426
infinite trees, 60
initialization/1,  111,  132,  133,
      157,  865,  909,  976,  1239,
      1271
initialization/2, 133
ins/2, 1381
instance/2, 281
instantiation, 1752
instantiation_error/1, 1142
integer, 1752
   unbounded, 487
integer//1, 259
integer/1, 179, 187, 511
interactor/0, 323, 946
internationalization, 64
interpreted, 1752
intersection/3, 1496
is/2, 486, 487, 512, 897
is_absolute_file_name/1, 649
is_absolute_url/1, 1699
is_assoc/1, 1321
is_dict/1, 775
is_dict/2, 776
is_list/1, 565
is_ordset/1, 1525
is_set/1, 1494
is_stream/1, 318
ISO Latin 1, 53

Java, 1151
jitindex, 61
join_threads/0, 945

keysort/2, 569, 571, 572

label/1, 1383
labeling/1, 1368
labeling/2, 1384
last/2, 1482
lazy_list_character_count/1, 1565
lazy_list_location//1, 1564
leash/1, 32, 689, 690, 892, 1726
length/2, 567
lex_chain/1, 1402
lgamma/1, 548
library(apply_macros) _l_i_b_r_a_r_y, 111
library(dcg/basics) _l_i_b_r_a_r_y, 259
library_directory/1, 45, 49, 120
license/1, 1760
license/2, 1759, 1760
limit/2, 1668
line_count/2, 321, 323, 345, 597
line_position/2, 321, 323, 346, 597
list_autoload/0, 1350
list_debug_topics/0, 1453
list_redefined/0, 1351
list_strings/0,  731, 758, 759, 761,
      1356
list_strings/1, 1357
list_to_assoc/2, 791, 1314
list_to_ord_set/2, 1528
list_to_set/2, 1495
list_trivial_fails/0, 1353
list_trivial_fails/1, 1354
list_undefined/0, 41, 119, 1348
list_undefined/1, 1349
list_void_declarations/0, 1352
listen/2, 1325, 1326
listen/3, 1326--1329
listening/3, 1330
listing/0, 173
listing/1, 32, 172, 173
lists _l_i_b_r_a_r_y, 564
load_file/2, 113
load_files/1, 112
load_files/2,  41, 44, 65, 111--114,
      126,   127,  156,  157,  161,
      692,  808, 1598,  1739, 1740,
      1749, 1765
load_foreign_library/1,  132,   978,
      987, 1247, 1272
load_foreign_library/2, 979
load_hotfixes/1, 113
locale, 463
locale_create/3, 450, 452
locale_destroy/1, 450, 451
locale_property/2, 452
locale_sort/2, 449, 464, 465, 607
log/1, 542
log10/1, 543
logical
   update view, 283
lsb/1, 557

MacOS, 41
make/0, 4, 41, 45, 49, 87, 94, 107,
      113, 116, 119, 126, 154
make_directory/1, 601, 657
make_library_index/1, 45, 47
make_library_index/2, 45, 48
make_library_index/[1
   2], 49
manpce/0, 68
map_assoc/2, 1315
map_assoc/3, 1316
map_list_to_pairs/3, 1551
maplist/2, 581, 800, 1294
maplist/3, 791, 809, 830, 1295
maplist/4, 1296
maplist/5, 1297
maplist_/3, 809, 830
max/2, 505
max_assoc/3, 1317
max_list/2, 1491
max_member/2, 1488
max_var_number/3, 1715
maximize/1, 1429
maximize/3, 1656, 1657
maybe/0, 1621
maybe/1, 1622
maybe/2, 1623
member/2, 32,  233, 566,  648, 808,
      1468, 1765
memberchk/2, 566, 761
memory
   layout, 69
merge_options/3, 1514
message
   service, 1322
message_hook/3,  242--246, 252, 712,
      1765
message_property/2, 41, 247
message_queue_create/1,  917,   922,
      924
message_queue_create/2,  922,   923,
      928
message_queue_create/3, 933
message_queue_destroy/1, 924, 925
message_queue_property/2, 913, 928
message_to_string/2, 243, 245, 249
meta-predicate, 1752
meta_options/3, 808, 1515
meta_predicate/1,   41,  138,   189,
      302,   809,  810,  830,  838,
      1175, 1225, 1269
min/2, 506
min_assoc/3, 1318
min_list/2, 1492
min_member/2, 1489
minimize/1, 1428
minimize/3, 1657
mod/2, 496
mode, 1752
module, 1752
   contex, 1752
module transparent, 1752
module/1, 41,  111, 293,  814, 815,
      904
module/2, 136,  466, 467, 803--805,
      808, 819, 827, 838
module/3, 805
module_property/2, 836, 837
module_transparent/1,    302,   810,
      813, 831, 838, 1175, 1752
msb/1, 556
msort/2, 569, 570
multi, 1752
multifile/1,  41,  116,  288,  291,
      302, 1736, 1752
must_be/2, 1639
mutex_create/1, 934, 937, 938
mutex_create/2, 935, 942
mutex_destroy/1, 936
mutex_lock/1, 938, 939
mutex_property/2, 942
mutex_statistics/0, 915
mutex_trylock/1, 939
mutex_unlock/1, 940
mutex_unlock_all/0, 941
my_compare/3, 1751
mypred/1, 816
name/1, 809
name/2, 431, 438
name_of/2, 1326
nb_current/2, 871
nb_delete/1, 872
nb_getval/2, 869, 871
nb_link_dict/3, 790
nb_linkarg/3, 427--429
nb_linkval/2,  428,  429, 790,  870,
      873
nb_set _l_i_b_r_a_r_y, 1500
nb_set_dict/3, 789
nb_set_to_list/2, 1506
nb_setarg/3,   109,  426--429,  577,
      789, 1500, 1639
nb_setval/2,  427,  429,  789,  865,
      868, 870, 873, 1734
neck, 1752
neighbors/3, 1689
neighbours/3, 1688, 1689
nextto/3, 1476
nl/0, 348
nl/1, 349
nl/[0
   1], 585
nodebug/0, 683, 684, 1726
nodebug/1, 1452
noguitracer/0, 96, 98, 107, 679
non deterministic, 1752
nondet, 1752
nonvar/1, 178
noprofile/1, 704
noprotocol/0, 672
normalize_space/2, 462
nospy/1, 32, 44, 687, 954, 1737
nospyall/0, 44, 688, 1737
not/1, 228, 1765
notrace/0, 677, 890, 891
notrace/1, 682
nth0/3, 1478
nth0/4, 1480
nth1/3, 1479
nth1/4, 1481
nth_clause/3, 302, 306, 307, 1720
nth_integer_root_and_remainder/4, 478
number
   rational, 487
number/1, 183
number_chars/2, 110, 435, 436
number_codes/2, 110, 431, 436--438
number_string/2, 737
number_to_chars/2, 1338
number_to_chars/3, 1339
numbervars/1, 1712
numbervars/3, 60, 390, 419--421
numbervars/4, 60, 393, 419, 420
numlist/3, 1493

objective/2, 1658
occurs_check, 205
offset/2, 1669
on_signal/3, 254, 255
once/1,  229, 230,  233, 340,  577,
      663,   682,  699,  700,  933,
      937, 1180
online_help _l_i_b_r_a_r_y, 1765
op/3, 288, 390, 467, 468, 819
open/3,  41,  109, 308,  310,  312,
      1143
open/4, 65, 66, 110, 311, 312, 316,
      322,   323,  384,  453,  791,
      792, 1637, 1638
open_any/5, 1464
open_chars_stream/2, 1342
open_dde_conversation/3, 716
open_hook/6, 1466
open_null_stream/1, 313, 322
open_resource/3, 1266, 1273, 1276
open_shared_object/2, 41,  616, 975,
      987, 988
open_shared_object/3, 987, 988
open_string/2, 755
operand, 1752
operator, 1752
   and modules, 466
opt_arguments/3, 1519
opt_help/2, 1522
opt_parse/4, 1520
opt_parse/5, 1521
option _l_i_b_r_a_r_y, 791, 799, 1639
option/2, 1511
option/3, 1510
options _l_i_b_r_a_r_y, 795
ord_add_element/3, 1535
ord_del_element/3, 1536
ord_disjoint/2, 1530
ord_empty/1, 1526
ord_intersect/2, 1529
ord_intersect/3, 1531
ord_intersection/2, 1532
ord_intersection/3, 1533
ord_intersection/4, 1534
ord_list_to_assoc/2, 1319
ord_memberchk/2, 1538
ord_selectchk/3, 1537
ord_seteq/2, 1527
ord_subset/2, 1539
ord_subtract/3, 1540
ord_symdiff/3, 1544
ord_union/2, 1541
ord_union/3, 1542
ord_union/4, 1543
order_by/2, 569, 1670

pack_info/1, 1586
pack_install/1, 1589
pack_install/2, 1590
pack_list/1, 1588
pack_list_installed/0, 1585
pack_property/2, 1597
pack_rebuild/0, 1593
pack_rebuild/1, 1592
pack_remove/1, 1596
pack_search/1, 1587
pack_upgrade/1, 1595
pack_url_file/2, 1591
pairs _l_i_b_r_a_r_y, 571, 791
pairs_keys/2, 1548
pairs_keys_values/3, 1546
pairs_values/2, 1547
parse_time/2, 627
parse_time/3, 627, 628
parse_type/3, 1523
parse_url/2, 1701
parse_url/3, 1702
parse_url_search/2, 1708
partition/4, 1292
partition/5, 1293
pce_dispatch/1, 968, 971
pce_thread/1, 970
pce_xref _l_i_b_r_a_r_y, 103
peek_byte/1, 373
peek_byte/2, 374
peek_byte/[1
   2], 110
peek_char/1, 377
peek_char/2, 378
peek_char/[1
   2], 110
peek_code/1, 375
peek_code/2, 376
peek_code/[1
   2], 110
peek_string/3, 379
pengines _l_i_b_r_a_r_y, 577
permission_error/3, 1148
permutation/2, 1486
persistent/1, 1553
phrase/2, 257, 258
phrase/3, 257, 259,  260, 756, 810,
      1765
phrase_from_file/2, 1560
phrase_from_file/3, 1561
phrase_from_quasi_quotation/2, 1611
phrase_from_stream/2, 1562
pi/0, 551
PL_abort_hook(), 1231
PL_abort_unhook(), 1232
PL_action(), 1220
PL_agc_hook(), 1235
PL_atom_chars(), 1015
PL_atom_nchars(), 1071
PL_atom_wchars(), 1074
PL_backtrace(), 1221
PL_blob_data(), 1163
PL_BLOB_NOCOPY, 1152
PL_BLOB_TEXT, 1152
PL_BLOB_UNIQUE, 1152
PL_call(), 1180
PL_call_predicate(), 1179
PL_chars_to_term(), 1123
PL_cleanup(), 1243
PL_cleanup_fork(), 1244
PL_clear_exception(), 1195
PL_close_foreign_frame(), 1183
PL_close_query(), 1178
PL_compare(), 1203
PL_cons_functor(), 1101
PL_cons_functor_v(), 1102
PL_cons_list(), 1103
PL_context(), 1187
PL_copy_term_ref(), 996
PL_create_engine(), 965
PL_cut_query(), 1177
PL_CYCLIC_TERM, 1083
PL_destroy_engine(), 966
PL_discard_foreign_frame(), 1184
PL_dispatch_hook(), 1230
PL_domain_error(), 1146
PL_end_stubborn_change(), 1261
PL_erase(), 1208
PL_erase_external(), 1211
PL_exception(), 1194
PL_existence_error(), 1147
PL_exit_hook(), 1234
PL_fail(), 1003
PL_foreign_context(), 1008
PL_foreign_context_address(), 1009
PL_foreign_context_predicate(), 1010
PL_foreign_control(), 1007
PL_free(), 1255
PL_functor_arity(), 1018
PL_functor_name(), 1017
PL_get_arg(), 1056
PL_get_atom(), 1040
PL_get_atom_chars(), 1041
PL_get_atom_ex(), 1127
PL_get_atom_nchars(), 1059
PL_get_blob(), 1162
PL_get_bool(), 1049
PL_get_bool_ex(), 1133
PL_get_char_ex(), 1135
PL_get_chars(), 1043
PL_get_compound_name_arity(), 1054
PL_get_file_name(), 1213
PL_get_file_nameW(), 1214
PL_get_float(), 1051
PL_get_float_ex(), 1134
PL_get_functor(), 1052
PL_get_head(), 1080
PL_get_int64(), 1047
PL_get_int64_ex(), 1130
PL_get_integer(), 1045
PL_get_integer_ex(), 1128
PL_get_intptr(), 1048
PL_get_intptr_ex(), 1131
PL_get_list(), 1079
PL_get_list_chars(), 1044
PL_get_list_ex(), 1137
PL_get_list_nchars(), 1060
PL_get_long(), 1046
PL_get_long_ex(), 1129
PL_get_module(), 1055
PL_get_mpq(), 1166
PL_get_mpz(), 1165
PL_get_name_arity(), 1053
PL_get_nchars(), 1061
PL_get_nil(), 1082
PL_get_nil_ex(), 1138
PL_get_pointer(), 1050
PL_get_pointer_ex(), 1136
PL_get_signum_ex(), 1200
PL_get_size_ex(), 1132

                                  1805
